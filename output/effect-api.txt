
# beep

Play a beeping sound.

To import and use `beep` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.beep
```

**Signature**

```ts
export declare const beep: Ansi
```


# cursorBackward

Moves the cursor backward by the specified number of `columns` (default `1`)
relative to the current cursor position.

If the cursor is already at the edge of the screen, this has no effect.

To import and use `cursorBackward` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.cursorBackward
```

**Signature**

```ts
export declare const cursorBackward: (columns?: number) => Ansi
```


# cursorDown

Moves the cursor down by the specified number of `lines` (default `1`)
relative to the current cursor position.

If the cursor is already at the edge of the screen, this has no effect.

To import and use `cursorDown` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.cursorDown
```

**Signature**

```ts
export declare const cursorDown: (lines?: number) => Ansi
```


# cursorForward

Moves the cursor forward by the specified number of `columns` (default `1`)
relative to the current cursor position.

If the cursor is already at the edge of the screen, this has no effect.

To import and use `cursorForward` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.cursorForward
```

**Signature**

```ts
export declare const cursorForward: (columns?: number) => Ansi
```


# cursorHide

Hides the cursor.

To import and use `cursorHide` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.cursorHide
```

**Signature**

```ts
export declare const cursorHide: Ansi
```


# cursorLeft

Moves the cursor to the first column of the current row.

To import and use `cursorLeft` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.cursorLeft
```

**Signature**

```ts
export declare const cursorLeft: Ansi
```


# cursorMove

Move the cursor position the specified number of `rows` and `columns`
relative to the current cursor position.

If the cursor is already at the edge of the screen in either direction, then
additional movement will have no effect.

To import and use `cursorMove` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.cursorMove
```

**Signature**

```ts
export declare const cursorMove: (column: number, row?: number) => Ansi
```


# cursorNextLine

Moves cursor to beginning of the line the specified number of rows down
(default `1`).

To import and use `cursorNextLine` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.cursorNextLine
```

**Signature**

```ts
export declare const cursorNextLine: (rows?: number) => Ansi
```


# cursorPrevLine

Moves cursor to beginning of the line the specified number of rows up
(default `1`).

To import and use `cursorPrevLine` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.cursorPrevLine
```

**Signature**

```ts
export declare const cursorPrevLine: (rows?: number) => Ansi
```


# cursorRestorePosition

Restores the cursor position, encoding shift state and formatting attributes
from the previous save, if any, otherwise resets these all to their defaults.

To import and use `cursorRestorePosition` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.cursorRestorePosition
```

**Signature**

```ts
export declare const cursorRestorePosition: Ansi
```


# cursorSavePosition

Saves the cursor position, encoding shift state and formatting attributes.

To import and use `cursorSavePosition` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.cursorSavePosition
```

**Signature**

```ts
export declare const cursorSavePosition: Ansi
```


# cursorShow

Shows the cursor.

To import and use `cursorShow` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.cursorShow
```

**Signature**

```ts
export declare const cursorShow: Ansi
```


# cursorTo

Moves the cursor to the specified `row` and `column`.

Though the ANSI Control Sequence for Cursor Position is `1`-based, this
method takes row and column values starting from `0` and adjusts them to `1`-
based values.

To import and use `cursorTo` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.cursorTo
```

**Signature**

```ts
export declare const cursorTo: (column: number, row?: number) => Ansi
```


# cursorUp

Moves the cursor up by the specified number of `lines` (default `1`) relative
to the current cursor position.

If the cursor is already at the edge of the screen, this has no effect.

To import and use `cursorUp` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.cursorUp
```

**Signature**

```ts
export declare const cursorUp: (lines?: number) => Ansi
```


# eraseDown

Clears from the current cursor position to the end of the screen.

The current cursor position does not change.

To import and use `eraseDown` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.eraseDown
```

**Signature**

```ts
export declare const eraseDown: Ansi
```


# eraseEndLine

Clears from the current cursor position to the end of the current line.

The current cursor position does not change.

To import and use `eraseEndLine` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.eraseEndLine
```

**Signature**

```ts
export declare const eraseEndLine: Ansi
```


# eraseLine

Clears the current line.

The current cursor position does not change.

To import and use `eraseLine` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.eraseLine
```

**Signature**

```ts
export declare const eraseLine: Ansi
```


# eraseLines

Erase from the current cursor position up the specified amount of rows.

To import and use `eraseLines` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.eraseLines
```

**Signature**

```ts
export declare const eraseLines: (rows: number) => Ansi
```


# eraseScreen

Clears the entire screen and move the cursor to the upper left.

To import and use `eraseScreen` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.eraseScreen
```

**Signature**

```ts
export declare const eraseScreen: Ansi
```


# eraseStartLine

Clears from the current cursor position to the start of the current line.

The current cursor position does not change.

To import and use `eraseStartLine` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.eraseStartLine
```

**Signature**

```ts
export declare const eraseStartLine: Ansi
```


# eraseUp

Clears from the current cursor position to the beginning of the screen.

The current cursor position does not change.

To import and use `eraseUp` from the "Ansi" module:

```ts
import * as Ansi from "@effect/printer-ansi/Ansi"
// Can be accessed like this
Ansi.eraseUp
```

**Signature**

```ts
export declare const eraseUp: Ansi
```


# beep

Play a beeping sound.

To import and use `beep` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.beep
```

**Signature**

```ts
export declare const beep: AnsiDoc
```


# cursorBackward

Moves the cursor backward by the specified number of `columns` (default `1`)
relative to the current cursor position.

If the cursor is already at the edge of the screen, this has no effect.

To import and use `cursorBackward` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.cursorBackward
```

**Signature**

```ts
export declare const cursorBackward: (columns?: number) => AnsiDoc
```


# cursorDown

Moves the cursor down by the specified number of `lines` (default `1`)
relative to the current cursor position.

If the cursor is already at the edge of the screen, this has no effect.

To import and use `cursorDown` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.cursorDown
```

**Signature**

```ts
export declare const cursorDown: (lines?: number) => AnsiDoc
```


# cursorForward

Moves the cursor forward by the specified number of `columns` (default `1`)
relative to the current cursor position.

If the cursor is already at the edge of the screen, this has no effect.

To import and use `cursorForward` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.cursorForward
```

**Signature**

```ts
export declare const cursorForward: (columns?: number) => AnsiDoc
```


# cursorHide

Hides the cursor.

To import and use `cursorHide` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.cursorHide
```

**Signature**

```ts
export declare const cursorHide: AnsiDoc
```


# cursorLeft

Moves the cursor to the first column of the current row.

To import and use `cursorLeft` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.cursorLeft
```

**Signature**

```ts
export declare const cursorLeft: AnsiDoc
```


# cursorMove

Move the cursor position the specified number of `rows` and `columns`
relative to the current cursor position.

If the cursor is already at the edge of the screen in either direction, then
additional movement will have no effect.

To import and use `cursorMove` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.cursorMove
```

**Signature**

```ts
export declare const cursorMove: (column: number, row?: number) => AnsiDoc
```


# cursorNextLine

Moves cursor to beginning of the line the specified number of rows down
(default `1`).

To import and use `cursorNextLine` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.cursorNextLine
```

**Signature**

```ts
export declare const cursorNextLine: (rows?: number) => AnsiDoc
```


# cursorPrevLine

Moves cursor to beginning of the line the specified number of rows up
(default `1`).

To import and use `cursorPrevLine` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.cursorPrevLine
```

**Signature**

```ts
export declare const cursorPrevLine: (rows?: number) => AnsiDoc
```


# cursorRestorePosition

Restores the cursor position, encoding shift state and formatting attributes
from the previous save, if any, otherwise resets these all to their defaults.

To import and use `cursorRestorePosition` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.cursorRestorePosition
```

**Signature**

```ts
export declare const cursorRestorePosition: AnsiDoc
```


# cursorSavePosition

Saves the cursor position, encoding shift state and formatting attributes.

To import and use `cursorSavePosition` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.cursorSavePosition
```

**Signature**

```ts
export declare const cursorSavePosition: AnsiDoc
```


# cursorShow

Shows the cursor.

To import and use `cursorShow` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.cursorShow
```

**Signature**

```ts
export declare const cursorShow: AnsiDoc
```


# cursorTo

Moves the cursor to the specified `row` and `column`.

Though the ANSI Control Sequence for Cursor Position is `1`-based, this
method takes row and column values starting from `0` and adjusts them to `1`-
based values.

To import and use `cursorTo` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.cursorTo
```

**Signature**

```ts
export declare const cursorTo: (column: number, row?: number) => AnsiDoc
```


# cursorUp

Moves the cursor up by the specified number of `lines` (default `1`) relative
to the current cursor position.

If the cursor is already at the edge of the screen, this has no effect.

To import and use `cursorUp` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.cursorUp
```

**Signature**

```ts
export declare const cursorUp: (lines?: number) => AnsiDoc
```


# eraseDown

Clears from the current cursor position to the end of the screen.

The current cursor position does not change.

To import and use `eraseDown` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.eraseDown
```

**Signature**

```ts
export declare const eraseDown: AnsiDoc
```


# eraseEndLine

Clears from the current cursor position to the end of the current line.

The current cursor position does not change.

To import and use `eraseEndLine` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.eraseEndLine
```

**Signature**

```ts
export declare const eraseEndLine: AnsiDoc
```


# eraseLine

Clears the current line.

The current cursor position does not change.

To import and use `eraseLine` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.eraseLine
```

**Signature**

```ts
export declare const eraseLine: AnsiDoc
```


# eraseLines

Erase from the current cursor position up the specified amount of rows.

To import and use `eraseLines` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.eraseLines
```

**Signature**

```ts
export declare const eraseLines: (rows: number) => AnsiDoc
```


# eraseScreen

Clears the entire screen and move the cursor to the upper left.

To import and use `eraseScreen` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.eraseScreen
```

**Signature**

```ts
export declare const eraseScreen: AnsiDoc
```


# eraseStartLine

Clears from the current cursor position to the start of the current line.

The current cursor position does not change.

To import and use `eraseStartLine` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.eraseStartLine
```

**Signature**

```ts
export declare const eraseStartLine: AnsiDoc
```


# eraseUp

Clears from the current cursor position to the beginning of the screen.

The current cursor position does not change.

To import and use `eraseUp` from the "AnsiDoc" module:

```ts
import * as AnsiDoc from "@effect/printer-ansi/AnsiDoc"
// Can be accessed like this
AnsiDoc.eraseUp
```

**Signature**

```ts
export declare const eraseUp: AnsiDoc
```


# getMonoid

Lift a `Monoid` into `F`, combining the inner values using the provided `Monoid`:

- `combine` is provided by {@link semiApplicative.getSemigroup}.
- `empty` is `F.of(M.empty)`

To import and use `getMonoid` from the "Applicative" module:

```ts
import * as Applicative from "@effect/typeclass/Applicative"
// Can be accessed like this
Applicative.getMonoid
```

**Signature**

```ts
export declare const getMonoid: <F extends TypeLambda>(
  F: Applicative<F>
) => <A, R, O, E>(M: Monoid<A>) => Monoid<Kind<F, R, O, E, A>>
```


# make

Returns a fast-check Arbitrary for the `A` type of the provided schema.

To import and use `make` from the "Arbitrary" module:

```ts
import * as Arbitrary from "effect/Arbitrary"
// Can be accessed like this
Arbitrary.make
```

**Signature**

```ts
export declare const make: <A, I, R>(schema: Schema.Schema<A, I, R>) => FastCheck.Arbitrary<A>
```


# makeLazy

Returns a LazyArbitrary for the `A` type of the provided schema.

To import and use `makeLazy` from the "Arbitrary" module:

```ts
import * as Arbitrary from "effect/Arbitrary"
// Can be accessed like this
Arbitrary.makeLazy
```

**Signature**

```ts
export declare const makeLazy: <A, I, R>(schema: Schema.Schema<A, I, R>) => LazyArbitrary<A>
```


# Args

Represents arguments that can be passed to a command-line application.

To import and use `Args` from the "Args" module:

```ts
import * as Args from "@effect/cli/Args"
// Can be accessed like this
Args.Args
```


# boolean

Creates a boolean argument.

Can optionally provide a custom argument name (defaults to `"boolean"`).

To import and use `boolean` from the "Args" module:

```ts
import * as Args from "@effect/cli/Args"
// Can be accessed like this
Args.boolean
```

**Signature**

```ts
export declare const boolean: (options?: Args.BaseArgsConfig) => Args<boolean>
```


# choice

Creates a choice argument.

Can optionally provide a custom argument name (defaults to `"choice"`).

To import and use `choice` from the "Args" module:

```ts
import * as Args from "@effect/cli/Args"
// Can be accessed like this
Args.choice
```

**Signature**

```ts
export declare const choice: <A>(choices: ReadonlyArray<[string, A]>, config?: Args.BaseArgsConfig) => Args<A>
```


# date

Creates a date argument.

Can optionally provide a custom argument name (defaults to `"date"`).

To import and use `date` from the "Args" module:

```ts
import * as Args from "@effect/cli/Args"
// Can be accessed like this
Args.date
```

**Signature**

```ts
export declare const date: (config?: Args.BaseArgsConfig) => Args<globalThis.Date>
```


# directory

Creates a directory argument.

Can optionally provide a custom argument name (defaults to `"directory"`).

To import and use `directory` from the "Args" module:

```ts
import * as Args from "@effect/cli/Args"
// Can be accessed like this
Args.directory
```

**Signature**

```ts
export declare const directory: (config?: Args.PathArgsConfig) => Args<string>
```


# file

Creates a file argument.

Can optionally provide a custom argument name (defaults to `"file"`).

To import and use `file` from the "Args" module:

```ts
import * as Args from "@effect/cli/Args"
// Can be accessed like this
Args.file
```

**Signature**

```ts
export declare const file: (config?: Args.PathArgsConfig) => Args<string>
```


# fileContent

Creates a file argument that reads its contents.

Can optionally provide a custom argument name (defaults to `"file"`).

To import and use `fileContent` from the "Args" module:

```ts
import * as Args from "@effect/cli/Args"
// Can be accessed like this
Args.fileContent
```

**Signature**

```ts
export declare const fileContent: (
  config?: Args.BaseArgsConfig | undefined
) => Args<readonly [path: string, content: Uint8Array]>
```


# fileParse

Creates a file argument that reads and parses its contents.

Can optionally provide a custom argument name (defaults to `"file"`).

To import and use `fileParse` from the "Args" module:

```ts
import * as Args from "@effect/cli/Args"
// Can be accessed like this
Args.fileParse
```

**Signature**

```ts
export declare const fileParse: (config?: Args.FormatArgsConfig | undefined) => Args<unknown>
```


# fileSchema

Creates a file argument that reads, parses and validates its contents.

Can optionally provide a custom argument name (defaults to `"file"`).

To import and use `fileSchema` from the "Args" module:

```ts
import * as Args from "@effect/cli/Args"
// Can be accessed like this
Args.fileSchema
```

**Signature**

```ts
export declare const fileSchema: <I, A>(
  schema: Schema<A, I, FileSystem | Path | Terminal>,
  config?: Args.FormatArgsConfig | undefined
) => Args<A>
```


# fileText

Creates a file argument that reads it's contents.

Can optionally provide a custom argument name (defaults to `"file"`).

To import and use `fileText` from the "Args" module:

```ts
import * as Args from "@effect/cli/Args"
// Can be accessed like this
Args.fileText
```

**Signature**

```ts
export declare const fileText: (
  config?: Args.BaseArgsConfig | undefined
) => Args<readonly [path: string, content: string]>
```


# float

Creates a floating point number argument.

Can optionally provide a custom argument name (defaults to `"float"`).

To import and use `float` from the "Args" module:

```ts
import * as Args from "@effect/cli/Args"
// Can be accessed like this
Args.float
```

**Signature**

```ts
export declare const float: (config?: Args.BaseArgsConfig) => Args<number>
```


# integer

Creates an integer argument.

Can optionally provide a custom argument name (defaults to `"integer"`).

To import and use `integer` from the "Args" module:

```ts
import * as Args from "@effect/cli/Args"
// Can be accessed like this
Args.integer
```

**Signature**

```ts
export declare const integer: (config?: Args.BaseArgsConfig) => Args<number>
```


# none

Creates an empty argument.

To import and use `none` from the "Args" module:

```ts
import * as Args from "@effect/cli/Args"
// Can be accessed like this
Args.none
```

**Signature**

```ts
export declare const none: Args<void>
```


# path

Creates a path argument.

Can optionally provide a custom argument name (defaults to `"path"`).

To import and use `path` from the "Args" module:

```ts
import * as Args from "@effect/cli/Args"
// Can be accessed like this
Args.path
```

**Signature**

```ts
export declare const path: (config?: Args.PathArgsConfig) => Args<string>
```


# redacted

Creates a text argument.

Can optionally provide a custom argument name (defaults to `"redacted"`).

To import and use `redacted` from the "Args" module:

```ts
import * as Args from "@effect/cli/Args"
// Can be accessed like this
Args.redacted
```

**Signature**

```ts
export declare const redacted: (config?: Args.BaseArgsConfig) => Args<Redacted>
```


# secret

Creates a text argument.

Can optionally provide a custom argument name (defaults to `"secret"`).

To import and use `secret` from the "Args" module:

```ts
import * as Args from "@effect/cli/Args"
// Can be accessed like this
Args.secret
```

**Signature**

```ts
export declare const secret: (config?: Args.BaseArgsConfig) => Args<Secret>
```


# text

Creates a text argument.

Can optionally provide a custom argument name (defaults to `"text"`).

To import and use `text` from the "Args" module:

```ts
import * as Args from "@effect/cli/Args"
// Can be accessed like this
Args.text
```

**Signature**

```ts
export declare const text: (config?: Args.BaseArgsConfig) => Args<string>
```


# allocate

Creates a new `Array` of the specified length.

To import and use `allocate` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.allocate
```

**Example**

```ts
import { Array } from "effect"

const result = Array.allocate<number>(3)
assert.deepStrictEqual(result.length, 3)
```

**Signature**

```ts
export declare const allocate: <A = never>(n: number) => Array<A | undefined>
```


# append

Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.

To import and use `append` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.append
```

**Example**

```ts
import { Array } from "effect"

const original = [1, 2, 3]
const result = Array.append(original, 4)
assert.deepStrictEqual(result, [1, 2, 3, 4])
```

**Signature**

```ts
export declare const append: {
  <B>(last: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>
  <A, B>(self: Iterable<A>, last: B): NonEmptyArray<A | B>
}
```


# appendAll

Concatenates two arrays (or iterables), combining their elements.
If either array is non-empty, the result is also a non-empty array.

To import and use `appendAll` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.appendAll
```

**Signature**

```ts
export declare const appendAll: {
  <S extends Iterable<any>, T extends Iterable<any>>(
    that: T
  ): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>
  <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>
  <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>
  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>
}
```


# bind

The "do simulation" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.

It can be used to simulate "array comprehension".
It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

To import and use `bind` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.bind
```

**Example**

```ts
import { Array as Arr, pipe } from "effect"
const doResult = pipe(
  Arr.Do,
  Arr.bind("x", () => [1, 3, 5]),
  Arr.bind("y", () => [2, 4, 6]),
  Arr.filter(({ x, y }) => x < y), // condition
  Arr.map(({ x, y }) => [x, y] as const) // transformation
)
assert.deepStrictEqual(doResult, [
  [1, 2],
  [1, 4],
  [1, 6],
  [3, 4],
  [3, 6],
  [5, 6]
])

// equivalent
const x = [1, 3, 5],
  y = [2, 4, 6],
  result = []
for (let i = 0; i < x.length; i++) {
  for (let j = 0; j < y.length; j++) {
    const _x = x[i],
      _y = y[j]
    if (_x < _y) result.push([_x, _y] as const)
  }
}
```

**Signature**

```ts
export declare const bind: {
  <A extends object, N extends string, B>(
    tag: Exclude<N, keyof A>,
    f: (a: NoInfer<A>) => ReadonlyArray<B>
  ): (self: ReadonlyArray<A>) => Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>
  <A extends object, N extends string, B>(
    self: ReadonlyArray<A>,
    tag: Exclude<N, keyof A>,
    f: (a: NoInfer<A>) => ReadonlyArray<B>
  ): Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>
}
```


# bindTo

The "do simulation" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.

It can be used to simulate "array comprehension".
It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

To import and use `bindTo` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.bindTo
```

**Example**

```ts
import { Array as Arr, pipe } from "effect"
const doResult = pipe(
  Arr.Do,
  Arr.bind("x", () => [1, 3, 5]),
  Arr.bind("y", () => [2, 4, 6]),
  Arr.filter(({ x, y }) => x < y), // condition
  Arr.map(({ x, y }) => [x, y] as const) // transformation
)
assert.deepStrictEqual(doResult, [
  [1, 2],
  [1, 4],
  [1, 6],
  [3, 4],
  [3, 6],
  [5, 6]
])

// equivalent
const x = [1, 3, 5],
  y = [2, 4, 6],
  result = []
for (let i = 0; i < x.length; i++) {
  for (let j = 0; j < y.length; j++) {
    const _x = x[i],
      _y = y[j]
    if (_x < _y) result.push([_x, _y] as const)
  }
}
```

**Signature**

```ts
export declare const bindTo: {
  <N extends string>(tag: N): <A>(self: ReadonlyArray<A>) => Array<{ [K in N]: A }>
  <A, N extends string>(self: ReadonlyArray<A>, tag: N): Array<{ [K in N]: A }>
}
```


# cartesian

Zips this chunk crosswise with the specified chunk.

To import and use `cartesian` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.cartesian
```

**Example**

```ts
import { Array } from "effect"

const array1 = [1, 2]
const array2 = ["a", "b"]
const product = Array.cartesian(array1, array2)
assert.deepStrictEqual(product, [
  [1, "a"],
  [1, "b"],
  [2, "a"],
  [2, "b"]
])
```

**Signature**

```ts
export declare const cartesian: {
  <B>(that: ReadonlyArray<B>): <A>(self: ReadonlyArray<A>) => Array<[A, B]>
  <A, B>(self: ReadonlyArray<A>, that: ReadonlyArray<B>): Array<[A, B]>
}
```


# cartesianWith

Zips this chunk crosswise with the specified chunk using the specified combiner.

To import and use `cartesianWith` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.cartesianWith
```

**Example**

```ts
import { Array } from "effect"

const array1 = [1, 2]
const array2 = ["a", "b"]
const product = Array.cartesianWith(array1, array2, (a, b) => `${a}-${b}`)
assert.deepStrictEqual(product, ["1-a", "1-b", "2-a", "2-b"])
```

**Signature**

```ts
export declare const cartesianWith: {
  <A, B, C>(that: ReadonlyArray<B>, f: (a: A, b: B) => C): (self: ReadonlyArray<A>) => Array<C>
  <A, B, C>(self: ReadonlyArray<A>, that: ReadonlyArray<B>, f: (a: A, b: B) => C): Array<C>
}
```


# chop

A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for "chopping" up the input
`Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a
value and the rest of the `Array`.

To import and use `chop` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.chop
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3, 4, 5]
const result = Array.chop(numbers, (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])
assert.deepStrictEqual(result, [2, 4, 6, 8, 10])

// Explanation:
// The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.
// The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,
// resulting in a new array `[2, 4, 6, 8, 10]`.
```

**Signature**

```ts
export declare const chop: {
  <S extends Iterable<any>, B>(
    f: (as: NonEmptyReadonlyArray<ReadonlyArray.Infer<S>>) => readonly [B, ReadonlyArray<ReadonlyArray.Infer<S>>]
  ): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>
  <A, B>(
    self: NonEmptyReadonlyArray<A>,
    f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]
  ): NonEmptyArray<B>
  <A, B>(self: Iterable<A>, f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]): Array<B>
}
```


# chunksOf

Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive
definition of `chunksOf`; it satisfies the property that

```ts
chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))
```

whenever `n` evenly divides the length of `self`.

To import and use `chunksOf` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.chunksOf
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3, 4, 5]
const result = Array.chunksOf(numbers, 2)
assert.deepStrictEqual(result, [[1, 2], [3, 4], [5]])

// Explanation:
// The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.
// It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,
// the last chunk contains the remaining elements.
// The result is `[[1, 2], [3, 4], [5]]`.
```

**Signature**

```ts
export declare const chunksOf: {
  (n: number): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, NonEmptyArray<ReadonlyArray.Infer<S>>>
  <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<NonEmptyArray<A>>
  <A>(self: Iterable<A>, n: number): Array<NonEmptyArray<A>>
}
```


# contains

Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.

To import and use `contains` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.contains
```

**Example**

```ts
import { Array } from "effect"

const letters = ["a", "b", "c", "d"]
const result = Array.contains("c")(letters)
assert.deepStrictEqual(result, true)
```

**Signature**

```ts
export declare const contains: { <A>(a: A): (self: Iterable<A>) => boolean; <A>(self: Iterable<A>, a: A): boolean }
```


# containsWith

Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `isEquivalent` function.

To import and use `containsWith` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.containsWith
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3, 4]
const isEquivalent = (a: number, b: number) => a === b
const containsNumber = Array.containsWith(isEquivalent)
const result = containsNumber(3)(numbers)
assert.deepStrictEqual(result, true)
```

**Signature**

```ts
export declare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => {
  (a: A): (self: Iterable<A>) => boolean
  (self: Iterable<A>, a: A): boolean
}
```


# copy

Copies an array.

To import and use `copy` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.copy
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3]
const copy = Array.copy(numbers)
assert.deepStrictEqual(copy, [1, 2, 3])
```

**Signature**

```ts
export declare const copy: {
  <A>(self: NonEmptyReadonlyArray<A>): NonEmptyArray<A>
  <A>(self: ReadonlyArray<A>): Array<A>
}
```


# dedupe

Remove duplicates from an `Iterable`, preserving the order of the first occurrence of each element.
The equivalence used to compare elements is provided by `Equal.equivalence()` from the `Equal` module.

To import and use `dedupe` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.dedupe
```

**Signature**

```ts
export declare const dedupe: <S extends Iterable<any> | NonEmptyReadonlyArray<any>>(
  self: S
) => S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never
```


# dedupeAdjacent

Deduplicates adjacent elements that are identical.

To import and use `dedupeAdjacent` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.dedupeAdjacent
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 1, 2, 2, 3, 3]
const unique = Array.dedupeAdjacent(numbers)
assert.deepStrictEqual(unique, [1, 2, 3])
```

**Signature**

```ts
export declare const dedupeAdjacent: <A>(self: Iterable<A>) => Array<A>
```


# dedupeAdjacentWith

Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.

To import and use `dedupeAdjacentWith` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.dedupeAdjacentWith
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 1, 2, 2, 3, 3]
const unique = Array.dedupeAdjacentWith(numbers, (a, b) => a === b)
assert.deepStrictEqual(unique, [1, 2, 3])
```

**Signature**

```ts
export declare const dedupeAdjacentWith: {
  <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Array<A>
  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A>
}
```


# dedupeWith

Remove duplicates from an `Iterable` using the provided `isEquivalent` function,
preserving the order of the first occurrence of each element.

To import and use `dedupeWith` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.dedupeWith
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 2, 3, 3, 3]
const unique = Array.dedupeWith(numbers, (a, b) => a === b)
assert.deepStrictEqual(unique, [1, 2, 3])
```

**Signature**

```ts
export declare const dedupeWith: {
  <S extends Iterable<any>>(
    isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<S>) => boolean
  ): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>
  <A>(self: NonEmptyReadonlyArray<A>, isEquivalent: (self: A, that: A) => boolean): NonEmptyArray<A>
  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A>
}
```


# difference

Creates a `Array` of values not included in the other given `Iterable`.
The order and references of result values are determined by the first `Iterable`.

To import and use `difference` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.difference
```

**Example**

```ts
import { Array } from "effect"

const array1 = [1, 2, 3]
const array2 = [2, 3, 4]
const difference = Array.difference(array1, array2)
assert.deepStrictEqual(difference, [1])
```

**Signature**

```ts
export declare const difference: {
  <A>(that: Iterable<A>): (self: Iterable<A>) => Array<A>
  <A>(self: Iterable<A>, that: Iterable<A>): Array<A>
}
```


# differenceWith

Creates a `Array` of values not included in the other given `Iterable` using the provided `isEquivalent` function.
The order and references of result values are determined by the first `Iterable`.

To import and use `differenceWith` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.differenceWith
```

**Example**

```ts
import { Array } from "effect"

const array1 = [1, 2, 3]
const array2 = [2, 3, 4]
const difference = Array.differenceWith<number>((a, b) => a === b)(array1, array2)
assert.deepStrictEqual(difference, [1])
```

**Signature**

```ts
export declare const differenceWith: <A>(isEquivalent: (self: A, that: A) => boolean) => {
  (that: Iterable<A>): (self: Iterable<A>) => Array<A>
  (self: Iterable<A>, that: Iterable<A>): Array<A>
}
```


# Do

The "do simulation" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.

It can be used to simulate "array comprehension".
It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

To import and use `Do` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.Do
```

**Example**

```ts
import { Array as Arr, pipe } from "effect"
const doResult = pipe(
  Arr.Do,
  Arr.bind("x", () => [1, 3, 5]),
  Arr.bind("y", () => [2, 4, 6]),
  Arr.filter(({ x, y }) => x < y), // condition
  Arr.map(({ x, y }) => [x, y] as const) // transformation
)
assert.deepStrictEqual(doResult, [
  [1, 2],
  [1, 4],
  [1, 6],
  [3, 4],
  [3, 6],
  [5, 6]
])

// equivalent
const x = [1, 3, 5],
  y = [2, 4, 6],
  result = []
for (let i = 0; i < x.length; i++) {
  for (let j = 0; j < y.length; j++) {
    const _x = x[i],
      _y = y[j]
    if (_x < _y) result.push([_x, _y] as const)
  }
}
```

**Signature**

```ts
export declare const Do: readonly {}[]
```


# drop

Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.

**Note**. `n` is normalized to a non negative integer.

To import and use `drop` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.drop
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3, 4, 5]
const result = Array.drop(numbers, 2)
assert.deepStrictEqual(result, [3, 4, 5])
```

**Signature**

```ts
export declare const drop: {
  (n: number): <A>(self: Iterable<A>) => Array<A>
  <A>(self: Iterable<A>, n: number): Array<A>
}
```


# dropRight

Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.

**Note**. `n` is normalized to a non negative integer.

To import and use `dropRight` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.dropRight
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3, 4, 5]
const result = Array.dropRight(numbers, 2)
assert.deepStrictEqual(result, [1, 2, 3])
```

**Signature**

```ts
export declare const dropRight: {
  (n: number): <A>(self: Iterable<A>) => Array<A>
  <A>(self: Iterable<A>, n: number): Array<A>
}
```


# dropWhile

Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.

To import and use `dropWhile` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.dropWhile
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3, 4, 5]
const result = Array.dropWhile(numbers, (x) => x < 4)
assert.deepStrictEqual(result, [4, 5])
```

**Signature**

```ts
export declare const dropWhile: {
  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>
  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>
}
```


# ensure

Creates a new `Array` from a value that might not be an iterable.

To import and use `ensure` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.ensure
```

**Example**

```ts
import { Array } from "effect"

assert.deepStrictEqual(Array.ensure("a"), ["a"])
assert.deepStrictEqual(Array.ensure(["a"]), ["a"])
assert.deepStrictEqual(Array.ensure(["a", "b", "c"]), ["a", "b", "c"])
```

**Signature**

```ts
export declare const ensure: <A>(self: ReadonlyArray<A> | A) => Array<A>
```


# every

Check if a predicate holds true for every `ReadonlyArray` element.

To import and use `every` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.every
```

**Signature**

```ts
export declare const every: {
  <A, B extends A>(
    refinement: (a: NoInfer<A>, i: number) => a is B
  ): (self: ReadonlyArray<A>) => self is ReadonlyArray<B>
  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: ReadonlyArray<A>) => boolean
  <A, B extends A>(self: ReadonlyArray<A>, refinement: (a: A, i: number) => a is B): self is ReadonlyArray<B>
  <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): boolean
}
```


# extend

Extends an array with a function that maps each subarray to a value.

To import and use `extend` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.extend
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3]
const result = Array.extend(numbers, (as) => as.length)
assert.deepStrictEqual(result, [3, 2, 1])

// Explanation:
// The function maps each subarray starting from each element to its length.
// The subarrays are: [1, 2, 3], [2, 3], [3].
// The lengths are: 3, 2, 1.
// Therefore, the result is [3, 2, 1].
```

**Signature**

```ts
export declare const extend: {
  <A, B>(f: (as: ReadonlyArray<A>) => B): (self: ReadonlyArray<A>) => Array<B>
  <A, B>(self: ReadonlyArray<A>, f: (as: ReadonlyArray<A>) => B): Array<B>
}
```


# filterMap

Applies a function to each element of the `Iterable` and filters based on the result, keeping the transformed values where the function returns `Some`.
This method combines filtering and mapping functionalities, allowing transformations and filtering of elements based on a single function pass.

To import and use `filterMap` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.filterMap
```

**Example**

```ts
import { Array, Option } from "effect"

const data = [1, 2, 3, 4, 5]
const evenSquares = (x: number) => (x % 2 === 0 ? Option.some(x * x) : Option.none())
const result = Array.filterMap(data, evenSquares)

assert.deepStrictEqual(result, [4, 16])
```

**Signature**

```ts
export declare const filterMap: {
  <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Array<B>
  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Array<B>
}
```


# filterMapWhile

Applies a function to each element of the array and filters based on the result, stopping when a condition is not met.
This method combines filtering and mapping in a single pass, and short-circuits, i.e., stops processing, as soon as the function returns `None`.
This is useful when you need to transform an array but only up to the point where a certain condition holds true.

To import and use `filterMapWhile` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.filterMapWhile
```

**Example**

```ts
import { Array, Option } from "effect"

const data = [2, 4, 5]
const toSquareTillOdd = (x: number) => (x % 2 === 0 ? Option.some(x * x) : Option.none())
const result = Array.filterMapWhile(data, toSquareTillOdd)

assert.deepStrictEqual(result, [4, 16])
```

**Signature**

```ts
export declare const filterMapWhile: {
  <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Array<B>
  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Array<B>
}
```


# findFirst

Returns the first element that satisfies the specified
predicate, or `None` if no such element exists.

To import and use `findFirst` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.findFirst
```

**Example**

```ts
import { Array, Option } from "effect"

const numbers = [1, 2, 3, 4, 5]
const result = Array.findFirst(numbers, (x) => x > 3)
assert.deepStrictEqual(result, Option.some(4))
```

**Signature**

```ts
export declare const findFirst: {
  <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>
  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>
  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>
  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>
  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>
  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>
}
```


# findFirstIndex

Return the first index for which a predicate holds.

To import and use `findFirstIndex` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.findFirstIndex
```

**Example**

```ts
import { Array, Option } from "effect"

const numbers = [5, 3, 8, 9]
const result = Array.findFirstIndex(numbers, (x) => x > 5)
assert.deepStrictEqual(result, Option.some(2))
```

**Signature**

```ts
export declare const findFirstIndex: {
  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<number>
  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<number>
}
```


# findLast

Finds the last element in an iterable collection that satisfies the given predicate or refinement.
Returns an `Option` containing the found element, or `Option.none` if no element matches.

To import and use `findLast` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.findLast
```

**Example**

```ts
import { Array, Option } from "effect"

const numbers = [1, 2, 3, 4, 5]
const result = Array.findLast(numbers, (n) => n % 2 === 0)
assert.deepStrictEqual(result, Option.some(4))
```

**Signature**

```ts
export declare const findLast: {
  <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>
  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>
  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>
  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>
  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>
  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>
}
```


# findLastIndex

Return the last index for which a predicate holds.

To import and use `findLastIndex` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.findLastIndex
```

**Example**

```ts
import { Array, Option } from "effect"

const numbers = [1, 3, 8, 9]
const result = Array.findLastIndex(numbers, (x) => x < 5)
assert.deepStrictEqual(result, Option.some(1))
```

**Signature**

```ts
export declare const findLastIndex: {
  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<number>
  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<number>
}
```


# flatMap

Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.

To import and use `flatMap` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.flatMap
```

**Signature**

```ts
export declare const flatMap: {
  <S extends ReadonlyArray<any>, T extends ReadonlyArray<any>>(
    f: (a: ReadonlyArray.Infer<S>, i: number) => T
  ): (self: S) => ReadonlyArray.AndNonEmpty<S, T, ReadonlyArray.Infer<T>>
  <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A, i: number) => NonEmptyReadonlyArray<B>): NonEmptyArray<B>
  <A, B>(self: ReadonlyArray<A>, f: (a: A, i: number) => ReadonlyArray<B>): Array<B>
}
```


# flatMapNullable

Maps over an array and flattens the result, removing null and undefined values.

To import and use `flatMapNullable` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.flatMapNullable
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3]
const result = Array.flatMapNullable(numbers, (n) => (n % 2 === 0 ? null : n))
assert.deepStrictEqual(result, [1, 3])

// Explanation:
// The array of numbers [1, 2, 3] is mapped with a function that returns null for even numbers
// and the number itself for odd numbers. The resulting array [1, null, 3] is then flattened
// to remove null values, resulting in [1, 3].
```

**Signature**

```ts
export declare const flatMapNullable: {
  <A, B>(f: (a: A) => B | null | undefined): (self: ReadonlyArray<A>) => Array<NonNullable<B>>
  <A, B>(self: ReadonlyArray<A>, f: (a: A) => B | null | undefined): Array<NonNullable<B>>
}
```


# flatten

Combines multiple arrays into a single array by concatenating all elements
from each nested array. This function ensures that the structure of nested
arrays is collapsed into a single, flat array.

To import and use `flatten` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.flatten
```

**Example**

```ts
import { Array } from "effect"

const nestedArrays = [[1, 2], [], [3, 4], [], [5, 6]]
const result = Array.flatten(nestedArrays)

assert.deepStrictEqual(result, [1, 2, 3, 4, 5, 6])
```

**Signature**

```ts
export declare const flatten: <S extends ReadonlyArray<ReadonlyArray<any>>>(self: S) => ReadonlyArray.Flatten<S>
```


# forEach

Performs a side-effect for each element of the `Iterable`.

To import and use `forEach` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.forEach
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3]
Array.forEach(numbers, (n) => console.log(n)) // 1, 2, 3
```

**Signature**

```ts
export declare const forEach: {
  <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void
  <A>(self: Iterable<A>, f: (a: A, i: number) => void): void
}
```


# fromIterable

Creates a new `Array` from an iterable collection of values.
If the input is already an array, it returns the input as-is.
Otherwise, it converts the iterable collection to an array.

To import and use `fromIterable` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.fromIterable
```

**Example**

```ts
import { Array } from "effect"

const set = new Set([1, 2, 3])
const result = Array.fromIterable(set)
assert.deepStrictEqual(result, [1, 2, 3])
```

**Signature**

```ts
export declare const fromIterable: <A>(collection: Iterable<A>) => Array<A>
```


# fromOption

Converts an `Option` to an array.

To import and use `fromOption` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.fromOption
```

**Example**

```ts
import { Array, Option } from "effect"

assert.deepStrictEqual(Array.fromOption(Option.some(1)), [1])
assert.deepStrictEqual(Array.fromOption(Option.none()), [])
```

**Signature**

```ts
export declare const fromOption: <A>(self: Option<A>) => Array<A>
```


# fromRecord

Takes a record and returns an array of tuples containing its keys and values.

To import and use `fromRecord` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.fromRecord
```

**Example**

```ts
import { Array } from "effect"

const x = { a: 1, b: 2, c: 3 }
assert.deepStrictEqual(Array.fromRecord(x), [
  ["a", 1],
  ["b", 2],
  ["c", 3]
])
```

**Signature**

```ts
export declare const fromRecord: <K extends string, A>(self: Readonly<Record<K, A>>) => Array<[K, A]>
```


# get

This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.

To import and use `get` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.get
```

**Signature**

```ts
export declare const get: {
  (index: number): <A>(self: ReadonlyArray<A>) => Option<A>
  <A>(self: ReadonlyArray<A>, index: number): Option<A>
}
```


# getEquivalence

Creates an equivalence relation for arrays.

To import and use `getEquivalence` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.getEquivalence
```

**Example**

```ts
import { Array } from "effect"

const numbers1 = [1, 2, 3]
const numbers2 = [1, 2, 3]
const eq = Array.getEquivalence<number>((a, b) => a === b)
assert.deepStrictEqual(eq(numbers1, numbers2), true)
```

**Signature**

```ts
export declare const getEquivalence: <A>(
  isEquivalent: Equivalence.Equivalence<A>
) => Equivalence.Equivalence<ReadonlyArray<A>>
```


# getLefts

Retrieves the `Left` values from an `Iterable` of `Either`s, collecting them into an array.

To import and use `getLefts` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.getLefts
```

**Example**

```ts
import { Array, Either } from "effect"

assert.deepStrictEqual(Array.getLefts([Either.right(1), Either.left("err"), Either.right(2)]), ["err"])
```

**Signature**

```ts
export declare const getLefts: <T extends Iterable<Either<any, any>>>(
  self: T
) => Array<Either.Left<ReadonlyArray.Infer<T>>>
```


# getOrder

This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.
The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.
If all elements are equal, the arrays are then compared based on their length.
It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.

To import and use `getOrder` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.getOrder
```

**Signature**

```ts
export declare const getOrder: <A>(O: Order.Order<A>) => Order.Order<ReadonlyArray<A>>
```


# getRights

Retrieves the `Right` values from an `Iterable` of `Either`s, collecting them into an array.

To import and use `getRights` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.getRights
```

**Example**

```ts
import { Array, Either } from "effect"

assert.deepStrictEqual(Array.getRights([Either.right(1), Either.left("err"), Either.right(2)]), [1, 2])
```

**Signature**

```ts
export declare const getRights: <T extends Iterable<Either<any, any>>>(
  self: T
) => Array<Either.Right<ReadonlyArray.Infer<T>>>
```


# getSomes

Retrieves the `Some` values from an `Iterable` of `Option`s, collecting them into an array.

To import and use `getSomes` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.getSomes
```

**Example**

```ts
import { Array, Option } from "effect"

assert.deepStrictEqual(Array.getSomes([Option.some(1), Option.none(), Option.some(2)]), [1, 2])
```

**Signature**

```ts
export declare const getSomes: <T extends Iterable<Option<X>>, X = any>(
  self: T
) => Array<Option.Value<ReadonlyArray.Infer<T>>>
```


# group

Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s.

To import and use `group` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.group
```

**Example**

```ts
import { Array } from "effect"

const result = Array.group([1, 1, 2, 2, 2, 3, 1])
assert.deepStrictEqual(result, [[1, 1], [2, 2, 2], [3], [1]])
```

**Signature**

```ts
export declare const group: <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>>
```


# groupBy

Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning
function on each element, and grouping the results according to values returned

To import and use `groupBy` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.groupBy
```

**Example**

```ts
import { Array } from "effect"

const people = [
  { name: "Alice", group: "A" },
  { name: "Bob", group: "B" },
  { name: "Charlie", group: "A" }
]
const result = Array.groupBy(people, (person) => person.group)
assert.deepStrictEqual(result, {
  A: [
    { name: "Alice", group: "A" },
    { name: "Charlie", group: "A" }
  ],
  B: [{ name: "Bob", group: "B" }]
})
```

**Signature**

```ts
export declare const groupBy: {
  <A, K extends string | symbol>(
    f: (a: A) => K
  ): (self: Iterable<A>) => Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>
  <A, K extends string | symbol>(
    self: Iterable<A>,
    f: (a: A) => K
  ): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>
}
```


# groupWith

Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.

To import and use `groupWith` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.groupWith
```

**Example**

```ts
import { Array } from "effect"

const result = Array.groupWith(["a", "a", "b", "b", "b", "c", "a"], (x, y) => x === y)
assert.deepStrictEqual(result, [["a", "a"], ["b", "b", "b"], ["c"], ["a"]])
```

**Signature**

```ts
export declare const groupWith: {
  <A>(isEquivalent: (self: A, that: A) => boolean): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>>
  <A>(self: NonEmptyReadonlyArray<A>, isEquivalent: (self: A, that: A) => boolean): NonEmptyArray<NonEmptyArray<A>>
}
```


# head

Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.

To import and use `head` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.head
```

**Signature**

```ts
export declare const head: <A>(self: ReadonlyArray<A>) => Option<A>
```


# headNonEmpty

Get the first element of a non empty array.

To import and use `headNonEmpty` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.headNonEmpty
```

**Example**

```ts
import { Array } from "effect"

const result = Array.headNonEmpty([1, 2, 3, 4])
assert.deepStrictEqual(result, 1)
```

**Signature**

```ts
export declare const headNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => A
```


# init

Get all but the last element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.

To import and use `init` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.init
```

**Signature**

```ts
export declare const init: <A>(self: Iterable<A>) => Option<Array<A>>
```


# initNonEmpty

Get all but the last element of a non empty array, creating a new array.

To import and use `initNonEmpty` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.initNonEmpty
```

**Example**

```ts
import { Array } from "effect"

const result = Array.initNonEmpty([1, 2, 3, 4])
assert.deepStrictEqual(result, [1, 2, 3])
```

**Signature**

```ts
export declare const initNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => Array<A>
```


# insertAt

Insert an element at the specified index, creating a new `NonEmptyArray`,
or return `None` if the index is out of bounds.

To import and use `insertAt` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.insertAt
```

**Example**

```ts
import { Array, Option } from "effect"

const letters = ["a", "b", "c", "e"]
const result = Array.insertAt(letters, 3, "d")
assert.deepStrictEqual(result, Option.some(["a", "b", "c", "d", "e"]))
```

**Signature**

```ts
export declare const insertAt: {
  <B>(i: number, b: B): <A>(self: Iterable<A>) => Option<NonEmptyArray<A | B>>
  <A, B>(self: Iterable<A>, i: number, b: B): Option<NonEmptyArray<A | B>>
}
```


# intersection

Creates an `Array` of unique values that are included in all given `Iterable`s.
The order and references of result values are determined by the first `Iterable`.

To import and use `intersection` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.intersection
```

**Example**

```ts
import { Array } from "effect"

const array1 = [1, 2, 3]
const array2 = [3, 4, 1]
const result = Array.intersection(array1, array2)
assert.deepStrictEqual(result, [1, 3])
```

**Signature**

```ts
export declare const intersection: {
  <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<A & B>
  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A & B>
}
```


# intersectionWith

Creates an `Array` of unique values that are included in all given `Iterable`s using the provided `isEquivalent` function.
The order and references of result values are determined by the first `Iterable`.

To import and use `intersectionWith` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.intersectionWith
```

**Example**

```ts
import { Array } from "effect"

const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }]
const array2 = [{ id: 3 }, { id: 4 }, { id: 1 }]
const isEquivalent = (a: { id: number }, b: { id: number }) => a.id === b.id
const result = Array.intersectionWith(isEquivalent)(array2)(array1)
assert.deepStrictEqual(result, [{ id: 1 }, { id: 3 }])
```

**Signature**

```ts
export declare const intersectionWith: <A>(isEquivalent: (self: A, that: A) => boolean) => {
  (that: Iterable<A>): (self: Iterable<A>) => Array<A>
  (self: Iterable<A>, that: Iterable<A>): Array<A>
}
```


# intersperse

Places an element in between members of an `Iterable`.
If the input is a non-empty array, the result is also a non-empty array.

To import and use `intersperse` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.intersperse
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3]
const result = Array.intersperse(numbers, 0)
assert.deepStrictEqual(result, [1, 0, 2, 0, 3])
```

**Signature**

```ts
export declare const intersperse: {
  <B>(middle: B): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>
  <A, B>(self: NonEmptyReadonlyArray<A>, middle: B): NonEmptyArray<A | B>
  <A, B>(self: Iterable<A>, middle: B): Array<A | B>
}
```


# isArray

Determine if `unknown` is an Array.

To import and use `isArray` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.isArray
```

**Example**

```ts
import { isArray } from "effect/Array"

assert.deepStrictEqual(isArray(null), false)
assert.deepStrictEqual(isArray([1, 2, 3]), true)
```

**Signature**

```ts
export declare const isArray: {
  (self: unknown): self is Array<unknown>
  <T>(self: T): self is Extract<T, ReadonlyArray<any>>
}
```


# isEmptyArray

Determine if an `Array` is empty narrowing down the type to `[]`.

To import and use `isEmptyArray` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.isEmptyArray
```

**Example**

```ts
import { isEmptyArray } from "effect/Array"

assert.deepStrictEqual(isEmptyArray([]), true)
assert.deepStrictEqual(isEmptyArray([1, 2, 3]), false)
```

**Signature**

```ts
export declare const isEmptyArray: <A>(self: Array<A>) => self is []
```


# isEmptyReadonlyArray

Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.

To import and use `isEmptyReadonlyArray` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.isEmptyReadonlyArray
```

**Example**

```ts
import { isEmptyReadonlyArray } from "effect/Array"

assert.deepStrictEqual(isEmptyReadonlyArray([]), true)
assert.deepStrictEqual(isEmptyReadonlyArray([1, 2, 3]), false)
```

**Signature**

```ts
export declare const isEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is readonly []
```


# isNonEmptyArray

Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.

An `Array` is considered to be a `NonEmptyArray` if it contains at least one element.

To import and use `isNonEmptyArray` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.isNonEmptyArray
```

**Example**

```ts
import { isNonEmptyArray } from "effect/Array"

assert.deepStrictEqual(isNonEmptyArray([]), false)
assert.deepStrictEqual(isNonEmptyArray([1, 2, 3]), true)
```

**Signature**

```ts
export declare const isNonEmptyArray: <A>(self: Array<A>) => self is NonEmptyArray<A>
```


# isNonEmptyReadonlyArray

Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.

A `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.

To import and use `isNonEmptyReadonlyArray` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.isNonEmptyReadonlyArray
```

**Example**

```ts
import { isNonEmptyReadonlyArray } from "effect/Array"

assert.deepStrictEqual(isNonEmptyReadonlyArray([]), false)
assert.deepStrictEqual(isNonEmptyReadonlyArray([1, 2, 3]), true)
```

**Signature**

```ts
export declare const isNonEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A>
```


# join

Joins the elements together with "sep" in the middle.

To import and use `join` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.join
```

**Example**

```ts
import { Array } from "effect"

const strings = ["a", "b", "c"]
const joined = Array.join(strings, "-")
assert.deepStrictEqual(joined, "a-b-c")
```

**Signature**

```ts
export declare const join: {
  (sep: string): (self: Iterable<string>) => string
  (self: Iterable<string>, sep: string): string
}
```


# last

Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.

To import and use `last` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.last
```

**Signature**

```ts
export declare const last: <A>(self: ReadonlyArray<A>) => Option<A>
```


# lastNonEmpty

Get the last element of a non empty array.

To import and use `lastNonEmpty` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.lastNonEmpty
```

**Example**

```ts
import { Array } from "effect"

const result = Array.lastNonEmpty([1, 2, 3, 4])
assert.deepStrictEqual(result, 4)
```

**Signature**

```ts
export declare const lastNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => A
```


# length

Return the number of elements in a `ReadonlyArray`.

To import and use `length` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.length
```

**Signature**

```ts
export declare const length: <A>(self: ReadonlyArray<A>) => number
```


# let

The "do simulation" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.

It can be used to simulate "array comprehension".
It's a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It's like assembling a new collection from pieces of other collections based on certain rules.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

To import and use `let` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.let
```

**Example**

```ts
import { Array as Arr, pipe } from "effect"
const doResult = pipe(
  Arr.Do,
  Arr.bind("x", () => [1, 3, 5]),
  Arr.bind("y", () => [2, 4, 6]),
  Arr.filter(({ x, y }) => x < y), // condition
  Arr.map(({ x, y }) => [x, y] as const) // transformation
)
assert.deepStrictEqual(doResult, [
  [1, 2],
  [1, 4],
  [1, 6],
  [3, 4],
  [3, 6],
  [5, 6]
])

// equivalent
const x = [1, 3, 5],
  y = [2, 4, 6],
  result = []
for (let i = 0; i < x.length; i++) {
  for (let j = 0; j < y.length; j++) {
    const _x = x[i],
      _y = y[j]
    if (_x < _y) result.push([_x, _y] as const)
  }
}
```


# liftEither

Lifts a function that returns an `Either` into a function that returns an array.
If the `Either` is a left, it returns an empty array.
If the `Either` is a right, it returns an array with the right value.

To import and use `liftEither` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.liftEither
```

**Example**

```ts
import { Array, Either } from "effect"

const parseNumber = (s: string): Either.Either<number, Error> =>
  isNaN(Number(s)) ? Either.left(new Error("Not a number")) : Either.right(Number(s))

const liftedParseNumber = Array.liftEither(parseNumber)

const result1 = liftedParseNumber("42")
assert.deepStrictEqual(result1, [42])

const result2 = liftedParseNumber("not a number")
assert.deepStrictEqual(result2, [])

// Explanation:
// The function parseNumber is lifted to return an array.
// When parsing "42", it returns an Either.left with the number 42, resulting in [42].
// When parsing "not a number", it returns an Either.right with an error, resulting in an empty array [].
```

**Signature**

```ts
export declare const liftEither: <A extends Array<unknown>, E, B>(f: (...a: A) => Either<B, E>) => (...a: A) => Array<B>
```


# liftPredicate

Lifts a predicate into an array.

To import and use `liftPredicate` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.liftPredicate
```

**Example**

```ts
import { Array } from "effect"

const isEven = (n: number) => n % 2 === 0
const to = Array.liftPredicate(isEven)
assert.deepStrictEqual(to(1), [])
assert.deepStrictEqual(to(2), [2])
```

**Signature**

```ts
export declare const liftPredicate: {
  <A, B extends A>(refinement: Refinement<A, B>): (a: A) => Array<B>
  <A>(predicate: Predicate<A>): <B extends A>(b: B) => Array<B>
}
```


# make

Builds a `NonEmptyArray` from an non-empty collection of elements.

To import and use `make` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.make
```

**Example**

```ts
import { Array } from "effect"

const result = Array.make(1, 2, 3)
assert.deepStrictEqual(result, [1, 2, 3])
```

**Signature**

```ts
export declare const make: <Elements extends NonEmptyArray<any>>(
  ...elements: Elements
) => NonEmptyArray<Elements[number]>
```


# makeBy

Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.

**Note**. `n` is normalized to an integer >= 1.

To import and use `makeBy` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.makeBy
```

**Example**

```ts
import { makeBy } from "effect/Array"

assert.deepStrictEqual(
  makeBy(5, (n) => n * 2),
  [0, 2, 4, 6, 8]
)
```

**Signature**

```ts
export declare const makeBy: {
  <A>(f: (i: number) => A): (n: number) => NonEmptyArray<A>
  <A>(n: number, f: (i: number) => A): NonEmptyArray<A>
}
```


# mapAccum

Statefully maps over the chunk, producing new elements of type `B`.

To import and use `mapAccum` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.mapAccum
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3]
const result = Array.mapAccum(numbers, 0, (acc, n) => [acc + n, acc + n])
assert.deepStrictEqual(result, [6, [1, 3, 6]])
```

**Signature**

```ts
export declare const mapAccum: {
  <S, A, B, I extends Iterable<A> = Iterable<A>>(
    s: S,
    f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]
  ): (self: I) => [state: S, mappedArray: ReadonlyArray.With<I, B>]
  <S, A, B, I extends Iterable<A> = Iterable<A>>(
    self: I,
    s: S,
    f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]
  ): [state: S, mappedArray: ReadonlyArray.With<I, B>]
}
```


# match

Matches the elements of an array, applying functions to cases of empty and non-empty arrays.

To import and use `match` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.match
```

**Example**

```ts
import { Array } from "effect"

const match = Array.match({
  onEmpty: () => "empty",
  onNonEmpty: ([head, ...tail]) => `head: ${head}, tail: ${tail.length}`
})
assert.deepStrictEqual(match([]), "empty")
assert.deepStrictEqual(match([1, 2, 3]), "head: 1, tail: 2")
```

**Signature**

```ts
export declare const match: {
  <B, A, C = B>(options: {
    readonly onEmpty: LazyArg<B>
    readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C
  }): (self: ReadonlyArray<A>) => B | C
  <A, B, C = B>(
    self: ReadonlyArray<A>,
    options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C }
  ): B | C
}
```


# matchLeft

Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.

To import and use `matchLeft` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.matchLeft
```

**Example**

```ts
import { Array } from "effect"

const matchLeft = Array.matchLeft({
  onEmpty: () => "empty",
  onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`
})
assert.deepStrictEqual(matchLeft([]), "empty")
assert.deepStrictEqual(matchLeft([1, 2, 3]), "head: 1, tail: 2")
```

**Signature**

```ts
export declare const matchLeft: {
  <B, A, C = B>(options: {
    readonly onEmpty: LazyArg<B>
    readonly onNonEmpty: (head: A, tail: Array<A>) => C
  }): (self: ReadonlyArray<A>) => B | C
  <A, B, C = B>(
    self: ReadonlyArray<A>,
    options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (head: A, tail: Array<A>) => C }
  ): B | C
}
```


# matchRight

Matches the elements of an array from the right, applying functions to cases of empty and non-empty arrays.

To import and use `matchRight` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.matchRight
```

**Example**

```ts
import { Array } from "effect"

const matchRight = Array.matchRight({
  onEmpty: () => "empty",
  onNonEmpty: (init, last) => `init: ${init.length}, last: ${last}`
})
assert.deepStrictEqual(matchRight([]), "empty")
assert.deepStrictEqual(matchRight([1, 2, 3]), "init: 2, last: 3")
```

**Signature**

```ts
export declare const matchRight: {
  <B, A, C = B>(options: {
    readonly onEmpty: LazyArg<B>
    readonly onNonEmpty: (init: Array<A>, last: A) => C
  }): (self: ReadonlyArray<A>) => B | C
  <A, B, C = B>(
    self: ReadonlyArray<A>,
    options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (init: Array<A>, last: A) => C }
  ): B | C
}
```


# max

Finds the maximum element in an array based on a comparator.

To import and use `max` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.max
```

**Example**

```ts
import { Array, Order } from "effect"

const max = Array.max([3, 1, 2], Order.number)
assert.deepStrictEqual(max, 3)
```

**Signature**

```ts
export declare const max: {
  <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A
  <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A
}
```


# min

Finds the minimum element in an array based on a comparator.

To import and use `min` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.min
```

**Example**

```ts
import { Array, Order } from "effect"

const min = Array.min([3, 1, 2], Order.number)
assert.deepStrictEqual(min, 1)
```

**Signature**

```ts
export declare const min: {
  <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A
  <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A
}
```


# modify

Apply a function to the element at the specified index, creating a new `Array`,
or return a copy of the input if the index is out of bounds.

To import and use `modify` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.modify
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3, 4]
const result = Array.modify(numbers, 2, (n) => n * 2)
assert.deepStrictEqual(result, [1, 2, 6, 4])
```

**Signature**

```ts
export declare const modify: {
  <A, B, S extends Iterable<A> = Iterable<A>>(
    i: number,
    f: (a: ReadonlyArray.Infer<S>) => B
  ): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>
  <A, B, S extends Iterable<A> = Iterable<A>>(
    self: S,
    i: number,
    f: (a: ReadonlyArray.Infer<S>) => B
  ): ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>
}
```


# modifyNonEmptyHead

Apply a function to the head, creating a new `NonEmptyReadonlyArray`.

To import and use `modifyNonEmptyHead` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.modifyNonEmptyHead
```

**Example**

```ts
import { Array } from "effect"

const result = Array.modifyNonEmptyHead([1, 2, 3], (n) => n * 10)
assert.deepStrictEqual(result, [10, 2, 3])
```

**Signature**

```ts
export declare const modifyNonEmptyHead: {
  <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>
  <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>
}
```


# modifyNonEmptyLast

Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.

To import and use `modifyNonEmptyLast` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.modifyNonEmptyLast
```

**Example**

```ts
import { Array } from "effect"

const result = Array.modifyNonEmptyLast([1, 2, 3], (n) => n * 2)
assert.deepStrictEqual(result, [1, 2, 6])
```

**Signature**

```ts
export declare const modifyNonEmptyLast: {
  <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>
  <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>
}
```


# modifyOption

Apply a function to the element at the specified index, creating a new `Array`,
or return `None` if the index is out of bounds.

To import and use `modifyOption` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.modifyOption
```

**Example**

```ts
import { Array, Option } from "effect"

const numbers = [1, 2, 3, 4]
const result = Array.modifyOption(numbers, 2, (n) => n * 2)
assert.deepStrictEqual(result, Option.some([1, 2, 6, 4]))

const outOfBoundsResult = Array.modifyOption(numbers, 5, (n) => n * 2)
assert.deepStrictEqual(outOfBoundsResult, Option.none())
```

**Signature**

```ts
export declare const modifyOption: {
  <A, B, S extends Iterable<A> = Iterable<A>>(
    i: number,
    f: (a: ReadonlyArray.Infer<S>) => B
  ): (self: S) => Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>
  <A, B, S extends Iterable<A> = Iterable<A>>(
    self: S,
    i: number,
    f: (a: ReadonlyArray.Infer<S>) => B
  ): Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>
}
```


# of

Constructs a new `NonEmptyArray<A>` from the specified value.

To import and use `of` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.of
```

**Signature**

```ts
export declare const of: <A>(a: A) => NonEmptyArray<A>
```


# pad

Pads an array.
Returns a new array of length `n` with the elements of `array` followed by `fill` elements if `array` is shorter than `n`.
If `array` is longer than `n`, the returned array will be a slice of `array` containing the `n` first elements of `array`.
If `n` is less than or equal to 0, the returned array will be an empty array.

To import and use `pad` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.pad
```

**Example**

```ts
import { Array } from "effect"

const arr = [1, 2, 3]
const result = Array.pad(arr, 6, 0)
assert.deepStrictEqual(result, [1, 2, 3, 0, 0, 0])
```

**Signature**

```ts
export declare const pad: {
  <A, T>(n: number, fill: T): (self: Array<A>) => Array<A | T>
  <A, T>(self: Array<A>, n: number, fill: T): Array<A | T>
}
```


# partition

Separate elements based on a predicate that also exposes the index of the element.

To import and use `partition` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.partition
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3, 4]

const result = Array.partition(numbers, (n) => n % 2 === 0)

assert.deepStrictEqual(result, [
  [1, 3],
  [2, 4]
])
```

**Signature**

```ts
export declare const partition: {
  <A, B extends A>(
    refinement: (a: NoInfer<A>, i: number) => a is B
  ): (self: Iterable<A>) => [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]
  <A>(
    predicate: (a: NoInfer<A>, i: number) => boolean
  ): (self: Iterable<A>) => [excluded: Array<A>, satisfying: Array<A>]
  <A, B extends A>(
    self: Iterable<A>,
    refinement: (a: A, i: number) => a is B
  ): [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]
  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [excluded: Array<A>, satisfying: Array<A>]
}
```


# partitionMap

Applies a function to each element of the `Iterable`, categorizing the results into two separate arrays.
This function is particularly useful for operations where each element can result in two possible types,
and you want to separate these types into different collections. For instance, separating validation results
into successes and failures.

To import and use `partitionMap` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.partitionMap
```

**Example**

```ts
import { Array, Either } from "effect"

const data = [1, 2, 3, 4, 5]
const isEven = (x: number) => x % 2 === 0
const partitioned = Array.partitionMap(data, (x) => (isEven(x) ? Either.right(x) : Either.left(x)))

assert.deepStrictEqual(partitioned, [
  [1, 3, 5],
  [2, 4]
])
```

**Signature**

```ts
export declare const partitionMap: {
  <A, B, C>(f: (a: A, i: number) => Either<C, B>): (self: Iterable<A>) => [left: Array<B>, right: Array<C>]
  <A, B, C>(self: Iterable<A>, f: (a: A, i: number) => Either<C, B>): [left: Array<B>, right: Array<C>]
}
```


# prepend

Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.

To import and use `prepend` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.prepend
```

**Example**

```ts
import { Array } from "effect"

const original = [2, 3, 4]
const result = Array.prepend(original, 1)
assert.deepStrictEqual(result, [1, 2, 3, 4])
```

**Signature**

```ts
export declare const prepend: {
  <B>(head: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>
  <A, B>(self: Iterable<A>, head: B): NonEmptyArray<A | B>
}
```


# prependAll

Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).
If either array is non-empty, the result is also a non-empty array.

To import and use `prependAll` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.prependAll
```

**Example**

```ts
import { Array } from "effect"

const prefix = [0, 1]
const array = [2, 3]
const result = Array.prependAll(array, prefix)
assert.deepStrictEqual(result, [0, 1, 2, 3])
```

**Signature**

```ts
export declare const prependAll: {
  <S extends Iterable<any>, T extends Iterable<any>>(
    that: T
  ): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>
  <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>
  <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>
  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>
}
```


# range

Return a `NonEmptyArray` containing a range of integers, including both endpoints.

To import and use `range` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.range
```

**Example**

```ts
import { range } from "effect/Array"

assert.deepStrictEqual(range(1, 3), [1, 2, 3])
```

**Signature**

```ts
export declare const range: (start: number, end: number) => NonEmptyArray<number>
```


# reduce

Reduces an array from the left.

To import and use `reduce` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.reduce
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3]
const result = Array.reduce(numbers, 0, (acc, n) => acc + n)
assert.deepStrictEqual(result, 6)
```

**Signature**

```ts
export declare const reduce: {
  <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B
  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B
}
```


# reduceRight

Reduces an array from the right.

To import and use `reduceRight` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.reduceRight
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3]
const result = Array.reduceRight(numbers, 0, (acc, n) => acc + n)
assert.deepStrictEqual(result, 6)
```

**Signature**

```ts
export declare const reduceRight: {
  <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B
  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B
}
```


# remove

Delete the element at the specified index, creating a new `Array`,
or return a copy of the input if the index is out of bounds.

To import and use `remove` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.remove
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3, 4]
const result = Array.remove(numbers, 2)
assert.deepStrictEqual(result, [1, 2, 4])

const outOfBoundsResult = Array.remove(numbers, 5)
assert.deepStrictEqual(outOfBoundsResult, [1, 2, 3, 4])
```

**Signature**

```ts
export declare const remove: {
  (i: number): <A>(self: Iterable<A>) => Array<A>
  <A>(self: Iterable<A>, i: number): Array<A>
}
```


# replace

Change the element at the specified index, creating a new `Array`,
or return a copy of the input if the index is out of bounds.

To import and use `replace` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.replace
```

**Example**

```ts
import { Array } from "effect"

const letters = ["a", "b", "c", "d"]
const result = Array.replace(letters, 1, "z")
assert.deepStrictEqual(result, ["a", "z", "c", "d"])
```

**Signature**

```ts
export declare const replace: {
  <B>(
    i: number,
    b: B
  ): <A, S extends Iterable<A> = Iterable<A>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>
  <A, B, S extends Iterable<A> = Iterable<A>>(
    self: S,
    i: number,
    b: B
  ): ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>
}
```


# replaceOption

Replaces an element in an array with the given value, returning an option of the updated array.

To import and use `replaceOption` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.replaceOption
```

**Example**

```ts
import { Array, Option } from "effect"

const numbers = [1, 2, 3]
const result = Array.replaceOption(numbers, 1, 4)
assert.deepStrictEqual(result, Option.some([1, 4, 3]))
```

**Signature**

```ts
export declare const replaceOption: {
  <B>(
    i: number,
    b: B
  ): <A, S extends Iterable<A> = Iterable<A>>(self: S) => Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>
  <A, B, S extends Iterable<A> = Iterable<A>>(
    self: S,
    i: number,
    b: B
  ): Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>
}
```


# replicate

Return a `NonEmptyArray` containing a value repeated the specified number of times.

**Note**. `n` is normalized to an integer >= 1.

To import and use `replicate` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.replicate
```

**Example**

```ts
import { Array } from "effect"

assert.deepStrictEqual(Array.replicate("a", 3), ["a", "a", "a"])
```

**Signature**

```ts
export declare const replicate: { (n: number): <A>(a: A) => NonEmptyArray<A>; <A>(a: A, n: number): NonEmptyArray<A> }
```


# reverse

Reverse an `Iterable`, creating a new `Array`.

To import and use `reverse` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.reverse
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3, 4]
const result = Array.reverse(numbers)
assert.deepStrictEqual(result, [4, 3, 2, 1])
```

**Signature**

```ts
export declare const reverse: <S extends Iterable<any> | NonEmptyReadonlyArray<any>>(
  self: S
) => S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never
```


# rotate

Rotate an `Iterable` by `n` steps.
If the input is a non-empty array, the result is also a non-empty array.

To import and use `rotate` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.rotate
```

**Example**

```ts
import { Array } from "effect"

const letters = ["a", "b", "c", "d"]
const result = Array.rotate(letters, 2)
assert.deepStrictEqual(result, ["c", "d", "a", "b"])
```

**Signature**

```ts
export declare const rotate: {
  (n: number): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>
  <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<A>
  <A>(self: Iterable<A>, n: number): Array<A>
}
```


# scan

Accumulates values from an `Iterable` starting from the left, storing
each intermediate result in an array. Useful for tracking the progression of
a value through a series of transformations.

To import and use `scan` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.scan
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3, 4]
const result = Array.scan(numbers, 0, (acc, value) => acc + value)
assert.deepStrictEqual(result, [0, 1, 3, 6, 10])

// Explanation:
// This function starts with the initial value (0 in this case)
// and adds each element of the array to this accumulator one by one,
// keeping track of the cumulative sum after each addition.
// Each of these sums is captured in the resulting array.
```

**Signature**

```ts
export declare const scan: {
  <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>
  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>
}
```


# scanRight

Accumulates values from an `Iterable` starting from the right, storing
each intermediate result in an array. Useful for tracking the progression of
a value through a series of transformations.

To import and use `scanRight` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.scanRight
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3, 4]
const result = Array.scanRight(numbers, 0, (acc, value) => acc + value)
assert.deepStrictEqual(result, [10, 9, 7, 4, 0])
```

**Signature**

```ts
export declare const scanRight: {
  <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>
  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>
}
```


# separate

Separates an `Iterable` into two arrays based on a predicate.

To import and use `separate` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.separate
```

**Signature**

```ts
export declare const separate: <T extends Iterable<Either<any, any>>>(
  self: T
) => [Array<Either.Left<ReadonlyArray.Infer<T>>>, Array<Either.Right<ReadonlyArray.Infer<T>>>]
```


# setNonEmptyHead

Change the head, creating a new `NonEmptyReadonlyArray`.

To import and use `setNonEmptyHead` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.setNonEmptyHead
```

**Example**

```ts
import { Array } from "effect"

const result = Array.setNonEmptyHead([1, 2, 3], 10)
assert.deepStrictEqual(result, [10, 2, 3])
```

**Signature**

```ts
export declare const setNonEmptyHead: {
  <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>
  <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>
}
```


# setNonEmptyLast

Change the last element, creating a new `NonEmptyReadonlyArray`.

To import and use `setNonEmptyLast` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.setNonEmptyLast
```

**Example**

```ts
import { Array } from "effect"

const result = Array.setNonEmptyLast([1, 2, 3], 4)
assert.deepStrictEqual(result, [1, 2, 4])
```

**Signature**

```ts
export declare const setNonEmptyLast: {
  <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>
  <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>
}
```


# some

Check if a predicate holds true for some `ReadonlyArray` element.

To import and use `some` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.some
```

**Signature**

```ts
export declare const some: {
  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A>
  <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): self is NonEmptyReadonlyArray<A>
}
```


# sort

Create a new array with elements sorted in increasing order based on the specified comparator.
If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.

To import and use `sort` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.sort
```

**Signature**

```ts
export declare const sort: {
  <B>(
    O: Order.Order<B>
  ): <A extends B, S extends ReadonlyArray<A> | Iterable<A>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>
  <A extends B, B>(self: NonEmptyReadonlyArray<A>, O: Order.Order<B>): NonEmptyArray<A>
  <A extends B, B>(self: Iterable<A>, O: Order.Order<B>): Array<A>
}
```


# sortBy

Sorts the elements of an `Iterable` in increasing order based on the provided
orders. The elements are compared using the first order in `orders`, then the
second order if the first comparison is equal, and so on.

To import and use `sortBy` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.sortBy
```

**Example**

```ts
import { Array, Order } from "effect"

const users = [
  { name: "Alice", age: 30 },
  { name: "Bob", age: 25 },
  { name: "Charlie", age: 30 }
]

const result = Array.sortBy(
  Order.mapInput(Order.number, (user: (typeof users)[number]) => user.age),
  Order.mapInput(Order.string, (user: (typeof users)[number]) => user.name)
)(users)

assert.deepStrictEqual(result, [
  { name: "Bob", age: 25 },
  { name: "Alice", age: 30 },
  { name: "Charlie", age: 30 }
])

// Explanation:
// The array of users is sorted first by age in ascending order. When ages are equal,
// the users are further sorted by name in ascending order.
```

**Signature**

```ts
export declare const sortBy: <S extends Iterable<any> | NonEmptyReadonlyArray<any>>(
  ...orders: ReadonlyArray<Order.Order<ReadonlyArray.Infer<S>>>
) => (
  self: S
) => S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never
```


# sortWith

Sorts an array based on a provided mapping function and order. The mapping
function transforms the elements into a value that can be compared, and the
order defines how those values should be sorted.

To import and use `sortWith` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.sortWith
```

**Example**

```ts
import { Array, Order } from "effect"

const strings = ["aaa", "b", "cc"]
const result = Array.sortWith(strings, (s) => s.length, Order.number)
assert.deepStrictEqual(result, ["b", "cc", "aaa"])

// Explanation:
// The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`
// converts each string into its length, and the `Order.number` specifies that the lengths should
// be sorted in ascending order.
```

**Signature**

```ts
export declare const sortWith: {
  <S extends Iterable<any> | NonEmptyReadonlyArray<any>, B>(
    f: (a: ReadonlyArray.Infer<S>) => B,
    order: Order.Order<B>
  ): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>
  <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B, O: Order.Order<B>): NonEmptyArray<A>
  <A, B>(self: Iterable<A>, f: (a: A) => B, order: Order.Order<B>): Array<A>
}
```


# span

Split an `Iterable` into two parts:

1. the longest initial subarray for which all elements satisfy the specified predicate
2. the remaining elements

To import and use `span` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.span
```

**Signature**

```ts
export declare const span: {
  <A, B extends A>(
    refinement: (a: NoInfer<A>, i: number) => a is B
  ): (self: Iterable<A>) => [init: Array<B>, rest: Array<Exclude<A, B>>]
  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [init: Array<A>, rest: Array<A>]
  <A, B extends A>(
    self: Iterable<A>,
    refinement: (a: A, i: number) => a is B
  ): [init: Array<B>, rest: Array<Exclude<A, B>>]
  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [init: Array<A>, rest: Array<A>]
}
```


# split

Splits this iterable into `n` equally sized arrays.

To import and use `split` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.split
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3, 4, 5, 6, 7, 8]
const result = Array.split(numbers, 3)
assert.deepStrictEqual(result, [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8]
])
```

**Signature**

```ts
export declare const split: {
  (n: number): <A>(self: Iterable<A>) => Array<Array<A>>
  <A>(self: Iterable<A>, n: number): Array<Array<A>>
}
```


# splitAt

Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.
The value of `n` can be `0`.

To import and use `splitAt` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.splitAt
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3, 4, 5]
const result = Array.splitAt(numbers, 3)
assert.deepStrictEqual(result, [
  [1, 2, 3],
  [4, 5]
])
```

**Signature**

```ts
export declare const splitAt: {
  (n: number): <A>(self: Iterable<A>) => [beforeIndex: Array<A>, fromIndex: Array<A>]
  <A>(self: Iterable<A>, n: number): [beforeIndex: Array<A>, fromIndex: Array<A>]
}
```


# splitNonEmptyAt

Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.
The value of `n` must be `>= 1`.

To import and use `splitNonEmptyAt` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.splitNonEmptyAt
```

**Example**

```ts
import { Array } from "effect"

const result = Array.splitNonEmptyAt(["a", "b", "c", "d", "e"], 3)
assert.deepStrictEqual(result, [
  ["a", "b", "c"],
  ["d", "e"]
])
```

**Signature**

```ts
export declare const splitNonEmptyAt: {
  (n: number): <A>(self: NonEmptyReadonlyArray<A>) => [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]
  <A>(self: NonEmptyReadonlyArray<A>, n: number): [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]
}
```


# splitWhere

Splits this iterable on the first element that matches this predicate.
Returns a tuple containing two arrays: the first one is before the match, and the second one is from the match onward.

To import and use `splitWhere` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.splitWhere
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3, 4, 5]
const result = Array.splitWhere(numbers, (n) => n > 3)
assert.deepStrictEqual(result, [
  [1, 2, 3],
  [4, 5]
])
```

**Signature**

```ts
export declare const splitWhere: {
  <A>(
    predicate: (a: NoInfer<A>, i: number) => boolean
  ): (self: Iterable<A>) => [beforeMatch: Array<A>, fromMatch: Array<A>]
  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [beforeMatch: Array<A>, fromMatch: Array<A>]
}
```


# tail

Get all but the first element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.

To import and use `tail` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.tail
```

**Signature**

```ts
export declare const tail: <A>(self: Iterable<A>) => Option<Array<A>>
```


# tailNonEmpty

Get all but the first element of a `NonEmptyReadonlyArray`.

To import and use `tailNonEmpty` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.tailNonEmpty
```

**Example**

```ts
import { Array } from "effect"

const result = Array.tailNonEmpty([1, 2, 3, 4])
assert.deepStrictEqual(result, [2, 3, 4])
```

**Signature**

```ts
export declare const tailNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => Array<A>
```


# take

Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.

**Note**. `n` is normalized to a non negative integer.

To import and use `take` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.take
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3, 4, 5]
const result = Array.take(numbers, 3)
assert.deepStrictEqual(result, [1, 2, 3])
```

**Signature**

```ts
export declare const take: {
  (n: number): <A>(self: Iterable<A>) => Array<A>
  <A>(self: Iterable<A>, n: number): Array<A>
}
```


# takeRight

Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.

**Note**. `n` is normalized to a non negative integer.

To import and use `takeRight` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.takeRight
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 2, 3, 4, 5]
const result = Array.takeRight(numbers, 3)
assert.deepStrictEqual(result, [3, 4, 5])
```

**Signature**

```ts
export declare const takeRight: {
  (n: number): <A>(self: Iterable<A>) => Array<A>
  <A>(self: Iterable<A>, n: number): Array<A>
}
```


# takeWhile

Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.

To import and use `takeWhile` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.takeWhile
```

**Example**

```ts
import { Array } from "effect"

const numbers = [1, 3, 2, 4, 1, 2]
const result = Array.takeWhile(numbers, (x) => x < 4)
assert.deepStrictEqual(result, [1, 3, 2])

// Explanation:
// - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.
// - The next element (`3`) is also less than `4`, so it adds `3`.
// - The next element (`2`) is again less than `4`, so it adds `2`.
// - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.
```

**Signature**

```ts
export declare const takeWhile: {
  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Array<B>
  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>
  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Array<B>
  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>
}
```


# unappend

Return a tuple containing a copy of the `NonEmptyReadonlyArray` without its last element, and that last element.

To import and use `unappend` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.unappend
```

**Example**

```ts
import { Array } from "effect"

const result = Array.unappend([1, 2, 3, 4])
assert.deepStrictEqual(result, [[1, 2, 3], 4])
```

**Signature**

```ts
export declare const unappend: <A>(
  self: NonEmptyReadonlyArray<A>
) => [arrayWithoutLastElement: Array<A>, lastElement: A]
```


# union

Creates a union of two arrays, removing duplicates.

To import and use `union` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.union
```

**Example**

```ts
import { Array } from "effect"

const array1 = [1, 2]
const array2 = [2, 3]
const result = Array.union(array1, array2)
assert.deepStrictEqual(result, [1, 2, 3])
```

**Signature**

```ts
export declare const union: {
  <T extends Iterable<any>>(
    that: T
  ): <S extends Iterable<any>>(
    self: S
  ) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>
  <A, B>(self: NonEmptyReadonlyArray<A>, that: ReadonlyArray<B>): NonEmptyArray<A | B>
  <A, B>(self: ReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>
  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>
}
```


# unionWith

Calculates the union of two arrays using the provided equivalence relation.

To import and use `unionWith` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.unionWith
```

**Example**

```ts
import { Array } from "effect"

const array1 = [1, 2]
const array2 = [2, 3]
const union = Array.unionWith(array1, array2, (a, b) => a === b)
assert.deepStrictEqual(union, [1, 2, 3])
```

**Signature**

```ts
export declare const unionWith: {
  <S extends Iterable<any>, T extends Iterable<any>>(
    that: T,
    isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<T>) => boolean
  ): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>
  <A, B>(
    self: NonEmptyReadonlyArray<A>,
    that: Iterable<B>,
    isEquivalent: (self: A, that: B) => boolean
  ): NonEmptyArray<A | B>
  <A, B>(
    self: Iterable<A>,
    that: NonEmptyReadonlyArray<B>,
    isEquivalent: (self: A, that: B) => boolean
  ): NonEmptyArray<A | B>
  <A, B>(self: Iterable<A>, that: Iterable<B>, isEquivalent: (self: A, that: B) => boolean): Array<A | B>
}
```


# unprepend

Return a tuple containing the first element, and a new `Array` of the remaining elements, if any.

To import and use `unprepend` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.unprepend
```

**Example**

```ts
import { Array } from "effect"

const result = Array.unprepend([1, 2, 3, 4])
assert.deepStrictEqual(result, [1, [2, 3, 4]])
```

**Signature**

```ts
export declare const unprepend: <A>(self: NonEmptyReadonlyArray<A>) => [firstElement: A, remainingElements: Array<A>]
```


# unsafeGet

Gets an element unsafely, will throw on out of bounds.

To import and use `unsafeGet` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.unsafeGet
```

**Signature**

```ts
export declare const unsafeGet: {
  (index: number): <A>(self: ReadonlyArray<A>) => A
  <A>(self: ReadonlyArray<A>, index: number): A
}
```


# unzip

This function is the inverse of `zip`. Takes an `Iterable` of pairs and return two corresponding `Array`s.

To import and use `unzip` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.unzip
```

**Example**

```ts
import { Array } from "effect"

const result = Array.unzip([
  [1, "a"],
  [2, "b"],
  [3, "c"]
])
assert.deepStrictEqual(result, [
  [1, 2, 3],
  ["a", "b", "c"]
])
```

**Signature**

```ts
export declare const unzip: <S extends Iterable<readonly [any, any]> | NonEmptyReadonlyArray<readonly [any, any]>>(
  self: S
) => S extends NonEmptyReadonlyArray<readonly [infer A, infer B]>
  ? [NonEmptyArray<A>, NonEmptyArray<B>]
  : S extends Iterable<readonly [infer A, infer B]>
    ? [Array<A>, Array<B>]
    : never
```


# zip

Takes two `Iterable`s and returns an `Array` of corresponding pairs.
If one input `Iterable` is short, excess elements of the
longer `Iterable` are discarded.

To import and use `zip` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.zip
```

**Example**

```ts
import { Array } from "effect"

const array1 = [1, 2, 3]
const array2 = ["a", "b"]
const result = Array.zip(array1, array2)
assert.deepStrictEqual(result, [
  [1, "a"],
  [2, "b"]
])
```

**Signature**

```ts
export declare const zip: {
  <B>(that: NonEmptyReadonlyArray<B>): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<[A, B]>
  <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<[A, B]>
  <A, B>(self: NonEmptyReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<[A, B]>
  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<[A, B]>
}
```


# zipWith

Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one
input `Iterable` is short, excess elements of the longer `Iterable` are discarded.

To import and use `zipWith` from the "Array" module:

```ts
import * as Array from "effect/Array"
// Can be accessed like this
Array.zipWith
```

**Example**

```ts
import { Array } from "effect"

const array1 = [1, 2, 3]
const array2 = [4, 5, 6]
const result = Array.zipWith(array1, array2, (a, b) => a + b)
assert.deepStrictEqual(result, [5, 7, 9])
```

**Signature**

```ts
export declare const zipWith: {
  <B, A, C>(that: NonEmptyReadonlyArray<B>, f: (a: A, b: B) => C): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<C>
  <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Array<C>
  <A, B, C>(self: NonEmptyReadonlyArray<A>, that: NonEmptyReadonlyArray<B>, f: (a: A, b: B) => C): NonEmptyArray<C>
  <B, A, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Array<C>
}
```


# bimapComposition

Returns a default ternary `bimap` composition.

To import and use `bimapComposition` from the "Bicovariant" module:

```ts
import * as Bicovariant from "@effect/typeclass/Bicovariant"
// Can be accessed like this
Bicovariant.bimapComposition
```

**Signature**

```ts
export declare const bimapComposition: <F extends TypeLambda, G extends TypeLambda>(
  CovariantF: Covariant<F>,
  BicovariantG: Bicovariant<G>
) => <FR, FO, FE, GR, GO, E1, A, E2, B>(
  self: Kind<F, FR, FO, FE, Kind<G, GR, GO, E1, A>>,
  f: (e: E1) => E2,
  g: (a: A) => B
) => Kind<F, FR, FO, FE, Kind<G, GR, GO, E2, B>>
```


# map

Returns a default `map` implementation.

To import and use `map` from the "Bicovariant" module:

```ts
import * as Bicovariant from "@effect/typeclass/Bicovariant"
// Can be accessed like this
Bicovariant.map
```

**Signature**

```ts
export declare const map: <F extends TypeLambda>(F: Bicovariant<F>) => Covariant<F>["map"]
```


# mapLeft

Returns a default `mapLeft` implementation.

To import and use `mapLeft` from the "Bicovariant" module:

```ts
import * as Bicovariant from "@effect/typeclass/Bicovariant"
// Can be accessed like this
Bicovariant.mapLeft
```

**Signature**

```ts
export declare const mapLeft: <F extends TypeLambda>(
  F: Bicovariant<F>
) => {
  <E, G>(f: (e: E) => G): <R, O, A>(self: Kind<F, R, O, E, A>) => Kind<F, R, O, G, A>
  <R, O, E, A, G>(self: Kind<F, R, O, E, A>, f: (e: E) => G): Kind<F, R, O, G, A>
}
```


# abs

Determines the absolute value of a given `BigDecimal`.

To import and use `abs` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.abs
```

**Example**

```ts
import { abs, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(abs(unsafeFromString("-5")), unsafeFromString("5"))
assert.deepStrictEqual(abs(unsafeFromString("0")), unsafeFromString("0"))
assert.deepStrictEqual(abs(unsafeFromString("5")), unsafeFromString("5"))
```

**Signature**

```ts
export declare const abs: (n: BigDecimal) => BigDecimal
```


# between

Checks if a `BigDecimal` is between a `minimum` and `maximum` value (inclusive).

To import and use `between` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.between
```

**Example**

```ts
import { BigDecimal } from "effect"

const between = BigDecimal.between({
  minimum: BigDecimal.unsafeFromString("1"),
  maximum: BigDecimal.unsafeFromString("5")
})

assert.deepStrictEqual(between(BigDecimal.unsafeFromString("3")), true)
assert.deepStrictEqual(between(BigDecimal.unsafeFromString("0")), false)
assert.deepStrictEqual(between(BigDecimal.unsafeFromString("6")), false)
```

**Signature**

```ts
export declare const between: {
  (options: { minimum: BigDecimal; maximum: BigDecimal }): (self: BigDecimal) => boolean
  (self: BigDecimal, options: { minimum: BigDecimal; maximum: BigDecimal }): boolean
}
```


# clamp

Restricts the given `BigDecimal` to be within the range specified by the `minimum` and `maximum` values.

- If the `BigDecimal` is less than the `minimum` value, the function returns the `minimum` value.
- If the `BigDecimal` is greater than the `maximum` value, the function returns the `maximum` value.
- Otherwise, it returns the original `BigDecimal`.

To import and use `clamp` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.clamp
```

**Example**

```ts
import { BigDecimal } from "effect"

const clamp = BigDecimal.clamp({
  minimum: BigDecimal.unsafeFromString("1"),
  maximum: BigDecimal.unsafeFromString("5")
})

assert.deepStrictEqual(clamp(BigDecimal.unsafeFromString("3")), BigDecimal.unsafeFromString("3"))
assert.deepStrictEqual(clamp(BigDecimal.unsafeFromString("0")), BigDecimal.unsafeFromString("1"))
assert.deepStrictEqual(clamp(BigDecimal.unsafeFromString("6")), BigDecimal.unsafeFromString("5"))
```

**Signature**

```ts
export declare const clamp: {
  (options: { minimum: BigDecimal; maximum: BigDecimal }): (self: BigDecimal) => BigDecimal
  (self: BigDecimal, options: { minimum: BigDecimal; maximum: BigDecimal }): BigDecimal
}
```


# divide

Provides a division operation on `BigDecimal`s.

If the dividend is not a multiple of the divisor the result will be a `BigDecimal` value
which represents the integer division rounded down to the nearest integer.

If the divisor is `0`, the result will be `None`.

To import and use `divide` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.divide
```

**Example**

```ts
import { BigDecimal, Option } from "effect"

assert.deepStrictEqual(
  BigDecimal.divide(BigDecimal.unsafeFromString("6"), BigDecimal.unsafeFromString("3")),
  Option.some(BigDecimal.unsafeFromString("2"))
)
assert.deepStrictEqual(
  BigDecimal.divide(BigDecimal.unsafeFromString("6"), BigDecimal.unsafeFromString("4")),
  Option.some(BigDecimal.unsafeFromString("1.5"))
)
assert.deepStrictEqual(
  BigDecimal.divide(BigDecimal.unsafeFromString("6"), BigDecimal.unsafeFromString("0")),
  Option.none()
)
```

**Signature**

```ts
export declare const divide: {
  (that: BigDecimal): (self: BigDecimal) => Option.Option<BigDecimal>
  (self: BigDecimal, that: BigDecimal): Option.Option<BigDecimal>
}
```


# equals

Checks if two `BigDecimal`s are equal.

To import and use `equals` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.equals
```

**Signature**

```ts
export declare const equals: {
  (that: BigDecimal): (self: BigDecimal) => boolean
  (self: BigDecimal, that: BigDecimal): boolean
}
```


# format

Formats a given `BigDecimal` as a `string`.

If the scale of the `BigDecimal` is greater than or equal to 16, the `BigDecimal` will
be formatted in scientific notation.

To import and use `format` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.format
```

**Example**

```ts
import { format, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(format(unsafeFromString("-5")), "-5")
assert.deepStrictEqual(format(unsafeFromString("123.456")), "123.456")
assert.deepStrictEqual(format(unsafeFromString("-0.00000123")), "-0.00000123")
```

**Signature**

```ts
export declare const format: (n: BigDecimal) => string
```


# fromBigInt

Creates a `BigDecimal` from a `bigint` value.

To import and use `fromBigInt` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.fromBigInt
```

**Signature**

```ts
export declare const fromBigInt: (n: bigint) => BigDecimal
```


# fromNumber

Creates a `BigDecimal` from a `number` value.

It is not recommended to convert a floating point number to a decimal directly,
as the floating point representation may be unexpected.

Throws a `RangeError` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).

To import and use `fromNumber` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.fromNumber
```

**Signature**

```ts
export declare const fromNumber: (n: number) => BigDecimal
```


# fromString

Parses a numerical `string` into a `BigDecimal`.

To import and use `fromString` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.fromString
```

**Example**

```ts
import { BigDecimal, Option } from "effect"

assert.deepStrictEqual(BigDecimal.fromString("123"), Option.some(BigDecimal.make(123n, 0)))
assert.deepStrictEqual(BigDecimal.fromString("123.456"), Option.some(BigDecimal.make(123456n, 3)))
assert.deepStrictEqual(BigDecimal.fromString("123.abc"), Option.none())
```

**Signature**

```ts
export declare const fromString: (s: string) => Option.Option<BigDecimal>
```


# greaterThan

Returns `true` if the first argument is greater than the second, otherwise `false`.

To import and use `greaterThan` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.greaterThan
```

**Example**

```ts
import { greaterThan, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(greaterThan(unsafeFromString("2"), unsafeFromString("3")), false)
assert.deepStrictEqual(greaterThan(unsafeFromString("3"), unsafeFromString("3")), false)
assert.deepStrictEqual(greaterThan(unsafeFromString("4"), unsafeFromString("3")), true)
```

**Signature**

```ts
export declare const greaterThan: {
  (that: BigDecimal): (self: BigDecimal) => boolean
  (self: BigDecimal, that: BigDecimal): boolean
}
```


# greaterThanOrEqualTo

Checks if a given `BigDecimal` is greater than or equal to the provided one.

To import and use `greaterThanOrEqualTo` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.greaterThanOrEqualTo
```

**Example**

```ts
import { greaterThanOrEqualTo, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString("2"), unsafeFromString("3")), false)
assert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString("3"), unsafeFromString("3")), true)
assert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString("4"), unsafeFromString("3")), true)
```

**Signature**

```ts
export declare const greaterThanOrEqualTo: {
  (that: BigDecimal): (self: BigDecimal) => boolean
  (self: BigDecimal, that: BigDecimal): boolean
}
```


# isBigDecimal

Checks if a given value is a `BigDecimal`.

To import and use `isBigDecimal` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.isBigDecimal
```

**Signature**

```ts
export declare const isBigDecimal: (u: unknown) => u is BigDecimal
```


# isInteger

Checks if a given `BigDecimal` is an integer.

To import and use `isInteger` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.isInteger
```

**Example**

```ts
import { isInteger, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(isInteger(unsafeFromString("0")), true)
assert.deepStrictEqual(isInteger(unsafeFromString("1")), true)
assert.deepStrictEqual(isInteger(unsafeFromString("1.1")), false)
```

**Signature**

```ts
export declare const isInteger: (n: BigDecimal) => boolean
```


# isNegative

Checks if a given `BigDecimal` is negative.

To import and use `isNegative` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.isNegative
```

**Example**

```ts
import { isNegative, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(isNegative(unsafeFromString("-1")), true)
assert.deepStrictEqual(isNegative(unsafeFromString("0")), false)
assert.deepStrictEqual(isNegative(unsafeFromString("1")), false)
```

**Signature**

```ts
export declare const isNegative: (n: BigDecimal) => boolean
```


# isPositive

Checks if a given `BigDecimal` is positive.

To import and use `isPositive` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.isPositive
```

**Example**

```ts
import { isPositive, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(isPositive(unsafeFromString("-1")), false)
assert.deepStrictEqual(isPositive(unsafeFromString("0")), false)
assert.deepStrictEqual(isPositive(unsafeFromString("1")), true)
```

**Signature**

```ts
export declare const isPositive: (n: BigDecimal) => boolean
```


# isZero

Checks if a given `BigDecimal` is `0`.

To import and use `isZero` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.isZero
```

**Example**

```ts
import { isZero, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(isZero(unsafeFromString("0")), true)
assert.deepStrictEqual(isZero(unsafeFromString("1")), false)
```

**Signature**

```ts
export declare const isZero: (n: BigDecimal) => boolean
```


# lessThan

Returns `true` if the first argument is less than the second, otherwise `false`.

To import and use `lessThan` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.lessThan
```

**Example**

```ts
import { lessThan, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(lessThan(unsafeFromString("2"), unsafeFromString("3")), true)
assert.deepStrictEqual(lessThan(unsafeFromString("3"), unsafeFromString("3")), false)
assert.deepStrictEqual(lessThan(unsafeFromString("4"), unsafeFromString("3")), false)
```

**Signature**

```ts
export declare const lessThan: {
  (that: BigDecimal): (self: BigDecimal) => boolean
  (self: BigDecimal, that: BigDecimal): boolean
}
```


# lessThanOrEqualTo

Checks if a given `BigDecimal` is less than or equal to the provided one.

To import and use `lessThanOrEqualTo` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.lessThanOrEqualTo
```

**Example**

```ts
import { lessThanOrEqualTo, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString("2"), unsafeFromString("3")), true)
assert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString("3"), unsafeFromString("3")), true)
assert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString("4"), unsafeFromString("3")), false)
```

**Signature**

```ts
export declare const lessThanOrEqualTo: {
  (that: BigDecimal): (self: BigDecimal) => boolean
  (self: BigDecimal, that: BigDecimal): boolean
}
```


# make

Creates a `BigDecimal` from a `bigint` value and a scale.

To import and use `make` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.make
```

**Signature**

```ts
export declare const make: (value: bigint, scale: number) => BigDecimal
```


# max

Returns the maximum between two `BigDecimal`s.

To import and use `max` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.max
```

**Example**

```ts
import { max, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(max(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("3"))
```

**Signature**

```ts
export declare const max: {
  (that: BigDecimal): (self: BigDecimal) => BigDecimal
  (self: BigDecimal, that: BigDecimal): BigDecimal
}
```


# min

Returns the minimum between two `BigDecimal`s.

To import and use `min` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.min
```

**Example**

```ts
import { min, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(min(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("2"))
```

**Signature**

```ts
export declare const min: {
  (that: BigDecimal): (self: BigDecimal) => BigDecimal
  (self: BigDecimal, that: BigDecimal): BigDecimal
}
```


# multiply

Provides a multiplication operation on `BigDecimal`s.

To import and use `multiply` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.multiply
```

**Example**

```ts
import { multiply, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(multiply(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("6"))
```

**Signature**

```ts
export declare const multiply: {
  (that: BigDecimal): (self: BigDecimal) => BigDecimal
  (self: BigDecimal, that: BigDecimal): BigDecimal
}
```


# negate

Provides a negate operation on `BigDecimal`s.

To import and use `negate` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.negate
```

**Example**

```ts
import { negate, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(negate(unsafeFromString("3")), unsafeFromString("-3"))
assert.deepStrictEqual(negate(unsafeFromString("-6")), unsafeFromString("6"))
```

**Signature**

```ts
export declare const negate: (n: BigDecimal) => BigDecimal
```


# normalize

Normalizes a given `BigDecimal` by removing trailing zeros.

To import and use `normalize` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.normalize
```

**Example**

```ts
import { normalize, make, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(normalize(unsafeFromString("123.00000")), normalize(make(123n, 0)))
assert.deepStrictEqual(normalize(unsafeFromString("12300000")), normalize(make(123n, -5)))
```

**Signature**

```ts
export declare const normalize: (self: BigDecimal) => BigDecimal
```


# remainder

Returns the remainder left over when one operand is divided by a second operand.

If the divisor is `0`, the result will be `None`.

To import and use `remainder` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.remainder
```

**Example**

```ts
import { BigDecimal, Option } from "effect"

assert.deepStrictEqual(
  BigDecimal.remainder(BigDecimal.unsafeFromString("2"), BigDecimal.unsafeFromString("2")),
  Option.some(BigDecimal.unsafeFromString("0"))
)
assert.deepStrictEqual(
  BigDecimal.remainder(BigDecimal.unsafeFromString("3"), BigDecimal.unsafeFromString("2")),
  Option.some(BigDecimal.unsafeFromString("1"))
)
assert.deepStrictEqual(
  BigDecimal.remainder(BigDecimal.unsafeFromString("-4"), BigDecimal.unsafeFromString("2")),
  Option.some(BigDecimal.unsafeFromString("0"))
)
```

**Signature**

```ts
export declare const remainder: {
  (divisor: BigDecimal): (self: BigDecimal) => Option.Option<BigDecimal>
  (self: BigDecimal, divisor: BigDecimal): Option.Option<BigDecimal>
}
```


# safeFromNumber

Creates a `BigDecimal` from a `number` value.

It is not recommended to convert a floating point number to a decimal directly,
as the floating point representation may be unexpected.

Returns `None` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).

To import and use `safeFromNumber` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.safeFromNumber
```

**Example**

```ts
import { BigDecimal, Option } from "effect"

assert.deepStrictEqual(BigDecimal.safeFromNumber(123), Option.some(BigDecimal.make(123n, 0)))
assert.deepStrictEqual(BigDecimal.safeFromNumber(123.456), Option.some(BigDecimal.make(123456n, 3)))
assert.deepStrictEqual(BigDecimal.safeFromNumber(Infinity), Option.none())
```

**Signature**

```ts
export declare const safeFromNumber: (n: number) => Option.Option<BigDecimal>
```


# scale

Scales a given `BigDecimal` to the specified scale.

If the given scale is smaller than the current scale, the value will be rounded down to
the nearest integer.

To import and use `scale` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.scale
```

**Signature**

```ts
export declare const scale: {
  (scale: number): (self: BigDecimal) => BigDecimal
  (self: BigDecimal, scale: number): BigDecimal
}
```


# sign

Determines the sign of a given `BigDecimal`.

To import and use `sign` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.sign
```

**Example**

```ts
import { sign, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(sign(unsafeFromString("-5")), -1)
assert.deepStrictEqual(sign(unsafeFromString("0")), 0)
assert.deepStrictEqual(sign(unsafeFromString("5")), 1)
```

**Signature**

```ts
export declare const sign: (n: BigDecimal) => Ordering
```


# subtract

Provides a subtraction operation on `BigDecimal`s.

To import and use `subtract` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.subtract
```

**Example**

```ts
import { subtract, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(subtract(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("-1"))
```

**Signature**

```ts
export declare const subtract: {
  (that: BigDecimal): (self: BigDecimal) => BigDecimal
  (self: BigDecimal, that: BigDecimal): BigDecimal
}
```


# sum

Provides an addition operation on `BigDecimal`s.

To import and use `sum` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.sum
```

**Example**

```ts
import { sum, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(sum(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("5"))
```

**Signature**

```ts
export declare const sum: {
  (that: BigDecimal): (self: BigDecimal) => BigDecimal
  (self: BigDecimal, that: BigDecimal): BigDecimal
}
```


# toExponential

Formats a given `BigDecimal` as a `string` in scientific notation.

To import and use `toExponential` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.toExponential
```

**Example**

```ts
import { toExponential, make } from "effect/BigDecimal"

assert.deepStrictEqual(toExponential(make(123456n, -5)), "1.23456e+10")
```

**Signature**

```ts
export declare const toExponential: (n: BigDecimal) => string
```


# unsafeDivide

Provides an unsafe division operation on `BigDecimal`s.

If the dividend is not a multiple of the divisor the result will be a `BigDecimal` value
which represents the integer division rounded down to the nearest integer.

Throws a `RangeError` if the divisor is `0`.

To import and use `unsafeDivide` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.unsafeDivide
```

**Example**

```ts
import { unsafeDivide, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeDivide(unsafeFromString("6"), unsafeFromString("3")), unsafeFromString("2"))
assert.deepStrictEqual(unsafeDivide(unsafeFromString("6"), unsafeFromString("4")), unsafeFromString("1.5"))
```

**Signature**

```ts
export declare const unsafeDivide: {
  (that: BigDecimal): (self: BigDecimal) => BigDecimal
  (self: BigDecimal, that: BigDecimal): BigDecimal
}
```


# unsafeFromNumber

Creates a `BigDecimal` from a `number` value.

It is not recommended to convert a floating point number to a decimal directly,
as the floating point representation may be unexpected.

Throws a `RangeError` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).

To import and use `unsafeFromNumber` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.unsafeFromNumber
```

**Example**

```ts
import { unsafeFromNumber, make } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeFromNumber(123), make(123n, 0))
assert.deepStrictEqual(unsafeFromNumber(123.456), make(123456n, 3))
```

**Signature**

```ts
export declare const unsafeFromNumber: (n: number) => BigDecimal
```


# unsafeFromString

Parses a numerical `string` into a `BigDecimal`.

To import and use `unsafeFromString` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.unsafeFromString
```

**Example**

```ts
import { unsafeFromString, make } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeFromString("123"), make(123n, 0))
assert.deepStrictEqual(unsafeFromString("123.456"), make(123456n, 3))
assert.throws(() => unsafeFromString("123.abc"))
```

**Signature**

```ts
export declare const unsafeFromString: (s: string) => BigDecimal
```


# unsafeRemainder

Returns the remainder left over when one operand is divided by a second operand.

Throws a `RangeError` if the divisor is `0`.

To import and use `unsafeRemainder` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.unsafeRemainder
```

**Example**

```ts
import { unsafeRemainder, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeRemainder(unsafeFromString("2"), unsafeFromString("2")), unsafeFromString("0"))
assert.deepStrictEqual(unsafeRemainder(unsafeFromString("3"), unsafeFromString("2")), unsafeFromString("1"))
assert.deepStrictEqual(unsafeRemainder(unsafeFromString("-4"), unsafeFromString("2")), unsafeFromString("0"))
```

**Signature**

```ts
export declare const unsafeRemainder: {
  (divisor: BigDecimal): (self: BigDecimal) => BigDecimal
  (self: BigDecimal, divisor: BigDecimal): BigDecimal
}
```


# unsafeToNumber

Converts a `BigDecimal` to a `number`.

This function will produce incorrect results if the `BigDecimal` exceeds the 64-bit range of a `number`.

To import and use `unsafeToNumber` from the "BigDecimal" module:

```ts
import * as BigDecimal from "effect/BigDecimal"
// Can be accessed like this
BigDecimal.unsafeToNumber
```

**Example**

```ts
import { unsafeToNumber, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeToNumber(unsafeFromString("123.456")), 123.456)
```

**Signature**

```ts
export declare const unsafeToNumber: (n: BigDecimal) => number
```


# abs

Determines the absolute value of a given `bigint`.

To import and use `abs` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.abs
```

**Example**

```ts
import { abs } from "effect/BigInt"

assert.deepStrictEqual(abs(-5n), 5n)
assert.deepStrictEqual(abs(0n), 0n)
assert.deepStrictEqual(abs(5n), 5n)
```

**Signature**

```ts
export declare const abs: (n: bigint) => bigint
```


# between

Checks if a `bigint` is between a `minimum` and `maximum` value (inclusive).

To import and use `between` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.between
```

**Example**

```ts
import { BigInt } from "effect"

const between = BigInt.between({ minimum: 0n, maximum: 5n })

assert.deepStrictEqual(between(3n), true)
assert.deepStrictEqual(between(-1n), false)
assert.deepStrictEqual(between(6n), false)
```

**Signature**

```ts
export declare const between: {
  (options: { minimum: bigint; maximum: bigint }): (self: bigint) => boolean
  (self: bigint, options: { minimum: bigint; maximum: bigint }): boolean
}
```


# clamp

Restricts the given `bigint` to be within the range specified by the `minimum` and `maximum` values.

- If the `bigint` is less than the `minimum` value, the function returns the `minimum` value.
- If the `bigint` is greater than the `maximum` value, the function returns the `maximum` value.
- Otherwise, it returns the original `bigint`.

To import and use `clamp` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.clamp
```

**Example**

```ts
import { BigInt } from "effect"

const clamp = BigInt.clamp({ minimum: 1n, maximum: 5n })

assert.equal(clamp(3n), 3n)
assert.equal(clamp(0n), 1n)
assert.equal(clamp(6n), 5n)
```

**Signature**

```ts
export declare const clamp: {
  (options: { minimum: bigint; maximum: bigint }): (self: bigint) => bigint
  (self: bigint, options: { minimum: bigint; maximum: bigint }): bigint
}
```


# decrement

Decrements a number by `1n`.

To import and use `decrement` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.decrement
```

**Example**

```ts
import { decrement } from "effect/BigInt"

assert.deepStrictEqual(decrement(3n), 2n)
```

**Signature**

```ts
export declare const decrement: (n: bigint) => bigint
```


# divide

Provides a division operation on `bigint`s.

If the dividend is not a multiple of the divisor the result will be a `bigint` value
which represents the integer division rounded down to the nearest integer.

Returns `None` if the divisor is `0n`.

To import and use `divide` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.divide
```

**Example**

```ts
import { BigInt, Option } from "effect"

assert.deepStrictEqual(BigInt.divide(6n, 3n), Option.some(2n))
assert.deepStrictEqual(BigInt.divide(6n, 0n), Option.none())
```

**Signature**

```ts
export declare const divide: {
  (that: bigint): (self: bigint) => Option.Option<bigint>
  (self: bigint, that: bigint): Option.Option<bigint>
}
```


# fromNumber

Takes a number and returns an `Option` of `bigint`.

If the number is outside the safe integer range for JavaScript (`Number.MAX_SAFE_INTEGER`
and `Number.MIN_SAFE_INTEGER`), it returns `Option.none()`. Otherwise, it attempts to
convert the number to a `bigint` and returns `Option.some(bigint)`.

To import and use `fromNumber` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.fromNumber
```

**Example**

```ts
import { BigInt as BI, Option } from "effect"

assert.deepStrictEqual(BI.fromNumber(42), Option.some(BigInt(42)))
assert.deepStrictEqual(BI.fromNumber(Number.MAX_SAFE_INTEGER + 1), Option.none())
assert.deepStrictEqual(BI.fromNumber(Number.MIN_SAFE_INTEGER - 1), Option.none())
```

**Signature**

```ts
export declare const fromNumber: (n: number) => Option.Option<bigint>
```


# fromString

Takes a string and returns an `Option` of `bigint`.

If the string is empty or contains characters that cannot be converted into a `bigint`,
it returns `Option.none()`, otherwise, it returns `Option.some(bigint)`.

To import and use `fromString` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.fromString
```

**Example**

```ts
import { BigInt as BI, Option } from "effect"

assert.deepStrictEqual(BI.fromString("42"), Option.some(BigInt(42)))
assert.deepStrictEqual(BI.fromString(" "), Option.none())
assert.deepStrictEqual(BI.fromString("a"), Option.none())
```

**Signature**

```ts
export declare const fromString: (s: string) => Option.Option<bigint>
```


# gcd

Determines the greatest common divisor of two `bigint`s.

To import and use `gcd` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.gcd
```

**Example**

```ts
import { gcd } from "effect/BigInt"

assert.deepStrictEqual(gcd(2n, 3n), 1n)
assert.deepStrictEqual(gcd(2n, 4n), 2n)
assert.deepStrictEqual(gcd(16n, 24n), 8n)
```

**Signature**

```ts
export declare const gcd: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint }
```


# greaterThan

Returns `true` if the first argument is greater than the second, otherwise `false`.

To import and use `greaterThan` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.greaterThan
```

**Example**

```ts
import { greaterThan } from "effect/BigInt"

assert.deepStrictEqual(greaterThan(2n, 3n), false)
assert.deepStrictEqual(greaterThan(3n, 3n), false)
assert.deepStrictEqual(greaterThan(4n, 3n), true)
```

**Signature**

```ts
export declare const greaterThan: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean }
```


# greaterThanOrEqualTo

Returns a function that checks if a given `bigint` is greater than or equal to the provided one.

To import and use `greaterThanOrEqualTo` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.greaterThanOrEqualTo
```

**Example**

```ts
import { greaterThanOrEqualTo } from "effect/BigInt"

assert.deepStrictEqual(greaterThanOrEqualTo(2n, 3n), false)
assert.deepStrictEqual(greaterThanOrEqualTo(3n, 3n), true)
assert.deepStrictEqual(greaterThanOrEqualTo(4n, 3n), true)
```

**Signature**

```ts
export declare const greaterThanOrEqualTo: {
  (that: bigint): (self: bigint) => boolean
  (self: bigint, that: bigint): boolean
}
```


# increment

Returns the result of adding `1n` to a given number.

To import and use `increment` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.increment
```

**Example**

```ts
import { increment } from "effect/BigInt"

assert.deepStrictEqual(increment(2n), 3n)
```

**Signature**

```ts
export declare const increment: (n: bigint) => bigint
```


# isBigInt

Tests if a value is a `bigint`.

To import and use `isBigInt` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.isBigInt
```

**Example**

```ts
import { isBigInt } from "effect/BigInt"

assert.deepStrictEqual(isBigInt(1n), true)
assert.deepStrictEqual(isBigInt(1), false)
```

**Signature**

```ts
export declare const isBigInt: (u: unknown) => u is bigint
```


# lcm

Determines the least common multiple of two `bigint`s.

To import and use `lcm` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.lcm
```

**Example**

```ts
import { lcm } from "effect/BigInt"

assert.deepStrictEqual(lcm(2n, 3n), 6n)
assert.deepStrictEqual(lcm(2n, 4n), 4n)
assert.deepStrictEqual(lcm(16n, 24n), 48n)
```

**Signature**

```ts
export declare const lcm: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint }
```


# lessThan

Returns `true` if the first argument is less than the second, otherwise `false`.

To import and use `lessThan` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.lessThan
```

**Example**

```ts
import { lessThan } from "effect/BigInt"

assert.deepStrictEqual(lessThan(2n, 3n), true)
assert.deepStrictEqual(lessThan(3n, 3n), false)
assert.deepStrictEqual(lessThan(4n, 3n), false)
```

**Signature**

```ts
export declare const lessThan: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean }
```


# lessThanOrEqualTo

Returns a function that checks if a given `bigint` is less than or equal to the provided one.

To import and use `lessThanOrEqualTo` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.lessThanOrEqualTo
```

**Example**

```ts
import { lessThanOrEqualTo } from "effect/BigInt"

assert.deepStrictEqual(lessThanOrEqualTo(2n, 3n), true)
assert.deepStrictEqual(lessThanOrEqualTo(3n, 3n), true)
assert.deepStrictEqual(lessThanOrEqualTo(4n, 3n), false)
```

**Signature**

```ts
export declare const lessThanOrEqualTo: {
  (that: bigint): (self: bigint) => boolean
  (self: bigint, that: bigint): boolean
}
```


# max

Returns the maximum between two `bigint`s.

To import and use `max` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.max
```

**Example**

```ts
import { max } from "effect/BigInt"

assert.deepStrictEqual(max(2n, 3n), 3n)
```

**Signature**

```ts
export declare const max: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint }
```


# min

Returns the minimum between two `bigint`s.

To import and use `min` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.min
```

**Example**

```ts
import { min } from "effect/BigInt"

assert.deepStrictEqual(min(2n, 3n), 2n)
```

**Signature**

```ts
export declare const min: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint }
```


# multiply

Provides a multiplication operation on `bigint`s.

To import and use `multiply` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.multiply
```

**Example**

```ts
import { multiply } from "effect/BigInt"

assert.deepStrictEqual(multiply(2n, 3n), 6n)
```

**Signature**

```ts
export declare const multiply: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint }
```


# multiplyAll

Takes an `Iterable` of `bigint`s and returns their multiplication as a single `number`.

To import and use `multiplyAll` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.multiplyAll
```

**Example**

```ts
import { multiplyAll } from "effect/BigInt"

assert.deepStrictEqual(multiplyAll([2n, 3n, 4n]), 24n)
```

**Signature**

```ts
export declare const multiplyAll: (collection: Iterable<bigint>) => bigint
```


# sign

Determines the sign of a given `bigint`.

To import and use `sign` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.sign
```

**Example**

```ts
import { sign } from "effect/BigInt"

assert.deepStrictEqual(sign(-5n), -1)
assert.deepStrictEqual(sign(0n), 0)
assert.deepStrictEqual(sign(5n), 1)
```

**Signature**

```ts
export declare const sign: (n: bigint) => Ordering
```


# sqrt

Determines the square root of a given `bigint` safely. Returns `none` if the given `bigint` is negative.

To import and use `sqrt` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.sqrt
```

**Example**

```ts
import { BigInt, Option } from "effect"

assert.deepStrictEqual(BigInt.sqrt(4n), Option.some(2n))
assert.deepStrictEqual(BigInt.sqrt(9n), Option.some(3n))
assert.deepStrictEqual(BigInt.sqrt(16n), Option.some(4n))
assert.deepStrictEqual(BigInt.sqrt(-1n), Option.none())
```

**Signature**

```ts
export declare const sqrt: (n: bigint) => Option.Option<bigint>
```


# subtract

Provides a subtraction operation on `bigint`s.

To import and use `subtract` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.subtract
```

**Example**

```ts
import { subtract } from "effect/BigInt"

assert.deepStrictEqual(subtract(2n, 3n), -1n)
```

**Signature**

```ts
export declare const subtract: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint }
```


# sum

Provides an addition operation on `bigint`s.

To import and use `sum` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.sum
```

**Example**

```ts
import { sum } from "effect/BigInt"

assert.deepStrictEqual(sum(2n, 3n), 5n)
```

**Signature**

```ts
export declare const sum: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint }
```


# sumAll

Takes an `Iterable` of `bigint`s and returns their sum as a single `bigint

To import and use `sumAll` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.sumAll
```

**Example**

```ts
import { sumAll } from "effect/BigInt"

assert.deepStrictEqual(sumAll([2n, 3n, 4n]), 9n)
```

**Signature**

```ts
export declare const sumAll: (collection: Iterable<bigint>) => bigint
```


# toNumber

Takes a `bigint` and returns an `Option` of `number`.

If the `bigint` is outside the safe integer range for JavaScript (`Number.MAX_SAFE_INTEGER`
and `Number.MIN_SAFE_INTEGER`), it returns `Option.none()`. Otherwise, it converts the `bigint`
to a number and returns `Option.some(number)`.

To import and use `toNumber` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.toNumber
```

**Example**

```ts
import { BigInt as BI, Option } from "effect"

assert.deepStrictEqual(BI.toNumber(BigInt(42)), Option.some(42))
assert.deepStrictEqual(BI.toNumber(BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1)), Option.none())
assert.deepStrictEqual(BI.toNumber(BigInt(Number.MIN_SAFE_INTEGER) - BigInt(1)), Option.none())
```

**Signature**

```ts
export declare const toNumber: (b: bigint) => Option.Option<number>
```


# unsafeDivide

Provides a division operation on `bigint`s.

If the dividend is not a multiple of the divisor the result will be a `bigint` value
which represents the integer division rounded down to the nearest integer.

Throws a `RangeError` if the divisor is `0n`.

To import and use `unsafeDivide` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.unsafeDivide
```

**Example**

```ts
import { unsafeDivide } from "effect/BigInt"

assert.deepStrictEqual(unsafeDivide(6n, 3n), 2n)
assert.deepStrictEqual(unsafeDivide(6n, 4n), 1n)
```

**Signature**

```ts
export declare const unsafeDivide: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint }
```


# unsafeSqrt

Determines the square root of a given `bigint` unsafely. Throws if the given `bigint` is negative.

To import and use `unsafeSqrt` from the "BigInt" module:

```ts
import * as BigInt from "effect/BigInt"
// Can be accessed like this
BigInt.unsafeSqrt
```

**Example**

```ts
import { unsafeSqrt } from "effect/BigInt"

assert.deepStrictEqual(unsafeSqrt(4n), 2n)
assert.deepStrictEqual(unsafeSqrt(9n), 3n)
assert.deepStrictEqual(unsafeSqrt(16n), 4n)
```

**Signature**

```ts
export declare const unsafeSqrt: (n: bigint) => bigint
```


# and

Combines two boolean using AND: `self && that`.

To import and use `and` from the "Boolean" module:

```ts
import * as Boolean from "effect/Boolean"
// Can be accessed like this
Boolean.and
```

**Example**

```ts
import { and } from "effect/Boolean"

assert.deepStrictEqual(and(true, true), true)
assert.deepStrictEqual(and(true, false), false)
assert.deepStrictEqual(and(false, true), false)
assert.deepStrictEqual(and(false, false), false)
```

**Signature**

```ts
export declare const and: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean }
```


# eqv

Combines two booleans using EQV (aka XNOR): `!xor(self, that)`.

To import and use `eqv` from the "Boolean" module:

```ts
import * as Boolean from "effect/Boolean"
// Can be accessed like this
Boolean.eqv
```

**Example**

```ts
import { eqv } from "effect/Boolean"

assert.deepStrictEqual(eqv(true, true), true)
assert.deepStrictEqual(eqv(true, false), false)
assert.deepStrictEqual(eqv(false, true), false)
assert.deepStrictEqual(eqv(false, false), true)
```

**Signature**

```ts
export declare const eqv: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean }
```


# every

This utility function is used to check if all the elements in a collection of boolean values are `true`.

To import and use `every` from the "Boolean" module:

```ts
import * as Boolean from "effect/Boolean"
// Can be accessed like this
Boolean.every
```

**Example**

```ts
import { every } from "effect/Boolean"

assert.deepStrictEqual(every([true, true, true]), true)
assert.deepStrictEqual(every([true, false, true]), false)
```

**Signature**

```ts
export declare const every: (collection: Iterable<boolean>) => boolean
```


# implies

Combines two booleans using an implication: `(!self || that)`.

To import and use `implies` from the "Boolean" module:

```ts
import * as Boolean from "effect/Boolean"
// Can be accessed like this
Boolean.implies
```

**Example**

```ts
import { implies } from "effect/Boolean"

assert.deepStrictEqual(implies(true, true), true)
assert.deepStrictEqual(implies(true, false), false)
assert.deepStrictEqual(implies(false, true), true)
assert.deepStrictEqual(implies(false, false), true)
```

**Signature**

```ts
export declare const implies: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean }
```


# isBoolean

Tests if a value is a `boolean`.

To import and use `isBoolean` from the "Boolean" module:

```ts
import * as Boolean from "effect/Boolean"
// Can be accessed like this
Boolean.isBoolean
```

**Example**

```ts
import { isBoolean } from "effect/Boolean"

assert.deepStrictEqual(isBoolean(true), true)
assert.deepStrictEqual(isBoolean("true"), false)
```

**Signature**

```ts
export declare const isBoolean: (input: unknown) => input is boolean
```


# match

This function returns the result of either of the given functions depending on the value of the boolean parameter.
It is useful when you have to run one of two functions depending on the boolean value.

To import and use `match` from the "Boolean" module:

```ts
import * as Boolean from "effect/Boolean"
// Can be accessed like this
Boolean.match
```

**Example**

```ts
import { Boolean } from "effect"

assert.deepStrictEqual(Boolean.match(true, { onFalse: () => "It's false!", onTrue: () => "It's true!" }), "It's true!")
```

**Signature**

```ts
export declare const match: {
  <A, B = A>(options: { readonly onFalse: LazyArg<A>; readonly onTrue: LazyArg<B> }): (value: boolean) => A | B
  <A, B>(value: boolean, options: { readonly onFalse: LazyArg<A>; readonly onTrue: LazyArg<B> }): A | B
}
```


# nand

Combines two boolean using NAND: `!(self && that)`.

To import and use `nand` from the "Boolean" module:

```ts
import * as Boolean from "effect/Boolean"
// Can be accessed like this
Boolean.nand
```

**Example**

```ts
import { nand } from "effect/Boolean"

assert.deepStrictEqual(nand(true, true), false)
assert.deepStrictEqual(nand(true, false), true)
assert.deepStrictEqual(nand(false, true), true)
assert.deepStrictEqual(nand(false, false), true)
```

**Signature**

```ts
export declare const nand: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean }
```


# nor

Combines two booleans using NOR: `!(self || that)`.

To import and use `nor` from the "Boolean" module:

```ts
import * as Boolean from "effect/Boolean"
// Can be accessed like this
Boolean.nor
```

**Example**

```ts
import { nor } from "effect/Boolean"

assert.deepStrictEqual(nor(true, true), false)
assert.deepStrictEqual(nor(true, false), false)
assert.deepStrictEqual(nor(false, true), false)
assert.deepStrictEqual(nor(false, false), true)
```

**Signature**

```ts
export declare const nor: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean }
```


# not

Negates the given boolean: `!self`

To import and use `not` from the "Boolean" module:

```ts
import * as Boolean from "effect/Boolean"
// Can be accessed like this
Boolean.not
```

**Example**

```ts
import { not } from "effect/Boolean"

assert.deepStrictEqual(not(true), false)
assert.deepStrictEqual(not(false), true)
```

**Signature**

```ts
export declare const not: (self: boolean) => boolean
```


# or

Combines two boolean using OR: `self || that`.

To import and use `or` from the "Boolean" module:

```ts
import * as Boolean from "effect/Boolean"
// Can be accessed like this
Boolean.or
```

**Example**

```ts
import { or } from "effect/Boolean"

assert.deepStrictEqual(or(true, true), true)
assert.deepStrictEqual(or(true, false), true)
assert.deepStrictEqual(or(false, true), true)
assert.deepStrictEqual(or(false, false), false)
```

**Signature**

```ts
export declare const or: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean }
```


# some

This utility function is used to check if at least one of the elements in a collection of boolean values is `true`.

To import and use `some` from the "Boolean" module:

```ts
import * as Boolean from "effect/Boolean"
// Can be accessed like this
Boolean.some
```

**Example**

```ts
import { some } from "effect/Boolean"

assert.deepStrictEqual(some([true, false, true]), true)
assert.deepStrictEqual(some([false, false, false]), false)
```

**Signature**

```ts
export declare const some: (collection: Iterable<boolean>) => boolean
```


# xor

Combines two booleans using XOR: `(!self && that) || (self && !that)`.

To import and use `xor` from the "Boolean" module:

```ts
import * as Boolean from "effect/Boolean"
// Can be accessed like this
Boolean.xor
```

**Example**

```ts
import { xor } from "effect/Boolean"

assert.deepStrictEqual(xor(true, true), false)
assert.deepStrictEqual(xor(true, false), true)
assert.deepStrictEqual(xor(false, true), true)
assert.deepStrictEqual(xor(false, false), false)
```

**Signature**

```ts
export declare const xor: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean }
```


# between

Checks if a value is between the lower and upper limit of a bound.

To import and use `between` from the "Bounded" module:

```ts
import * as Bounded from "@effect/typeclass/Bounded"
// Can be accessed like this
Bounded.between
```

**Signature**

```ts
export declare const between: <A>(B: Bounded<A>) => (a: A) => boolean
```


# clamp

Clamp a value between `minBound` and `maxBound` values.

To import and use `clamp` from the "Bounded" module:

```ts
import * as Bounded from "@effect/typeclass/Bounded"
// Can be accessed like this
Bounded.clamp
```

**Signature**

```ts
export declare const clamp: <A>(B: Bounded<A>) => (a: A) => A
```


# max

`Monoid` that returns last maximum of elements.

To import and use `max` from the "Bounded" module:

```ts
import * as Bounded from "@effect/typeclass/Bounded"
// Can be accessed like this
Bounded.max
```

**Signature**

```ts
export declare const max: <A>(B: Bounded<A>) => Monoid<A>
```


# min

`Monoid` that returns last minimum of elements.

To import and use `min` from the "Bounded" module:

```ts
import * as Bounded from "@effect/typeclass/Bounded"
// Can be accessed like this
Bounded.min
```

**Signature**

```ts
export declare const min: <A>(B: Bounded<A>) => Monoid<A>
```


# reverse

Reverses the `Order` of a `Bounded` and flips `maxBound` and `minBound` values.

To import and use `reverse` from the "Bounded" module:

```ts
import * as Bounded from "@effect/typeclass/Bounded"
// Can be accessed like this
Bounded.reverse
```

**Signature**

```ts
export declare const reverse: <A>(B: Bounded<A>) => Bounded<A>
```


# all

Combines two or more brands together to form a single branded type.
This API is useful when you want to validate that the input data passes multiple brand validators.

To import and use `all` from the "Brand" module:

```ts
import * as Brand from "effect/Brand"
// Can be accessed like this
Brand.all
```

**Example**

```ts
import { Brand } from "effect"

type Int = number & Brand.Brand<"Int">
const Int = Brand.refined<Int>(
  (n) => Number.isInteger(n),
  (n) => Brand.error(`Expected ${n} to be an integer`)
)
type Positive = number & Brand.Brand<"Positive">
const Positive = Brand.refined<Positive>(
  (n) => n > 0,
  (n) => Brand.error(`Expected ${n} to be positive`)
)

const PositiveInt = Brand.all(Int, Positive)

assert.strictEqual(PositiveInt(1), 1)
assert.throws(() => PositiveInt(1.1))
```

**Signature**

```ts
export declare const all: <Brands extends readonly [Brand.Constructor<any>, ...Array<Brand.Constructor<any>>]>(
  ...brands: Brand.EnsureCommonBase<Brands>
) => Brand.Constructor<
  Types.UnionToIntersection<{ [B in keyof Brands]: Brand.FromConstructor<Brands[B]> }[number]> extends infer X extends
    Brand<any>
    ? X
    : Brand<any>
>
```


# Brand

A generic interface that defines a branded type.

To import and use `Brand` from the "Brand" module:

```ts
import * as Brand from "effect/Brand"
// Can be accessed like this
Brand.Brand
```


# error

Returns a `BrandErrors` that contains a single `RefinementError`.

To import and use `error` from the "Brand" module:

```ts
import * as Brand from "effect/Brand"
// Can be accessed like this
Brand.error
```

**Signature**

```ts
export declare const error: (message: string, meta?: unknown) => Brand.BrandErrors
```


# errors

Takes a variable number of `BrandErrors` and returns a single `BrandErrors` that contains all refinement errors.

To import and use `errors` from the "Brand" module:

```ts
import * as Brand from "effect/Brand"
// Can be accessed like this
Brand.errors
```

**Signature**

```ts
export declare const errors: (...errors: Array<Brand.BrandErrors>) => Brand.BrandErrors
```


# nominal

This function returns a `Brand.Constructor` that **does not apply any runtime checks**, it just returns the provided value.
It can be used to create nominal types that allow distinguishing between two values of the same type but with different meanings.

If you also want to perform some validation, see {@link refined}.

To import and use `nominal` from the "Brand" module:

```ts
import * as Brand from "effect/Brand"
// Can be accessed like this
Brand.nominal
```

**Example**

```ts
import { Brand } from "effect"

type UserId = number & Brand.Brand<"UserId">

const UserId = Brand.nominal<UserId>()

assert.strictEqual(UserId(1), 1)
```

**Signature**

```ts
export declare const nominal: <A extends Brand<any>>() => Brand.Constructor<A>
```


# refined

Returns a `Brand.Constructor` that can construct a branded type from an unbranded value using the provided `refinement`
predicate as validation of the input data.

If you don't want to perform any validation but only distinguish between two values of the same type but with different meanings,
see {@link nominal}.

To import and use `refined` from the "Brand" module:

```ts
import * as Brand from "effect/Brand"
// Can be accessed like this
Brand.refined
```

**Example**

```ts
import { Brand } from "effect"

type Int = number & Brand.Brand<"Int">

const Int = Brand.refined<Int>(
  (n) => Number.isInteger(n),
  (n) => Brand.error(`Expected ${n} to be an integer`)
)

assert.strictEqual(Int(1), 1)
assert.throws(() => Int(1.1))
```

**Signature**

```ts
export declare function refined<A extends Brand<any>>(
  f: (unbranded: Brand.Unbranded<A>) => Option.Option<Brand.BrandErrors>
): Brand.Constructor<A>
export declare function refined<A extends Brand<any>>(
  refinement: Predicate<Brand.Unbranded<A>>,
  onFailure: (unbranded: Brand.Unbranded<A>) => Brand.BrandErrors
): Brand.Constructor<A>
```


# Broadcaster

An interface to communicate with a remote broadcast receiver

To import and use `Broadcaster` from the "Broadcaster" module:

```ts
import * as Broadcaster from "@effect/cluster/Broadcaster"
// Can be accessed like this
Broadcaster.Broadcaster
```


# layerLocalStorage

Creates a KeyValueStore layer that uses the browser's localStorage api. Values are stored between sessions.

To import and use `layerLocalStorage` from the "BrowserKeyValueStore" module:

```ts
import * as BrowserKeyValueStore from "@effect/platform-browser/BrowserKeyValueStore"
// Can be accessed like this
BrowserKeyValueStore.layerLocalStorage
```

**Signature**

```ts
export declare const layerLocalStorage: Layer.Layer<KeyValueStore.KeyValueStore, never, never>
```


# layerSessionStorage

Creates a KeyValueStore layer that uses the browser's sessionStorage api. Values are stored only for the current session.

To import and use `layerSessionStorage` from the "BrowserKeyValueStore" module:

```ts
import * as BrowserKeyValueStore from "@effect/platform-browser/BrowserKeyValueStore"
// Can be accessed like this
BrowserKeyValueStore.layerSessionStorage
```

**Signature**

```ts
export declare const layerSessionStorage: Layer.Layer<KeyValueStore.KeyValueStore, never, never>
```


# layerWebSocketConstructor

A WebSocket constructor that uses globalThis.WebSocket.

To import and use `layerWebSocketConstructor` from the "BrowserSocket" module:

```ts
import * as BrowserSocket from "@effect/platform-browser/BrowserSocket"
// Can be accessed like this
BrowserSocket.layerWebSocketConstructor
```

**Signature**

```ts
export declare const layerWebSocketConstructor: Layer.Layer<Socket.WebSocketConstructor, never, never>
```


# fromEventListenerDocument

Creates a `Stream` from document.addEventListener.

To import and use `fromEventListenerDocument` from the "BrowserStream" module:

```ts
import * as BrowserStream from "@effect/platform-browser/BrowserStream"
// Can be accessed like this
BrowserStream.fromEventListenerDocument
```

**Signature**

```ts
export declare const fromEventListenerDocument: <K extends keyof DocumentEventMap>(
  type: K,
  options?:
    | boolean
    | {
        readonly capture?: boolean
        readonly passive?: boolean
        readonly once?: boolean
        readonly bufferSize?: number | "unbounded" | undefined
      }
    | undefined
) => Stream.Stream<DocumentEventMap[K], never, never>
```


# fromEventListenerWindow

Creates a `Stream` from window.addEventListener.

To import and use `fromEventListenerWindow` from the "BrowserStream" module:

```ts
import * as BrowserStream from "@effect/platform-browser/BrowserStream"
// Can be accessed like this
BrowserStream.fromEventListenerWindow
```

**Signature**

```ts
export declare const fromEventListenerWindow: <K extends keyof WindowEventMap>(
  type: K,
  options?:
    | boolean
    | {
        readonly capture?: boolean
        readonly passive?: boolean
        readonly once?: boolean
        readonly bufferSize?: number | "unbounded" | undefined
      }
    | undefined
) => Stream.Stream<WindowEventMap[K], never, never>
```


# layerContext

A Layer providing the `HttpPlatform`, `FileSystem`, `Etag.Generator`, and `Path`
services.

The `FileSystem` service is a no-op implementation, so this layer is only
useful for platforms that have no file system.

To import and use `layerContext` from the "BunHttpServer" module:

```ts
import * as BunHttpServer from "@effect/platform-bun/BunHttpServer"
// Can be accessed like this
BunHttpServer.layerContext
```

**Signature**

```ts
export declare const layerContext: Layer.Layer<
  Platform.HttpPlatform | Etag.Generator | BunContext.BunContext,
  never,
  never
>
```


# layerTest

Layer starting a server on a random port and producing an `HttpClient`
with prepended url of the running http server.

To import and use `layerTest` from the "BunHttpServer" module:

```ts
import * as BunHttpServer from "@effect/platform-bun/BunHttpServer"
// Can be accessed like this
BunHttpServer.layerTest
```

**Signature**

```ts
export declare const layerTest: Layer.Layer<
  Server.HttpServer | Platform.HttpPlatform | Etag.Generator | BunContext.BunContext | HttpClient.HttpClient,
  HttpServerError.ServeError,
  never
>
```


# Cache

A `Cache` is defined in terms of a lookup function that, given a key of
type `Key`, can either fail with an error of type `Error` or succeed with a
value of type `Value`. Getting a value from the cache will either return
the previous result of the lookup function if it is available or else
compute a new result with the lookup function, put it in the cache, and
return it.

A cache also has a specified capacity and time to live. When the cache is
at capacity the least recently accessed values in the cache will be
removed to make room for new values. Getting a value with a life older than
the specified time to live will result in a new value being computed with
the lookup function and returned when available.

The cache is safe for concurrent access. If multiple fibers attempt to get
the same key the lookup function will only be computed once and the result
will be returned to all fibers.

To import and use `Cache` from the "Cache" module:

```ts
import * as Cache from "effect/Cache"
// Can be accessed like this
Cache.Cache
```


# CacheStats

`CacheStats` represents a snapshot of statistics for the cache as of a
point in time.

To import and use `CacheStats` from the "Cache" module:

```ts
import * as Cache from "effect/Cache"
// Can be accessed like this
Cache.CacheStats
```


# ConsumerCache

A ConsumerCache models a portion of a cache which is safe to share without allowing to create new values or access existing ones.

It can be used safely to give over control for request management without leaking writer side details.

To import and use `ConsumerCache` from the "Cache" module:

```ts
import * as Cache from "effect/Cache"
// Can be accessed like this
Cache.ConsumerCache
```


# EntryStats

Represents a snapshot of statistics for an entry in the cache.

To import and use `EntryStats` from the "Cache" module:

```ts
import * as Cache from "effect/Cache"
// Can be accessed like this
Cache.EntryStats
```


# Lookup

A `Lookup` represents a lookup function that, given a key of type `Key`, can
return an effect that will either produce a value of type `Value` or fail
with an error of type `Error` using an environment of type `Environment`.

To import and use `Lookup` from the "Cache" module:

```ts
import * as Cache from "effect/Cache"
// Can be accessed like this
Cache.Lookup
```


# make

Constructs a new cache with the specified capacity, time to live, and
lookup function.

To import and use `make` from the "Cache" module:

```ts
import * as Cache from "effect/Cache"
// Can be accessed like this
Cache.make
```

**Signature**

```ts
export declare const make: <Key, Value, Error = never, Environment = never>(options: {
  readonly capacity: number
  readonly timeToLive: Duration.DurationInput
  readonly lookup: Lookup<Key, Value, Error, Environment>
}) => Effect.Effect<Cache<Key, Value, Error>, never, Environment>
```


# makeCacheStats

Constructs a new `CacheStats` from the specified values.

To import and use `makeCacheStats` from the "Cache" module:

```ts
import * as Cache from "effect/Cache"
// Can be accessed like this
Cache.makeCacheStats
```

**Signature**

```ts
export declare const makeCacheStats: (options: {
  readonly hits: number
  readonly misses: number
  readonly size: number
}) => CacheStats
```


# makeEntryStats

Constructs a new `EntryStats` from the specified values.

To import and use `makeEntryStats` from the "Cache" module:

```ts
import * as Cache from "effect/Cache"
// Can be accessed like this
Cache.makeEntryStats
```

**Signature**

```ts
export declare const makeEntryStats: (loadedMillis: number) => EntryStats
```


# makeWith

Constructs a new cache with the specified capacity, time to live, and
lookup function, where the time to live can depend on the `Exit` value
returned by the lookup function.

To import and use `makeWith` from the "Cache" module:

```ts
import * as Cache from "effect/Cache"
// Can be accessed like this
Cache.makeWith
```

**Signature**

```ts
export declare const makeWith: <Key, Value, Error = never, Environment = never>(options: {
  readonly capacity: number
  readonly lookup: Lookup<Key, Value, Error, Environment>
  readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput
}) => Effect.Effect<Cache<Key, Value, Error>, never, Environment>
```


# andThen

Sequences two `Cause`s. The second `Cause` can be dependent on the result of
the first `Cause`.

To import and use `andThen` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.andThen
```

**Signature**

```ts
export declare const andThen: {
  <E, E2>(f: (e: E) => Cause<E2>): (self: Cause<E>) => Cause<E2>
  <E2>(f: Cause<E2>): <E>(self: Cause<E>) => Cause<E2>
  <E, E2>(self: Cause<E>, f: (e: E) => Cause<E2>): Cause<E2>
  <E, E2>(self: Cause<E>, f: Cause<E2>): Cause<E2>
}
```


# as

Replaces any errors in a `Cause` with a provided constant error.

**Details**

This function transforms all `Fail` errors into the specified error value,
preserving the structure of the `Cause`. It's useful when you no longer need
the original error details but still want to keep the cause shape.

To import and use `as` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.as
```

**Signature**

```ts
export declare const as: {
  <E2>(error: E2): <E>(self: Cause<E>) => Cause<E2>
  <E, E2>(self: Cause<E>, error: E2): Cause<E2>
}
```


# Cause

Represents the full history of a failure within an `Effect`.

**Details**

This type is a data structure that captures all information about why and how
an effect has failed, including parallel errors, sequential errors, defects,
and interruptions. It enables a "lossless" error model: no error-related
information is discarded, which helps in debugging and understanding the root
cause of failures.

To import and use `Cause` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.Cause
```


# CauseReducer

Describes methods for reducing a `Cause<E>` into a value of type `Z` with
access to contextual information.

**Details**

This interface is meant for advanced transformations of `Cause`. By
implementing each method, you can define how different parts of the `Cause`
structure (like `Fail`, `Die`, or `Interrupt`) should be transformed into a
final type `Z`. The `context` parameter carries additional data needed during
this reduction.

To import and use `CauseReducer` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.CauseReducer
```


# CauseTypeId

A unique symbol identifying the `Cause` type.

**Details**

This provides a symbol that helps identify instances of the `Cause` data
type. This can be used for advanced operations such as refining types or
building internal utilities that check whether an unknown value is a `Cause`.

To import and use `CauseTypeId` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.CauseTypeId
```

**Signature**

```ts
export declare const CauseTypeId: typeof CauseTypeId
```


# contains

Checks if the current `Cause` contains or is equal to another `Cause`.

**Details**

This function returns `true` if `that` cause is part of or the same as
the current `Cause`. It's useful when you need to check for specific
error patterns or deduplicate repeated failures.

To import and use `contains` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.contains
```

**Signature**

```ts
export declare const contains: {
  <E2>(that: Cause<E2>): <E>(self: Cause<E>) => boolean
  <E, E2>(self: Cause<E>, that: Cause<E2>): boolean
}
```


# defects

Extracts all unrecoverable defects from a `Cause`.

**Details**

This function returns a chunk of values representing unexpected errors
(`Die`). It's handy for capturing or logging unanticipated failures that
might need special handling, such as bug reports.

To import and use `defects` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.defects
```

**Signature**

```ts
export declare const defects: <E>(self: Cause<E>) => Chunk.Chunk<unknown>
```


# die

Creates a `Die` cause from an unexpected error.

**Details**

This function wraps an unhandled or unknown defect (like a runtime crash)
into a `Cause`. It's useful for capturing unforeseen issues in a structured
way.

To import and use `die` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.die
```

**Signature**

```ts
export declare const die: (defect: unknown) => Cause<never>
```


# Die

Represents an unexpected defect within a `Cause`.

**Details**

This interface models a `Cause` for errors that are typically unrecoverable or
unanticipatedlike runtime exceptions or bugs. When code "dies," it indicates a
severe failure that wasn't accounted for.

To import and use `Die` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.Die
```


# dieOption

Retrieves the first `Die` defect in a `Cause`, if present.

**Details**

This function returns an `Option` containing the first unexpected failure
(`Die`) discovered. It's helpful for diagnosing the primary defect in a chain
of errors.

To import and use `dieOption` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.dieOption
```

**Signature**

```ts
export declare const dieOption: <E>(self: Cause<E>) => Option.Option<unknown>
```


# empty

Creates an `Empty` cause.

**Details**

This function returns a cause that signifies "no error." It's commonly used
to represent an absence of failure conditions.

To import and use `empty` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.empty
```

**Signature**

```ts
export declare const empty: Cause<never>
```


# Empty

Represents a lack of errors within a `Cause`.

To import and use `Empty` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.Empty
```


# ExceededCapacityException

An error that occurs when resource capacity is exceeded.

To import and use `ExceededCapacityException` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.ExceededCapacityException
```


# ExceededCapacityExceptionTypeId

A unique symbol identifying the `ExceededCapacityException` type.

**Details**

This provides a symbol that identifies an `ExceededCapacityException`. It
denotes situations where a resource has exceeded its configured capacity
limit.

To import and use `ExceededCapacityExceptionTypeId` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.ExceededCapacityExceptionTypeId
```

**Signature**

```ts
export declare const ExceededCapacityExceptionTypeId: typeof ExceededCapacityExceptionTypeId
```


# fail

Creates a `Fail` cause from an expected error.

**Details**

This function constructs a `Cause` carrying an error of type `E`. It's used
when you want to represent a known or anticipated failure in your effectful
computations.

To import and use `fail` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.fail
```

**Signature**

```ts
export declare const fail: <E>(error: E) => Cause<E>
```


# Fail

Represents an expected error within a `Cause`.

**Details**

This interface models a `Cause` that carries an expected or known error of
type `E`. For example, if you validate user input and find it invalid, you
might store that error within a `Fail`.

To import and use `Fail` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.Fail
```


# failureOption

Retrieves the first `Fail` error in a `Cause`, if present.

**Details**

This function returns an `Option` containing the first recoverable error
(`E`) from the cause. It's often used to quickly check if there's a primary
error to handle or display.

To import and use `failureOption` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.failureOption
```

**Signature**

```ts
export declare const failureOption: <E>(self: Cause<E>) => Option.Option<E>
```


# failureOrCause

Splits a `Cause` into either its first `Fail` error or the rest of the cause
(which might only contain `Die` or `Interrupt`).

**Details**

This function either returns the checked error (`E`) or the remaining
`Cause<never>` with defects/interruptions. It helps you decide if there's a
recoverable path or if only unhandled issues remain.

To import and use `failureOrCause` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.failureOrCause
```

**Signature**

```ts
export declare const failureOrCause: <E>(self: Cause<E>) => Either.Either<Cause<never>, E>
```


# failures

Extracts all recoverable errors of type `E` from a `Cause`.

**Details**

This function returns a chunk of errors, providing a list of all `Fail`
values found in the cause. It's useful for collecting all known failures for
logging or combined error handling.

To import and use `failures` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.failures
```

**Signature**

```ts
export declare const failures: <E>(self: Cause<E>) => Chunk.Chunk<E>
```


# filter

Preserves parts of a `Cause` that match a given predicate.

**Details**

This function allows you to retain only the parts of a `Cause` structure that
match a specified predicate or refinement. Any parts of the `Cause` that do
not match the provided condition are excluded from the result.

You can use this function in two ways:

- With a `Predicate`: A function that evaluates whether a `Cause` should be
  retained based on its value.
- With a `Refinement`: A more specific predicate that can refine the type of
  the `Cause`.

This is useful when you need to extract specific types of errors, defects, or
interruptions from a `Cause` while discarding unrelated parts.

To import and use `filter` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.filter
```

**Signature**

```ts
export declare const filter: {
  <E, EB extends E>(refinement: Refinement<Cause<NoInfer<E>>, Cause<EB>>): (self: Cause<E>) => Cause<EB>
  <E>(predicate: Predicate<Cause<NoInfer<E>>>): (self: Cause<E>) => Cause<E>
  <E, EB extends E>(self: Cause<E>, refinement: Refinement<Cause<E>, Cause<EB>>): Cause<EB>
  <E>(self: Cause<E>, predicate: Predicate<Cause<E>>): Cause<E>
}
```


# find

Searches a `Cause` using a partial function to extract information.

**Details**

This function allows you to search through a `Cause` using a custom partial
function. The partial function is applied to the `Cause`, and if it matches,
the result is returned wrapped in a `Some`. If no match is found, the result
is `None`.

This is particularly useful when you are only interested in specific types of
errors, defects, or interruption causes within a potentially complex `Cause`
structure. By leveraging a partial function, you can focus on extracting only
the relevant information you care about.

The partial function should return an `Option` indicating whether it matched
and the value it extracted.

To import and use `find` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.find
```

**Signature**

```ts
export declare const find: {
  <E, Z>(pf: (cause: Cause<E>) => Option.Option<Z>): (self: Cause<E>) => Option.Option<Z>
  <E, Z>(self: Cause<E>, pf: (cause: Cause<E>) => Option.Option<Z>): Option.Option<Z>
}
```


# flatMap

Transforms errors in a `Cause` into new causes.

**Details**

This function applies a function `f` to each `Fail` error, converting it into
a new `Cause`. This is especially powerful for merging or restructuring error
types while preserving or combining cause information.

To import and use `flatMap` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.flatMap
```

**Signature**

```ts
export declare const flatMap: {
  <E, E2>(f: (e: E) => Cause<E2>): (self: Cause<E>) => Cause<E2>
  <E, E2>(self: Cause<E>, f: (e: E) => Cause<E2>): Cause<E2>
}
```


# flatten

Flattens a nested `Cause` structure.

**Details**

This function takes a `Cause<Cause<E>>` and merges the layers into a single
`Cause<E>`. It's useful for eliminating additional nesting created by
repeated transformations or compositions.

To import and use `flatten` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.flatten
```

**Signature**

```ts
export declare const flatten: <E>(self: Cause<Cause<E>>) => Cause<E>
```


# flipCauseOption

Strips out failures with an error of `None` from a `Cause<Option<E>>`.

**Details**

This function turns a `Cause<Option<E>>` into an `Option<Cause<E>>`. If the
cause only contains failures of `None`, it becomes `None`; otherwise, it
returns a `Cause` of the remaining errors. It's helpful when working with
optional errors and filtering out certain error paths.

To import and use `flipCauseOption` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.flipCauseOption
```

**Signature**

```ts
export declare const flipCauseOption: <E>(self: Cause<Option.Option<E>>) => Option.Option<Cause<E>>
```


# IllegalArgumentException

An error representing an invalid argument passed to a method.

**Details**

This interface is used for signaling that a function or method received an
argument that does not meet its preconditions.

To import and use `IllegalArgumentException` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.IllegalArgumentException
```


# IllegalArgumentExceptionTypeId

A unique symbol identifying the `IllegalArgumentException` type.

**Details**

This provides a symbol that identifies an `IllegalArgumentException`. This is
often used in scenarios where invalid arguments are supplied to methods that
expect specific input.

To import and use `IllegalArgumentExceptionTypeId` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.IllegalArgumentExceptionTypeId
```

**Signature**

```ts
export declare const IllegalArgumentExceptionTypeId: typeof IllegalArgumentExceptionTypeId
```


# interrupt

Creates an `Interrupt` cause from a `FiberId`.

**Details**

This function represents a fiber that has been interrupted. It stores the
identifier of the interrupted fiber, enabling precise tracking of concurrent
cancellations.

To import and use `interrupt` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.interrupt
```

**Signature**

```ts
export declare const interrupt: (fiberId: FiberId.FiberId) => Cause<never>
```


# Interrupt

Represents fiber interruption within a `Cause`.

**Details**

This interface models a scenario where an effect was halted by an external
signal, carrying a `FiberId` that identifies which fiber was interrupted.
Interruption is a normal part of concurrency, used for cancellation or
resource cleanup.

To import and use `Interrupt` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.Interrupt
```


# InterruptedException

An error representing fiber interruption.

**Details**

This interface represents errors that occur when a fiber is forcefully
interrupted. Interruption can happen for various reasons, including
cancellations or system directives to halt operations. Code that deals with
concurrency might need to catch or handle these to ensure proper cleanup.

To import and use `InterruptedException` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.InterruptedException
```


# InterruptedExceptionTypeId

A unique symbol identifying the `InterruptedException` type.

**Details**

This provides a symbol that identifies an `InterruptedException`. This is
typically used internally to recognize when a fiber has been interrupted,
helping the framework handle interruption logic correctly.

To import and use `InterruptedExceptionTypeId` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.InterruptedExceptionTypeId
```

**Signature**

```ts
export declare const InterruptedExceptionTypeId: typeof InterruptedExceptionTypeId
```


# interruptOption

Retrieves the first `Interrupt` in a `Cause`, if present.

**Details**

This function returns an `Option` with the first fiber interruption
discovered. This is particularly useful for concurrency analysis or debugging
cancellations.

To import and use `interruptOption` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.interruptOption
```

**Signature**

```ts
export declare const interruptOption: <E>(self: Cause<E>) => Option.Option<FiberId.FiberId>
```


# interruptors

Collects all `FiberId`s responsible for interrupting a fiber.

**Details**

This function returns a set of IDs indicating which fibers caused
interruptions within this `Cause`. It's useful for debugging concurrency
issues or tracing cancellations.

To import and use `interruptors` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.interruptors
```

**Signature**

```ts
export declare const interruptors: <E>(self: Cause<E>) => HashSet.HashSet<FiberId.FiberId>
```


# InvalidPubSubCapacityException

An error indicating invalid capacity for a `PubSub`.

To import and use `InvalidPubSubCapacityException` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.InvalidPubSubCapacityException
```


# InvalidPubSubCapacityExceptionTypeId

A unique symbol identifying the `InvalidPubSubCapacityException` type.

**Details**

This provides a symbol that identifies an `InvalidPubSubCapacityException`.
It indicates an error related to an invalid capacity passed to a `PubSub`
structure.

To import and use `InvalidPubSubCapacityExceptionTypeId` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.InvalidPubSubCapacityExceptionTypeId
```

**Signature**

```ts
export declare const InvalidPubSubCapacityExceptionTypeId: typeof InvalidPubSubCapacityExceptionTypeId
```


# isCause

Checks if a value is a `Cause`.

To import and use `isCause` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isCause
```

**Signature**

```ts
export declare const isCause: (u: unknown) => u is Cause<unknown>
```


# isDie

Checks if a `Cause` contains a defect.

**Details**

This function returns `true` if the `Cause` includes any unexpected or
unhandled errors (`Die`). It's useful for differentiating known failures from
unexpected ones.

To import and use `isDie` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isDie
```

**Signature**

```ts
export declare const isDie: <E>(self: Cause<E>) => boolean
```


# isDieType

Checks if a `Cause` is a `Die` type.

To import and use `isDieType` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isDieType
```

**Signature**

```ts
export declare const isDieType: <E>(self: Cause<E>) => self is Die
```


# isEmpty

Checks if a `Cause` is entirely empty.

**Details**

This function returns `true` if the `Cause` contains no errors, defects, or
interruptions. It's helpful for verifying if a computation truly had no
failures.

To import and use `isEmpty` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isEmpty
```

**Signature**

```ts
export declare const isEmpty: <E>(self: Cause<E>) => boolean
```


# isEmptyType

Checks if a `Cause` is an `Empty` type.

To import and use `isEmptyType` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isEmptyType
```

**Signature**

```ts
export declare const isEmptyType: <E>(self: Cause<E>) => self is Empty
```


# isExceededCapacityException

Checks if a given unknown value is an `ExceededCapacityException`.

To import and use `isExceededCapacityException` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isExceededCapacityException
```

**Signature**

```ts
export declare const isExceededCapacityException: (u: unknown) => u is ExceededCapacityException
```


# isFailType

Checks if a `Cause` is a `Fail` type.

To import and use `isFailType` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isFailType
```

**Signature**

```ts
export declare const isFailType: <E>(self: Cause<E>) => self is Fail<E>
```


# isFailure

Checks if a `Cause` contains a failure.

**Details**

This function returns `true` if the `Cause` includes any `Fail` error. It's
commonly used to confirm whether a workflow encountered an anticipated error
versus just defects or interruptions.

To import and use `isFailure` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isFailure
```

**Signature**

```ts
export declare const isFailure: <E>(self: Cause<E>) => boolean
```


# isIllegalArgumentException

Checks if a given unknown value is an `IllegalArgumentException`.

To import and use `isIllegalArgumentException` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isIllegalArgumentException
```

**Signature**

```ts
export declare const isIllegalArgumentException: (u: unknown) => u is IllegalArgumentException
```


# isInterrupted

Checks if a `Cause` contains an interruption.

**Details**

This function returns `true` if the `Cause` includes any fiber interruptions.

To import and use `isInterrupted` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isInterrupted
```

**Signature**

```ts
export declare const isInterrupted: <E>(self: Cause<E>) => boolean
```


# isInterruptedException

Checks if a given unknown value is an `InterruptedException`.

To import and use `isInterruptedException` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isInterruptedException
```

**Signature**

```ts
export declare const isInterruptedException: (u: unknown) => u is InterruptedException
```


# isInterruptedOnly

Checks if a `Cause` contains only interruptions.

**Details**

This function returns `true` if the `Cause` has been interrupted but does not
contain any other failures, such as `Fail` or `Die`. It's helpful for
verifying purely "cancellation" scenarios.

To import and use `isInterruptedOnly` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isInterruptedOnly
```

**Signature**

```ts
export declare const isInterruptedOnly: <E>(self: Cause<E>) => boolean
```


# isInterruptType

Checks if a `Cause` is an `Interrupt` type.

To import and use `isInterruptType` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isInterruptType
```

**Signature**

```ts
export declare const isInterruptType: <E>(self: Cause<E>) => self is Interrupt
```


# isNoSuchElementException

Checks if a given unknown value is a `NoSuchElementException`.

To import and use `isNoSuchElementException` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isNoSuchElementException
```

**Signature**

```ts
export declare const isNoSuchElementException: (u: unknown) => u is NoSuchElementException
```


# isParallelType

Checks if a `Cause` is a `Parallel` type.

To import and use `isParallelType` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isParallelType
```

**Signature**

```ts
export declare const isParallelType: <E>(self: Cause<E>) => self is Parallel<E>
```


# isRuntimeException

Checks if a given unknown value is a `RuntimeException`.

To import and use `isRuntimeException` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isRuntimeException
```

**Signature**

```ts
export declare const isRuntimeException: (u: unknown) => u is RuntimeException
```


# isSequentialType

Checks if a `Cause` is a `Sequential` type.

To import and use `isSequentialType` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isSequentialType
```

**Signature**

```ts
export declare const isSequentialType: <E>(self: Cause<E>) => self is Sequential<E>
```


# isUnknownException

Checks if a given unknown value is an `UnknownException`.

To import and use `isUnknownException` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.isUnknownException
```

**Signature**

```ts
export declare const isUnknownException: (u: unknown) => u is UnknownException
```


# keepDefects

Removes all `Fail` and `Interrupt` nodes, keeping only defects (`Die`) in a
`Cause`.

**Details**

This function strips a cause of recoverable errors and interruptions, leaving
only unexpected failures. If no defects remain, it returns `None`. It's
valuable for focusing only on unanticipated problems when both known errors
and defects could occur.

To import and use `keepDefects` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.keepDefects
```

**Signature**

```ts
export declare const keepDefects: <E>(self: Cause<E>) => Option.Option<Cause<never>>
```


# linearize

Linearizes a `Cause` into a set of parallel causes, each containing a
sequential chain of failures.

**Details**

This function reorganizes the cause structure so that you can analyze each
parallel branch separately, even if they have multiple sequential errors.

To import and use `linearize` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.linearize
```

**Signature**

```ts
export declare const linearize: <E>(self: Cause<E>) => HashSet.HashSet<Cause<E>>
```


# map

Transforms the errors in a `Cause` using a user-provided function.

**Details**

This function applies `f` to each `Fail` error while leaving defects (`Die`)
and interruptions untouched. It's useful for changing or simplifying error
types in your effectful workflows.

To import and use `map` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.map
```

**Signature**

```ts
export declare const map: {
  <E, E2>(f: (e: E) => E2): (self: Cause<E>) => Cause<E2>
  <E, E2>(self: Cause<E>, f: (e: E) => E2): Cause<E2>
}
```


# match

Transforms a `Cause` into a single value using custom handlers for each
possible case.

**Details**

This function processes a `Cause` by applying a set of custom handlers to
each possible type of cause: `Empty`, `Fail`, `Die`, `Interrupt`,
`Sequential`, and `Parallel`. The result of this function is a single value
of type `Z`. This function allows you to define exactly how to handle each
part of a `Cause`, whether it's a failure, defect, interruption, or a
combination of these.

The options parameter provides handlers for:

- `onEmpty`: Handles the case where the cause is `Empty`, meaning no errors
  occurred.
- `onFail`: Processes a failure with an error of type `E`.
- `onDie`: Processes a defect (unexpected error).
- `onInterrupt`: Handles a fiber interruption, providing the `FiberId` of the
  interruption.
- `onSequential`: Combines two sequential causes into a single value of type
  `Z`.
- `onParallel`: Combines two parallel causes into a single value of type `Z`.

To import and use `match` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.match
```

**Signature**

```ts
export declare const match: {
  <Z, E>(options: {
    readonly onEmpty: Z
    readonly onFail: (error: E) => Z
    readonly onDie: (defect: unknown) => Z
    readonly onInterrupt: (fiberId: FiberId.FiberId) => Z
    readonly onSequential: (left: Z, right: Z) => Z
    readonly onParallel: (left: Z, right: Z) => Z
  }): (self: Cause<E>) => Z
  <Z, E>(
    self: Cause<E>,
    options: {
      readonly onEmpty: Z
      readonly onFail: (error: E) => Z
      readonly onDie: (defect: unknown) => Z
      readonly onInterrupt: (fiberId: FiberId.FiberId) => Z
      readonly onSequential: (left: Z, right: Z) => Z
      readonly onParallel: (left: Z, right: Z) => Z
    }
  ): Z
}
```


# NoSuchElementException

An error that occurs when an expected element is missing.

**Details**

This interface indicates scenarios like looking up an item in a collection
or searching for data that should be present but isn't. It helps your code
signal a more specific issue rather than a general error.

To import and use `NoSuchElementException` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.NoSuchElementException
```


# NoSuchElementExceptionTypeId

A unique symbol identifying the `NoSuchElementException` type.

**Details**

This provides a symbol that identifies a `NoSuchElementException`. It helps
differentiate cases where a required element is missing within a data
structure.

To import and use `NoSuchElementExceptionTypeId` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.NoSuchElementExceptionTypeId
```

**Signature**

```ts
export declare const NoSuchElementExceptionTypeId: typeof NoSuchElementExceptionTypeId
```


# originalError

Retrieves the original, unproxied error instance from an error object.

**Details**

This function returns the underlying error object without any
library-specific wrapping or proxying that might occur during error handling.
This can be essential if you need direct access to the error's native
properties, such as stack traces or custom data fields, for detailed
debugging or integration with external systems.

To import and use `originalError` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.originalError
```

**Signature**

```ts
export declare const originalError: <E>(obj: E) => E
```


# parallel

Combines two `Cause`s in parallel.

**Details**

This function merges two errors that occurred simultaneously. Instead of
discarding one error, both are retained, allowing for richer error reporting
and debugging.

To import and use `parallel` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.parallel
```

**Signature**

```ts
export declare const parallel: <E, E2>(left: Cause<E>, right: Cause<E2>) => Cause<E | E2>
```


# Parallel

Represents parallel composition of two `Cause`s.

**Details**

This interface captures failures that happen simultaneously. In scenarios
with concurrency, more than one operation can fail in parallel. Instead of
losing information, this structure stores both errors together.

To import and use `Parallel` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.Parallel
```


# pretty

Converts a `Cause` into a human-readable string.

**Details**

This function pretty-prints the entire `Cause`, including any failures,
defects, and interruptions. It can be especially helpful for logging,
debugging, or displaying structured errors to users.

You can optionally pass `options` to configure how the error cause is
rendered. By default, it includes essential details of all errors in the
`Cause`.

To import and use `pretty` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.pretty
```

**Signature**

```ts
export declare const pretty: <E>(
  cause: Cause<E>,
  options?: { readonly renderErrorCause?: boolean | undefined }
) => string
```


# PrettyError

A shape for prettified errors, optionally including a source span.

To import and use `PrettyError` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.PrettyError
```


# prettyErrors

Returns a list of prettified errors (`PrettyError`) from a `Cause`.

**Details**

This function inspects the entire `Cause` and produces an array of
`PrettyError` objects. Each object may include additional metadata, such as a
`Span`, to provide deeper insights into where and how the error occurred.

To import and use `prettyErrors` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.prettyErrors
```

**Signature**

```ts
export declare const prettyErrors: <E>(cause: Cause<E>) => Array<PrettyError>
```


# reduce

Combines all parts of a `Cause` into a single value by starting with an
initial value.

**Details**

This function processes a `Cause` by starting with an initial value (`zero`)
and applying a custom function (`pf`) to combine all elements of the `Cause`
into a single result of type `Z`. The custom function determines how each
part of the `Cause` contributes to the final result. The function can return
an `Option` to either continue combining values or skip specific parts of the
`Cause`.

This function is useful for tasks such as:

- Aggregating error messages from a `Cause` into a single string.
- Summarizing the structure of a `Cause` into a simplified result.
- Filtering or processing only specific parts of a `Cause`.

The reduction proceeds in a top-down manner, visiting all nodes in the
`Cause` structure. This gives you complete control over how each part of the
`Cause` contributes to the final result.

To import and use `reduce` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.reduce
```

**Signature**

```ts
export declare const reduce: {
  <Z, E>(zero: Z, pf: (accumulator: Z, cause: Cause<E>) => Option.Option<Z>): (self: Cause<E>) => Z
  <Z, E>(self: Cause<E>, zero: Z, pf: (accumulator: Z, cause: Cause<E>) => Option.Option<Z>): Z
}
```


# reduceWithContext

Combines all parts of a `Cause` into a single value using a custom reducer
and a context.

**Details**

This function allows you to reduce a `Cause` into a single value of type `Z`
using a custom `CauseReducer`. A `CauseReducer` provides methods to handle
specific parts of the `Cause`, such as failures, defects, or interruptions.
Additionally, this function provides access to a `context` value, which can
be used to carry information or maintain state during the reduction process.

This is particularly useful when the reduction process needs additional
context or configuration, such as:

- Aggregating error details with dynamic formatting.
- Collecting logs or statistics about the `Cause`.
- Performing stateful transformations based on the `context`.

To import and use `reduceWithContext` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.reduceWithContext
```

**Signature**

```ts
export declare const reduceWithContext: {
  <C, E, Z>(context: C, reducer: CauseReducer<C, E, Z>): (self: Cause<E>) => Z
  <C, E, Z>(self: Cause<E>, context: C, reducer: CauseReducer<C, E, Z>): Z
}
```


# RuntimeException

An error representing a runtime error.

**Details**

This interface is used for errors that occur at runtime but are still
considered recoverable or typed.

To import and use `RuntimeException` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.RuntimeException
```


# RuntimeExceptionTypeId

A unique symbol identifying the `RuntimeException` type.

**Details**

This provides a symbol that identifies a `RuntimeException`. This is
typically used internally by the library to recognize checked exceptions that
occur during runtime.

To import and use `RuntimeExceptionTypeId` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.RuntimeExceptionTypeId
```

**Signature**

```ts
export declare const RuntimeExceptionTypeId: typeof RuntimeExceptionTypeId
```


# sequential

Combines two `Cause`s sequentially.

**Details**

This function merges two errors that occurred in sequence, such as a main
error followed by a finalization error. It preserves both errors for complete
failure information.

To import and use `sequential` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.sequential
```

**Signature**

```ts
export declare const sequential: <E, E2>(left: Cause<E>, right: Cause<E2>) => Cause<E | E2>
```


# Sequential

Represents sequential composition of two `Cause`s.

**Details**

This interface models the scenario where one error follows another in
sequence, such as when a main effect fails and then a finalizer also fails.
It ensures both errors are retained in the final `Cause`.

To import and use `Sequential` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.Sequential
```


# size

Calculates the size of a `Cause`.

**Details**

This function returns the total number of `Cause` nodes in the semiring
structure, reflecting how many individual error elements are recorded.

To import and use `size` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.size
```

**Signature**

```ts
export declare const size: <E>(self: Cause<E>) => number
```


# squash

Extracts the most "important" defect from a `Cause`.

**Details**

This function reduces a `Cause` to a single, prioritized defect. It evaluates
the `Cause` in the following order of priority:

1. If the `Cause` contains a failure (e.g., from `Effect.fail`), it returns
   the raw error value.
2. If there is no failure, it looks for the first defect (e.g., from
   `Effect.die`).
3. If neither of the above is present, and the `Cause` stems from an
   interruption, it creates and returns an `InterruptedException`.

This function ensures you can always extract a meaningful representation of
the primary issue from a potentially complex `Cause` structure.

**When to Use**

Use this function when you need to extract the most relevant error or defect
from a `Cause`, especially in scenarios where multiple errors or defects may
be present. It's particularly useful for simplifying error reporting or
logging.

To import and use `squash` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.squash
```

**Signature**

```ts
export declare const squash: <E>(self: Cause<E>) => unknown
```


# squashWith

Extracts the most "important" defect from a `Cause`, transforming failures
into defects using a provided function.

**Details**

This function reduces a `Cause` to a single, prioritized defect, while
allowing you to transform recoverable failures into defects through a custom
function. It processes the `Cause` in the following order:

1. If the `Cause` contains a failure (e.g., from `Effect.fail`), it applies
   the provided function `f` to the error to transform it into a defect.
2. If there is no failure, it looks for the first defect (e.g., from
   `Effect.die`) and returns it.
3. If neither is present and the `Cause` stems from an interruption, it
   returns an `InterruptedException`.

This function is particularly useful when you need custom handling or
transformation of errors while processing a `Cause`.

To import and use `squashWith` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.squashWith
```

**Signature**

```ts
export declare const squashWith: {
  <E>(f: (error: E) => unknown): (self: Cause<E>) => unknown
  <E>(self: Cause<E>, f: (error: E) => unknown): unknown
}
```


# stripFailures

Removes `Fail` and `Interrupt` nodes from a `Cause`, keeping only defects
(`Die`).

**Details**

This function is similar to `keepDefects` but returns a `Cause<never>`
directly, which can still store `Die` or finalizer-related defects. It's
helpful for analyzing only the irrecoverable portion of the error.

To import and use `stripFailures` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.stripFailures
```

**Signature**

```ts
export declare const stripFailures: <E>(self: Cause<E>) => Cause<never>
```


# stripSomeDefects

Removes matching defects from a `Cause` using a partial function, returning
the remainder.

**Details**

This function applies a user-defined extraction function to each defect
(`Die`). If the function matches the defect, that defect is removed. If all
defects match, the result is `None`. Otherwise, you get a `Cause` with the
unmatched defects.

To import and use `stripSomeDefects` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.stripSomeDefects
```

**Signature**

```ts
export declare const stripSomeDefects: {
  (pf: (defect: unknown) => Option.Option<unknown>): <E>(self: Cause<E>) => Option.Option<Cause<E>>
  <E>(self: Cause<E>, pf: (defect: unknown) => Option.Option<unknown>): Option.Option<Cause<E>>
}
```


# TimeoutException

An error representing a computation that timed out.

To import and use `TimeoutException` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.TimeoutException
```


# TimeoutExceptionTypeId

A unique symbol identifying the `TimeoutException` type.

**Details**

This provides a symbol that identifies a `TimeoutException`. It helps the
framework recognize errors related to operations that fail to complete within
a given timeframe.

To import and use `TimeoutExceptionTypeId` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.TimeoutExceptionTypeId
```

**Signature**

```ts
export declare const TimeoutExceptionTypeId: typeof TimeoutExceptionTypeId
```


# UnknownException

A checked exception for handling unknown or unexpected errors.

**Details**

This interface captures errors that don't fall under known categories. It is
especially helpful for wrapping low-level or third-party library errors that
might provide little or no context, such as from a rejected promise.

To import and use `UnknownException` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.UnknownException
```


# UnknownExceptionTypeId

A unique symbol identifying the `UnknownException` type.

**Details**

This provides a symbol that identifies an `UnknownException`. It is typically
used for generic or unexpected errors that do not fit other specific
exception categories.

To import and use `UnknownExceptionTypeId` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.UnknownExceptionTypeId
```

**Signature**

```ts
export declare const UnknownExceptionTypeId: typeof UnknownExceptionTypeId
```


# YieldableError

Represents an error object that can be yielded in `Effect.gen`.

To import and use `YieldableError` from the "Cause" module:

```ts
import * as Cause from "effect/Cause"
// Can be accessed like this
Cause.YieldableError
```


# tap

Returns an effect that effectfully "peeks" at the success of this effect.

To import and use `tap` from the "Chainable" module:

```ts
import * as Chainable from "@effect/typeclass/Chainable"
// Can be accessed like this
Chainable.tap
```

**Signature**

```ts
export declare const tap: <F extends TypeLambda>(
  F: Chainable<F>
) => {
  <A, R2, O2, E2, _>(
    f: (a: A) => Kind<F, R2, O2, E2, _>
  ): <R1, O1, E1>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, A>
  <R1, O1, E1, A, R2, O2, E2, _>(
    self: Kind<F, R1, O1, E1, A>,
    f: (a: A) => Kind<F, R2, O2, E2, _>
  ): Kind<F, R1 & R2, O1 | O2, E1 | E2, A>
}
```


# zipLeft

Sequences the specified effect after this effect, but ignores the value
produced by the effect.

To import and use `zipLeft` from the "Chainable" module:

```ts
import * as Chainable from "@effect/typeclass/Chainable"
// Can be accessed like this
Chainable.zipLeft
```

**Signature**

```ts
export declare const zipLeft: <F extends TypeLambda>(
  F: Chainable<F>
) => {
  <R2, O2, E2, _>(
    that: Kind<F, R2, O2, E2, _>
  ): <R1, O1, E1, A>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, A>
  <R1, O1, E1, A, R2, O2, E2, _>(
    self: Kind<F, R1, O1, E1, A>,
    that: Kind<F, R2, O2, E2, _>
  ): Kind<F, R1 & R2, O1 | O2, E1 | E2, A>
}
```


# as

Returns a new channel that is the same as this one, except the terminal
value of the channel is the specified constant value.

This method produces the same result as mapping this channel to the
specified constant value.

To import and use `as` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.as
```

**Signature**

```ts
export declare const as: {
  <OutDone2>(
    value: OutDone2
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    value: OutDone2
  ): Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>
}
```


# buffer

Creates a channel backed by a buffer. When the buffer is empty, the channel
will simply passthrough its input as output. However, when the buffer is
non-empty, the value inside the buffer will be passed along as output.

To import and use `buffer` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.buffer
```

**Signature**

```ts
export declare const buffer: <InElem, InErr, InDone>(options: {
  readonly empty: InElem
  readonly isEmpty: Predicate<InElem>
  readonly ref: Ref.Ref<InElem>
}) => Channel<InElem, InElem, InErr, InErr, InDone, InDone, never>
```


# catchAll

Returns a new channel that is the same as this one, except if this channel
errors for any typed error, then the returned channel will switch over to
using the fallback channel returned by the specified error handler.

To import and use `catchAll` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.catchAll
```

**Signature**

```ts
export declare const catchAll: {
  <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(
    f: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>
  ): <OutElem, InElem, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<
    OutElem1 | OutElem,
    InElem & InElem1,
    OutErr1,
    InErr & InErr1,
    OutDone1 | OutDone,
    InDone & InDone1,
    Env1 | Env
  >
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>
  ): Channel<
    OutElem | OutElem1,
    InElem & InElem1,
    OutErr1,
    InErr & InErr1,
    OutDone | OutDone1,
    InDone & InDone1,
    Env | Env1
  >
}
```


# catchAllCause

Returns a new channel that is the same as this one, except if this channel
errors for any typed error, then the returned channel will switch over to
using the fallback channel returned by the specified error handler.

To import and use `catchAllCause` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.catchAllCause
```

**Signature**

```ts
export declare const catchAllCause: {
  <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(
    f: (cause: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>
  ): <OutElem, InElem, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<
    OutElem1 | OutElem,
    InElem & InElem1,
    OutErr1,
    InErr & InErr1,
    OutDone1 | OutDone,
    InDone & InDone1,
    Env1 | Env
  >
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (cause: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>
  ): Channel<
    OutElem | OutElem1,
    InElem & InElem1,
    OutErr1,
    InErr & InErr1,
    OutDone | OutDone1,
    InDone & InDone1,
    Env | Env1
  >
}
```


# Channel

A `Channel` is a nexus of I/O operations, which supports both reading and
writing. A channel may read values of type `InElem` and write values of type
`OutElem`. When the channel finishes, it yields a value of type `OutDone`. A
channel may fail with a value of type `OutErr`.

Channels are the foundation of Streams: both streams and sinks are built on
channels. Most users shouldn't have to use channels directly, as streams and
sinks are much more convenient and cover all common use cases. However, when
adding new stream and sink operators, or doing something highly specialized,
it may be useful to use channels directly.

Channels compose in a variety of ways:

- **Piping**: One channel can be piped to another channel, assuming the
  input type of the second is the same as the output type of the first.
- **Sequencing**: The terminal value of one channel can be used to create
  another channel, and both the first channel and the function that makes
  the second channel can be composed into a channel.
- **Concatenating**: The output of one channel can be used to create other
  channels, which are all concatenated together. The first channel and the
  function that makes the other channels can be composed into a channel.

To import and use `Channel` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.Channel
```


# ChannelException

Represents a generic checked exception which occurs when a `Channel` is
executed.

To import and use `ChannelException` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.ChannelException
```


# collect

Returns a new channel, which is the same as this one, except its outputs
are filtered and transformed by the specified partial function.

To import and use `collect` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.collect
```

**Signature**

```ts
export declare const collect: {
  <OutElem, OutElem2>(
    pf: (o: OutElem) => Option.Option<OutElem2>
  ): <InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, unknown, never, unknown, void, unknown, never>
  ) => Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    pf: (o: OutElem) => Option.Option<OutElem2>
  ): Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>
}
```


# concatAll

Concat sequentially a channel of channels.

To import and use `concatAll` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.concatAll
```

**Signature**

```ts
export declare const concatAll: <OutElem, InElem, OutErr, InErr, InDone, Env>(
  channels: Channel<Channel<OutElem, InElem, OutErr, InErr, any, InDone, Env>, InElem, OutErr, InErr, any, InDone, Env>
) => Channel<OutElem, InElem, OutErr, InErr, any, InDone, Env>
```


# concatAllWith

Concat sequentially a channel of channels.

To import and use `concatAllWith` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.concatAllWith
```

**Signature**

```ts
export declare const concatAllWith: <
  OutElem,
  InElem2,
  OutErr2,
  InErr2,
  OutDone,
  InDone2,
  Env2,
  InElem,
  OutErr,
  InErr,
  OutDone2,
  InDone,
  Env,
  OutDone3
>(
  channels: Channel<
    Channel<OutElem, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>,
    InElem,
    OutErr,
    InErr,
    OutDone2,
    InDone,
    Env
  >,
  f: (o: OutDone, o1: OutDone) => OutDone,
  g: (o: OutDone, o2: OutDone2) => OutDone3
) => Channel<OutElem, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>
```


# concatMap

Returns a new channel whose outputs are fed to the specified factory
function, which creates new channels in response. These new channels are
sequentially concatenated together, and all their outputs appear as outputs
of the newly returned channel.

To import and use `concatMap` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.concatMap
```

**Signature**

```ts
export declare const concatMap: {
  <OutElem, OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>(
    f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>
  ): <Env, InErr, InElem, InDone, OutErr, OutDone>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, unknown, InDone & InDone2, Env2 | Env>
  <Env, InErr, InElem, InDone, OutErr, OutDone, OutElem, OutElem2, Env2, InErr2, InElem2, InDone2, OutErr2, X>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>
  ): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, unknown, InDone & InDone2, Env | Env2>
}
```


# concatMapWith

Returns a new channel whose outputs are fed to the specified factory
function, which creates new channels in response. These new channels are
sequentially concatenated together, and all their outputs appear as outputs
of the newly returned channel. The provided merging function is used to
merge the terminal values of all channels into the single terminal value of
the returned channel.

To import and use `concatMapWith` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.concatMapWith
```

**Signature**

```ts
export declare const concatMapWith: {
  <OutElem, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone2, OutDone3>(
    f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>,
    g: (o: OutDone, o1: OutDone) => OutDone,
    h: (o: OutDone, o2: OutDone2) => OutDone3
  ): <Env, InErr, InElem, InDone, OutErr>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>
  ) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>
  <
    OutElem,
    InElem,
    OutErr,
    InErr,
    OutDone2,
    InDone,
    Env,
    OutElem2,
    InElem2,
    OutErr2,
    InErr2,
    OutDone,
    InDone2,
    Env2,
    OutDone3
  >(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>,
    f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>,
    g: (o: OutDone, o1: OutDone) => OutDone,
    h: (o: OutDone, o2: OutDone2) => OutDone3
  ): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, OutDone3, InDone & InDone2, Env | Env2>
}
```


# concatMapWithCustom

Returns a new channel whose outputs are fed to the specified factory
function, which creates new channels in response. These new channels are
sequentially concatenated together, and all their outputs appear as outputs
of the newly returned channel. The provided merging function is used to
merge the terminal values of all channels into the single terminal value of
the returned channel.

To import and use `concatMapWithCustom` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.concatMapWithCustom
```

**Signature**

```ts
export declare const concatMapWithCustom: {
  <OutElem, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone2, OutDone3>(
    f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>,
    g: (o: OutDone, o1: OutDone) => OutDone,
    h: (o: OutDone, o2: OutDone2) => OutDone3,
    onPull: (
      upstreamPullRequest: UpstreamPullRequest.UpstreamPullRequest<OutElem>
    ) => UpstreamPullStrategy.UpstreamPullStrategy<OutElem2>,
    onEmit: (elem: OutElem2) => ChildExecutorDecision.ChildExecutorDecision
  ): <Env, InErr, InElem, InDone, OutErr>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>
  ) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>
  <
    OutElem,
    InElem,
    OutErr,
    InErr,
    OutDone2,
    InDone,
    Env,
    OutElem2,
    InElem2,
    OutErr2,
    InErr2,
    OutDone,
    InDone2,
    Env2,
    OutDone3
  >(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>,
    f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>,
    g: (o: OutDone, o1: OutDone) => OutDone,
    h: (o: OutDone, o2: OutDone2) => OutDone3,
    onPull: (
      upstreamPullRequest: UpstreamPullRequest.UpstreamPullRequest<OutElem>
    ) => UpstreamPullStrategy.UpstreamPullStrategy<OutElem2>,
    onEmit: (elem: OutElem2) => ChildExecutorDecision.ChildExecutorDecision
  ): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, OutDone3, InDone & InDone2, Env | Env2>
}
```


# concatOut

Returns a new channel, which is the concatenation of all the channels that
are written out by this channel. This method may only be called on channels
that output other channels.

To import and use `concatOut` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.concatOut
```

**Signature**

```ts
export declare const concatOut: <OutElem, InElem, OutErr, InErr, InDone, Env, OutDone>(
  self: Channel<
    Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env>,
    InElem,
    OutErr,
    InErr,
    OutDone,
    InDone,
    Env
  >
) => Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env>
```


# context

Accesses the whole context of the channel.

To import and use `context` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.context
```

**Signature**

```ts
export declare const context: <Env>() => Channel<never, unknown, never, unknown, Context.Context<Env>, unknown, Env>
```


# contextWith

Accesses the context of the channel with the specified function.

To import and use `contextWith` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.contextWith
```

**Signature**

```ts
export declare const contextWith: <Env, OutDone>(
  f: (env: Context.Context<Env>) => OutDone
) => Channel<never, unknown, never, unknown, OutDone, unknown, Env>
```


# contextWithChannel

Accesses the context of the channel in the context of a channel.

To import and use `contextWithChannel` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.contextWithChannel
```

**Signature**

```ts
export declare const contextWithChannel: <Env, OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1>(
  f: (env: Context.Context<Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1>
) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1>
```


# contextWithEffect

Accesses the context of the channel in the context of an effect.

To import and use `contextWithEffect` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.contextWithEffect
```

**Signature**

```ts
export declare const contextWithEffect: <Env, OutDone, OutErr, Env1>(
  f: (env: Context.Context<Env>) => Effect.Effect<OutDone, OutErr, Env1>
) => Channel<never, unknown, OutErr, unknown, OutDone, unknown, Env | Env1>
```


# doneCollect

Returns a new channel, which is the same as this one, except that all the
outputs are collected and bundled into a tuple together with the terminal
value of this channel.

As the channel returned from this channel collects all of this channel's
output into an in- memory chunk, it is not safe to call this method on
channels that output a large or unbounded number of values.

To import and use `doneCollect` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.doneCollect
```

**Signature**

```ts
export declare const doneCollect: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
  self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
) => Channel<never, InElem, OutErr, InErr, [Chunk.Chunk<OutElem>, OutDone], InDone, Env>
```


# drain

Returns a new channel which reads all the elements from upstream's output
channel and ignores them, then terminates with the upstream result value.

To import and use `drain` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.drain
```

**Signature**

```ts
export declare const drain: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
  self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
) => Channel<never, InElem, OutErr, InErr, OutDone, InDone, Env>
```


# embedInput

Returns a new channel which connects the given `AsyncInputProducer` as
this channel's input.

To import and use `embedInput` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.embedInput
```

**Signature**

```ts
export declare const embedInput: {
  <InErr, InElem, InDone>(
    input: SingleProducerAsyncInput.AsyncInputProducer<InErr, InElem, InDone>
  ): <OutElem, OutErr, OutDone, Env>(
    self: Channel<OutElem, unknown, OutErr, unknown, OutDone, unknown, Env>
  ) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  <OutElem, OutErr, OutDone, Env, InErr, InElem, InDone>(
    self: Channel<OutElem, unknown, OutErr, unknown, OutDone, unknown, Env>,
    input: SingleProducerAsyncInput.AsyncInputProducer<InErr, InElem, InDone>
  ): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
}
```


# emitCollect

Returns a new channel that collects the output and terminal value of this
channel, which it then writes as output of the returned channel.

To import and use `emitCollect` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.emitCollect
```

**Signature**

```ts
export declare const emitCollect: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
  self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
) => Channel<[Chunk.Chunk<OutElem>, OutDone], InElem, OutErr, InErr, void, InDone, Env>
```


# ensuring

Returns a new channel with an attached finalizer. The finalizer is
guaranteed to be executed so long as the channel begins execution (and
regardless of whether or not it completes).

To import and use `ensuring` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.ensuring
```

**Signature**

```ts
export declare const ensuring: {
  <Z, Env1>(
    finalizer: Effect.Effect<Z, never, Env1>
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1 | Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Z, Env1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    finalizer: Effect.Effect<Z, never, Env1>
  ): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1>
}
```


# ensuringWith

Returns a new channel with an attached finalizer. The finalizer is
guaranteed to be executed so long as the channel begins execution (and
regardless of whether or not it completes).

To import and use `ensuringWith` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.ensuringWith
```

**Signature**

```ts
export declare const ensuringWith: {
  <OutDone, OutErr, Env2>(
    finalizer: (e: Exit.Exit<OutDone, OutErr>) => Effect.Effect<unknown, never, Env2>
  ): <OutElem, InElem, InErr, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env2 | Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Env2>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    finalizer: (e: Exit.Exit<OutDone, OutErr>) => Effect.Effect<unknown, never, Env2>
  ): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env2>
}
```


# fail

Constructs a channel that fails immediately with the specified error.

To import and use `fail` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.fail
```

**Signature**

```ts
export declare const fail: <E>(error: E) => Channel<never, unknown, E, unknown, never, unknown>
```


# failCause

Constructs a channel that fails immediately with the specified `Cause`.

To import and use `failCause` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.failCause
```

**Signature**

```ts
export declare const failCause: <E>(cause: Cause.Cause<E>) => Channel<never, unknown, E, unknown, never, unknown>
```


# failCauseSync

Constructs a channel that succeeds immediately with the specified lazily
evaluated `Cause`.

To import and use `failCauseSync` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.failCauseSync
```

**Signature**

```ts
export declare const failCauseSync: <E>(
  evaluate: LazyArg<Cause.Cause<E>>
) => Channel<never, unknown, E, unknown, never, unknown>
```


# failSync

Constructs a channel that succeeds immediately with the specified lazily
evaluated value.

To import and use `failSync` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.failSync
```

**Signature**

```ts
export declare const failSync: <E>(evaluate: LazyArg<E>) => Channel<never, unknown, E, unknown, never, unknown>
```


# flatMap

Returns a new channel, which sequentially combines this channel, together
with the provided factory function, which creates a second channel based on
the terminal value of this channel. The result is a channel that will first
perform the functions of this channel, before performing the functions of
the created channel (including yielding its terminal value).

To import and use `flatMap` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.flatMap
```

**Signature**

```ts
export declare const flatMap: {
  <OutDone, OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>(
    f: (d: OutDone) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>
  ): <OutElem, InElem, OutErr, InErr, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<
    OutElem1 | OutElem,
    InElem & InElem1,
    OutErr1 | OutErr,
    InErr & InErr1,
    OutDone2,
    InDone & InDone1,
    Env1 | Env
  >
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (d: OutDone) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>
  ): Channel<
    OutElem | OutElem1,
    InElem & InElem1,
    OutErr | OutErr1,
    InErr & InErr1,
    OutDone2,
    InDone & InDone1,
    Env | Env1
  >
}
```


# flatten

Returns a new channel, which flattens the terminal value of this channel.
This function may only be called if the terminal value of this channel is
another channel of compatible types.

To import and use `flatten` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.flatten
```

**Signature**

```ts
export declare const flatten: <
  OutElem,
  InElem,
  OutErr,
  InErr,
  OutElem1,
  InElem1,
  OutErr1,
  InErr1,
  OutDone2,
  InDone1,
  Env1,
  InDone,
  Env
>(
  self: Channel<
    OutElem,
    InElem,
    OutErr,
    InErr,
    Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>,
    InDone,
    Env
  >
) => Channel<
  OutElem | OutElem1,
  InElem & InElem1,
  OutErr | OutErr1,
  InErr & InErr1,
  OutDone2,
  InDone & InDone1,
  Env1 | Env
>
```


# foldCauseChannel

Folds over the result of this channel including any cause of termination.

To import and use `foldCauseChannel` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.foldCauseChannel
```

**Signature**

```ts
export declare const foldCauseChannel: {
  <
    OutErr,
    OutElem1,
    InElem1,
    OutErr2,
    InErr1,
    OutDone2,
    InDone1,
    Env1,
    OutDone,
    OutElem2,
    InElem2,
    OutErr3,
    InErr2,
    OutDone3,
    InDone2,
    Env2
  >(options: {
    readonly onFailure: (c: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1>
    readonly onSuccess: (o: OutDone) => Channel<OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>
  }): <Env, InErr, InElem, InDone, OutElem>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<
    OutElem1 | OutElem2 | OutElem,
    InElem & InElem1 & InElem2,
    OutErr2 | OutErr3,
    InErr & InErr1 & InErr2,
    OutDone2 | OutDone3,
    InDone & InDone1 & InDone2,
    Env1 | Env2 | Env
  >
  <
    OutElem,
    InElem,
    OutErr,
    InErr,
    OutDone,
    InDone,
    Env,
    OutElem1,
    InElem1,
    OutErr2,
    InErr1,
    OutDone2,
    InDone1,
    Env1,
    OutElem2,
    InElem2,
    OutErr3,
    InErr2,
    OutDone3,
    InDone2,
    Env2
  >(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    options: {
      readonly onFailure: (
        c: Cause.Cause<OutErr>
      ) => Channel<OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1>
      readonly onSuccess: (o: OutDone) => Channel<OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>
    }
  ): Channel<
    OutElem | OutElem1 | OutElem2,
    InElem & InElem1 & InElem2,
    OutErr2 | OutErr3,
    InErr & InErr1 & InErr2,
    OutDone2 | OutDone3,
    InDone & InDone1 & InDone2,
    Env | Env1 | Env2
  >
}
```


# foldChannel

Folds over the result of this channel.

To import and use `foldChannel` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.foldChannel
```

**Signature**

```ts
export declare const foldChannel: {
  <
    OutErr,
    OutElem1,
    InElem1,
    OutErr1,
    InErr1,
    OutDone1,
    InDone1,
    Env1,
    OutDone,
    OutElem2,
    InElem2,
    OutErr2,
    InErr2,
    OutDone2,
    InDone2,
    Env2
  >(options: {
    readonly onFailure: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>
    readonly onSuccess: (done: OutDone) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>
  }): <Env, InErr, InElem, InDone, OutElem>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<
    OutElem1 | OutElem2 | OutElem,
    InElem & InElem1 & InElem2,
    OutErr1 | OutErr2,
    InErr & InErr1 & InErr2,
    OutDone1 | OutDone2,
    InDone & InDone1 & InDone2,
    Env1 | Env2 | Env
  >
  <
    OutElem,
    InElem,
    OutErr,
    InErr,
    OutDone,
    InDone,
    Env,
    OutElem1,
    InElem1,
    OutErr1,
    InErr1,
    OutDone1,
    InDone1,
    Env1,
    OutElem2,
    InElem2,
    OutErr2,
    InErr2,
    OutDone2,
    InDone2,
    Env2
  >(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    options: {
      readonly onFailure: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>
      readonly onSuccess: (done: OutDone) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>
    }
  ): Channel<
    OutElem | OutElem1 | OutElem2,
    InElem & InElem1 & InElem2,
    OutErr1 | OutErr2,
    InErr & InErr1 & InErr2,
    OutDone1 | OutDone2,
    InDone & InDone1 & InDone2,
    Env | Env1 | Env2
  >
}
```


# fromEffect

Use an effect to end a channel.

To import and use `fromEffect` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.fromEffect
```

**Signature**

```ts
export declare const fromEffect: <A, E, R>(
  effect: Effect.Effect<A, E, R>
) => Channel<never, unknown, E, unknown, A, unknown, R>
```


# fromEither

Constructs a channel from an `Either`.

To import and use `fromEither` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.fromEither
```

**Signature**

```ts
export declare const fromEither: <R, L>(either: Either.Either<R, L>) => Channel<never, unknown, L, unknown, R, unknown>
```


# fromInput

Construct a `Channel` from an `AsyncInputConsumer`.

To import and use `fromInput` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.fromInput
```

**Signature**

```ts
export declare const fromInput: <Err, Elem, Done>(
  input: SingleProducerAsyncInput.AsyncInputConsumer<Err, Elem, Done>
) => Channel<Elem, unknown, Err, unknown, Done, unknown>
```


# fromOption

Construct a `Channel` from an `Option`.

To import and use `fromOption` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.fromOption
```

**Signature**

```ts
export declare const fromOption: <A>(
  option: Option.Option<A>
) => Channel<never, unknown, Option.Option<never>, unknown, A, unknown>
```


# fromPubSub

Construct a `Channel` from a `PubSub`.

To import and use `fromPubSub` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.fromPubSub
```

**Signature**

```ts
export declare const fromPubSub: <Done, Err, Elem>(
  pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>
) => Channel<Elem, unknown, Err, unknown, Done, unknown>
```


# fromPubSubScoped

Construct a `Channel` from a `PubSub` within a scoped effect.

To import and use `fromPubSubScoped` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.fromPubSubScoped
```

**Signature**

```ts
export declare const fromPubSubScoped: <Done, Err, Elem>(
  pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>
) => Effect.Effect<Channel<Elem, unknown, Err, unknown, Done, unknown>, never, Scope.Scope>
```


# fromQueue

Construct a `Channel` from a `Queue`.

To import and use `fromQueue` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.fromQueue
```

**Signature**

```ts
export declare const fromQueue: <Done, Err, Elem>(
  queue: Queue.Dequeue<Either.Either<Elem, Exit.Exit<Done, Err>>>
) => Channel<Elem, unknown, Err, unknown, Done, unknown>
```


# interruptWhen

Returns a new channel, which is the same as this one, except it will be
interrupted when the specified effect completes. If the effect completes
successfully before the underlying channel is done, then the returned
channel will yield the success value of the effect as its terminal value.
On the other hand, if the underlying channel finishes first, then the
returned channel will yield the success value of the underlying channel as
its terminal value.

To import and use `interruptWhen` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.interruptWhen
```

**Signature**

```ts
export declare const interruptWhen: {
  <OutDone1, OutErr1, Env1>(
    effect: Effect.Effect<OutDone1, OutErr1, Env1>
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env1 | Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    effect: Effect.Effect<OutDone1, OutErr1, Env1>
  ): Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env | Env1>
}
```


# interruptWhenDeferred

Returns a new channel, which is the same as this one, except it will be
interrupted when the specified deferred is completed. If the deferred is
completed before the underlying channel is done, then the returned channel
will yield the value of the deferred. Otherwise, if the underlying channel
finishes first, then the returned channel will yield the value of the
underlying channel.

To import and use `interruptWhenDeferred` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.interruptWhenDeferred
```

**Signature**

```ts
export declare const interruptWhenDeferred: {
  <OutDone1, OutErr1>(
    deferred: Deferred.Deferred<OutDone1, OutErr1>
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    deferred: Deferred.Deferred<OutDone1, OutErr1>
  ): Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env>
}
```


# isChannelException

Returns `true` if the specified value is an `ChannelException`, `false`
otherwise.

To import and use `isChannelException` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.isChannelException
```

**Signature**

```ts
export declare const isChannelException: (u: unknown) => u is ChannelException<unknown>
```


# map

Returns a new channel, which is the same as this one, except the terminal
value of the returned channel is created by applying the specified function
to the terminal value of this channel.

To import and use `map` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.map
```

**Signature**

```ts
export declare const map: {
  <OutDone, OutDone2>(
    f: (out: OutDone) => OutDone2
  ): <OutElem, InElem, OutErr, InErr, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (out: OutDone) => OutDone2
  ): Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>
}
```


# mapEffect

Returns a new channel, which is the same as this one, except the terminal
value of the returned channel is created by applying the specified
effectful function to the terminal value of this channel.

To import and use `mapEffect` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.mapEffect
```

**Signature**

```ts
export declare const mapEffect: {
  <OutDone, OutDone1, OutErr1, Env1>(
    f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>
  ): <OutElem, InElem, OutErr, InErr, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1, InDone, Env1 | Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>
  ): Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone1, InDone, Env | Env1>
}
```


# mapError

Returns a new channel, which is the same as this one, except the failure
value of the returned channel is created by applying the specified function
to the failure value of this channel.

To import and use `mapError` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.mapError
```

**Signature**

```ts
export declare const mapError: {
  <OutErr, OutErr2>(
    f: (err: OutErr) => OutErr2
  ): <OutElem, InElem, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (err: OutErr) => OutErr2
  ): Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>
}
```


# mapErrorCause

A more powerful version of `mapError` which also surfaces the `Cause`
of the channel failure.

To import and use `mapErrorCause` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.mapErrorCause
```

**Signature**

```ts
export declare const mapErrorCause: {
  <OutErr, OutErr2>(
    f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>
  ): <OutElem, InElem, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>
  ): Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>
}
```


# mapInput

Returns a new channel which is the same as this one but applies the given
function to the input channel's done value.

To import and use `mapInput` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.mapInput
```

**Signature**

```ts
export declare const mapInput: {
  <InDone0, InDone>(
    f: (a: InDone0) => InDone
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (a: InDone0) => InDone
  ): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>
}
```


# mapInputContext

Transforms the context being provided to the channel with the specified
function.

To import and use `mapInputContext` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.mapInputContext
```

**Signature**

```ts
export declare const mapInputContext: {
  <Env0, Env>(
    f: (env: Context.Context<Env0>) => Context.Context<Env>
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Env0>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (env: Context.Context<Env0>) => Context.Context<Env>
  ): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env0>
}
```


# mapInputEffect

Returns a new channel which is the same as this one but applies the given
effectual function to the input channel's done value.

To import and use `mapInputEffect` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.mapInputEffect
```

**Signature**

```ts
export declare const mapInputEffect: {
  <InDone0, InDone, InErr, Env1>(
    f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>
  ): <OutElem, InElem, OutErr, OutDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env1 | Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0, Env1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>
  ): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env | Env1>
}
```


# mapInputError

Returns a new channel which is the same as this one but applies the given
function to the input channel's error value.

To import and use `mapInputError` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.mapInputError
```

**Signature**

```ts
export declare const mapInputError: {
  <InErr0, InErr>(
    f: (a: InErr0) => InErr
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (a: InErr0) => InErr
  ): Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>
}
```


# mapInputErrorEffect

Returns a new channel which is the same as this one but applies the given
effectual function to the input channel's error value.

To import and use `mapInputErrorEffect` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.mapInputErrorEffect
```

**Signature**

```ts
export declare const mapInputErrorEffect: {
  <InErr0, InDone, InErr, Env1>(
    f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>
  ): <OutElem, InElem, OutErr, OutDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env1 | Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0, Env1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>
  ): Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env | Env1>
}
```


# mapInputIn

Returns a new channel which is the same as this one but applies the given
function to the input channel's output elements.

To import and use `mapInputIn` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.mapInputIn
```

**Signature**

```ts
export declare const mapInputIn: {
  <InElem0, InElem>(
    f: (a: InElem0) => InElem
  ): <OutElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (a: InElem0) => InElem
  ): Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>
}
```


# mapInputInEffect

Returns a new channel which is the same as this one but applies the given
effectual function to the input channel's output elements.

To import and use `mapInputInEffect` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.mapInputInEffect
```

**Signature**

```ts
export declare const mapInputInEffect: {
  <InElem0, InElem, InErr, Env1>(
    f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>
  ): <OutElem, OutErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env1 | Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0, Env1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>
  ): Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env | Env1>
}
```


# mapOut

Maps the output of this channel using the specified function.

To import and use `mapOut` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.mapOut
```

**Signature**

```ts
export declare const mapOut: {
  <OutElem, OutElem2>(
    f: (o: OutElem) => OutElem2
  ): <InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (o: OutElem) => OutElem2
  ): Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>
}
```


# mapOutEffect

Creates a channel that is like this channel but the given effectful function
gets applied to each emitted output element.

To import and use `mapOutEffect` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.mapOutEffect
```

**Signature**

```ts
export declare const mapOutEffect: {
  <OutElem, OutElem1, OutErr1, Env1>(
    f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>
  ): <InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>
  ): Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1>
}
```


# mapOutEffectPar

Creates a channel that is like this channel but the given ZIO function gets
applied to each emitted output element, taking `n` elements at once and
mapping them in parallel.

To import and use `mapOutEffectPar` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.mapOutEffectPar
```

**Signature**

```ts
export declare const mapOutEffectPar: {
  <OutElem, OutElem1, OutErr1, Env1>(
    f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>,
    n: number
  ): <InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>,
    n: number
  ): Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1>
}
```


# mergeMap

Returns a new channel which creates a new channel for each emitted element
and merges some of them together. Different merge strategies control what
happens if there are more than the given maximum number of channels gets
created. See `Channel.mergeAll`.

To import and use `mergeMap` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.mergeMap
```

**Signature**

```ts
export declare const mergeMap: {
  <OutElem, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(
    f: (outElem: OutElem) => Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,
    options: {
      readonly concurrency: number | "unbounded"
      readonly bufferSize?: number | undefined
      readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined
    }
  ): <InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (outElem: OutElem) => Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,
    options: {
      readonly concurrency: number | "unbounded"
      readonly bufferSize?: number | undefined
      readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined
    }
  ): Channel<OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, unknown, InDone & InDone1, Env | Env1>
}
```


# mergeOut

Returns a new channel which merges a number of channels emitted by this
channel using the back pressuring merge strategy. See `Channel.mergeAll`.

To import and use `mergeOut` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.mergeOut
```

**Signature**

```ts
export declare const mergeOut: {
  (
    n: number
  ): <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<
      Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,
      InElem,
      OutErr,
      InErr,
      OutDone,
      InDone,
      Env
    >
  ) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>
  <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<
      Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>,
      InElem,
      OutErr,
      InErr,
      OutDone,
      InDone,
      Env
    >,
    n: number
  ): Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>
}
```


# mergeOutWith

Returns a new channel which merges a number of channels emitted by this
channel using the back pressuring merge strategy and uses a given function
to merge each completed subchannel's result value. See
`Channel.mergeAll`.

To import and use `mergeOutWith` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.mergeOutWith
```

**Signature**

```ts
export declare const mergeOutWith: {
  <OutDone1>(
    n: number,
    f: (o1: OutDone1, o2: OutDone1) => OutDone1
  ): <OutElem1, InElem1, OutErr1, InErr1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(
    self: Channel<
      Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,
      InElem,
      OutErr,
      InErr,
      OutDone1,
      InDone,
      Env
    >
  ) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone1, InDone & InDone1, Env1 | Env>
  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(
    self: Channel<
      Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,
      InElem,
      OutErr,
      InErr,
      OutDone1,
      InDone,
      Env
    >,
    n: number,
    f: (o1: OutDone1, o2: OutDone1) => OutDone1
  ): Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone1, InDone & InDone1, Env1 | Env>
}
```


# mergeWith

Returns a new channel, which is the merge of this channel and the specified
channel, where the behavior of the returned channel on left or right early
termination is decided by the specified `leftDone` and `rightDone` merge
decisions.

To import and use `mergeWith` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.mergeWith
```

**Signature**

```ts
export declare const mergeWith: {
  <
    OutElem1,
    InElem1,
    OutErr1,
    InErr1,
    OutDone1,
    InDone1,
    Env1,
    OutDone,
    OutErr,
    OutErr2,
    OutDone2,
    OutErr3,
    OutDone3
  >(options: {
    readonly other: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>
    readonly onSelfDone: (
      exit: Exit.Exit<OutDone, OutErr>
    ) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>
    readonly onOtherDone: (
      ex: Exit.Exit<OutDone1, OutErr1>
    ) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>
  }): <Env, InErr, InElem, InDone, OutElem>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<
    OutElem1 | OutElem,
    InElem & InElem1,
    OutErr2 | OutErr3,
    InErr & InErr1,
    OutDone2 | OutDone3,
    InDone & InDone1,
    Env1 | Env
  >
  <
    OutElem,
    InElem,
    OutErr,
    InErr,
    OutDone,
    InDone,
    Env,
    OutElem1,
    InElem1,
    OutErr1,
    InErr1,
    OutDone1,
    InDone1,
    Env1,
    OutErr2,
    OutDone2,
    OutErr3,
    OutDone3
  >(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    options: {
      readonly other: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>
      readonly onSelfDone: (
        exit: Exit.Exit<OutDone, OutErr>
      ) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>
      readonly onOtherDone: (
        ex: Exit.Exit<OutDone1, OutErr1>
      ) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>
    }
  ): Channel<
    OutElem | OutElem1,
    InElem & InElem1,
    OutErr2 | OutErr3,
    InErr & InErr1,
    OutDone2 | OutDone3,
    InDone & InDone1,
    Env | Env1
  >
}
```


# never

Returns a channel that never completes

To import and use `never` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.never
```

**Signature**

```ts
export declare const never: Channel<never, unknown, never, unknown, never, unknown, never>
```


# orDie

Translates channel failure into death of the fiber, making all failures
unchecked and not a part of the type of the channel.

To import and use `orDie` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.orDie
```

**Signature**

```ts
export declare const orDie: {
  <E>(
    error: LazyArg<E>
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    error: LazyArg<E>
  ): Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>
}
```


# orDieWith

Keeps none of the errors, and terminates the fiber with them, using the
specified function to convert the `OutErr` into a defect.

To import and use `orDieWith` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.orDieWith
```

**Signature**

```ts
export declare const orDieWith: {
  <OutErr>(
    f: (e: OutErr) => unknown
  ): <OutElem, InElem, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (e: OutErr) => unknown
  ): Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>
}
```


# orElse

Returns a new channel that will perform the operations of this one, until
failure, and then it will switch over to the operations of the specified
fallback channel.

To import and use `orElse` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.orElse
```

**Signature**

```ts
export declare const orElse: {
  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(
    that: LazyArg<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<
    OutElem1 | OutElem,
    InElem & InElem1,
    OutErr1,
    InErr & InErr1,
    OutDone1 | OutDone,
    InDone & InDone1,
    Env1 | Env
  >
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    that: LazyArg<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>
  ): Channel<
    OutElem | OutElem1,
    InElem & InElem1,
    OutErr1,
    InErr & InErr1,
    OutDone | OutDone1,
    InDone & InDone1,
    Env | Env1
  >
}
```


# pipeTo

Returns a new channel that pipes the output of this channel into the
specified channel. The returned channel has the input type of this channel,
and the output type of the specified channel, terminating with the value of
the specified channel.

To import and use `pipeTo` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.pipeTo
```

**Signature**

```ts
export declare const pipeTo: {
  <OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>(
    that: Channel<OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>
  ): <InElem, InErr, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem2, InElem, OutErr2, InErr, OutDone2, InDone, Env2 | Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    that: Channel<OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>
  ): Channel<OutElem2, InElem, OutErr2, InErr, OutDone2, InDone, Env | Env2>
}
```


# pipeToOrFail

Returns a new channel that pipes the output of this channel into the
specified channel and preserves this channel's failures without providing
them to the other channel for observation.

To import and use `pipeToOrFail` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.pipeToOrFail
```

**Signature**

```ts
export declare const pipeToOrFail: {
  <OutElem2, OutElem, OutErr2, OutDone2, OutDone, Env2>(
    that: Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>
  ): <InElem, OutErr, InErr, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem2, InElem, OutErr2 | OutErr, InErr, OutDone2, InDone, Env2 | Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    that: Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>
  ): Channel<OutElem2, InElem, OutErr | OutErr2, InErr, OutDone2, InDone, Env | Env2>
}
```


# provideContext

Provides the channel with its required context, which eliminates its
dependency on `Env`.

To import and use `provideContext` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.provideContext
```

**Signature**

```ts
export declare const provideContext: {
  <Env>(
    env: Context.Context<Env>
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, never>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    env: Context.Context<Env>
  ): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, never>
}
```


# provideLayer

Provides a layer to the channel, which translates it to another level.

To import and use `provideLayer` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.provideLayer
```

**Signature**

```ts
export declare const provideLayer: {
  <Env, OutErr2, Env0>(
    layer: Layer.Layer<Env, OutErr2, Env0>
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2, Env0>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    layer: Layer.Layer<Env, OutErr2, Env0>
  ): Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0>
}
```


# provideService

Provides the effect with the single service it requires. If the effect
requires more than one service use `provideContext` instead.

To import and use `provideService` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.provideService
```

**Signature**

```ts
export declare const provideService: {
  <I, S>(
    tag: Context.Tag<I, S>,
    service: Types.NoInfer<S>
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, I>>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, I, S>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    tag: Context.Tag<I, S>,
    service: Types.NoInfer<S>
  ): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, I>>
}
```


# provideSomeLayer

Splits the context into two parts, providing one part using the
specified layer and leaving the remainder `Env0`.

To import and use `provideSomeLayer` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.provideSomeLayer
```

**Signature**

```ts
export declare const provideSomeLayer: {
  <R2, OutErr2, Env0>(
    layer: Layer.Layer<R2, OutErr2, Env0>
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, R>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>
  ) => Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, R, R2, OutErr2, Env0>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>,
    layer: Layer.Layer<R2, OutErr2, Env0>
  ): Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>
}
```


# repeated

Creates a channel which repeatedly runs this channel.

To import and use `repeated` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.repeated
```

**Signature**

```ts
export declare const repeated: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
  self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
```


# run

Runs a channel until the end is received.

To import and use `run` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.run
```

**Signature**

```ts
export declare const run: <OutErr, InErr, OutDone, InDone, Env>(
  self: Channel<never, unknown, OutErr, InErr, OutDone, InDone, Env>
) => Effect.Effect<OutDone, OutErr, Env>
```


# runCollect

Run the channel until it finishes with a done value or fails with an error
and collects its emitted output elements.

The channel must not read any input.

To import and use `runCollect` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.runCollect
```

**Signature**

```ts
export declare const runCollect: <OutElem, OutErr, InErr, OutDone, InDone, Env>(
  self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, Env>
) => Effect.Effect<[Chunk.Chunk<OutElem>, OutDone], OutErr, Env>
```


# runDrain

Runs a channel until the end is received.

To import and use `runDrain` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.runDrain
```

**Signature**

```ts
export declare const runDrain: <OutElem, OutErr, InErr, OutDone, InDone, Env>(
  self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, Env>
) => Effect.Effect<OutDone, OutErr, Env>
```


# runScoped

Run the channel until it finishes with a done value or fails with an error.
The channel must not read any input or write any output.

Closing the channel, which includes execution of all the finalizers
attached to the channel will be added to the current scope as a finalizer.

To import and use `runScoped` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.runScoped
```

**Signature**

```ts
export declare const runScoped: <OutErr, InErr, OutDone, InDone, Env>(
  self: Channel<never, unknown, OutErr, InErr, OutDone, InDone, Env>
) => Effect.Effect<OutDone, OutErr, Env | Scope.Scope>
```


# scoped

Use a scoped effect to emit an output element.

To import and use `scoped` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.scoped
```

**Signature**

```ts
export declare const scoped: <A, E, R>(
  effect: Effect.Effect<A, E, R>
) => Channel<A, unknown, E, unknown, unknown, unknown, Exclude<R, Scope.Scope>>
```


# scopedWith

Use a function that receives a scope and returns an effect to emit an output
element. The output element will be the result of the returned effect, if
successful.

To import and use `scopedWith` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.scopedWith
```

**Signature**

```ts
export declare const scopedWith: <A, E, R>(
  f: (scope: Scope.Scope) => Effect.Effect<A, E, R>
) => Channel<A, unknown, E, unknown, unknown, unknown, R>
```


# splitLines

Splits strings on newlines. Handles both Windows newlines (`\r\n`) and UNIX
newlines (`\n`).

To import and use `splitLines` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.splitLines
```

**Signature**

```ts
export declare const splitLines: <Err, Done>() => Channel<
  Chunk.Chunk<string>,
  Chunk.Chunk<string>,
  Err,
  Err,
  Done,
  Done,
  never
>
```


# succeed

Constructs a channel that succeeds immediately with the specified value.

To import and use `succeed` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.succeed
```

**Signature**

```ts
export declare const succeed: <A>(value: A) => Channel<never, unknown, never, unknown, A, unknown>
```


# suspend

Lazily constructs a channel from the given side effect.

To import and use `suspend` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.suspend
```

**Signature**

```ts
export declare const suspend: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
  evaluate: LazyArg<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>>
) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
```


# sync

Constructs a channel that succeeds immediately with the specified lazy value.

To import and use `sync` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.sync
```

**Signature**

```ts
export declare const sync: <OutDone>(
  evaluate: LazyArg<OutDone>
) => Channel<never, unknown, never, unknown, OutDone, unknown>
```


# toPubSub

Converts a `Channel` to a `PubSub`.

To import and use `toPubSub` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.toPubSub
```

**Signature**

```ts
export declare const toPubSub: <Done, Err, Elem>(
  pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>
) => Channel<never, Elem, never, Err, unknown, Done>
```


# toPull

Returns a scoped `Effect` that can be used to repeatedly pull elements from
the constructed `Channel`. The pull effect fails with the channel's failure
in case the channel fails, or returns either the channel's done value or an
emitted element.

To import and use `toPull` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.toPull
```

**Signature**

```ts
export declare const toPull: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
  self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
) => Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Scope.Scope | Env>
```


# toPullIn

Returns an `Effect` that can be used to repeatedly pull elements from the
constructed `Channel` within the provided `Scope`. The pull effect fails
with the channel's failure in case the channel fails, or returns either the
channel's done value or an emitted element.

To import and use `toPullIn` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.toPullIn
```

**Signature**

```ts
export declare const toPullIn: {
  (
    scope: Scope.Scope
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    scope: Scope.Scope
  ): Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env>
}
```


# toQueue

Converts a `Channel` to a `Queue`.

To import and use `toQueue` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.toQueue
```

**Signature**

```ts
export declare const toQueue: <Done, Err, Elem>(
  queue: Queue.Enqueue<Either.Either<Elem, Exit.Exit<Done, Err>>>
) => Channel<never, Elem, never, Err, unknown, Done>
```


# toSink

Converts this channel to a `Sink`.

To import and use `toSink` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.toSink
```

**Signature**

```ts
export declare const toSink: <OutElem, InElem, OutErr, InErr, OutDone, Env>(
  self: Channel<Chunk.Chunk<OutElem>, Chunk.Chunk<InElem>, OutErr, InErr, OutDone, unknown, Env>
) => Sink.Sink<OutDone, InElem, OutElem, OutErr, Env>
```


# toStream

Converts this channel to a `Stream`.

To import and use `toStream` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.toStream
```

**Signature**

```ts
export declare const toStream: <OutElem, OutErr, OutDone, Env>(
  self: Channel<Chunk.Chunk<OutElem>, unknown, OutErr, unknown, OutDone, unknown, Env>
) => Stream.Stream<OutElem, OutErr, Env>
```


# unwrap

Constructs a `Channel` from an effect that will result in a `Channel` if
successful.

To import and use `unwrap` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.unwrap
```

**Signature**

```ts
export declare const unwrap: <OutElem, InElem, OutErr, InErr, OutDone, InDone, R2, E, R>(
  channel: Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R2>, E, R>
) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, R | R2>
```


# unwrapScoped

Constructs a `Channel` from a scoped effect that will result in a
`Channel` if successful.

To import and use `unwrapScoped` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.unwrapScoped
```

**Signature**

```ts
export declare const unwrapScoped: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E, R>(
  self: Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, E, R>
) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, Env | Exclude<R, Scope.Scope>>
```


# unwrapScopedWith

Constructs a `Channel` from a function which receives a `Scope` and returns
an effect that will result in a `Channel` if successful.

To import and use `unwrapScopedWith` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.unwrapScopedWith
```

**Signature**

```ts
export declare const unwrapScopedWith: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E, R>(
  f: (scope: Scope.Scope) => Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, E, R>
) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, R | Env>
```


# updateService

Updates a service in the context of this channel.

To import and use `updateService` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.updateService
```

**Signature**

```ts
export declare const updateService: {
  <I, S>(
    tag: Context.Tag<I, S>,
    f: (resource: Types.NoInfer<S>) => Types.NoInfer<S>
  ): <OutElem, OutErr, InErr, OutDone, InDone, R>(
    self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>
  ) => Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, I | R>
  <OutElem, OutErr, InErr, OutDone, InDone, R, I, S>(
    self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>,
    tag: Context.Tag<I, S>,
    f: (resource: Types.NoInfer<S>) => Types.NoInfer<S>
  ): Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, I | R>
}
```


# withSpan

Wraps the channel with a new span for tracing.

To import and use `withSpan` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.withSpan
```

**Signature**

```ts
export declare const withSpan: {
  (
    name: string,
    options?: Tracer.SpanOptions | undefined
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Tracer.ParentSpan>>
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    name: string,
    options?: Tracer.SpanOptions | undefined
  ): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, Tracer.ParentSpan>>
}
```


# write

Writes a single value to the channel.

To import and use `write` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.write
```

**Signature**

```ts
export declare const write: <OutElem>(out: OutElem) => Channel<OutElem>
```


# writeAll

Writes a sequence of values to the channel.

To import and use `writeAll` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.writeAll
```

**Signature**

```ts
export declare const writeAll: <OutElems extends Array<any>>(...outs: OutElems) => Channel<OutElems[number]>
```


# writeChunk

Writes a `Chunk` of values to the channel.

To import and use `writeChunk` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.writeChunk
```

**Signature**

```ts
export declare const writeChunk: <OutElem>(outs: Chunk.Chunk<OutElem>) => Channel<OutElem>
```


# zip

Returns a new channel that is the sequential composition of this channel
and the specified channel. The returned channel terminates with a tuple of
the terminal values of both channels.

To import and use `zip` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.zip
```

**Signature**

```ts
export declare const zip: {
  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(
    that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,
    options?: { readonly concurrent?: boolean | undefined } | undefined
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<
    OutElem1 | OutElem,
    InElem & InElem1,
    OutErr1 | OutErr,
    InErr & InErr1,
    readonly [OutDone, OutDone1],
    InDone & InDone1,
    Env1 | Env
  >
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,
    options?: { readonly concurrent?: boolean | undefined } | undefined
  ): Channel<
    OutElem | OutElem1,
    InElem & InElem1,
    OutErr | OutErr1,
    InErr & InErr1,
    readonly [OutDone, OutDone1],
    InDone & InDone1,
    Env | Env1
  >
}
```


# zipLeft

Returns a new channel that is the sequential composition of this channel
and the specified channel. The returned channel terminates with the
terminal value of this channel.

To import and use `zipLeft` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.zipLeft
```

**Signature**

```ts
export declare const zipLeft: {
  <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(
    that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,
    options?: { readonly concurrent?: boolean | undefined } | undefined
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<
    OutElem1 | OutElem,
    InElem & InElem1,
    OutErr1 | OutErr,
    InErr & InErr1,
    OutDone,
    InDone & InDone1,
    Env1 | Env
  >
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,
    options?: { readonly concurrent?: boolean | undefined } | undefined
  ): Channel<
    OutElem | OutElem1,
    InElem & InElem1,
    OutErr | OutErr1,
    InErr & InErr1,
    OutDone,
    InDone & InDone1,
    Env | Env1
  >
}
```


# zipRight

Returns a new channel that is the sequential composition of this channel
and the specified channel. The returned channel terminates with the
terminal value of that channel.

To import and use `zipRight` from the "Channel" module:

```ts
import * as Channel from "effect/Channel"
// Can be accessed like this
Channel.zipRight
```

**Signature**

```ts
export declare const zipRight: {
  <Env1, InErr1, InElem1, InDone1, OutErr1, OutElem1, OutDone1>(
    that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,
    options?: { readonly concurrent?: boolean | undefined }
  ): <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<
    OutElem1 | OutElem,
    InElem & InElem1,
    OutErr1 | OutErr,
    InErr & InErr1,
    OutDone1,
    InDone & InDone1,
    Env1 | Env
  >
  <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, Env1, InErr1, InElem1, InDone1, OutErr1, OutElem1, OutDone1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>,
    options?: { readonly concurrent?: boolean | undefined }
  ): Channel<
    OutElem | OutElem1,
    InElem & InElem1,
    OutErr | OutErr1,
    InErr & InErr1,
    OutDone1,
    InDone & InDone1,
    Env | Env1
  >
}
```


# Close

Close the current substream with a given value and pass execution to the
next substream

To import and use `Close` from the "ChildExecutorDecision" module:

```ts
import * as ChildExecutorDecision from "effect/ChildExecutorDecision"
// Can be accessed like this
ChildExecutorDecision.Close
```


# Continue

Continue executing the current substream

To import and use `Continue` from the "ChildExecutorDecision" module:

```ts
import * as ChildExecutorDecision from "effect/ChildExecutorDecision"
// Can be accessed like this
ChildExecutorDecision.Continue
```


# isChildExecutorDecision

Returns `true` if the specified value is a `ChildExecutorDecision`, `false`
otherwise.

To import and use `isChildExecutorDecision` from the "ChildExecutorDecision" module:

```ts
import * as ChildExecutorDecision from "effect/ChildExecutorDecision"
// Can be accessed like this
ChildExecutorDecision.isChildExecutorDecision
```

**Signature**

```ts
export declare const isChildExecutorDecision: (u: unknown) => u is ChildExecutorDecision
```


# isClose

Returns `true` if the specified `ChildExecutorDecision` is a `Close`, `false`
otherwise.

To import and use `isClose` from the "ChildExecutorDecision" module:

```ts
import * as ChildExecutorDecision from "effect/ChildExecutorDecision"
// Can be accessed like this
ChildExecutorDecision.isClose
```

**Signature**

```ts
export declare const isClose: (self: ChildExecutorDecision) => self is Close
```


# isContinue

Returns `true` if the specified `ChildExecutorDecision` is a `Continue`,
`false` otherwise.

To import and use `isContinue` from the "ChildExecutorDecision" module:

```ts
import * as ChildExecutorDecision from "effect/ChildExecutorDecision"
// Can be accessed like this
ChildExecutorDecision.isContinue
```

**Signature**

```ts
export declare const isContinue: (self: ChildExecutorDecision) => self is Continue
```


# isYield

Returns `true` if the specified `ChildExecutorDecision` is a `Yield`, `false`
otherwise.

To import and use `isYield` from the "ChildExecutorDecision" module:

```ts
import * as ChildExecutorDecision from "effect/ChildExecutorDecision"
// Can be accessed like this
ChildExecutorDecision.isYield
```

**Signature**

```ts
export declare const isYield: (self: ChildExecutorDecision) => self is Yield
```


# match

Folds over a `ChildExecutorDecision` to produce a value of type `A`.

To import and use `match` from the "ChildExecutorDecision" module:

```ts
import * as ChildExecutorDecision from "effect/ChildExecutorDecision"
// Can be accessed like this
ChildExecutorDecision.match
```

**Signature**

```ts
export declare const match: {
  <A>(options: {
    readonly onContinue: () => A
    readonly onClose: (value: unknown) => A
    readonly onYield: () => A
  }): (self: ChildExecutorDecision) => A
  <A>(
    self: ChildExecutorDecision,
    options: { readonly onContinue: () => A; readonly onClose: (value: unknown) => A; readonly onYield: () => A }
  ): A
}
```


# Yield

Pass execution to the next substream. This either pulls a new element
from upstream, or yields to an already created active substream.

To import and use `Yield` from the "ChildExecutorDecision" module:

```ts
import * as ChildExecutorDecision from "effect/ChildExecutorDecision"
// Can be accessed like this
ChildExecutorDecision.Yield
```


# append

Appends the specified element to the end of the `Chunk`.

To import and use `append` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.append
```

**Signature**

```ts
export declare const append: {
  <A2>(a: A2): <A>(self: Chunk<A>) => NonEmptyChunk<A2 | A>
  <A, A2>(self: Chunk<A>, a: A2): NonEmptyChunk<A | A2>
}
```


# appendAll

Concatenates two chunks, combining their elements.
If either chunk is non-empty, the result is also a non-empty chunk.

To import and use `appendAll` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.appendAll
```

**Example**

```ts
import { Chunk } from "effect"

assert.deepStrictEqual(Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make("a", "b")), Chunk.toArray), [1, 2, "a", "b"])
```

**Signature**

```ts
export declare const appendAll: {
  <S extends Chunk<any>, T extends Chunk<any>>(
    that: T
  ): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>
  <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>
  <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>
  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>
}
```


# chunksOf

Groups elements in chunks of up to `n` elements.

To import and use `chunksOf` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.chunksOf
```

**Signature**

```ts
export declare const chunksOf: {
  (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>
  <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>
}
```


# compact

Filter out optional values

To import and use `compact` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.compact
```

**Signature**

```ts
export declare const compact: <A>(self: Chunk<Option<A>>) => Chunk<A>
```


# contains

Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.

To import and use `contains` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.contains
```

**Signature**

```ts
export declare const contains: { <A>(a: A): (self: Chunk<A>) => boolean; <A>(self: Chunk<A>, a: A): boolean }
```


# containsWith

Returns a function that checks if a `Chunk` contains a given value using a provided `isEquivalent` function.

To import and use `containsWith` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.containsWith
```

**Signature**

```ts
export declare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => {
  (a: A): (self: Chunk<A>) => boolean
  (self: Chunk<A>, a: A): boolean
}
```


# dedupe

Remove duplicates from an array, keeping the first occurrence of an element.

To import and use `dedupe` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.dedupe
```

**Signature**

```ts
export declare const dedupe: <A>(self: Chunk<A>) => Chunk<A>
```


# dedupeAdjacent

Deduplicates adjacent elements that are identical.

To import and use `dedupeAdjacent` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.dedupeAdjacent
```

**Signature**

```ts
export declare const dedupeAdjacent: <A>(self: Chunk<A>) => Chunk<A>
```


# difference

Creates a `Chunk` of values not included in the other given `Chunk`.
The order and references of result values are determined by the first `Chunk`.

To import and use `difference` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.difference
```

**Signature**

```ts
export declare const difference: {
  <A>(that: Chunk<A>): (self: Chunk<A>) => Chunk<A>
  <A>(self: Chunk<A>, that: Chunk<A>): Chunk<A>
}
```


# differenceWith

Creates a `Chunk` of values not included in the other given `Chunk` using the provided `isEquivalent` function.
The order and references of result values are determined by the first `Chunk`.

To import and use `differenceWith` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.differenceWith
```

**Signature**

```ts
export declare const differenceWith: <A>(isEquivalent: (self: A, that: A) => boolean) => {
  (that: Chunk<A>): (self: Chunk<A>) => Chunk<A>
  (self: Chunk<A>, that: Chunk<A>): Chunk<A>
}
```


# drop

Drops the first up to `n` elements from the chunk

To import and use `drop` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.drop
```

**Signature**

```ts
export declare const drop: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A> }
```


# dropRight

Drops the last `n` elements.

To import and use `dropRight` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.dropRight
```

**Signature**

```ts
export declare const dropRight: {
  (n: number): <A>(self: Chunk<A>) => Chunk<A>
  <A>(self: Chunk<A>, n: number): Chunk<A>
}
```


# dropWhile

Drops all elements so long as the predicate returns true.

To import and use `dropWhile` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.dropWhile
```

**Signature**

```ts
export declare const dropWhile: {
  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>
  <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>
}
```


# every

Check if a predicate holds true for every `Chunk` element.

To import and use `every` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.every
```

**Signature**

```ts
export declare const every: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => self is Chunk<B>
  <A>(predicate: Predicate<A>): (self: Chunk<A>) => boolean
  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): self is Chunk<B>
  <A>(self: Chunk<A>, predicate: Predicate<A>): boolean
}
```


# filter

Returns a filtered and mapped subset of the elements.

To import and use `filter` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.filter
```

**Signature**

```ts
export declare const filter: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>
  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>
  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>
  <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>
}
```


# filterMap

Returns a filtered and mapped subset of the elements.

To import and use `filterMap` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.filterMap
```

**Signature**

```ts
export declare const filterMap: {
  <A, B>(f: (a: A, i: number) => Option<B>): (self: Chunk<A>) => Chunk<B>
  <A, B>(self: Chunk<A>, f: (a: A, i: number) => Option<B>): Chunk<B>
}
```


# filterMapWhile

Transforms all elements of the chunk for as long as the specified function returns some value

To import and use `filterMapWhile` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.filterMapWhile
```

**Signature**

```ts
export declare const filterMapWhile: {
  <A, B>(f: (a: A) => Option<B>): (self: Chunk<A>) => Chunk<B>
  <A, B>(self: Chunk<A>, f: (a: A) => Option<B>): Chunk<B>
}
```


# findFirst

Returns the first element that satisfies the specified
predicate, or `None` if no such element exists.

To import and use `findFirst` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.findFirst
```

**Signature**

```ts
export declare const findFirst: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>
  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>
  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>
  <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>
}
```


# findFirstIndex

Return the first index for which a predicate holds.

To import and use `findFirstIndex` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.findFirstIndex
```

**Signature**

```ts
export declare const findFirstIndex: {
  <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>
  <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>
}
```


# findLast

Find the last element for which a predicate holds.

To import and use `findLast` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.findLast
```

**Signature**

```ts
export declare const findLast: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>
  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>
  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>
  <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>
}
```


# findLastIndex

Return the last index for which a predicate holds.

To import and use `findLastIndex` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.findLastIndex
```

**Signature**

```ts
export declare const findLastIndex: {
  <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>
  <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>
}
```


# flatMap

Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.

To import and use `flatMap` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.flatMap
```

**Signature**

```ts
export declare const flatMap: {
  <S extends Chunk<any>, T extends Chunk<any>>(
    f: (a: Chunk.Infer<S>, i: number) => T
  ): (self: S) => Chunk.AndNonEmpty<S, T, Chunk.Infer<T>>
  <A, B>(self: NonEmptyChunk<A>, f: (a: A, i: number) => NonEmptyChunk<B>): NonEmptyChunk<B>
  <A, B>(self: Chunk<A>, f: (a: A, i: number) => Chunk<B>): Chunk<B>
}
```


# flatten

Flattens a chunk of chunks into a single chunk by concatenating all chunks.

To import and use `flatten` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.flatten
```

**Signature**

```ts
export declare const flatten: <S extends Chunk<Chunk<any>>>(self: S) => Chunk.Flatten<S>
```


# forEach

Iterates over each element of a `Chunk` and applies a function to it.

**Details**

This function processes every element of the given `Chunk`, calling the
provided function `f` on each element. It does not return a new value;
instead, it is primarily used for side effects, such as logging or
accumulating data in an external variable.

To import and use `forEach` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.forEach
```

**Signature**

```ts
export declare const forEach: {
  <A, B>(f: (a: A, index: number) => B): (self: Chunk<A>) => void
  <A, B>(self: Chunk<A>, f: (a: A, index: number) => B): void
}
```


# fromIterable

Creates a new `Chunk` from an iterable collection of values.

To import and use `fromIterable` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.fromIterable
```

**Signature**

```ts
export declare const fromIterable: <A>(self: Iterable<A>) => Chunk<A>
```


# get

This function provides a safe way to read a value at a particular index from a `Chunk`.

To import and use `get` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.get
```

**Signature**

```ts
export declare const get: {
  (index: number): <A>(self: Chunk<A>) => Option<A>
  <A>(self: Chunk<A>, index: number): Option<A>
}
```


# getEquivalence

Compares the two chunks of equal length using the specified function

To import and use `getEquivalence` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.getEquivalence
```

**Signature**

```ts
export declare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<Chunk<A>>
```


# head

Returns the first element of this chunk if it exists.

To import and use `head` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.head
```

**Signature**

```ts
export declare const head: <A>(self: Chunk<A>) => Option<A>
```


# headNonEmpty

Returns the first element of this non empty chunk.

To import and use `headNonEmpty` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.headNonEmpty
```

**Signature**

```ts
export declare const headNonEmpty: <A>(self: NonEmptyChunk<A>) => A
```


# intersection

Creates a Chunk of unique values that are included in all given Chunks.

The order and references of result values are determined by the Chunk.

To import and use `intersection` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.intersection
```

**Signature**

```ts
export declare const intersection: {
  <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A & B>
  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A & B>
}
```


# isChunk

Checks if `u` is a `Chunk<unknown>`

To import and use `isChunk` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.isChunk
```

**Signature**

```ts
export declare const isChunk: { <A>(u: Iterable<A>): u is Chunk<A>; (u: unknown): u is Chunk<unknown> }
```


# isEmpty

Determines if the chunk is empty.

To import and use `isEmpty` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.isEmpty
```

**Signature**

```ts
export declare const isEmpty: <A>(self: Chunk<A>) => boolean
```


# isNonEmpty

Determines if the chunk is not empty.

To import and use `isNonEmpty` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.isNonEmpty
```

**Signature**

```ts
export declare const isNonEmpty: <A>(self: Chunk<A>) => self is NonEmptyChunk<A>
```


# join

Joins the elements together with "sep" in the middle.

To import and use `join` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.join
```

**Signature**

```ts
export declare const join: {
  (sep: string): (self: Chunk<string>) => string
  (self: Chunk<string>, sep: string): string
}
```


# last

Returns the last element of this chunk if it exists.

To import and use `last` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.last
```

**Signature**

```ts
export declare const last: <A>(self: Chunk<A>) => Option<A>
```


# lastNonEmpty

Returns the last element of this non empty chunk.

To import and use `lastNonEmpty` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.lastNonEmpty
```

**Signature**

```ts
export declare const lastNonEmpty: <A>(self: NonEmptyChunk<A>) => A
```


# make

Builds a `NonEmptyChunk` from an non-empty collection of elements.

To import and use `make` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.make
```

**Signature**

```ts
export declare const make: <As extends readonly [any, ...ReadonlyArray<any>]>(...as: As) => NonEmptyChunk<As[number]>
```


# makeBy

Return a Chunk of length n with element i initialized with f(i).

**Note**. `n` is normalized to an integer >= 1.

To import and use `makeBy` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.makeBy
```

**Signature**

```ts
export declare const makeBy: {
  <A>(f: (i: number) => A): (n: number) => NonEmptyChunk<A>
  <A>(n: number, f: (i: number) => A): NonEmptyChunk<A>
}
```


# map

Transforms the elements of a chunk using the specified mapping function.
If the input chunk is non-empty, the resulting chunk will also be non-empty.

To import and use `map` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.map
```

**Example**

```ts
import { Chunk } from "effect"

assert.deepStrictEqual(
  Chunk.map(Chunk.make(1, 2), (n) => n + 1),
  Chunk.make(2, 3)
)
```

**Signature**

```ts
export declare const map: {
  <S extends Chunk<any>, B>(f: (a: Chunk.Infer<S>, i: number) => B): (self: S) => Chunk.With<S, B>
  <A, B>(self: NonEmptyChunk<A>, f: (a: A, i: number) => B): NonEmptyChunk<B>
  <A, B>(self: Chunk<A>, f: (a: A, i: number) => B): Chunk<B>
}
```


# mapAccum

Statefully maps over the chunk, producing new elements of type `B`.

To import and use `mapAccum` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.mapAccum
```

**Signature**

```ts
export declare const mapAccum: {
  <S, A, B>(s: S, f: (s: S, a: A) => readonly [S, B]): (self: Chunk<A>) => [S, Chunk<B>]
  <S, A, B>(self: Chunk<A>, s: S, f: (s: S, a: A) => readonly [S, B]): [S, Chunk<B>]
}
```


# modify

Apply a function to the element at the specified index, creating a new `Chunk`,
or returning the input if the index is out of bounds.

To import and use `modify` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.modify
```

**Signature**

```ts
export declare const modify: {
  <A, B>(i: number, f: (a: A) => B): (self: Chunk<A>) => Chunk<A | B>
  <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Chunk<A | B>
}
```


# of

Builds a `NonEmptyChunk` from a single element.

To import and use `of` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.of
```

**Signature**

```ts
export declare const of: <A>(a: A) => NonEmptyChunk<A>
```


# partition

Separate elements based on a predicate that also exposes the index of the element.

To import and use `partition` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.partition
```

**Signature**

```ts
export declare const partition: {
  <A, B extends A>(
    refinement: (a: NoInfer<A>, i: number) => a is B
  ): (self: Chunk<A>) => [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>]
  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Chunk<A>) => [excluded: Chunk<A>, satisfying: Chunk<A>]
  <A, B extends A>(
    self: Chunk<A>,
    refinement: (a: A, i: number) => a is B
  ): [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>]
  <A>(self: Chunk<A>, predicate: (a: A, i: number) => boolean): [excluded: Chunk<A>, satisfying: Chunk<A>]
}
```


# partitionMap

Partitions the elements of this chunk into two chunks using f.

To import and use `partitionMap` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.partitionMap
```

**Signature**

```ts
export declare const partitionMap: {
  <A, B, C>(f: (a: A) => Either<C, B>): (self: Chunk<A>) => [left: Chunk<B>, right: Chunk<C>]
  <A, B, C>(self: Chunk<A>, f: (a: A) => Either<C, B>): [left: Chunk<B>, right: Chunk<C>]
}
```


# prepend

Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.

To import and use `prepend` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.prepend
```

**Signature**

```ts
export declare const prepend: {
  <B>(elem: B): <A>(self: Chunk<A>) => NonEmptyChunk<B | A>
  <A, B>(self: Chunk<A>, elem: B): NonEmptyChunk<A | B>
}
```


# prependAll

Prepends the specified prefix chunk to the beginning of the specified chunk.
If either chunk is non-empty, the result is also a non-empty chunk.

To import and use `prependAll` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.prependAll
```

**Example**

```ts
import { Chunk } from "effect"

assert.deepStrictEqual(Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make("a", "b")), Chunk.toArray), ["a", "b", 1, 2])
```

**Signature**

```ts
export declare const prependAll: {
  <S extends Chunk<any>, T extends Chunk<any>>(
    that: T
  ): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>
  <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>
  <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>
  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>
}
```


# range

Create a non empty `Chunk` containing a range of integers, including both endpoints.

To import and use `range` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.range
```

**Signature**

```ts
export declare const range: (start: number, end: number) => NonEmptyChunk<number>
```


# remove

Delete the element at the specified index, creating a new `Chunk`.

To import and use `remove` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.remove
```

**Signature**

```ts
export declare const remove: { (i: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, i: number): Chunk<A> }
```


# replace

Change the element at the specified index, creating a new `Chunk`,
or returning the input if the index is out of bounds.

To import and use `replace` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.replace
```

**Signature**

```ts
export declare const replace: {
  <B>(i: number, b: B): <A>(self: Chunk<A>) => Chunk<B | A>
  <A, B>(self: Chunk<A>, i: number, b: B): Chunk<B | A>
}
```


# reverse

Reverses the order of elements in a `Chunk`.
Importantly, if the input chunk is a `NonEmptyChunk`, the reversed chunk will also be a `NonEmptyChunk`.

To import and use `reverse` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.reverse
```

**Example**

```ts
import { Chunk } from "effect"

const numbers = Chunk.make(1, 2, 3)
const reversedNumbers = Chunk.reverse(numbers)
assert.deepStrictEqual(reversedNumbers, Chunk.make(3, 2, 1))
```

**Signature**

```ts
export declare const reverse: <S extends Chunk<any>>(self: S) => Chunk.With<S, Chunk.Infer<S>>
```


# separate

Partitions the elements of this chunk into two chunks.

To import and use `separate` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.separate
```

**Signature**

```ts
export declare const separate: <A, B>(self: Chunk<Either<B, A>>) => [Chunk<A>, Chunk<B>]
```


# size

Retireves the size of the chunk

To import and use `size` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.size
```

**Signature**

```ts
export declare const size: <A>(self: Chunk<A>) => number
```


# some

Check if a predicate holds true for some `Chunk` element.

To import and use `some` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.some
```

**Signature**

```ts
export declare const some: {
  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => self is NonEmptyChunk<A>
  <A>(self: Chunk<A>, predicate: Predicate<A>): self is NonEmptyChunk<A>
}
```


# sort

Sort the elements of a Chunk in increasing order, creating a new Chunk.

To import and use `sort` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.sort
```

**Signature**

```ts
export declare const sort: {
  <B>(O: Order.Order<B>): <A extends B>(self: Chunk<A>) => Chunk<A>
  <A extends B, B>(self: Chunk<A>, O: Order.Order<B>): Chunk<A>
}
```


# split

Splits this chunk into `n` equally sized chunks.

To import and use `split` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.split
```

**Signature**

```ts
export declare const split: {
  (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>
  <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>
}
```


# splitAt

Returns two splits of this chunk at the specified index.

To import and use `splitAt` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.splitAt
```

**Signature**

```ts
export declare const splitAt: {
  (n: number): <A>(self: Chunk<A>) => [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]
  <A>(self: Chunk<A>, n: number): [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]
}
```


# splitNonEmptyAt

Splits a `NonEmptyChunk` into two segments, with the first segment containing a maximum of `n` elements.
The value of `n` must be `>= 1`.

To import and use `splitNonEmptyAt` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.splitNonEmptyAt
```

**Signature**

```ts
export declare const splitNonEmptyAt: {
  (n: number): <A>(self: NonEmptyChunk<A>) => [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]
  <A>(self: NonEmptyChunk<A>, n: number): [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]
}
```


# splitWhere

Splits this chunk on the first element that matches this predicate.
Returns a tuple containing two chunks: the first one is before the match, and the second one is from the match onward.

To import and use `splitWhere` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.splitWhere
```

**Signature**

```ts
export declare const splitWhere: {
  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]
  <A>(self: Chunk<A>, predicate: Predicate<A>): [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]
}
```


# tail

Returns every elements after the first.

To import and use `tail` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.tail
```

**Signature**

```ts
export declare const tail: <A>(self: Chunk<A>) => Option<Chunk<A>>
```


# tailNonEmpty

Returns every elements after the first.

To import and use `tailNonEmpty` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.tailNonEmpty
```

**Signature**

```ts
export declare const tailNonEmpty: <A>(self: NonEmptyChunk<A>) => Chunk<A>
```


# take

Takes the first up to `n` elements from the chunk

To import and use `take` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.take
```

**Signature**

```ts
export declare const take: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A> }
```


# takeRight

Takes the last `n` elements.

To import and use `takeRight` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.takeRight
```

**Signature**

```ts
export declare const takeRight: {
  (n: number): <A>(self: Chunk<A>) => Chunk<A>
  <A>(self: Chunk<A>, n: number): Chunk<A>
}
```


# takeWhile

Takes all elements so long as the predicate returns true.

To import and use `takeWhile` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.takeWhile
```

**Signature**

```ts
export declare const takeWhile: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>
  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>
  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>
  <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>
}
```


# toArray

Converts a `Chunk` into an `Array`. If the provided `Chunk` is non-empty
(`NonEmptyChunk`), the function will return a `NonEmptyArray`, ensuring the
non-empty property is preserved.

To import and use `toArray` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.toArray
```

**Signature**

```ts
export declare const toArray: <S extends Chunk<any>>(
  self: S
) => S extends NonEmptyChunk<any> ? RA.NonEmptyArray<Chunk.Infer<S>> : Array<Chunk.Infer<S>>
```


# toReadonlyArray

Converts a `Chunk` into a `ReadonlyArray`. If the provided `Chunk` is
non-empty (`NonEmptyChunk`), the function will return a
`NonEmptyReadonlyArray`, ensuring the non-empty property is preserved.

To import and use `toReadonlyArray` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.toReadonlyArray
```

**Signature**

```ts
export declare const toReadonlyArray: <S extends Chunk<any>>(
  self: S
) => S extends NonEmptyChunk<any> ? RA.NonEmptyReadonlyArray<Chunk.Infer<S>> : ReadonlyArray<Chunk.Infer<S>>
```


# union

Creates a Chunks of unique values, in order, from all given Chunks.

To import and use `union` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.union
```

**Signature**

```ts
export declare const union: {
  <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A | B>
  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>
}
```


# unsafeFromArray

Wraps an array into a chunk without copying, unsafe on mutable arrays

To import and use `unsafeFromArray` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.unsafeFromArray
```

**Signature**

```ts
export declare const unsafeFromArray: <A>(self: ReadonlyArray<A>) => Chunk<A>
```


# unsafeFromNonEmptyArray

Wraps an array into a chunk without copying, unsafe on mutable arrays

To import and use `unsafeFromNonEmptyArray` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.unsafeFromNonEmptyArray
```

**Signature**

```ts
export declare const unsafeFromNonEmptyArray: <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyChunk<A>
```


# unsafeGet

Gets an element unsafely, will throw on out of bounds

To import and use `unsafeGet` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.unsafeGet
```

**Signature**

```ts
export declare const unsafeGet: { (index: number): <A>(self: Chunk<A>) => A; <A>(self: Chunk<A>, index: number): A }
```


# unsafeHead

Returns the first element of this chunk.

It will throw an error if the chunk is empty.

To import and use `unsafeHead` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.unsafeHead
```

**Signature**

```ts
export declare const unsafeHead: <A>(self: Chunk<A>) => A
```


# unsafeLast

Returns the last element of this chunk.

It will throw an error if the chunk is empty.

To import and use `unsafeLast` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.unsafeLast
```

**Signature**

```ts
export declare const unsafeLast: <A>(self: Chunk<A>) => A
```


# unzip

Takes a `Chunk` of pairs and return two corresponding `Chunk`s.

Note: The function is reverse of `zip`.

To import and use `unzip` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.unzip
```

**Signature**

```ts
export declare const unzip: <A, B>(self: Chunk<readonly [A, B]>) => [Chunk<A>, Chunk<B>]
```


# zip

Zips this chunk pointwise with the specified chunk.

To import and use `zip` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.zip
```

**Signature**

```ts
export declare const zip: {
  <B>(that: Chunk<B>): <A>(self: Chunk<A>) => Chunk<[A, B]>
  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<[A, B]>
}
```


# zipWith

Zips this chunk pointwise with the specified chunk using the specified combiner.

To import and use `zipWith` from the "Chunk" module:

```ts
import * as Chunk from "effect/Chunk"
// Can be accessed like this
Chunk.zipWith
```

**Signature**

```ts
export declare const zipWith: {
  <A, B, C>(that: Chunk<B>, f: (a: A, b: B) => C): (self: Chunk<A>) => Chunk<C>
  <A, B, C>(self: Chunk<A>, that: Chunk<B>, f: (a: A, b: B) => C): Chunk<C>
}
```


# CliApp

A `CliApp<A>` is a complete description of a command-line application.

To import and use `CliApp` from the "CliApp" module:

```ts
import * as CliApp from "@effect/cli/CliApp"
// Can be accessed like this
CliApp.CliApp
```


# CliConfig

Represents how arguments from the command-line are to be parsed.

To import and use `CliConfig` from the "CliConfig" module:

```ts
import * as CliConfig from "@effect/cli/CliConfig"
// Can be accessed like this
CliConfig.CliConfig
```


# layer

A layer that directly interfaces with the navigator.clipboard api

To import and use `layer` from the "Clipboard" module:

```ts
import * as Clipboard from "@effect/platform-browser/Clipboard"
// Can be accessed like this
Clipboard.layer
```

**Signature**

```ts
export declare const layer: Layer.Layer<Clipboard, never, never>
```


# Clock

Represents a time-based clock which provides functionality related to time
and scheduling.

To import and use `Clock` from the "Clock" module:

```ts
import * as Clock from "effect/Clock"
// Can be accessed like this
Clock.Clock
```


# CommandInput

Configures the pipe that is established between the parent and child
processes' `stdin` stream.

Defaults to "pipe"

To import and use `CommandInput` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.CommandInput
```


# CommandOutput

Configures the pipes that are established between the parent and child
processes `stderr` and `stdout` streams.

Defaults to "pipe"

To import and use `CommandOutput` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.CommandOutput
```


# env

Specify the environment variables that will be used when running this command.

To import and use `env` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.env
```

**Signature**

```ts
export declare const env: {
  (environment: Record<string, string | undefined>): (self: Command) => Command
  (self: Command, environment: Record<string, string | undefined>): Command
}
```


# exitCode

Returns the exit code of the command after the process has completed
execution.

To import and use `exitCode` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.exitCode
```

**Signature**

```ts
export declare const exitCode: (self: Command) => Effect<ExitCode, PlatformError, CommandExecutor>
```


# feed

Feed a string to standard input (default encoding of UTF-8).

To import and use `feed` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.feed
```

**Signature**

```ts
export declare const feed: { (input: string): (self: Command) => Command; (self: Command, input: string): Command }
```


# flatten

Flatten this command to a non-empty array of standard commands.

For a `StandardCommand`, this simply returns a `1` element array
For a `PipedCommand`, all commands in the pipe will be extracted out into
a array from left to right

To import and use `flatten` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.flatten
```

**Signature**

```ts
export declare const flatten: (self: Command) => NonEmptyReadonlyArray<StandardCommand>
```


# isCommand

Returns `true` if the specified value is a `Command`, otherwise returns
`false`.

To import and use `isCommand` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.isCommand
```

**Signature**

```ts
export declare const isCommand: (u: unknown) => u is Command
```


# lines

Runs the command returning the output as an array of lines with the specified
encoding.

To import and use `lines` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.lines
```

**Signature**

```ts
export declare const lines: (
  command: Command,
  encoding?: string
) => Effect<Array<string>, PlatformError, CommandExecutor>
```


# make

Create a command with the specified process name and an optional list of
arguments.

To import and use `make` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.make
```

**Signature**

```ts
export declare const make: (command: string, ...args: Array<string>) => Command
```


# pipeTo

Pipe one command to another command from left to right.

Conceptually, the equivalent of piping one shell command to another:

```sh
command1 | command2
```

To import and use `pipeTo` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.pipeTo
```

**Signature**

```ts
export declare const pipeTo: { (into: Command): (self: Command) => Command; (self: Command, into: Command): Command }
```


# runInShell

Allows for specifying whether or not a `Command` should be run inside a
shell.

To import and use `runInShell` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.runInShell
```

**Signature**

```ts
export declare const runInShell: {
  (shell: string | boolean): (self: Command) => Command
  (self: Command, shell: string | boolean): Command
}
```


# start

Start running the command and return a handle to the running process.

To import and use `start` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.start
```

**Signature**

```ts
export declare const start: (command: Command) => Effect<Process, PlatformError, CommandExecutor | Scope>
```


# stderr

Specify the standard error stream for a command.

To import and use `stderr` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.stderr
```

**Signature**

```ts
export declare const stderr: {
  (stderr: Command.Output): (self: Command) => Command
  (self: Command, stderr: Command.Output): Command
}
```


# stdin

Specify the standard input stream for a command.

To import and use `stdin` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.stdin
```

**Signature**

```ts
export declare const stdin: {
  (stdin: Command.Input): (self: Command) => Command
  (self: Command, stdin: Command.Input): Command
}
```


# stdout

Specify the standard output stream for a command.

To import and use `stdout` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.stdout
```

**Signature**

```ts
export declare const stdout: {
  (stdout: Command.Output): (self: Command) => Command
  (self: Command, stdout: Command.Output): Command
}
```


# stream

Start running the command and return the output as a `Stream`.

To import and use `stream` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.stream
```

**Signature**

```ts
export declare const stream: (command: Command) => Stream<Uint8Array, PlatformError, CommandExecutor>
```


# streamLines

Runs the command returning the output as an stream of lines with the
specified encoding.

To import and use `streamLines` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.streamLines
```

**Signature**

```ts
export declare const streamLines: (
  command: Command,
  encoding?: string
) => Stream<string, PlatformError, CommandExecutor>
```


# string

Runs the command returning the entire output as a string with the
specified encoding.

If an encoding is not specified, the encoding will default to `utf-8`.

To import and use `string` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.string
```

**Signature**

```ts
export declare const string: {
  (encoding?: string): (command: Command) => Effect<string, PlatformError, CommandExecutor>
  (command: Command, encoding?: string): Effect<string, PlatformError, CommandExecutor>
}
```


# workingDirectory

Set the working directory that will be used when this command will be run.

For piped commands, the working directory of each command will be set to the
specified working directory.

To import and use `workingDirectory` from the "Command" module:

```ts
import * as Command from "@effect/platform/Command"
// Can be accessed like this
Command.workingDirectory
```

**Signature**

```ts
export declare const workingDirectory: {
  (cwd: string): (self: Command) => Command
  (self: Command, cwd: string): Command
}
```


# Command

A `Command` represents a command in a command-line application.

Every command-line application will have at least one command: the
application itself. Other command-line applications may support multiple
commands.

To import and use `Command` from the "CommandDescriptor" module:

```ts
import * as CommandDescriptor from "@effect/cli/CommandDescriptor"
// Can be accessed like this
CommandDescriptor.Command
```


# all

Constructs a config from a tuple / struct / arguments of configs.

To import and use `all` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.all
```

**Signature**

```ts
export declare const all: <const Arg extends Iterable<Config<any>> | Record<string, Config<any>>>(
  arg: Arg
) => Config<
  [Arg] extends [ReadonlyArray<Config<any>>]
    ? { -readonly [K in keyof Arg]: [Arg[K]] extends [Config<infer A>] ? A : never }
    : [Arg] extends [Iterable<Config<infer A>>]
      ? Array<A>
      : [Arg] extends [Record<string, Config<any>>]
        ? { -readonly [K in keyof Arg]: [Arg[K]] extends [Config<infer A>] ? A : never }
        : never
>
```


# array

Constructs a config for an array of values.

To import and use `array` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.array
```

**Signature**

```ts
export declare const array: <A>(config: Config<A>, name?: string) => Config<Array<A>>
```


# boolean

Constructs a config for a boolean value.

To import and use `boolean` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.boolean
```

**Signature**

```ts
export declare const boolean: (name?: string) => Config<boolean>
```


# chunk

Constructs a config for a sequence of values.

To import and use `chunk` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.chunk
```

**Signature**

```ts
export declare const chunk: <A>(config: Config<A>, name?: string) => Config<Chunk.Chunk<A>>
```


# Config

A `Config` describes the structure of some configuration data.

To import and use `Config` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.Config
```


# date

Constructs a config for a date value.

To import and use `date` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.date
```

**Signature**

```ts
export declare const date: (name?: string) => Config<Date>
```


# duration

Constructs a config for a duration value.

To import and use `duration` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.duration
```

**Signature**

```ts
export declare const duration: (name?: string) => Config<Duration.Duration>
```


# fail

Constructs a config that fails with the specified message.

To import and use `fail` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.fail
```

**Signature**

```ts
export declare const fail: (message: string) => Config<never>
```


# hashMap

Constructs a config for a sequence of values.

To import and use `hashMap` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.hashMap
```

**Signature**

```ts
export declare const hashMap: <A>(config: Config<A>, name?: string) => Config<HashMap.HashMap<string, A>>
```


# hashSet

Constructs a config for a sequence of values.

To import and use `hashSet` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.hashSet
```

**Signature**

```ts
export declare const hashSet: <A>(config: Config<A>, name?: string) => Config<HashSet.HashSet<A>>
```


# integer

Constructs a config for a integer value.

To import and use `integer` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.integer
```

**Signature**

```ts
export declare const integer: (name?: string) => Config<number>
```


# isConfig

This function returns `true` if the specified value is an `Config` value,
`false` otherwise.

This function can be useful for checking the type of a value before
attempting to operate on it as an `Config` value. For example, you could
use `isConfig` to check the type of a value before using it as an
argument to a function that expects an `Config` value.

To import and use `isConfig` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.isConfig
```

**Signature**

```ts
export declare const isConfig: (u: unknown) => u is Config<unknown>
```


# literal

Constructs a config for a literal value.

To import and use `literal` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.literal
```

**Example**

```ts
import { Config } from "effect"

const config = Config.literal("http", "https")("PROTOCOL")
```

**Signature**

```ts
export declare const literal: <Literals extends ReadonlyArray<LiteralValue>>(
  ...literals: Literals
) => (name?: string) => Config<Literals[number]>
```


# logLevel

Constructs a config for a `LogLevel` value.

To import and use `logLevel` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.logLevel
```

**Signature**

```ts
export declare const logLevel: (name?: string) => Config<LogLevel.LogLevel>
```


# map

Returns a config whose structure is the same as this one, but which produces
a different value, constructed using the specified function.

To import and use `map` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.map
```

**Signature**

```ts
export declare const map: {
  <A, B>(f: (a: A) => B): (self: Config<A>) => Config<B>
  <A, B>(self: Config<A>, f: (a: A) => B): Config<B>
}
```


# mapAttempt

Returns a config whose structure is the same as this one, but which may
produce a different value, constructed using the specified function, which
may throw exceptions that will be translated into validation errors.

To import and use `mapAttempt` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.mapAttempt
```

**Signature**

```ts
export declare const mapAttempt: {
  <A, B>(f: (a: A) => B): (self: Config<A>) => Config<B>
  <A, B>(self: Config<A>, f: (a: A) => B): Config<B>
}
```


# mapOrFail

Returns a new config whose structure is the samea as this one, but which
may produce a different value, constructed using the specified fallible
function.

To import and use `mapOrFail` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.mapOrFail
```

**Signature**

```ts
export declare const mapOrFail: {
  <A, B>(f: (a: A) => Either.Either<B, ConfigError.ConfigError>): (self: Config<A>) => Config<B>
  <A, B>(self: Config<A>, f: (a: A) => Either.Either<B, ConfigError.ConfigError>): Config<B>
}
```


# nested

Returns a config that has this configuration nested as a property of the
specified name.

To import and use `nested` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.nested
```

**Signature**

```ts
export declare const nested: {
  (name: string): <A>(self: Config<A>) => Config<A>
  <A>(self: Config<A>, name: string): Config<A>
}
```


# nonEmptyString

Constructs a config for a non-empty string value.

To import and use `nonEmptyString` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.nonEmptyString
```

**Signature**

```ts
export declare const nonEmptyString: (name?: string) => Config<string>
```


# number

Constructs a config for a float value.

To import and use `number` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.number
```

**Signature**

```ts
export declare const number: (name?: string) => Config<number>
```


# option

Returns an optional version of this config, which will be `None` if the
data is missing from configuration, and `Some` otherwise.

To import and use `option` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.option
```

**Signature**

```ts
export declare const option: <A>(self: Config<A>) => Config<Option.Option<A>>
```


# orElse

Returns a config whose structure is preferentially described by this
config, but which falls back to the specified config if there is an issue
reading from this config.

To import and use `orElse` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.orElse
```

**Signature**

```ts
export declare const orElse: {
  <A2>(that: LazyArg<Config<A2>>): <A>(self: Config<A>) => Config<A2 | A>
  <A, A2>(self: Config<A>, that: LazyArg<Config<A2>>): Config<A | A2>
}
```


# orElseIf

Returns configuration which reads from this configuration, but which falls
back to the specified configuration if reading from this configuration
fails with an error satisfying the specified predicate.

To import and use `orElseIf` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.orElseIf
```

**Signature**

```ts
export declare const orElseIf: {
  <A2>(options: {
    readonly if: Predicate<ConfigError.ConfigError>
    readonly orElse: LazyArg<Config<A2>>
  }): <A>(self: Config<A>) => Config<A>
  <A, A2>(
    self: Config<A>,
    options: { readonly if: Predicate<ConfigError.ConfigError>; readonly orElse: LazyArg<Config<A2>> }
  ): Config<A>
}
```


# primitive

Constructs a new primitive config.

To import and use `primitive` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.primitive
```

**Signature**

```ts
export declare const primitive: <A>(
  description: string,
  parse: (text: string) => Either.Either<A, ConfigError.ConfigError>
) => Config<A>
```


# redacted

Constructs a config for a redacted value.

To import and use `redacted` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.redacted
```

**Signature**

```ts
export declare const redacted: {
  (name?: string): Config<Redacted.Redacted>
  <A>(config: Config<A>): Config<Redacted.Redacted<A>>
}
```


# repeat

Returns a config that describes a sequence of values, each of which has the
structure of this config.

To import and use `repeat` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.repeat
```

**Signature**

```ts
export declare const repeat: <A>(self: Config<A>) => Config<Array<A>>
```


# secret

Constructs a config for a secret value.

To import and use `secret` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.secret
```

**Signature**

```ts
export declare const secret: (name?: string) => Config<Secret.Secret>
```


# string

Constructs a config for a string value.

To import and use `string` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.string
```

**Signature**

```ts
export declare const string: (name?: string) => Config<string>
```


# succeed

Constructs a config which contains the specified value.

To import and use `succeed` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.succeed
```

**Signature**

```ts
export declare const succeed: <A>(value: A) => Config<A>
```


# suspend

Lazily constructs a config.

To import and use `suspend` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.suspend
```

**Signature**

```ts
export declare const suspend: <A>(config: LazyArg<Config<A>>) => Config<A>
```


# sync

Constructs a config which contains the specified lazy value.

To import and use `sync` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.sync
```

**Signature**

```ts
export declare const sync: <A>(value: LazyArg<A>) => Config<A>
```


# unwrap

Constructs a config from some configuration wrapped with the `Wrap<A>` utility type.

For example:

```
import { Config, unwrap } from "./Config"

interface Options { key: string }

const makeConfig = (config: Config.Wrap<Options>): Config<Options> => unwrap(config)
```

To import and use `unwrap` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.unwrap
```

**Signature**

```ts
export declare const unwrap: <A>(wrapped: Config.Wrap<A>) => Config<A>
```


# url

Constructs a config for a URL value.

To import and use `url` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.url
```

**Signature**

```ts
export declare const url: (name?: string) => Config<URL>
```


# validate

Returns a config that describes the same structure as this one, but which
performs validation during loading.

To import and use `validate` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.validate
```

**Signature**

```ts
export declare const validate: {
  <A, B extends A>(options: {
    readonly message: string
    readonly validation: Refinement<A, B>
  }): (self: Config<A>) => Config<B>
  <A>(options: { readonly message: string; readonly validation: Predicate<A> }): (self: Config<A>) => Config<A>
  <A, B extends A>(
    self: Config<A>,
    options: { readonly message: string; readonly validation: Refinement<A, B> }
  ): Config<B>
  <A>(self: Config<A>, options: { readonly message: string; readonly validation: Predicate<A> }): Config<A>
}
```


# withDefault

Returns a config that describes the same structure as this one, but has the
specified default value in case the information cannot be found.

To import and use `withDefault` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.withDefault
```

**Signature**

```ts
export declare const withDefault: {
  <const A2>(def: A2): <A>(self: Config<A>) => Config<A2 | A>
  <A, const A2>(self: Config<A>, def: A2): Config<A | A2>
}
```


# withDescription

Adds a description to this configuration, which is intended for humans.

To import and use `withDescription` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.withDescription
```

**Signature**

```ts
export declare const withDescription: {
  (description: string): <A>(self: Config<A>) => Config<A>
  <A>(self: Config<A>, description: string): Config<A>
}
```


# zip

Returns a config that is the composition of this config and the specified
config.

To import and use `zip` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.zip
```

**Signature**

```ts
export declare const zip: {
  <B>(that: Config<B>): <A>(self: Config<A>) => Config<[A, B]>
  <A, B>(self: Config<A>, that: Config<B>): Config<[A, B]>
}
```


# zipWith

Returns a config that is the composes this config and the specified config
using the provided function.

To import and use `zipWith` from the "Config" module:

```ts
import * as Config from "effect/Config"
// Can be accessed like this
Config.zipWith
```

**Signature**

```ts
export declare const zipWith: {
  <B, A, C>(that: Config<B>, f: (a: A, b: B) => C): (self: Config<A>) => Config<C>
  <A, B, C>(self: Config<A>, that: Config<B>, f: (a: A, b: B) => C): Config<C>
}
```


# ConfigError

The possible ways that loading configuration data may fail.

To import and use `ConfigError` from the "ConfigError" module:

```ts
import * as ConfigError from "effect/ConfigError"
// Can be accessed like this
ConfigError.ConfigError
```


# isAnd

Returns `true` if the specified `ConfigError` is an `And`, `false` otherwise.

To import and use `isAnd` from the "ConfigError" module:

```ts
import * as ConfigError from "effect/ConfigError"
// Can be accessed like this
ConfigError.isAnd
```

**Signature**

```ts
export declare const isAnd: (self: ConfigError) => self is And
```


# isConfigError

Returns `true` if the specified value is a `ConfigError`, `false` otherwise.

To import and use `isConfigError` from the "ConfigError" module:

```ts
import * as ConfigError from "effect/ConfigError"
// Can be accessed like this
ConfigError.isConfigError
```

**Signature**

```ts
export declare const isConfigError: (u: unknown) => u is ConfigError
```


# isInvalidData

Returns `true` if the specified `ConfigError` is an `InvalidData`, `false`
otherwise.

To import and use `isInvalidData` from the "ConfigError" module:

```ts
import * as ConfigError from "effect/ConfigError"
// Can be accessed like this
ConfigError.isInvalidData
```

**Signature**

```ts
export declare const isInvalidData: (self: ConfigError) => self is InvalidData
```


# isMissingData

Returns `true` if the specified `ConfigError` is an `MissingData`, `false`
otherwise.

To import and use `isMissingData` from the "ConfigError" module:

```ts
import * as ConfigError from "effect/ConfigError"
// Can be accessed like this
ConfigError.isMissingData
```

**Signature**

```ts
export declare const isMissingData: (self: ConfigError) => self is MissingData
```


# isMissingDataOnly

Returns `true` if the specified `ConfigError` contains only `MissingData` errors, `false` otherwise.

To import and use `isMissingDataOnly` from the "ConfigError" module:

```ts
import * as ConfigError from "effect/ConfigError"
// Can be accessed like this
ConfigError.isMissingDataOnly
```

**Signature**

```ts
export declare const isMissingDataOnly: (self: ConfigError) => boolean
```


# isOr

Returns `true` if the specified `ConfigError` is an `Or`, `false` otherwise.

To import and use `isOr` from the "ConfigError" module:

```ts
import * as ConfigError from "effect/ConfigError"
// Can be accessed like this
ConfigError.isOr
```

**Signature**

```ts
export declare const isOr: (self: ConfigError) => self is Or
```


# isSourceUnavailable

Returns `true` if the specified `ConfigError` is a `SourceUnavailable`,
`false` otherwise.

To import and use `isSourceUnavailable` from the "ConfigError" module:

```ts
import * as ConfigError from "effect/ConfigError"
// Can be accessed like this
ConfigError.isSourceUnavailable
```

**Signature**

```ts
export declare const isSourceUnavailable: (self: ConfigError) => self is SourceUnavailable
```


# isUnsupported

Returns `true` if the specified `ConfigError` is an `Unsupported`, `false`
otherwise.

To import and use `isUnsupported` from the "ConfigError" module:

```ts
import * as ConfigError from "effect/ConfigError"
// Can be accessed like this
ConfigError.isUnsupported
```

**Signature**

```ts
export declare const isUnsupported: (self: ConfigError) => self is Unsupported
```


# ConfigProvider

A ConfigProvider is a service that provides configuration given a description
of the structure of that configuration.

To import and use `ConfigProvider` from the "ConfigProvider" module:

```ts
import * as ConfigProvider from "effect/ConfigProvider"
// Can be accessed like this
ConfigProvider.ConfigProvider
```


# constantCase

Returns a new config provider that will automatically convert all property
names to constant case. This can be utilized to adapt the names of
configuration properties from the default naming convention of camel case
to the naming convention of a config provider.

To import and use `constantCase` from the "ConfigProvider" module:

```ts
import * as ConfigProvider from "effect/ConfigProvider"
// Can be accessed like this
ConfigProvider.constantCase
```

**Signature**

```ts
export declare const constantCase: (self: ConfigProvider) => ConfigProvider
```


# fromEnv

A config provider that loads configuration from context variables,
using the default System service.

To import and use `fromEnv` from the "ConfigProvider" module:

```ts
import * as ConfigProvider from "effect/ConfigProvider"
// Can be accessed like this
ConfigProvider.fromEnv
```

**Signature**

```ts
export declare const fromEnv: (config?: ConfigProvider.FromEnvConfig) => ConfigProvider
```


# fromFlat

Constructs a new `ConfigProvider` from a key/value (flat) provider, where
nesting is embedded into the string keys.

To import and use `fromFlat` from the "ConfigProvider" module:

```ts
import * as ConfigProvider from "effect/ConfigProvider"
// Can be accessed like this
ConfigProvider.fromFlat
```

**Signature**

```ts
export declare const fromFlat: (flat: ConfigProvider.Flat) => ConfigProvider
```


# fromJson

Constructs a new `ConfigProvider` from a JSON object.

To import and use `fromJson` from the "ConfigProvider" module:

```ts
import * as ConfigProvider from "effect/ConfigProvider"
// Can be accessed like this
ConfigProvider.fromJson
```

**Signature**

```ts
export declare const fromJson: (json: unknown) => ConfigProvider
```


# fromMap

Constructs a ConfigProvider using a map and the specified delimiter string,
which determines how to split the keys in the map into path segments.

To import and use `fromMap` from the "ConfigProvider" module:

```ts
import * as ConfigProvider from "effect/ConfigProvider"
// Can be accessed like this
ConfigProvider.fromMap
```

**Signature**

```ts
export declare const fromMap: (
  map: Map<string, string>,
  config?: Partial<ConfigProvider.FromMapConfig>
) => ConfigProvider
```


# kebabCase

Returns a new config provider that will automatically convert all property
names to kebab case. This can be utilized to adapt the names of
configuration properties from the default naming convention of camel case
to the naming convention of a config provider.

To import and use `kebabCase` from the "ConfigProvider" module:

```ts
import * as ConfigProvider from "effect/ConfigProvider"
// Can be accessed like this
ConfigProvider.kebabCase
```

**Signature**

```ts
export declare const kebabCase: (self: ConfigProvider) => ConfigProvider
```


# lowerCase

Returns a new config provider that will automatically convert all property
names to lower case. This can be utilized to adapt the names of
configuration properties from the default naming convention of camel case
to the naming convention of a config provider.

To import and use `lowerCase` from the "ConfigProvider" module:

```ts
import * as ConfigProvider from "effect/ConfigProvider"
// Can be accessed like this
ConfigProvider.lowerCase
```

**Signature**

```ts
export declare const lowerCase: (self: ConfigProvider) => ConfigProvider
```


# make

Creates a new config provider.

To import and use `make` from the "ConfigProvider" module:

```ts
import * as ConfigProvider from "effect/ConfigProvider"
// Can be accessed like this
ConfigProvider.make
```

**Signature**

```ts
export declare const make: (options: {
  readonly load: <A>(config: Config.Config<A>) => Effect.Effect<A, ConfigError.ConfigError>
  readonly flattened: ConfigProvider.Flat
}) => ConfigProvider
```


# makeFlat

Creates a new flat config provider.

To import and use `makeFlat` from the "ConfigProvider" module:

```ts
import * as ConfigProvider from "effect/ConfigProvider"
// Can be accessed like this
ConfigProvider.makeFlat
```

**Signature**

```ts
export declare const makeFlat: (options: {
  readonly load: <A>(
    path: ReadonlyArray<string>,
    config: Config.Config.Primitive<A>,
    split: boolean
  ) => Effect.Effect<Array<A>, ConfigError.ConfigError>
  readonly enumerateChildren: (
    path: ReadonlyArray<string>
  ) => Effect.Effect<HashSet.HashSet<string>, ConfigError.ConfigError>
  readonly patch: PathPatch.PathPatch
}) => ConfigProvider.Flat
```


# mapInputPath

Returns a new config provider that will automatically tranform all path
configuration names with the specified function. This can be utilized to
adapt the names of configuration properties from one naming convention to
another.

To import and use `mapInputPath` from the "ConfigProvider" module:

```ts
import * as ConfigProvider from "effect/ConfigProvider"
// Can be accessed like this
ConfigProvider.mapInputPath
```

**Signature**

```ts
export declare const mapInputPath: {
  (f: (path: string) => string): (self: ConfigProvider) => ConfigProvider
  (self: ConfigProvider, f: (path: string) => string): ConfigProvider
}
```


# nested

Returns a new config provider that will automatically nest all
configuration under the specified property name. This can be utilized to
aggregate separate configuration sources that are all required to load a
single configuration value.

To import and use `nested` from the "ConfigProvider" module:

```ts
import * as ConfigProvider from "effect/ConfigProvider"
// Can be accessed like this
ConfigProvider.nested
```

**Signature**

```ts
export declare const nested: {
  (name: string): (self: ConfigProvider) => ConfigProvider
  (self: ConfigProvider, name: string): ConfigProvider
}
```


# orElse

Returns a new config provider that preferentially loads configuration data
from this one, but which will fall back to the specified alternate provider
if there are any issues loading the configuration from this provider.

To import and use `orElse` from the "ConfigProvider" module:

```ts
import * as ConfigProvider from "effect/ConfigProvider"
// Can be accessed like this
ConfigProvider.orElse
```

**Signature**

```ts
export declare const orElse: {
  (that: LazyArg<ConfigProvider>): (self: ConfigProvider) => ConfigProvider
  (self: ConfigProvider, that: LazyArg<ConfigProvider>): ConfigProvider
}
```


# snakeCase

Returns a new config provider that will automatically convert all property
names to upper case. This can be utilized to adapt the names of
configuration properties from the default naming convention of camel case
to the naming convention of a config provider.

To import and use `snakeCase` from the "ConfigProvider" module:

```ts
import * as ConfigProvider from "effect/ConfigProvider"
// Can be accessed like this
ConfigProvider.snakeCase
```

**Signature**

```ts
export declare const snakeCase: (self: ConfigProvider) => ConfigProvider
```


# unnested

Returns a new config provider that will automatically un-nest all
configuration under the specified property name. This can be utilized to
de-aggregate separate configuration sources that are all required to load a
single configuration value.

To import and use `unnested` from the "ConfigProvider" module:

```ts
import * as ConfigProvider from "effect/ConfigProvider"
// Can be accessed like this
ConfigProvider.unnested
```

**Signature**

```ts
export declare const unnested: {
  (name: string): (self: ConfigProvider) => ConfigProvider
  (self: ConfigProvider, name: string): ConfigProvider
}
```


# upperCase

Returns a new config provider that will automatically convert all property
names to upper case. This can be utilized to adapt the names of
configuration properties from the default naming convention of camel case
to the naming convention of a config provider.

To import and use `upperCase` from the "ConfigProvider" module:

```ts
import * as ConfigProvider from "effect/ConfigProvider"
// Can be accessed like this
ConfigProvider.upperCase
```

**Signature**

```ts
export declare const upperCase: (self: ConfigProvider) => ConfigProvider
```


# within

Returns a new config provider that transforms the config provider with the
specified function within the specified path.

To import and use `within` from the "ConfigProvider" module:

```ts
import * as ConfigProvider from "effect/ConfigProvider"
// Can be accessed like this
ConfigProvider.within
```

**Signature**

```ts
export declare const within: {
  (path: ReadonlyArray<string>, f: (self: ConfigProvider) => ConfigProvider): (self: ConfigProvider) => ConfigProvider
  (self: ConfigProvider, path: ReadonlyArray<string>, f: (self: ConfigProvider) => ConfigProvider): ConfigProvider
}
```


# PathPatch

Represents a description of how to modify the path to a configuration
value.

To import and use `PathPatch` from the "ConfigProviderPathPatch" module:

```ts
import * as ConfigProviderPathPatch from "effect/ConfigProviderPathPatch"
// Can be accessed like this
ConfigProviderPathPatch.PathPatch
```


# add

Adds a service to a given `Context`.

To import and use `add` from the "Context" module:

```ts
import * as Context from "effect/Context"
// Can be accessed like this
Context.add
```

**Example**

```ts
import { Context, pipe } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const someContext = Context.make(Port, { PORT: 8080 })

const Services = pipe(someContext, Context.add(Timeout, { TIMEOUT: 5000 }))

assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
```

**Signature**

```ts
export declare const add: {
  <T extends Tag<any, any>>(
    tag: T,
    service: Tag.Service<T>
  ): <Services>(self: Context<Services>) => Context<Services | Tag.Identifier<T>>
  <Services, T extends Tag<any, any>>(
    self: Context<Services>,
    tag: T,
    service: Tag.Service<T>
  ): Context<Services | Tag.Identifier<T>>
}
```


# empty

Returns an empty `Context`.

To import and use `empty` from the "Context" module:

```ts
import * as Context from "effect/Context"
// Can be accessed like this
Context.empty
```

**Example**

```ts
import { Context } from "effect"

assert.strictEqual(Context.isContext(Context.empty()), true)
```

**Signature**

```ts
export declare const empty: () => Context<never>
```


# GenericTag

Creates a new `Tag` instance with an optional key parameter.

To import and use `GenericTag` from the "Context" module:

```ts
import * as Context from "effect/Context"
// Can be accessed like this
Context.GenericTag
```

**Example**

```ts
import { Context } from "effect"

assert.strictEqual(Context.GenericTag("PORT").key === Context.GenericTag("PORT").key, true)
```

**Signature**

```ts
export declare const GenericTag: <Identifier, Service = Identifier>(key: string) => Tag<Identifier, Service>
```


# get

Get a service from the context that corresponds to the given tag.

To import and use `get` from the "Context" module:

```ts
import * as Context from "effect/Context"
// Can be accessed like this
Context.get
```

**Example**

```ts
import { pipe, Context } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const Services = pipe(Context.make(Port, { PORT: 8080 }), Context.add(Timeout, { TIMEOUT: 5000 }))

assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
```

**Signature**

```ts
export declare const get: {
  <I, S>(tag: Reference<I, S>): <Services>(self: Context<Services>) => S
  <Services, T extends ValidTagsById<Services>>(tag: T): (self: Context<Services>) => Tag.Service<T>
  <Services, I, S>(self: Context<Services>, tag: Reference<I, S>): S
  <Services, T extends ValidTagsById<Services>>(self: Context<Services>, tag: T): Tag.Service<T>
}
```


# getOption

Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not
found, the `Option` object will be `None`.

To import and use `getOption` from the "Context" module:

```ts
import * as Context from "effect/Context"
// Can be accessed like this
Context.getOption
```

**Example**

```ts
import { Context, Option } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const Services = Context.make(Port, { PORT: 8080 })

assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))
assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())
```

**Signature**

```ts
export declare const getOption: {
  <S, I>(tag: Tag<I, S>): <Services>(self: Context<Services>) => Option<S>
  <Services, S, I>(self: Context<Services>, tag: Tag<I, S>): Option<S>
}
```


# getOrElse

Get a service from the context that corresponds to the given tag, or
use the fallback value.

To import and use `getOrElse` from the "Context" module:

```ts
import * as Context from "effect/Context"
// Can be accessed like this
Context.getOrElse
```

**Signature**

```ts
export declare const getOrElse: {
  <S, I, B>(tag: Tag<I, S>, orElse: LazyArg<B>): <Services>(self: Context<Services>) => S | B
  <Services, S, I, B>(self: Context<Services>, tag: Tag<I, S>, orElse: LazyArg<B>): S | B
}
```


# isContext

Checks if the provided argument is a `Context`.

To import and use `isContext` from the "Context" module:

```ts
import * as Context from "effect/Context"
// Can be accessed like this
Context.isContext
```

**Example**

```ts
import { Context } from "effect"

assert.strictEqual(Context.isContext(Context.empty()), true)
```

**Signature**

```ts
export declare const isContext: (input: unknown) => input is Context<never>
```


# isReference

Checks if the provided argument is a `Reference`.

To import and use `isReference` from the "Context" module:

```ts
import * as Context from "effect/Context"
// Can be accessed like this
Context.isReference
```

**Signature**

```ts
export declare const isReference: (u: unknown) => u is Reference<any, any>
```


# isTag

Checks if the provided argument is a `Tag`.

To import and use `isTag` from the "Context" module:

```ts
import * as Context from "effect/Context"
// Can be accessed like this
Context.isTag
```

**Example**

```ts
import { Context } from "effect"

assert.strictEqual(Context.isTag(Context.GenericTag("Tag")), true)
```

**Signature**

```ts
export declare const isTag: (input: unknown) => input is Tag<any, any>
```


# make

Creates a new `Context` with a single service associated to the tag.

To import and use `make` from the "Context" module:

```ts
import * as Context from "effect/Context"
// Can be accessed like this
Context.make
```

**Example**

```ts
import { Context } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")

const Services = Context.make(Port, { PORT: 8080 })

assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
```

**Signature**

```ts
export declare const make: <T extends Tag<any, any>>(tag: T, service: Tag.Service<T>) => Context<Tag.Identifier<T>>
```


# merge

Merges two `Context`s, returning a new `Context` containing the services of both.

To import and use `merge` from the "Context" module:

```ts
import * as Context from "effect/Context"
// Can be accessed like this
Context.merge
```

**Example**

```ts
import { Context } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const firstContext = Context.make(Port, { PORT: 8080 })
const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })

const Services = Context.merge(firstContext, secondContext)

assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
```

**Signature**

```ts
export declare const merge: {
  <R1>(that: Context<R1>): <Services>(self: Context<Services>) => Context<R1 | Services>
  <Services, R1>(self: Context<Services>, that: Context<R1>): Context<Services | R1>
}
```


# mergeAll

Merges any number of `Context`s, returning a new `Context` containing the services of all.

To import and use `mergeAll` from the "Context" module:

```ts
import * as Context from "effect/Context"
// Can be accessed like this
Context.mergeAll
```

**Example**

```ts
import { Context } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
const Host = Context.GenericTag<{ HOST: string }>("Host")

const firstContext = Context.make(Port, { PORT: 8080 })
const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })
const thirdContext = Context.make(Host, { HOST: "localhost" })

const Services = Context.mergeAll(firstContext, secondContext, thirdContext)

assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
assert.deepStrictEqual(Context.get(Services, Host), { HOST: "localhost" })
```

**Signature**

```ts
export declare const mergeAll: <T extends Array<unknown>>(
  ...ctxs_0: { [K in keyof T]: Context<T[K]> }
) => Context<T[number]>
```


# pick

Returns a new `Context` that contains only the specified services.

To import and use `pick` from the "Context" module:

```ts
import * as Context from "effect/Context"
// Can be accessed like this
Context.pick
```

**Example**

```ts
import { pipe, Context, Option } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const someContext = pipe(Context.make(Port, { PORT: 8080 }), Context.add(Timeout, { TIMEOUT: 5000 }))

const Services = pipe(someContext, Context.pick(Port))

assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))
assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())
```

**Signature**

```ts
export declare const pick: <Services, S extends Array<ValidTagsById<Services>>>(
  ...tags: S
) => (self: Context<Services>) => Context<{ [k in keyof S]: Tag.Identifier<S[k]> }[number]>
```


# Reference

Creates a context tag with a default value.

**Details**

`Context.Reference` allows you to create a tag that can hold a value. You can
provide a default value for the service, which will automatically be used
when the context is accessed, or override it with a custom implementation
when needed.

To import and use `Reference` from the "Context" module:

```ts
import * as Context from "effect/Context"
// Can be accessed like this
Context.Reference
```

**Example**

```ts
// Title: Declaring a Tag with a default value
import { Context, Effect } from "effect"

class SpecialNumber extends Context.Reference<SpecialNumber>()("SpecialNumber", { defaultValue: () => 2048 }) {}

//       Effect<void, never, never>
//      
const program = Effect.gen(function* () {
  const specialNumber = yield* SpecialNumber
  console.log(`The special number is ${specialNumber}`)
})

// No need to provide the SpecialNumber implementation
Effect.runPromise(program)
// Output: The special number is 2048
```

**Example**

```ts
// Title: Overriding the default value
import { Context, Effect } from "effect"

class SpecialNumber extends Context.Reference<SpecialNumber>()("SpecialNumber", { defaultValue: () => 2048 }) {}

const program = Effect.gen(function* () {
  const specialNumber = yield* SpecialNumber
  console.log(`The special number is ${specialNumber}`)
})

Effect.runPromise(program.pipe(Effect.provideService(SpecialNumber, -1)))
// Output: The special number is -1
```

**Signature**

```ts
export declare const Reference: <Self>() => <const Id extends string, Service>(
  id: Id,
  options: { readonly defaultValue: () => Service }
) => ReferenceClass<Self, Id, Service>
```


# unsafeGet

Get a service from the context that corresponds to the given tag.
This function is unsafe because if the tag is not present in the context, a runtime error will be thrown.

For a safer version see {@link getOption}.

To import and use `unsafeGet` from the "Context" module:

```ts
import * as Context from "effect/Context"
// Can be accessed like this
Context.unsafeGet
```

**Example**

```ts
import { Context } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const Services = Context.make(Port, { PORT: 8080 })

assert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })
assert.throws(() => Context.unsafeGet(Services, Timeout))
```

**Signature**

```ts
export declare const unsafeGet: {
  <S, I>(tag: Tag<I, S>): <Services>(self: Context<Services>) => S
  <Services, S, I>(self: Context<Services>, tag: Tag<I, S>): S
}
```


# contramapComposition

Composing two contravariant functors yields a Covariant functor.

Returns a default binary `map` composition.

To import and use `contramapComposition` from the "Contravariant" module:

```ts
import * as Contravariant from "@effect/typeclass/Contravariant"
// Can be accessed like this
Contravariant.contramapComposition
```

**Signature**

```ts
export declare const contramapComposition: <F extends TypeLambda, G extends TypeLambda>(
  F: Contravariant<F>,
  G: Contravariant<G>
) => <FR, FO, FE, GR, GO, GE, A, B>(
  self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>,
  f: (a: A) => B
) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>
```


# imap

Returns a default `imap` implementation.

To import and use `imap` from the "Contravariant" module:

```ts
import * as Contravariant from "@effect/typeclass/Contravariant"
// Can be accessed like this
Contravariant.imap
```

**Signature**

```ts
export declare const imap: <F extends TypeLambda>(
  contramap: <R, O, E, A, B>(self: Kind<F, R, O, E, A>, f: (b: B) => A) => Kind<F, R, O, E, B>
) => Invariant<F>["imap"]
```


# empty

An empty Cookies object

To import and use `empty` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.empty
```

**Signature**

```ts
export declare const empty: Cookies
```


# fromIterable

Create a Cookies object from an Iterable

To import and use `fromIterable` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.fromIterable
```

**Signature**

```ts
export declare const fromIterable: (cookies: Iterable<Cookie>) => Cookies
```


# fromReadonlyRecord

Create a Cookies object from an Iterable

To import and use `fromReadonlyRecord` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.fromReadonlyRecord
```

**Signature**

```ts
export declare const fromReadonlyRecord: (cookies: Record.ReadonlyRecord<string, Cookie>) => Cookies
```


# fromSetCookie

Create a Cookies object from a set of Set-Cookie headers

To import and use `fromSetCookie` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.fromSetCookie
```

**Signature**

```ts
export declare const fromSetCookie: (headers: Iterable<string> | string) => Cookies
```


# get

Get a cookie from a Cookies object

To import and use `get` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.get
```

**Signature**

```ts
export declare const get: {
  (name: string): (self: Cookies) => Option.Option<Cookie>
  (self: Cookies, name: string): Option.Option<Cookie>
}
```


# getValue

Get a cookie from a Cookies object

To import and use `getValue` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.getValue
```

**Signature**

```ts
export declare const getValue: {
  (name: string): (self: Cookies) => Option.Option<string>
  (self: Cookies, name: string): Option.Option<string>
}
```


# makeCookie

Create a new cookie

To import and use `makeCookie` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.makeCookie
```

**Signature**

```ts
export declare function makeCookie(
  name: string,
  value: string,
  options?: Cookie["options"] | undefined
): Either.Either<Cookie, CookiesError>
```


# merge

Combine two Cookies objects, removing duplicates from the first

To import and use `merge` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.merge
```

**Signature**

```ts
export declare const merge: { (that: Cookies): (self: Cookies) => Cookies; (self: Cookies, that: Cookies): Cookies }
```


# parseHeader

Parse a cookie header into a record of key-value pairs

Adapted from https://github.com/fastify/fastify-cookie under MIT License

To import and use `parseHeader` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.parseHeader
```

**Signature**

```ts
export declare function parseHeader(header: string): Record<string, string>
```


# remove

Remove a cookie by name

To import and use `remove` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.remove
```

**Signature**

```ts
export declare const remove: { (name: string): (self: Cookies) => Cookies; (self: Cookies, name: string): Cookies }
```


# serializeCookie

Serialize a cookie into a string

Adapted from https://github.com/fastify/fastify-cookie under MIT License

To import and use `serializeCookie` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.serializeCookie
```

**Signature**

```ts
export declare function serializeCookie(self: Cookie): string
```


# set

Add a cookie to a Cookies object

To import and use `set` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.set
```

**Signature**

```ts
export declare const set: {
  (name: string, value: string, options?: Cookie["options"]): (self: Cookies) => Either.Either<Cookies, CookiesError>
  (self: Cookies, name: string, value: string, options?: Cookie["options"]): Either.Either<Cookies, CookiesError>
}
```


# setAll

Add multiple cookies to a Cookies object

To import and use `setAll` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.setAll
```

**Signature**

```ts
export declare const setAll: {
  (
    cookies: Iterable<readonly [name: string, value: string, options?: Cookie["options"]]>
  ): (self: Cookies) => Either.Either<Cookies, CookiesError>
  (
    self: Cookies,
    cookies: Iterable<readonly [name: string, value: string, options?: Cookie["options"]]>
  ): Either.Either<Cookies, CookiesError>
}
```


# setAllCookie

Add multiple cookies to a Cookies object

To import and use `setAllCookie` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.setAllCookie
```

**Signature**

```ts
export declare const setAllCookie: {
  (cookies: Iterable<Cookie>): (self: Cookies) => Cookies
  (self: Cookies, cookies: Iterable<Cookie>): Cookies
}
```


# setCookie

Add a cookie to a Cookies object

To import and use `setCookie` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.setCookie
```

**Signature**

```ts
export declare const setCookie: {
  (cookie: Cookie): (self: Cookies) => Cookies
  (self: Cookies, cookie: Cookie): Cookies
}
```


# toCookieHeader

Serialize a Cookies object into a Cookie header

To import and use `toCookieHeader` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.toCookieHeader
```

**Signature**

```ts
export declare const toCookieHeader: (self: Cookies) => string
```


# toRecord

To record

To import and use `toRecord` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.toRecord
```

**Signature**

```ts
export declare const toRecord: (self: Cookies) => Record<string, string>
```


# toSetCookieHeaders

Serialize a Cookies object into Headers object containing one or more Set-Cookie headers

To import and use `toSetCookieHeaders` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.toSetCookieHeaders
```

**Signature**

```ts
export declare const toSetCookieHeaders: (self: Cookies) => Array<string>
```


# unsafeMakeCookie

Create a new cookie, throwing an error if invalid

To import and use `unsafeMakeCookie` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.unsafeMakeCookie
```

**Signature**

```ts
export declare const unsafeMakeCookie: (name: string, value: string, options?: Cookie["options"] | undefined) => Cookie
```


# unsafeSet

Add a cookie to a Cookies object

To import and use `unsafeSet` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.unsafeSet
```

**Signature**

```ts
export declare const unsafeSet: {
  (name: string, value: string, options?: Cookie["options"]): (self: Cookies) => Cookies
  (self: Cookies, name: string, value: string, options?: Cookie["options"]): Cookies
}
```


# unsafeSetAll

Add multiple cookies to a Cookies object, throwing an error if invalid

To import and use `unsafeSetAll` from the "Cookies" module:

```ts
import * as Cookies from "@effect/platform/Cookies"
// Can be accessed like this
Cookies.unsafeSetAll
```

**Signature**

```ts
export declare const unsafeSetAll: {
  (cookies: Iterable<readonly [name: string, value: string, options?: Cookie["options"]]>): (self: Cookies) => Cookies
  (self: Cookies, cookies: Iterable<readonly [name: string, value: string, options?: Cookie["options"]]>): Cookies
}
```


# imap

Returns a default `imap` implementation.

To import and use `imap` from the "Covariant" module:

```ts
import * as Covariant from "@effect/typeclass/Covariant"
// Can be accessed like this
Covariant.imap
```

**Signature**

```ts
export declare const imap: <F extends TypeLambda>(
  map: <R, O, E, A, B>(self: Kind<F, R, O, E, A>, f: (a: A) => B) => Kind<F, R, O, E, B>
) => Invariant<F>["imap"]
```


# mapComposition

Returns a default `map` composition.

To import and use `mapComposition` from the "Covariant" module:

```ts
import * as Covariant from "@effect/typeclass/Covariant"
// Can be accessed like this
Covariant.mapComposition
```

**Signature**

```ts
export declare const mapComposition: <F extends TypeLambda, G extends TypeLambda>(
  F: Covariant<F>,
  G: Covariant<G>
) => <FR, FO, FE, GR, GO, GE, A, B>(
  self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>,
  f: (a: A) => B
) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>
```


# equals

Checks if two `Cron`s are equal.

To import and use `equals` from the "Cron" module:

```ts
import * as Cron from "effect/Cron"
// Can be accessed like this
Cron.equals
```

**Signature**

```ts
export declare const equals: { (that: Cron): (self: Cron) => boolean; (self: Cron, that: Cron): boolean }
```


# isCron

Checks if a given value is a `Cron` instance.

To import and use `isCron` from the "Cron" module:

```ts
import * as Cron from "effect/Cron"
// Can be accessed like this
Cron.isCron
```

**Signature**

```ts
export declare const isCron: (u: unknown) => u is Cron
```


# isParseError

Returns `true` if the specified value is an `ParseError`, `false` otherwise.

To import and use `isParseError` from the "Cron" module:

```ts
import * as Cron from "effect/Cron"
// Can be accessed like this
Cron.isParseError
```

**Signature**

```ts
export declare const isParseError: (u: unknown) => u is ParseError
```


# make

Creates a `Cron` instance.

To import and use `make` from the "Cron" module:

```ts
import * as Cron from "effect/Cron"
// Can be accessed like this
Cron.make
```

**Signature**

```ts
export declare const make: (values: {
  readonly seconds?: Iterable<number> | undefined
  readonly minutes: Iterable<number>
  readonly hours: Iterable<number>
  readonly days: Iterable<number>
  readonly months: Iterable<number>
  readonly weekdays: Iterable<number>
  readonly tz?: DateTime.TimeZone | undefined
}) => Cron
```


# match

Checks if a given `Date` falls within an active `Cron` time window.

To import and use `match` from the "Cron" module:

```ts
import * as Cron from "effect/Cron"
// Can be accessed like this
Cron.match
```

**Example**

```ts
import { Cron, Either } from "effect"

const cron = Either.getOrThrow(Cron.parse("0 4 8-14 * *"))
assert.deepStrictEqual(Cron.match(cron, new Date("2021-01-08 04:00:00")), true)
assert.deepStrictEqual(Cron.match(cron, new Date("2021-01-08 05:00:00")), false)
```

**Signature**

```ts
export declare const match: (cron: Cron, date: DateTime.DateTime.Input) => boolean
```


# next

Returns the next run `Date` for the given `Cron` instance.

Uses the current time as a starting point if no value is provided for `now`.

To import and use `next` from the "Cron" module:

```ts
import * as Cron from "effect/Cron"
// Can be accessed like this
Cron.next
```

**Example**

```ts
import { Cron, Either } from "effect"

const after = new Date("2021-01-01 00:00:00")
const cron = Either.getOrThrow(Cron.parse("0 4 8-14 * *"))
assert.deepStrictEqual(Cron.next(cron, after), new Date("2021-01-08 04:00:00"))
```

**Signature**

```ts
export declare const next: (cron: Cron, now?: DateTime.DateTime.Input) => Date
```


# parse

Parses a cron expression into a `Cron` instance.

To import and use `parse` from the "Cron" module:

```ts
import * as Cron from "effect/Cron"
// Can be accessed like this
Cron.parse
```

**Example**

```ts
import { Cron, Either } from "effect"

// At 04:00 on every day-of-month from 8 through 14.
assert.deepStrictEqual(
  Cron.parse("0 0 4 8-14 * *"),
  Either.right(
    Cron.make({
      seconds: [0],
      minutes: [0],
      hours: [4],
      days: [8, 9, 10, 11, 12, 13, 14],
      months: [],
      weekdays: []
    })
  )
)
```

**Signature**

```ts
export declare const parse: (cron: string, tz?: DateTime.TimeZone | string) => Either.Either<Cron, ParseError>
```


# ParseError

Represents a checked exception which occurs when decoding fails.

To import and use `ParseError` from the "Cron" module:

```ts
import * as Cron from "effect/Cron"
// Can be accessed like this
Cron.ParseError
```


# sequence

Returns an `IterableIterator` which yields the sequence of `Date`s that match the `Cron` instance.

To import and use `sequence` from the "Cron" module:

```ts
import * as Cron from "effect/Cron"
// Can be accessed like this
Cron.sequence
```

**Signature**

```ts
export declare const sequence: (cron: Cron, now?: DateTime.DateTime.Input) => IterableIterator<Date>
```


# unsafeParse

Parses a cron expression into a `Cron` instance.

**Details**

This function takes a cron expression as a string and attempts to parse it
into a `Cron` instance. If the expression is valid, the resulting `Cron`
instance will represent the schedule defined by the cron expression.

If the expression is invalid, the function throws a `ParseError`.

You can optionally provide a time zone (`tz`) to interpret the cron
expression in a specific time zone. If no time zone is provided, the cron
expression will use the default time zone.

To import and use `unsafeParse` from the "Cron" module:

```ts
import * as Cron from "effect/Cron"
// Can be accessed like this
Cron.unsafeParse
```

**Example**

```ts
import { Cron } from "effect"

// At 04:00 on every day-of-month from 8 through 14.
console.log(Cron.unsafeParse("0 4 8-14 * *"))
// Output:
// {
//   _id: 'Cron',
//   tz: { _id: 'Option', _tag: 'None' },
//   seconds: [ 0 ],
//   minutes: [ 0 ],
//   hours: [ 4 ],
//   days: [
//      8,  9, 10, 11,
//     12, 13, 14
//   ],
//   months: [],
//   weekdays: []
// }
```

**Signature**

```ts
export declare const unsafeParse: (cron: string, tz?: DateTime.TimeZone | string) => Cron
```


# MonoidMultiply

`bigint` monoid under multiplication.

The `empty` value is `1n`.

To import and use `MonoidMultiply` from the "BigInt" module:

```ts
import * as BigInt from "@effect/typeclass/data/BigInt"
// Can be accessed like this
BigInt.MonoidMultiply
```

**Example**

```ts
import { MonoidMultiply } from "@effect/typeclass/data/BigInt"

assert.deepStrictEqual(MonoidMultiply.combine(2n, 3n), 6n)
assert.deepStrictEqual(MonoidMultiply.combine(2n, MonoidMultiply.empty), 2n)
```

**Signature**

```ts
export declare const MonoidMultiply: monoid.Monoid<bigint>
```


# MonoidSum

`bigint` monoid under addition.

The `empty` value is `0n`.

To import and use `MonoidSum` from the "BigInt" module:

```ts
import * as BigInt from "@effect/typeclass/data/BigInt"
// Can be accessed like this
BigInt.MonoidSum
```

**Example**

```ts
import { MonoidSum } from "@effect/typeclass/data/BigInt"

assert.deepStrictEqual(MonoidSum.combine(2n, 3n), 5n)
assert.deepStrictEqual(MonoidSum.combine(2n, MonoidSum.empty), 2n)
```

**Signature**

```ts
export declare const MonoidSum: monoid.Monoid<bigint>
```


# SemigroupMax

A `Semigroup` that uses the maximum between two values.

To import and use `SemigroupMax` from the "BigInt" module:

```ts
import * as BigInt from "@effect/typeclass/data/BigInt"
// Can be accessed like this
BigInt.SemigroupMax
```

**Example**

```ts
import { SemigroupMax } from "@effect/typeclass/data/BigInt"

assert.deepStrictEqual(SemigroupMax.combine(2n, 3n), 3n)
```

**Signature**

```ts
export declare const SemigroupMax: semigroup.Semigroup<bigint>
```


# SemigroupMin

A `Semigroup` that uses the minimum between two values.

To import and use `SemigroupMin` from the "BigInt" module:

```ts
import * as BigInt from "@effect/typeclass/data/BigInt"
// Can be accessed like this
BigInt.SemigroupMin
```

**Example**

```ts
import { SemigroupMin } from "@effect/typeclass/data/BigInt"

assert.deepStrictEqual(SemigroupMin.combine(2n, 3n), 2n)
```

**Signature**

```ts
export declare const SemigroupMin: semigroup.Semigroup<bigint>
```


# SemigroupMultiply

`bigint` semigroup under multiplication.

To import and use `SemigroupMultiply` from the "BigInt" module:

```ts
import * as BigInt from "@effect/typeclass/data/BigInt"
// Can be accessed like this
BigInt.SemigroupMultiply
```

**Signature**

```ts
export declare const SemigroupMultiply: semigroup.Semigroup<bigint>
```


# SemigroupSum

`bigint` semigroup under addition.

To import and use `SemigroupSum` from the "BigInt" module:

```ts
import * as BigInt from "@effect/typeclass/data/BigInt"
// Can be accessed like this
BigInt.SemigroupSum
```

**Example**

```ts
import { SemigroupSum } from "@effect/typeclass/data/BigInt"

assert.deepStrictEqual(SemigroupSum.combine(2n, 3n), 5n)
```

**Signature**

```ts
export declare const SemigroupSum: semigroup.Semigroup<bigint>
```


# MonoidEqv

`boolean` monoid under equivalence.

The `empty` value is `true`.

To import and use `MonoidEqv` from the "Boolean" module:

```ts
import * as Boolean from "@effect/typeclass/data/Boolean"
// Can be accessed like this
Boolean.MonoidEqv
```

**Signature**

```ts
export declare const MonoidEqv: monoid.Monoid<boolean>
```


# MonoidEvery

`boolean` monoid under conjunction, see also {@link SemigroupEvery}.

The `empty` value is `true`.

To import and use `MonoidEvery` from the "Boolean" module:

```ts
import * as Boolean from "@effect/typeclass/data/Boolean"
// Can be accessed like this
Boolean.MonoidEvery
```

**Signature**

```ts
export declare const MonoidEvery: monoid.Monoid<boolean>
```


# MonoidSome

`boolean` monoid under disjunction, see also {@link SemigroupSome}.

The `empty` value is `false`.

To import and use `MonoidSome` from the "Boolean" module:

```ts
import * as Boolean from "@effect/typeclass/data/Boolean"
// Can be accessed like this
Boolean.MonoidSome
```

**Signature**

```ts
export declare const MonoidSome: monoid.Monoid<boolean>
```


# MonoidXor

`boolean` monoid under exclusive disjunction, see also {@link SemigroupXor}.

The `empty` value is `false`.

To import and use `MonoidXor` from the "Boolean" module:

```ts
import * as Boolean from "@effect/typeclass/data/Boolean"
// Can be accessed like this
Boolean.MonoidXor
```

**Signature**

```ts
export declare const MonoidXor: monoid.Monoid<boolean>
```


# SemigroupEqv

`boolean` semigroup under equivalence.

To import and use `SemigroupEqv` from the "Boolean" module:

```ts
import * as Boolean from "@effect/typeclass/data/Boolean"
// Can be accessed like this
Boolean.SemigroupEqv
```

**Example**

```ts
import { SemigroupEqv } from "@effect/typeclass/data/Boolean"

assert.deepStrictEqual(SemigroupEqv.combine(true, true), true)
assert.deepStrictEqual(SemigroupEqv.combine(true, false), false)
assert.deepStrictEqual(SemigroupEqv.combine(false, true), false)
assert.deepStrictEqual(SemigroupEqv.combine(false, false), true)
```

**Signature**

```ts
export declare const SemigroupEqv: semigroup.Semigroup<boolean>
```


# SemigroupEvery

`boolean` semigroup under conjunction.

To import and use `SemigroupEvery` from the "Boolean" module:

```ts
import * as Boolean from "@effect/typeclass/data/Boolean"
// Can be accessed like this
Boolean.SemigroupEvery
```

**Example**

```ts
import { SemigroupEvery } from "@effect/typeclass/data/Boolean"

assert.deepStrictEqual(SemigroupEvery.combine(true, true), true)
assert.deepStrictEqual(SemigroupEvery.combine(true, false), false)
assert.deepStrictEqual(SemigroupEvery.combine(false, true), false)
assert.deepStrictEqual(SemigroupEvery.combine(false, false), false)
```

**Signature**

```ts
export declare const SemigroupEvery: semigroup.Semigroup<boolean>
```


# SemigroupSome

`boolean` semigroup under disjunction.

To import and use `SemigroupSome` from the "Boolean" module:

```ts
import * as Boolean from "@effect/typeclass/data/Boolean"
// Can be accessed like this
Boolean.SemigroupSome
```

**Example**

```ts
import { SemigroupSome } from "@effect/typeclass/data/Boolean"

assert.deepStrictEqual(SemigroupSome.combine(true, true), true)
assert.deepStrictEqual(SemigroupSome.combine(true, false), true)
assert.deepStrictEqual(SemigroupSome.combine(false, true), true)
assert.deepStrictEqual(SemigroupSome.combine(false, false), false)
```

**Signature**

```ts
export declare const SemigroupSome: semigroup.Semigroup<boolean>
```


# SemigroupXor

`boolean` semigroup under exclusive disjunction.

To import and use `SemigroupXor` from the "Boolean" module:

```ts
import * as Boolean from "@effect/typeclass/data/Boolean"
// Can be accessed like this
Boolean.SemigroupXor
```

**Example**

```ts
import { SemigroupXor } from "@effect/typeclass/data/Boolean"

assert.deepStrictEqual(SemigroupXor.combine(true, true), false)
assert.deepStrictEqual(SemigroupXor.combine(true, false), true)
assert.deepStrictEqual(SemigroupXor.combine(false, true), true)
assert.deepStrictEqual(SemigroupXor.combine(false, false), false)
```

**Signature**

```ts
export declare const SemigroupXor: semigroup.Semigroup<boolean>
```


# case

Provides a constructor for the specified `Case`.

To import and use `case` from the "Data" module:

```ts
import * as Data from "effect/Data"
// Can be accessed like this
Data.case
```

**Example**

```ts
import { Data, Equal } from "effect"

interface Person {
  readonly name: string
}

// Creating a constructor for the specified Case
const Person = Data.case<Person>()

// Creating instances of Person
const mike1 = Person({ name: "Mike" })
const mike2 = Person({ name: "Mike" })
const john = Person({ name: "John" })

// Checking equality
assert.deepStrictEqual(Equal.equals(mike1, mike2), true)
assert.deepStrictEqual(Equal.equals(mike1, john), false)
```


# Class

Provides a constructor for a Case Class.

To import and use `Class` from the "Data" module:

```ts
import * as Data from "effect/Data"
// Can be accessed like this
Data.Class
```

**Example**

```ts
import { Data, Equal } from "effect"

class Person extends Data.Class<{ readonly name: string }> {}

// Creating instances of Person
const mike1 = new Person({ name: "Mike" })
const mike2 = new Person({ name: "Mike" })
const john = new Person({ name: "John" })

// Checking equality
assert.deepStrictEqual(Equal.equals(mike1, mike2), true)
assert.deepStrictEqual(Equal.equals(mike1, john), false)
```

**Signature**

```ts
export declare const Class: new <A extends Record<string, any> = {}>(
  args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A]: A[P] }
) => Readonly<A>
```


# Error

Provides a constructor for a Case Class.

To import and use `Error` from the "Data" module:

```ts
import * as Data from "effect/Data"
// Can be accessed like this
Data.Error
```

**Signature**

```ts
export declare const Error: new <A extends Record<string, any> = {}>(
  args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A]: A[P] }
) => Cause.YieldableError & Readonly<A>
```


# MonoidMax

A `Monoid` that uses the maximum between two values.

The `empty` value is `Infinity`.

To import and use `MonoidMax` from the "Number" module:

```ts
import * as Number from "@effect/typeclass/data/Number"
// Can be accessed like this
Number.MonoidMax
```

**Example**

```ts
import { MonoidMax } from "@effect/typeclass/data/Number"

assert.deepStrictEqual(MonoidMax.combine(2, 3), 3)
assert.deepStrictEqual(MonoidMax.combine(2, MonoidMax.empty), 2)
```

**Signature**

```ts
export declare const MonoidMax: monoid.Monoid<number>
```


# MonoidMin

A `Monoid` that uses the minimum between two values.

The `empty` value is `-Infinity`.

To import and use `MonoidMin` from the "Number" module:

```ts
import * as Number from "@effect/typeclass/data/Number"
// Can be accessed like this
Number.MonoidMin
```

**Example**

```ts
import { MonoidMin } from "@effect/typeclass/data/Number"

assert.deepStrictEqual(MonoidMin.combine(2, 3), 2)
assert.deepStrictEqual(MonoidMin.combine(2, MonoidMin.empty), 2)
```

**Signature**

```ts
export declare const MonoidMin: monoid.Monoid<number>
```


# MonoidMultiply

`number` monoid under multiplication.

The `empty` value is `1`.

To import and use `MonoidMultiply` from the "Number" module:

```ts
import * as Number from "@effect/typeclass/data/Number"
// Can be accessed like this
Number.MonoidMultiply
```

**Example**

```ts
import { MonoidMultiply } from "@effect/typeclass/data/Number"

assert.deepStrictEqual(MonoidMultiply.combine(2, 3), 6)
assert.deepStrictEqual(MonoidMultiply.combine(2, MonoidMultiply.empty), 2)
```

**Signature**

```ts
export declare const MonoidMultiply: monoid.Monoid<number>
```


# MonoidSum

`number` monoid under addition.

The `empty` value is `0`.

To import and use `MonoidSum` from the "Number" module:

```ts
import * as Number from "@effect/typeclass/data/Number"
// Can be accessed like this
Number.MonoidSum
```

**Example**

```ts
import { MonoidSum } from "@effect/typeclass/data/Number"

assert.deepStrictEqual(MonoidSum.combine(2, 3), 5)
assert.deepStrictEqual(MonoidSum.combine(2, MonoidSum.empty), 2)
```

**Signature**

```ts
export declare const MonoidSum: monoid.Monoid<number>
```


# SemigroupMax

A `Semigroup` that uses the maximum between two values.

To import and use `SemigroupMax` from the "Number" module:

```ts
import * as Number from "@effect/typeclass/data/Number"
// Can be accessed like this
Number.SemigroupMax
```

**Example**

```ts
import { SemigroupMax } from "@effect/typeclass/data/Number"

assert.deepStrictEqual(SemigroupMax.combine(2, 3), 3)
```

**Signature**

```ts
export declare const SemigroupMax: semigroup.Semigroup<number>
```


# SemigroupMin

A `Semigroup` that uses the minimum between two values.

To import and use `SemigroupMin` from the "Number" module:

```ts
import * as Number from "@effect/typeclass/data/Number"
// Can be accessed like this
Number.SemigroupMin
```

**Example**

```ts
import { SemigroupMin } from "@effect/typeclass/data/Number"

assert.deepStrictEqual(SemigroupMin.combine(2, 3), 2)
```

**Signature**

```ts
export declare const SemigroupMin: semigroup.Semigroup<number>
```


# SemigroupMultiply

`number` semigroup under multiplication.

To import and use `SemigroupMultiply` from the "Number" module:

```ts
import * as Number from "@effect/typeclass/data/Number"
// Can be accessed like this
Number.SemigroupMultiply
```

**Example**

```ts
import { SemigroupMultiply } from "@effect/typeclass/data/Number"

assert.deepStrictEqual(SemigroupMultiply.combine(2, 3), 6)
```

**Signature**

```ts
export declare const SemigroupMultiply: semigroup.Semigroup<number>
```


# SemigroupSum

`number` semigroup under addition.

To import and use `SemigroupSum` from the "Number" module:

```ts
import * as Number from "@effect/typeclass/data/Number"
// Can be accessed like this
Number.SemigroupSum
```

**Example**

```ts
import { SemigroupSum } from "@effect/typeclass/data/Number"

assert.deepStrictEqual(SemigroupSum.combine(2, 3), 5)
```

**Signature**

```ts
export declare const SemigroupSum: semigroup.Semigroup<number>
```


# Monoid

`Monoid` instance for `Ordering`, returns the left-most non-zero `Ordering`.

The `empty` value is `0`.

To import and use `Monoid` from the "Ordering" module:

```ts
import * as Ordering from "@effect/typeclass/data/Ordering"
// Can be accessed like this
Ordering.Monoid
```

**Example**

```ts
import { Monoid } from "@effect/typeclass/data/Ordering"

assert.deepStrictEqual(Monoid.combine(Monoid.empty, -1), -1)
assert.deepStrictEqual(Monoid.combine(Monoid.empty, 1), 1)
assert.deepStrictEqual(Monoid.combine(1, -1), 1)
```

**Signature**

```ts
export declare const Monoid: monoid.Monoid<Ordering>
```


# Semigroup

`Semigroup` instance for `Ordering`, returns the left-most non-zero `Ordering`.

To import and use `Semigroup` from the "Ordering" module:

```ts
import * as Ordering from "@effect/typeclass/data/Ordering"
// Can be accessed like this
Ordering.Semigroup
```

**Example**

```ts
import { Semigroup } from "@effect/typeclass/data/Ordering"

assert.deepStrictEqual(Semigroup.combine(0, -1), -1)
assert.deepStrictEqual(Semigroup.combine(0, 1), 1)
assert.deepStrictEqual(Semigroup.combine(1, -1), 1)
```

**Signature**

```ts
export declare const Semigroup: semigroup.Semigroup<Ordering>
```


# getMonoidUnion

A `Monoid` that creates a union of two records.

It allows combining two records where values for matching keys are combined using the provided `Monoid` instance.
If a key exists in only one of the records, that key-value pair is included as is in the resulting record.

The `empty` value for this `Monoid` is an empty record `{}`.

To import and use `getMonoidUnion` from the "Record" module:

```ts
import * as Record from "@effect/typeclass/data/Record"
// Can be accessed like this
Record.getMonoidUnion
```

**Example**

```ts
import * as NumberInstances from "@effect/typeclass/data/Number"
import { getMonoidUnion } from "@effect/typeclass/data/Record"

const monoid = getMonoidUnion(NumberInstances.MonoidSum)

assert.deepStrictEqual(monoid.combine({ a: 1 }, { a: 1, b: 3 }), { a: 2, b: 3 })
assert.deepStrictEqual(monoid.combine({ a: 1 }, monoid.empty), { a: 1 })
```

**Signature**

```ts
export declare const getMonoidUnion: <A>(value: monoid.Monoid<A>) => monoid.Monoid<Record.ReadonlyRecord<string, A>>
```


# getSemigroupIntersection

A `Semigroup` that creates an intersection of two records.

This `Semigroup` takes two records and combines them into a new record containing only the keys that are present in both records.
The values for matching keys are combined using the provided `Semigroup` instance.

To import and use `getSemigroupIntersection` from the "Record" module:

```ts
import * as Record from "@effect/typeclass/data/Record"
// Can be accessed like this
Record.getSemigroupIntersection
```

**Example**

```ts
import * as NumberInstances from "@effect/typeclass/data/Number"
import { getSemigroupIntersection } from "@effect/typeclass/data/Record"

assert.deepStrictEqual(getSemigroupIntersection(NumberInstances.MonoidSum).combine({ a: 1 }, { a: 1, b: 3 }), { a: 2 })
```

**Signature**

```ts
export declare const getSemigroupIntersection: <A>(
  value: semigroup.Semigroup<A>
) => semigroup.Semigroup<Record.ReadonlyRecord<string, A>>
```


# getSemigroupUnion

A `Semigroup` that creates a union of two records.

This `Semigroup` takes two records and combines them into a single record.
If a key exists in both records, the provided `Semigroup` instance is used to combine the values for that key.
If a key exists in only one of the records, that key-value pair is included as is in the resulting record.

For example, when using the `MonoidSum`, values for matching keys will be summed.

To import and use `getSemigroupUnion` from the "Record" module:

```ts
import * as Record from "@effect/typeclass/data/Record"
// Can be accessed like this
Record.getSemigroupUnion
```

**Example**

```ts
import * as NumberInstances from "@effect/typeclass/data/Number"
import { getSemigroupUnion } from "@effect/typeclass/data/Record"

assert.deepStrictEqual(getSemigroupUnion(NumberInstances.MonoidSum).combine({ a: 1 }, { a: 1, b: 3 }), { a: 2, b: 3 })
```

**Signature**

```ts
export declare const getSemigroupUnion: <A>(
  value: semigroup.Semigroup<A>
) => semigroup.Semigroup<Record.ReadonlyRecord<string, A>>
```


# Monoid

`string` monoid under concatenation.

The `empty` value is `''`.

To import and use `Monoid` from the "String" module:

```ts
import * as String from "@effect/typeclass/data/String"
// Can be accessed like this
String.Monoid
```

**Signature**

```ts
export declare const Monoid: monoid.Monoid<string>
```


# Semigroup

`string` semigroup under concatenation.

To import and use `Semigroup` from the "String" module:

```ts
import * as String from "@effect/typeclass/data/String"
// Can be accessed like this
String.Semigroup
```

**Signature**

```ts
export declare const Semigroup: semigroup.Semigroup<string>
```


# tagged

Provides a tagged constructor for the specified `Case`.

To import and use `tagged` from the "Data" module:

```ts
import * as Data from "effect/Data"
// Can be accessed like this
Data.tagged
```

**Example**

```ts
import { Data } from "effect"

interface Person {
  readonly _tag: "Person" // the tag
  readonly name: string
}

const Person = Data.tagged<Person>("Person")

const mike = Person({ name: "Mike" })

assert.deepEqual(mike, { _tag: "Person", name: "Mike" })
```

**Signature**

```ts
export declare const tagged: <A extends { readonly _tag: string }>(tag: A["_tag"]) => Case.Constructor<A, "_tag">
```


# TaggedClass

Provides a Tagged constructor for a Case Class.

To import and use `TaggedClass` from the "Data" module:

```ts
import * as Data from "effect/Data"
// Can be accessed like this
Data.TaggedClass
```

**Example**

```ts
import { Data, Equal } from "effect"

class Person extends Data.TaggedClass("Person")<{ readonly name: string }> {}

// Creating instances of Person
const mike1 = new Person({ name: "Mike" })
const mike2 = new Person({ name: "Mike" })
const john = new Person({ name: "John" })

// Checking equality
assert.deepStrictEqual(Equal.equals(mike1, mike2), true)
assert.deepStrictEqual(Equal.equals(mike1, john), false)

assert.deepStrictEqual(mike1._tag, "Person")
```

**Signature**

```ts
export declare const TaggedClass: <Tag extends string>(
  tag: Tag
) => new <A extends Record<string, any> = {}>(
  args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P] }
) => Readonly<A> & { readonly _tag: Tag }
```


# taggedEnum

Create a constructor for a tagged union of `Data` structs.

You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to
the constructor.

To import and use `taggedEnum` from the "Data" module:

```ts
import * as Data from "effect/Data"
// Can be accessed like this
Data.taggedEnum
```

**Example**

```ts
import { Data } from "effect"

const { BadRequest, NotFound } = Data.taggedEnum<
  | { readonly _tag: "BadRequest"; readonly status: 400; readonly message: string }
  | { readonly _tag: "NotFound"; readonly status: 404; readonly message: string }
>()

const notFound = NotFound({ status: 404, message: "Not Found" })
```

**Example**

```ts
import { Data } from "effect"

type MyResult<E, A> = Data.TaggedEnum<{
  Failure: { readonly error: E }
  Success: { readonly value: A }
}>
interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {
  readonly taggedEnum: MyResult<this["A"], this["B"]>
}
const { Failure, Success } = Data.taggedEnum<MyResultDefinition>()

const success = Success({ value: 1 })
```

**Signature**

```ts
export declare const taggedEnum: {
  <Z extends TaggedEnum.WithGenerics<1>>(): Types.Simplify<
    {
      readonly [Tag in Z["taggedEnum"]["_tag"]]: <A>(
        args: TaggedEnum.Args<TaggedEnum.Kind<Z, A>, Tag, Extract<TaggedEnum.Kind<Z, A>, { readonly _tag: Tag }>>
      ) => TaggedEnum.Value<TaggedEnum.Kind<Z, A>, Tag>
    } & TaggedEnum.GenericMatchers<Z>
  >
  <Z extends TaggedEnum.WithGenerics<2>>(): Types.Simplify<
    {
      readonly [Tag in Z["taggedEnum"]["_tag"]]: <A, B>(
        args: TaggedEnum.Args<TaggedEnum.Kind<Z, A, B>, Tag, Extract<TaggedEnum.Kind<Z, A, B>, { readonly _tag: Tag }>>
      ) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B>, Tag>
    } & TaggedEnum.GenericMatchers<Z>
  >
  <Z extends TaggedEnum.WithGenerics<3>>(): Types.Simplify<
    {
      readonly [Tag in Z["taggedEnum"]["_tag"]]: <A, B, C>(
        args: TaggedEnum.Args<
          TaggedEnum.Kind<Z, A, B, C>,
          Tag,
          Extract<TaggedEnum.Kind<Z, A, B, C>, { readonly _tag: Tag }>
        >
      ) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B, C>, Tag>
    } & TaggedEnum.GenericMatchers<Z>
  >
  <Z extends TaggedEnum.WithGenerics<4>>(): Types.Simplify<
    {
      readonly [Tag in Z["taggedEnum"]["_tag"]]: <A, B, C, D>(
        args: TaggedEnum.Args<
          TaggedEnum.Kind<Z, A, B, C, D>,
          Tag,
          Extract<TaggedEnum.Kind<Z, A, B, C, D>, { readonly _tag: Tag }>
        >
      ) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B, C, D>, Tag>
    } & TaggedEnum.GenericMatchers<Z>
  >
  <A extends { readonly _tag: string }>(): TaggedEnum.Constructor<A>
}
```


# TaggedEnum

Create a tagged enum data type, which is a union of `Data` structs.

```ts
import { Data } from "effect"

type HttpError = Data.TaggedEnum<{
  BadRequest: { readonly status: 400; readonly message: string }
  NotFound: { readonly status: 404; readonly message: string }
}>

// Equivalent to:
type HttpErrorPlain =
  | {
      readonly _tag: "BadRequest"
      readonly status: 400
      readonly message: string
    }
  | {
      readonly _tag: "NotFound"
      readonly status: 404
      readonly message: string
    }
```

To import and use `TaggedEnum` from the "Data" module:

```ts
import * as Data from "effect/Data"
// Can be accessed like this
Data.TaggedEnum
```


# add

Add the given `amount` of `unit`'s to a `DateTime`.

The time zone is taken into account when adding days, weeks, months, and
years.

To import and use `add` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.add
```

**Example**

```ts
import { DateTime } from "effect"

// add 5 minutes
DateTime.unsafeMake(0).pipe(DateTime.add({ minutes: 5 }))
```

**Signature**

```ts
export declare const add: {
  (parts: Partial<DateTime.PartsForMath>): <A extends DateTime>(self: A) => A
  <A extends DateTime>(self: A, parts: Partial<DateTime.PartsForMath>): A
}
```


# addDuration

Add the given `Duration` to a `DateTime`.

To import and use `addDuration` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.addDuration
```

**Example**

```ts
import { DateTime } from "effect"

// add 5 minutes
DateTime.unsafeMake(0).pipe(DateTime.addDuration("5 minutes"))
```

**Signature**

```ts
export declare const addDuration: {
  (duration: Duration.DurationInput): <A extends DateTime>(self: A) => A
  <A extends DateTime>(self: A, duration: Duration.DurationInput): A
}
```


# DateTime

A `DateTime` represents a point in time. It can optionally have a time zone
associated with it.

To import and use `DateTime` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.DateTime
```


# distance

Calulate the difference between two `DateTime` values, returning the number
of milliseconds the `other` DateTime is from `self`.

If `other` is _after_ `self`, the result will be a positive number.

To import and use `distance` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.distance
```

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  const other = DateTime.add(now, { minutes: 1 })

  // returns 60000
  DateTime.distance(now, other)
})
```

**Signature**

```ts
export declare const distance: {
  (other: DateTime): (self: DateTime) => number
  (self: DateTime, other: DateTime): number
}
```


# distanceDuration

Calulate the distance between two `DateTime` values.

To import and use `distanceDuration` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.distanceDuration
```

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  const other = DateTime.add(now, { minutes: 1 })

  // returns Duration.minutes(1)
  DateTime.distanceDuration(now, other)
})
```

**Signature**

```ts
export declare const distanceDuration: {
  (other: DateTime): (self: DateTime) => Duration.Duration
  (self: DateTime, other: DateTime): Duration.Duration
}
```


# distanceDurationEither

Calulate the difference between two `DateTime` values.

If the `other` DateTime is before `self`, the result will be a negative
`Duration`, returned as a `Left`.

If the `other` DateTime is after `self`, the result will be a positive
`Duration`, returned as a `Right`.

To import and use `distanceDurationEither` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.distanceDurationEither
```

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  const other = DateTime.add(now, { minutes: 1 })

  // returns Either.right(Duration.minutes(1))
  DateTime.distanceDurationEither(now, other)

  // returns Either.left(Duration.minutes(1))
  DateTime.distanceDurationEither(other, now)
})
```

**Signature**

```ts
export declare const distanceDurationEither: {
  (other: DateTime): (self: DateTime) => Either.Either<Duration.Duration, Duration.Duration>
  (self: DateTime, other: DateTime): Either.Either<Duration.Duration, Duration.Duration>
}
```


# endOf

Converts a `DateTime` to the end of the given `part`.

If the part is `week`, the `weekStartsOn` option can be used to specify the
day of the week that the week starts on. The default is 0 (Sunday).

To import and use `endOf` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.endOf
```

**Example**

```ts
import { DateTime } from "effect"

// returns "2024-01-01T23:59:59.999Z"
DateTime.unsafeMake("2024-01-01T12:00:00Z").pipe(DateTime.endOf("day"), DateTime.formatIso)
```

**Signature**

```ts
export declare const endOf: {
  (
    part: DateTime.UnitSingular,
    options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined }
  ): <A extends DateTime>(self: A) => A
  <A extends DateTime>(
    self: A,
    part: DateTime.UnitSingular,
    options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined }
  ): A
}
```


# format

Format a `DateTime` as a string using the `DateTimeFormat` API.

The `timeZone` option is set to the offset of the time zone.

Note: On Node versions < 22, fixed "Offset" zones will set the time zone to
"UTC" and use the adjusted `Date`.

To import and use `format` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.format
```

**Signature**

```ts
export declare const format: {
  (
    options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined }) | undefined
  ): (self: DateTime) => string
  (
    self: DateTime,
    options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined }) | undefined
  ): string
}
```


# formatIntl

Format a `DateTime` as a string using the `DateTimeFormat` API.

To import and use `formatIntl` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.formatIntl
```

**Signature**

```ts
export declare const formatIntl: {
  (format: Intl.DateTimeFormat): (self: DateTime) => string
  (self: DateTime, format: Intl.DateTimeFormat): string
}
```


# formatIso

Format a `DateTime` as a UTC ISO string.

To import and use `formatIso` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.formatIso
```

**Signature**

```ts
export declare const formatIso: (self: DateTime) => string
```


# formatIsoDate

Format a `DateTime` as a time zone adjusted ISO date string.

To import and use `formatIsoDate` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.formatIsoDate
```

**Signature**

```ts
export declare const formatIsoDate: (self: DateTime) => string
```


# formatIsoDateUtc

Format a `DateTime` as a UTC ISO date string.

To import and use `formatIsoDateUtc` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.formatIsoDateUtc
```

**Signature**

```ts
export declare const formatIsoDateUtc: (self: DateTime) => string
```


# formatIsoOffset

Format a `DateTime.Zoned` as a ISO string with an offset.

To import and use `formatIsoOffset` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.formatIsoOffset
```

**Signature**

```ts
export declare const formatIsoOffset: (self: DateTime) => string
```


# formatIsoZoned

Format a `DateTime.Zoned` as a string.

It uses the format: `YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]`.

To import and use `formatIsoZoned` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.formatIsoZoned
```

**Signature**

```ts
export declare const formatIsoZoned: (self: Zoned) => string
```


# formatLocal

Format a `DateTime` as a string using the `DateTimeFormat` API.

It will use the system's local time zone & locale.

To import and use `formatLocal` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.formatLocal
```

**Signature**

```ts
export declare const formatLocal: {
  (
    options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined }) | undefined
  ): (self: DateTime) => string
  (
    self: DateTime,
    options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined }) | undefined
  ): string
}
```


# formatUtc

Format a `DateTime` as a string using the `DateTimeFormat` API.

This forces the time zone to be UTC.

To import and use `formatUtc` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.formatUtc
```

**Signature**

```ts
export declare const formatUtc: {
  (
    options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined }) | undefined
  ): (self: DateTime) => string
  (
    self: DateTime,
    options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined }) | undefined
  ): string
}
```


# getPart

Get a part of a `DateTime` as a number.

The part will be time zone adjusted.

To import and use `getPart` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.getPart
```

**Example**

```ts
import { DateTime } from "effect"

const now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: "Europe/London" })
const year = DateTime.getPart(now, "year")
assert.strictEqual(year, 2024)
```

**Signature**

```ts
export declare const getPart: {
  (part: keyof DateTime.PartsWithWeekday): (self: DateTime) => number
  (self: DateTime, part: keyof DateTime.PartsWithWeekday): number
}
```


# getPartUtc

Get a part of a `DateTime` as a number.

The part will be in the UTC time zone.

To import and use `getPartUtc` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.getPartUtc
```

**Example**

```ts
import { DateTime } from "effect"

const now = DateTime.unsafeMake({ year: 2024 })
const year = DateTime.getPartUtc(now, "year")
assert.strictEqual(year, 2024)
```

**Signature**

```ts
export declare const getPartUtc: {
  (part: keyof DateTime.PartsWithWeekday): (self: DateTime) => number
  (self: DateTime, part: keyof DateTime.PartsWithWeekday): number
}
```


# layerCurrentZone

Create a Layer from the given time zone.

To import and use `layerCurrentZone` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.layerCurrentZone
```

**Signature**

```ts
export declare const layerCurrentZone: (zone: TimeZone) => Layer.Layer<CurrentTimeZone>
```


# layerCurrentZoneLocal

Create a Layer from the systems local time zone.

To import and use `layerCurrentZoneLocal` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.layerCurrentZoneLocal
```

**Signature**

```ts
export declare const layerCurrentZoneLocal: Layer.Layer<CurrentTimeZone, never, never>
```


# layerCurrentZoneNamed

Create a Layer from the given IANA time zone identifier.

To import and use `layerCurrentZoneNamed` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.layerCurrentZoneNamed
```

**Signature**

```ts
export declare const layerCurrentZoneNamed: (zoneId: string) => Layer.Layer<CurrentTimeZone, IllegalArgumentException>
```


# layerCurrentZoneOffset

Create a Layer from the given time zone offset.

To import and use `layerCurrentZoneOffset` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.layerCurrentZoneOffset
```

**Signature**

```ts
export declare const layerCurrentZoneOffset: (offset: number) => Layer.Layer<CurrentTimeZone>
```


# make

Create a `DateTime` from one of the following:

- A `DateTime`
- A `Date` instance (invalid dates will throw an `IllegalArgumentException`)
- The `number` of milliseconds since the Unix epoch
- An object with the parts of a date
- A `string` that can be parsed by `Date.parse`

If the input is invalid, `None` will be returned.

To import and use `make` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.make
```

**Example**

```ts
import { DateTime } from "effect"

// from Date
DateTime.make(new Date())

// from parts
DateTime.make({ year: 2024 })

// from string
DateTime.make("2024-01-01")
```

**Signature**

```ts
export declare const make: <A extends DateTime.Input>(input: A) => Option.Option<DateTime.PreserveZone<A>>
```


# makeZoned

Create a `DateTime.Zoned` using `DateTime.make` and a time zone.

The input is treated as UTC and then the time zone is attached.

If the date time input or time zone is invalid, `None` will be returned.

To import and use `makeZoned` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.makeZoned
```

**Example**

```ts
import { DateTime } from "effect"

DateTime.makeZoned(new Date(), { timeZone: "Europe/London" })
```

**Signature**

```ts
export declare const makeZoned: (
  input: DateTime.Input,
  options?: {
    readonly timeZone?: number | string | TimeZone | undefined
    readonly adjustForTimeZone?: boolean | undefined
  }
) => Option.Option<Zoned>
```


# makeZonedFromString

Create a `DateTime.Zoned` from a string.

It uses the format: `YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]`.

To import and use `makeZonedFromString` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.makeZonedFromString
```

**Signature**

```ts
export declare const makeZonedFromString: (input: string) => Option.Option<Zoned>
```


# mapEpochMillis

Transform a `DateTime` by applying a function to the number of milliseconds
since the Unix epoch.

To import and use `mapEpochMillis` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.mapEpochMillis
```

**Example**

```ts
import { DateTime } from "effect"

// add 10 milliseconds
DateTime.unsafeMake(0).pipe(DateTime.mapEpochMillis((millis) => millis + 10))
```

**Signature**

```ts
export declare const mapEpochMillis: {
  (f: (millis: number) => number): <A extends DateTime>(self: A) => A
  <A extends DateTime>(self: A, f: (millis: number) => number): A
}
```


# mutate

Modify a `DateTime` by applying a function to a cloned `Date` instance.

The `Date` will first have the time zone applied if possible, and then be
converted back to a `DateTime` within the same time zone.

To import and use `mutate` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.mutate
```

**Signature**

```ts
export declare const mutate: {
  (f: (date: Date) => void): <A extends DateTime>(self: A) => A
  <A extends DateTime>(self: A, f: (date: Date) => void): A
}
```


# mutateUtc

Modify a `DateTime` by applying a function to a cloned UTC `Date` instance.

To import and use `mutateUtc` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.mutateUtc
```

**Signature**

```ts
export declare const mutateUtc: {
  (f: (date: Date) => void): <A extends DateTime>(self: A) => A
  <A extends DateTime>(self: A, f: (date: Date) => void): A
}
```


# nearest

Converts a `DateTime` to the nearest given `part`.

If the part is `week`, the `weekStartsOn` option can be used to specify the
day of the week that the week starts on. The default is 0 (Sunday).

To import and use `nearest` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.nearest
```

**Example**

```ts
import { DateTime } from "effect"

// returns "2024-01-02T00:00:00Z"
DateTime.unsafeMake("2024-01-01T12:01:00Z").pipe(DateTime.nearest("day"), DateTime.formatIso)
```

**Signature**

```ts
export declare const nearest: {
  (
    part: DateTime.UnitSingular,
    options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined }
  ): <A extends DateTime>(self: A) => A
  <A extends DateTime>(
    self: A,
    part: DateTime.UnitSingular,
    options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined }
  ): A
}
```


# now

Get the current time using the `Clock` service and convert it to a `DateTime`.

To import and use `now` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.now
```

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
})
```

**Signature**

```ts
export declare const now: Effect.Effect<Utc, never, never>
```


# nowInCurrentZone

Get the current time as a `DateTime.Zoned`, using the `CurrentTimeZone`.

To import and use `nowInCurrentZone` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.nowInCurrentZone
```

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the "Europe/London" time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneNamed("Europe/London"))
```

**Signature**

```ts
export declare const nowInCurrentZone: Effect.Effect<Zoned, never, CurrentTimeZone>
```


# removeTime

Remove the time aspect of a `DateTime`, first adjusting for the time
zone. It will return a `DateTime.Utc` only containing the date.

To import and use `removeTime` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.removeTime
```

**Example**

```ts
import { DateTime } from "effect"

// returns "2024-01-01T00:00:00Z"
DateTime.unsafeMakeZoned("2024-01-01T05:00:00Z", {
  timeZone: "Pacific/Auckland",
  adjustForTimeZone: true
}).pipe(DateTime.removeTime, DateTime.formatIso)
```

**Signature**

```ts
export declare const removeTime: (self: DateTime) => Utc
```


# setParts

Set the different parts of a `DateTime` as an object.

The Date will be time zone adjusted.

To import and use `setParts` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.setParts
```

**Signature**

```ts
export declare const setParts: {
  (parts: Partial<DateTime.PartsWithWeekday>): <A extends DateTime>(self: A) => A
  <A extends DateTime>(self: A, parts: Partial<DateTime.PartsWithWeekday>): A
}
```


# setPartsUtc

Set the different parts of a `DateTime` as an object.

To import and use `setPartsUtc` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.setPartsUtc
```

**Signature**

```ts
export declare const setPartsUtc: {
  (parts: Partial<DateTime.PartsWithWeekday>): <A extends DateTime>(self: A) => A
  <A extends DateTime>(self: A, parts: Partial<DateTime.PartsWithWeekday>): A
}
```


# setZone

Set the time zone of a `DateTime`, returning a new `DateTime.Zoned`.

To import and use `setZone` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.setZone
```

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  const zone = DateTime.zoneUnsafeMakeNamed("Europe/London")

  // set the time zone
  const zoned: DateTime.Zoned = DateTime.setZone(now, zone)
})
```

**Signature**

```ts
export declare const setZone: {
  (zone: TimeZone, options?: { readonly adjustForTimeZone?: boolean | undefined }): (self: DateTime) => Zoned
  (self: DateTime, zone: TimeZone, options?: { readonly adjustForTimeZone?: boolean | undefined }): Zoned
}
```


# setZoneCurrent

Set the time zone of a `DateTime` to the current time zone, which is
determined by the `CurrentTimeZone` service.

To import and use `setZoneCurrent` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.setZoneCurrent
```

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now

  // set the time zone to "Europe/London"
  const zoned = yield* DateTime.setZoneCurrent(now)
}).pipe(DateTime.withCurrentZoneNamed("Europe/London"))
```

**Signature**

```ts
export declare const setZoneCurrent: (self: DateTime) => Effect.Effect<Zoned, never, CurrentTimeZone>
```


# setZoneNamed

Set the time zone of a `DateTime` from an IANA time zone identifier. If the
time zone is invalid, `None` will be returned.

To import and use `setZoneNamed` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.setZoneNamed
```

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  // set the time zone, returns an Option
  DateTime.setZoneNamed(now, "Europe/London")
})
```

**Signature**

```ts
export declare const setZoneNamed: {
  (
    zoneId: string,
    options?: { readonly adjustForTimeZone?: boolean | undefined }
  ): (self: DateTime) => Option.Option<Zoned>
  (self: DateTime, zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined }): Option.Option<Zoned>
}
```


# setZoneOffset

Add a fixed offset time zone to a `DateTime`.

The offset is in milliseconds.

To import and use `setZoneOffset` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.setZoneOffset
```

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now

  // set the offset time zone in milliseconds
  const zoned: DateTime.Zoned = DateTime.setZoneOffset(now, 3 * 60 * 60 * 1000)
})
```

**Signature**

```ts
export declare const setZoneOffset: {
  (offset: number, options?: { readonly adjustForTimeZone?: boolean | undefined }): (self: DateTime) => Zoned
  (self: DateTime, offset: number, options?: { readonly adjustForTimeZone?: boolean | undefined }): Zoned
}
```


# startOf

Converts a `DateTime` to the start of the given `part`.

If the part is `week`, the `weekStartsOn` option can be used to specify the
day of the week that the week starts on. The default is 0 (Sunday).

To import and use `startOf` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.startOf
```

**Example**

```ts
import { DateTime } from "effect"

// returns "2024-01-01T00:00:00Z"
DateTime.unsafeMake("2024-01-01T12:00:00Z").pipe(DateTime.startOf("day"), DateTime.formatIso)
```

**Signature**

```ts
export declare const startOf: {
  (
    part: DateTime.UnitSingular,
    options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined }
  ): <A extends DateTime>(self: A) => A
  <A extends DateTime>(
    self: A,
    part: DateTime.UnitSingular,
    options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined }
  ): A
}
```


# subtract

Subtract the given `amount` of `unit`'s from a `DateTime`.

To import and use `subtract` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.subtract
```

**Example**

```ts
import { DateTime } from "effect"

// subtract 5 minutes
DateTime.unsafeMake(0).pipe(DateTime.subtract({ minutes: 5 }))
```

**Signature**

```ts
export declare const subtract: {
  (parts: Partial<DateTime.PartsForMath>): <A extends DateTime>(self: A) => A
  <A extends DateTime>(self: A, parts: Partial<DateTime.PartsForMath>): A
}
```


# subtractDuration

Subtract the given `Duration` from a `DateTime`.

To import and use `subtractDuration` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.subtractDuration
```

**Example**

```ts
import { DateTime } from "effect"

// subtract 5 minutes
DateTime.unsafeMake(0).pipe(DateTime.subtractDuration("5 minutes"))
```

**Signature**

```ts
export declare const subtractDuration: {
  (duration: Duration.DurationInput): <A extends DateTime>(self: A) => A
  <A extends DateTime>(self: A, duration: Duration.DurationInput): A
}
```


# toDate

Convert a `DateTime` to a `Date`, applying the time zone first.

To import and use `toDate` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.toDate
```

**Signature**

```ts
export declare const toDate: (self: DateTime) => Date
```


# toDateUtc

Get the UTC `Date` of a `DateTime`.

To import and use `toDateUtc` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.toDateUtc
```

**Signature**

```ts
export declare const toDateUtc: (self: DateTime) => Date
```


# toEpochMillis

Get the milliseconds since the Unix epoch of a `DateTime`.

To import and use `toEpochMillis` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.toEpochMillis
```

**Signature**

```ts
export declare const toEpochMillis: (self: DateTime) => number
```


# toParts

Get the different parts of a `DateTime` as an object.

The parts will be time zone adjusted.

To import and use `toParts` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.toParts
```

**Signature**

```ts
export declare const toParts: (self: DateTime) => DateTime.PartsWithWeekday
```


# toPartsUtc

Get the different parts of a `DateTime` as an object.

The parts will be in UTC.

To import and use `toPartsUtc` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.toPartsUtc
```

**Signature**

```ts
export declare const toPartsUtc: (self: DateTime) => DateTime.PartsWithWeekday
```


# toUtc

For a `DateTime` returns a new `DateTime.Utc`.

To import and use `toUtc` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.toUtc
```

**Example**

```ts
import { DateTime } from "effect"

const now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: "Europe/London" })

// set as UTC
const utc: DateTime.Utc = DateTime.toUtc(now)
```

**Signature**

```ts
export declare const toUtc: (self: DateTime) => Utc
```


# unsafeFromDate

Create a `DateTime` from a `Date`.

If the `Date` is invalid, an `IllegalArgumentException` will be thrown.

To import and use `unsafeFromDate` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.unsafeFromDate
```

**Signature**

```ts
export declare const unsafeFromDate: (date: Date) => Utc
```


# unsafeMake

Create a `DateTime` from one of the following:

- A `DateTime`
- A `Date` instance (invalid dates will throw an `IllegalArgumentException`)
- The `number` of milliseconds since the Unix epoch
- An object with the parts of a date
- A `string` that can be parsed by `Date.parse`

To import and use `unsafeMake` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.unsafeMake
```

**Example**

```ts
import { DateTime } from "effect"

// from Date
DateTime.unsafeMake(new Date())

// from parts
DateTime.unsafeMake({ year: 2024 })

// from string
DateTime.unsafeMake("2024-01-01")
```

**Signature**

```ts
export declare const unsafeMake: <A extends DateTime.Input>(input: A) => DateTime.PreserveZone<A>
```


# unsafeMakeZoned

Create a `DateTime.Zoned` using `DateTime.unsafeMake` and a time zone.

The input is treated as UTC and then the time zone is attached, unless
`adjustForTimeZone` is set to `true`. In that case, the input is treated as
already in the time zone.

To import and use `unsafeMakeZoned` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.unsafeMakeZoned
```

**Example**

```ts
import { DateTime } from "effect"

DateTime.unsafeMakeZoned(new Date(), { timeZone: "Europe/London" })
```

**Signature**

```ts
export declare const unsafeMakeZoned: (
  input: DateTime.Input,
  options?: {
    readonly timeZone?: number | string | TimeZone | undefined
    readonly adjustForTimeZone?: boolean | undefined
  }
) => Zoned
```


# unsafeNow

Get the current time using `Date.now`.

To import and use `unsafeNow` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.unsafeNow
```

**Signature**

```ts
export declare const unsafeNow: LazyArg<Utc>
```


# unsafeSetZoneNamed

Set the time zone of a `DateTime` from an IANA time zone identifier. If the
time zone is invalid, an `IllegalArgumentException` will be thrown.

To import and use `unsafeSetZoneNamed` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.unsafeSetZoneNamed
```

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  // set the time zone
  DateTime.unsafeSetZoneNamed(now, "Europe/London")
})
```

**Signature**

```ts
export declare const unsafeSetZoneNamed: {
  (zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined }): (self: DateTime) => Zoned
  (self: DateTime, zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined }): Zoned
}
```


# withCurrentZone

Provide the `CurrentTimeZone` to an effect.

To import and use `withCurrentZone` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.withCurrentZone
```

**Example**

```ts
import { DateTime, Effect } from "effect"

const zone = DateTime.zoneUnsafeMakeNamed("Europe/London")

Effect.gen(function* () {
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZone(zone))
```

**Signature**

```ts
export declare const withCurrentZone: {
  (zone: TimeZone): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>
  <A, E, R>(effect: Effect.Effect<A, E, R>, zone: TimeZone): Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>
}
```


# withCurrentZoneLocal

Provide the `CurrentTimeZone` to an effect, using the system's local time
zone.

To import and use `withCurrentZoneLocal` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.withCurrentZoneLocal
```

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the system's local time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneLocal)
```

**Signature**

```ts
export declare const withCurrentZoneLocal: <A, E, R>(
  effect: Effect.Effect<A, E, R>
) => Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>
```


# withCurrentZoneNamed

Provide the `CurrentTimeZone` to an effect using an IANA time zone
identifier.

If the time zone is invalid, it will fail with an `IllegalArgumentException`.

To import and use `withCurrentZoneNamed` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.withCurrentZoneNamed
```

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the "Europe/London" time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneNamed("Europe/London"))
```

**Signature**

```ts
export declare const withCurrentZoneNamed: {
  (
    zone: string
  ): <A, E, R>(
    effect: Effect.Effect<A, E, R>
  ) => Effect.Effect<A, E | IllegalArgumentException, Exclude<R, CurrentTimeZone>>
  <A, E, R>(
    effect: Effect.Effect<A, E, R>,
    zone: string
  ): Effect.Effect<A, E | IllegalArgumentException, Exclude<R, CurrentTimeZone>>
}
```


# withCurrentZoneOffset

Provide the `CurrentTimeZone` to an effect, using a offset.

To import and use `withCurrentZoneOffset` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.withCurrentZoneOffset
```

**Example**

```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the system's local time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneOffset(3 * 60 * 60 * 1000))
```

**Signature**

```ts
export declare const withCurrentZoneOffset: {
  (offset: number): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>
  <A, E, R>(effect: Effect.Effect<A, E, R>, offset: number): Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>
}
```


# withDate

Using the time zone adjusted `Date`, apply a function to the `Date` and
return the result.

To import and use `withDate` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.withDate
```

**Example**

```ts
import { DateTime } from "effect"

// get the time zone adjusted date in milliseconds
DateTime.unsafeMakeZoned(0, { timeZone: "Europe/London" }).pipe(DateTime.withDate((date) => date.getTime()))
```

**Signature**

```ts
export declare const withDate: {
  <A>(f: (date: Date) => A): (self: DateTime) => A
  <A>(self: DateTime, f: (date: Date) => A): A
}
```


# withDateUtc

Using the time zone adjusted `Date`, apply a function to the `Date` and
return the result.

To import and use `withDateUtc` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.withDateUtc
```

**Example**

```ts
import { DateTime } from "effect"

// get the date in milliseconds
DateTime.unsafeMake(0).pipe(DateTime.withDateUtc((date) => date.getTime()))
```

**Signature**

```ts
export declare const withDateUtc: {
  <A>(f: (date: Date) => A): (self: DateTime) => A
  <A>(self: DateTime, f: (date: Date) => A): A
}
```


# zonedOffset

Calculate the time zone offset of a `DateTime.Zoned` in milliseconds.

To import and use `zonedOffset` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.zonedOffset
```

**Signature**

```ts
export declare const zonedOffset: (self: Zoned) => number
```


# zonedOffsetIso

Calculate the time zone offset of a `DateTime` in milliseconds.

The offset is formatted as "HH:MM".

To import and use `zonedOffsetIso` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.zonedOffsetIso
```

**Signature**

```ts
export declare const zonedOffsetIso: (self: Zoned) => string
```


# zoneFromString

Try parse a TimeZone from a string

To import and use `zoneFromString` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.zoneFromString
```

**Signature**

```ts
export declare const zoneFromString: (zone: string) => Option.Option<TimeZone>
```


# zoneMakeLocal

Create a named time zone from the system's local time zone.

To import and use `zoneMakeLocal` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.zoneMakeLocal
```

**Signature**

```ts
export declare const zoneMakeLocal: () => TimeZone.Named
```


# zoneMakeNamed

Create a named time zone from a IANA time zone identifier. If the time zone
is invalid, `None` will be returned.

To import and use `zoneMakeNamed` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.zoneMakeNamed
```

**Signature**

```ts
export declare const zoneMakeNamed: (zoneId: string) => Option.Option<TimeZone.Named>
```


# zoneMakeNamedEffect

Create a named time zone from a IANA time zone identifier. If the time zone
is invalid, it will fail with an `IllegalArgumentException`.

To import and use `zoneMakeNamedEffect` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.zoneMakeNamedEffect
```

**Signature**

```ts
export declare const zoneMakeNamedEffect: (zoneId: string) => Effect.Effect<TimeZone.Named, IllegalArgumentException>
```


# zoneMakeOffset

Create a fixed offset time zone.

To import and use `zoneMakeOffset` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.zoneMakeOffset
```

**Signature**

```ts
export declare const zoneMakeOffset: (offset: number) => TimeZone.Offset
```


# zoneToString

Format a `TimeZone` as a string.

To import and use `zoneToString` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.zoneToString
```

**Example**

```ts
import { DateTime, Effect } from "effect"

// Outputs "+03:00"
DateTime.zoneToString(DateTime.zoneMakeOffset(3 * 60 * 60 * 1000))

// Outputs "Europe/London"
DateTime.zoneToString(DateTime.zoneUnsafeMakeNamed("Europe/London"))
```

**Signature**

```ts
export declare const zoneToString: (self: TimeZone) => string
```


# zoneUnsafeMakeNamed

Attempt to create a named time zone from a IANA time zone identifier.

If the time zone is invalid, an `IllegalArgumentException` will be thrown.

To import and use `zoneUnsafeMakeNamed` from the "DateTime" module:

```ts
import * as DateTime from "effect/DateTime"
// Can be accessed like this
DateTime.zoneUnsafeMakeNamed
```

**Signature**

```ts
export declare const zoneUnsafeMakeNamed: (zoneId: string) => TimeZone.Named
```


# await

Retrieves the value of the `Deferred`, suspending the fiber running the
workflow until the result is available.

To import and use `await` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.await
```


# complete

Completes the deferred with the result of the specified effect. If the
deferred has already been completed, the method will produce false.

Note that `Deferred.completeWith` will be much faster, so consider using
that if you do not need to memoize the result of the specified effect.

To import and use `complete` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.complete
```

**Signature**

```ts
export declare const complete: {
  <A, E>(effect: Effect.Effect<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>
  <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>
}
```


# completeWith

Completes the deferred with the result of the specified effect. If the
deferred has already been completed, the method will produce false.

To import and use `completeWith` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.completeWith
```

**Signature**

```ts
export declare const completeWith: {
  <A, E>(effect: Effect.Effect<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>
  <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>
}
```


# Deferred

A `Deferred` represents an asynchronous variable that can be set exactly
once, with the ability for an arbitrary number of fibers to suspend (by
calling `Deferred.await`) and automatically resume when the variable is set.

`Deferred` can be used for building primitive actions whose completions
require the coordinated action of multiple fibers, and for building
higher-level concurrent or asynchronous structures.

To import and use `Deferred` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.Deferred
```


# die

Kills the `Deferred` with the specified defect, which will be propagated to
all fibers waiting on the value of the `Deferred`.

To import and use `die` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.die
```

**Signature**

```ts
export declare const die: {
  (defect: unknown): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>
  <A, E>(self: Deferred<A, E>, defect: unknown): Effect.Effect<boolean>
}
```


# dieSync

Kills the `Deferred` with the specified defect, which will be propagated to
all fibers waiting on the value of the `Deferred`.

To import and use `dieSync` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.dieSync
```

**Signature**

```ts
export declare const dieSync: {
  (evaluate: LazyArg<unknown>): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>
  <A, E>(self: Deferred<A, E>, evaluate: LazyArg<unknown>): Effect.Effect<boolean>
}
```


# done

Exits the `Deferred` with the specified `Exit` value, which will be
propagated to all fibers waiting on the value of the `Deferred`.

To import and use `done` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.done
```

**Signature**

```ts
export declare const done: {
  <A, E>(exit: Exit.Exit<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>
  <A, E>(self: Deferred<A, E>, exit: Exit.Exit<A, E>): Effect.Effect<boolean>
}
```


# fail

Fails the `Deferred` with the specified error, which will be propagated to
all fibers waiting on the value of the `Deferred`.

To import and use `fail` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.fail
```

**Signature**

```ts
export declare const fail: {
  <E>(error: E): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>
  <A, E>(self: Deferred<A, E>, error: E): Effect.Effect<boolean>
}
```


# failCause

Fails the `Deferred` with the specified `Cause`, which will be propagated to
all fibers waiting on the value of the `Deferred`.

To import and use `failCause` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.failCause
```

**Signature**

```ts
export declare const failCause: {
  <E>(cause: Cause.Cause<E>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>
  <A, E>(self: Deferred<A, E>, cause: Cause.Cause<E>): Effect.Effect<boolean>
}
```


# failCauseSync

Fails the `Deferred` with the specified `Cause`, which will be propagated to
all fibers waiting on the value of the `Deferred`.

To import and use `failCauseSync` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.failCauseSync
```

**Signature**

```ts
export declare const failCauseSync: {
  <E>(evaluate: LazyArg<Cause.Cause<E>>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>
  <A, E>(self: Deferred<A, E>, evaluate: LazyArg<Cause.Cause<E>>): Effect.Effect<boolean>
}
```


# failSync

Fails the `Deferred` with the specified error, which will be propagated to
all fibers waiting on the value of the `Deferred`.

To import and use `failSync` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.failSync
```

**Signature**

```ts
export declare const failSync: {
  <E>(evaluate: LazyArg<E>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>
  <A, E>(self: Deferred<A, E>, evaluate: LazyArg<E>): Effect.Effect<boolean>
}
```


# interrupt

Completes the `Deferred` with interruption. This will interrupt all fibers
waiting on the value of the `Deferred` with the `FiberId` of the fiber
calling this method.

To import and use `interrupt` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.interrupt
```

**Signature**

```ts
export declare const interrupt: <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>
```


# interruptWith

Completes the `Deferred` with interruption. This will interrupt all fibers
waiting on the value of the `Deferred` with the specified `FiberId`.

To import and use `interruptWith` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.interruptWith
```

**Signature**

```ts
export declare const interruptWith: {
  (fiberId: FiberId.FiberId): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>
  <A, E>(self: Deferred<A, E>, fiberId: FiberId.FiberId): Effect.Effect<boolean>
}
```


# isDone

Returns `true` if this `Deferred` has already been completed with a value or
an error, `false` otherwise.

To import and use `isDone` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.isDone
```

**Signature**

```ts
export declare const isDone: <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>
```


# make

Creates a new `Deferred`.

To import and use `make` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.make
```

**Signature**

```ts
export declare const make: <A, E = never>() => Effect.Effect<Deferred<A, E>>
```


# makeAs

Creates a new `Deferred` from the specified `FiberId`.

To import and use `makeAs` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.makeAs
```

**Signature**

```ts
export declare const makeAs: <A, E = never>(fiberId: FiberId.FiberId) => Effect.Effect<Deferred<A, E>>
```


# poll

Returns a `Some<Effect<A, E, R>>` from the `Deferred` if this `Deferred` has
already been completed, `None` otherwise.

To import and use `poll` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.poll
```

**Signature**

```ts
export declare const poll: <A, E>(self: Deferred<A, E>) => Effect.Effect<Option.Option<Effect.Effect<A, E>>>
```


# succeed

Completes the `Deferred` with the specified value.

To import and use `succeed` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.succeed
```

**Signature**

```ts
export declare const succeed: {
  <A>(value: A): <E>(self: Deferred<A, E>) => Effect.Effect<boolean>
  <A, E>(self: Deferred<A, E>, value: A): Effect.Effect<boolean>
}
```


# sync

Completes the `Deferred` with the specified lazily evaluated value.

To import and use `sync` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.sync
```

**Signature**

```ts
export declare const sync: {
  <A>(evaluate: LazyArg<A>): <E>(self: Deferred<A, E>) => Effect.Effect<boolean>
  <A, E>(self: Deferred<A, E>, evaluate: LazyArg<A>): Effect.Effect<boolean>
}
```


# unsafeDone

Unsafely exits the `Deferred` with the specified `Exit` value, which will be
propagated to all fibers waiting on the value of the `Deferred`.

To import and use `unsafeDone` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.unsafeDone
```

**Signature**

```ts
export declare const unsafeDone: <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>) => void
```


# unsafeMake

Unsafely creates a new `Deferred` from the specified `FiberId`.

To import and use `unsafeMake` from the "Deferred" module:

```ts
import * as Deferred from "effect/Deferred"
// Can be accessed like this
Deferred.unsafeMake
```

**Signature**

```ts
export declare const unsafeMake: <A, E = never>(fiberId: FiberId.FiberId) => Deferred<A, E>
```


# chunk

Constructs a differ that knows how to diff a `Chunk` of values given a
differ that knows how to diff the values.

To import and use `chunk` from the "Differ" module:

```ts
import * as Differ from "effect/Differ"
// Can be accessed like this
Differ.chunk
```

**Signature**

```ts
export declare const chunk: <Value, Patch>(
  differ: Differ<Value, Patch>
) => Differ<Chunk<Value>, Differ.Chunk.Patch<Value, Patch>>
```


# combine

Combines two patches to produce a new patch that describes the updates of
the first patch and then the updates of the second patch. The combine
operation should be associative. In addition, if the combine operation is
commutative then joining multiple fibers concurrently will result in
deterministic `FiberRef` values.

To import and use `combine` from the "Differ" module:

```ts
import * as Differ from "effect/Differ"
// Can be accessed like this
Differ.combine
```

**Signature**

```ts
export declare const combine: {
  <Patch>(first: Patch, second: Patch): <Value>(self: Differ<Value, Patch>) => Patch
  <Value, Patch>(self: Differ<Value, Patch>, first: Patch, second: Patch): Patch
}
```


# Differ

A `Differ<Value, Patch>` knows how to compare an old value and new value of
type `Value` to produce a patch of type `Patch` that describes the
differences between those values. A `Differ` also knows how to apply a patch
to an old value to produce a new value that represents the old value updated
with the changes described by the patch.

A `Differ` can be used to construct a `FiberRef` supporting compositional
updates using the `FiberRef.makePatch` constructor.

The `Differ` companion object contains constructors for `Differ` values for
common data types such as `Chunk`, `HashMap`, and `HashSet``. In addition,
`Differ`values can be transformed using the `transform`operator and combined
using the`orElseEither`and`zip`operators. This allows creating`Differ`
values for arbitrarily complex data types compositionally.

To import and use `Differ` from the "Differ" module:

```ts
import * as Differ from "effect/Differ"
// Can be accessed like this
Differ.Differ
```


# empty

An empty patch that describes no changes.

To import and use `empty` from the "Differ" module:

```ts
import * as Differ from "effect/Differ"
// Can be accessed like this
Differ.empty
```

**Signature**

```ts
export declare const empty: <Value, Patch>(self: Differ<Value, Patch>) => Patch
```


# environment

Constructs a differ that knows how to diff `Env` values.

To import and use `environment` from the "Differ" module:

```ts
import * as Differ from "effect/Differ"
// Can be accessed like this
Differ.environment
```

**Signature**

```ts
export declare const environment: <A>() => Differ<Context<A>, Differ.Context.Patch<A, A>>
```


# hashMap

Constructs a differ that knows how to diff a `HashMap` of keys and values given
a differ that knows how to diff the values.

To import and use `hashMap` from the "Differ" module:

```ts
import * as Differ from "effect/Differ"
// Can be accessed like this
Differ.hashMap
```

**Signature**

```ts
export declare const hashMap: <Key, Value, Patch>(
  differ: Differ<Value, Patch>
) => Differ<HashMap<Key, Value>, Differ.HashMap.Patch<Key, Value, Patch>>
```


# hashSet

Constructs a differ that knows how to diff a `HashSet` of values.

To import and use `hashSet` from the "Differ" module:

```ts
import * as Differ from "effect/Differ"
// Can be accessed like this
Differ.hashSet
```

**Signature**

```ts
export declare const hashSet: <Value>() => Differ<HashSet<Value>, Differ.HashSet.Patch<Value>>
```


# make

Constructs a new `Differ`.

To import and use `make` from the "Differ" module:

```ts
import * as Differ from "effect/Differ"
// Can be accessed like this
Differ.make
```

**Signature**

```ts
export declare const make: <Value, Patch>(params: {
  readonly empty: Patch
  readonly diff: (oldValue: Value, newValue: Value) => Patch
  readonly combine: (first: Patch, second: Patch) => Patch
  readonly patch: (patch: Patch, oldValue: Value) => Value
}) => Differ<Value, Patch>
```


# orElseEither

Combines this differ and the specified differ to produce a differ that
knows how to diff the sum of their values.

To import and use `orElseEither` from the "Differ" module:

```ts
import * as Differ from "effect/Differ"
// Can be accessed like this
Differ.orElseEither
```

**Signature**

```ts
export declare const orElseEither: {
  <Value2, Patch2>(
    that: Differ<Value2, Patch2>
  ): <Value, Patch>(
    self: Differ<Value, Patch>
  ) => Differ<Either<Value2, Value>, Differ.Or.Patch<Value, Value2, Patch, Patch2>>
  <Value, Patch, Value2, Patch2>(
    self: Differ<Value, Patch>,
    that: Differ<Value2, Patch2>
  ): Differ<Either<Value2, Value>, Differ.Or.Patch<Value, Value2, Patch, Patch2>>
}
```


# patch

Applies a patch to an old value to produce a new value that is equal to the
old value with the updates described by the patch.

To import and use `patch` from the "Differ" module:

```ts
import * as Differ from "effect/Differ"
// Can be accessed like this
Differ.patch
```

**Signature**

```ts
export declare const patch: {
  <Patch, Value>(patch: Patch, oldValue: Value): (self: Differ<Value, Patch>) => Value
  <Patch, Value>(self: Differ<Value, Patch>, patch: Patch, oldValue: Value): Value
}
```


# readonlyArray

Constructs a differ that knows how to diff a `ReadonlyArray` of values.

To import and use `readonlyArray` from the "Differ" module:

```ts
import * as Differ from "effect/Differ"
// Can be accessed like this
Differ.readonlyArray
```

**Signature**

```ts
export declare const readonlyArray: <Value, Patch>(
  differ: Differ<Value, Patch>
) => Differ<ReadonlyArray<Value>, Differ.ReadonlyArray.Patch<Value, Patch>>
```


# transform

Transforms the type of values that this differ knows how to differ using
the specified functions that map the new and old value types to each other.

To import and use `transform` from the "Differ" module:

```ts
import * as Differ from "effect/Differ"
// Can be accessed like this
Differ.transform
```

**Signature**

```ts
export declare const transform: {
  <Value, Value2>(options: {
    readonly toNew: (value: Value) => Value2
    readonly toOld: (value: Value2) => Value
  }): <Patch>(self: Differ<Value, Patch>) => Differ<Value2, Patch>
  <Value, Patch, Value2>(
    self: Differ<Value, Patch>,
    options: { readonly toNew: (value: Value) => Value2; readonly toOld: (value: Value2) => Value }
  ): Differ<Value2, Patch>
}
```


# update

Constructs a differ that just diffs two values by returning a function that
sets the value to the new value. This differ does not support combining
multiple updates to the value compositionally and should only be used when
there is no compositional way to update them.

To import and use `update` from the "Differ" module:

```ts
import * as Differ from "effect/Differ"
// Can be accessed like this
Differ.update
```

**Signature**

```ts
export declare const update: <A>() => Differ<A, (a: A) => A>
```


# updateWith

A variant of `update` that allows specifying the function that will be used
to combine old values with new values.

To import and use `updateWith` from the "Differ" module:

```ts
import * as Differ from "effect/Differ"
// Can be accessed like this
Differ.updateWith
```

**Signature**

```ts
export declare const updateWith: <A>(f: (x: A, y: A) => A) => Differ<A, (a: A) => A>
```


# zip

Combines this differ and the specified differ to produce a new differ that
knows how to diff the product of their values.

To import and use `zip` from the "Differ" module:

```ts
import * as Differ from "effect/Differ"
// Can be accessed like this
Differ.zip
```

**Signature**

```ts
export declare const zip: {
  <Value2, Patch2>(
    that: Differ<Value2, Patch2>
  ): <Value, Patch>(self: Differ<Value, Patch>) => Differ<readonly [Value, Value2], readonly [Patch, Patch2]>
  <Value, Patch, Value2, Patch2>(
    self: Differ<Value, Patch>,
    that: Differ<Value2, Patch2>
  ): Differ<readonly [Value, Value2], readonly [Patch, Patch2]>
}
```


# align

The `align` combinator lays out a document with the nesting level set to the
current column.

To import and use `align` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.align
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

// As an example, the documents below will be placed one above the other
// regardless of the current nesting level

// Without `align`ment, the second line is simply placed below everything
// that has been laid out so far
const unaligned = Doc.hsep([Doc.text("lorem"), Doc.vsep([Doc.text("ipsum"), Doc.text("dolor")])])

assert.strictEqual(
  Doc.render(unaligned, { style: "pretty" }),
  String.stripMargin(
    `|lorem ipsum
     |dolor`
  )
)

// With `align`ment, the `vsep`ed documents all start at the same column
const aligned = Doc.hsep([Doc.text("lorem"), Doc.align(Doc.vsep([Doc.text("ipsum"), Doc.text("dolor")]))])

assert.strictEqual(
  Doc.render(aligned, { style: "pretty" }),
  String.stripMargin(
    `|lorem ipsum
     |      dolor`
  )
)
```

**Signature**

```ts
export declare const align: <A>(self: Doc<A>) => Doc<A>
```


# alterAnnotations

Change the annotations of a document. Individual annotations can be removed,
changed, or replaced by multiple ones.

This is a general function that combines `unAnnotate` and `reAnnotate`, and
is useful for mapping semantic annotations (such as this is a keyword) to
display annotations (such as this is red and underlined) because some
backends may not care about certain annotations while others may.

Annotations earlier in the new list will be applied earlier, so returning
`[Bold, Green]` will result in a bold document that contains green text, and
not vice versa.

Since this traverses the entire document tree, including the parts that are
not rendered (due to other layouts having better fit), it is preferable to
reannotate a document **after** producing the layout by using
`alterAnnotations` from the `SimpleDocStream` module.

To import and use `alterAnnotations` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.alterAnnotations
```

**Signature**

```ts
export declare const alterAnnotations: {
  <A, B>(f: (a: A) => Iterable<B>): (self: Doc<A>) => Doc<B>
  <A, B>(self: Doc<A>, f: (a: A) => Iterable<B>): Doc<B>
}
```


# angleBracketed

Encloses the input document in angle brackets (`<>`).

To import and use `angleBracketed` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.angleBracketed
```

**Signature**

```ts
export declare const angleBracketed: <A>(self: Doc<A>) => Doc<A>
```


# annotate

Adds an annotation to a `Doc`. The annotation can then be used by the rendering
algorithm to, for example, add color to certain parts of the output.

**Note** This function is relevant only for custom formats with their own annotations,
and is not relevant for basic pretty printing.

To import and use `annotate` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.annotate
```

**Signature**

```ts
export declare const annotate: {
  <A>(annotation: A): (self: Doc<A>) => Doc<A>
  <A>(self: Doc<A>, annotation: A): Doc<A>
}
```


# Annotated

Represents a document with an associated annotation.

To import and use `Annotated` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.Annotated
```


# backslash

A document containing a single `\` character.

To import and use `backslash` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.backslash
```

**Signature**

```ts
export declare const backslash: Doc<never>
```


# cat

The `cat` combinator lays out two documents separated by nothing.

To import and use `cat` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.cat
```

**Signature**

```ts
export declare const cat: {
  <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>
  <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>
}
```


# Cat

Represents the concatenation of two documents.

To import and use `Cat` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.Cat
```


# cats

The `cats` combinator will attempt to lay out a collection of documents
separated by nothing. If the output does not fit the page, then the documents
will be separated by newlines. This is what differentiates it from `vcat`,
which always lays out documents beneath one another.

To import and use `cats` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.cats
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hsep([Doc.text("Docs:"), Doc.cats(Doc.words("lorem ipsum dolor"))])

assert.strictEqual(Doc.render(doc, { style: "pretty" }), "Docs: loremipsumdolor")

// If the document exceeds the width of the page, the documents are rendered
// one above another
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 10 }
  }),
  String.stripMargin(
    `|Docs: lorem
     |ipsum
     |dolor`
  )
)
```

**Signature**

```ts
export declare const cats: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```


# catWithLine

The `catWithLine` combinator concatenates two documents by placing a `line`
document between them.

To import and use `catWithLine` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.catWithLine
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc: Doc.Doc<never> = pipe(Doc.char("a"), Doc.catWithLine(Doc.char("b")))

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|a
     |b`
  )
)
```

**Signature**

```ts
export declare const catWithLine: {
  <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>
  <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>
}
```


# catWithLineBreak

The `catWithLineBreak` combinator concatenates two documents by placing a
`lineBreak` document between them.

To import and use `catWithLineBreak` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.catWithLineBreak
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc: Doc.Doc<never> = pipe(Doc.char("a"), Doc.catWithLineBreak(Doc.char("b")))

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|a
     |b`
  )
)

assert.strictEqual(Doc.render(Doc.group(doc), { style: "pretty" }), "ab")
```

**Signature**

```ts
export declare const catWithLineBreak: {
  <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>
  <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>
}
```


# catWithSoftLine

The `catWithSoftLine` combinator concatenates two documents by placing a
`softLine` document between them.

To import and use `catWithSoftLine` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.catWithSoftLine
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc: Doc.Doc<never> = pipe(Doc.char("a"), Doc.catWithSoftLine(Doc.char("b")))

assert.strictEqual(Doc.render(doc, { style: "pretty" }), "a b")

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 1 }
  }),
  String.stripMargin(
    `|a
     |b`
  )
)
```

**Signature**

```ts
export declare const catWithSoftLine: {
  <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>
  <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>
}
```


# catWithSoftLineBreak

The `catWithSoftLineBreak` combinator concatenates two documents by
placing a `softLineBreak` document between them.

To import and use `catWithSoftLineBreak` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.catWithSoftLineBreak
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc: Doc.Doc<never> = pipe(Doc.char("a"), Doc.catWithSoftLineBreak(Doc.char("b")))

assert.strictEqual(Doc.render(doc, { style: "pretty" }), "ab")

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 1 }
  }),
  String.stripMargin(
    `|a
     |b`
  )
)
```

**Signature**

```ts
export declare const catWithSoftLineBreak: {
  <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>
  <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>
}
```


# catWithSpace

The `catWithSpace` combinator concatenates two documents by placing a
`space` document between them.

To import and use `catWithSpace` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.catWithSpace
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"

const doc: Doc.Doc<never> = pipe(Doc.char("a"), Doc.catWithSpace(Doc.char("b")))

assert.strictEqual(Doc.render(doc, { style: "pretty" }), "a b")
```

**Signature**

```ts
export declare const catWithSpace: {
  <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>
  <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>
}
```


# changesUponFlattening

Select the first element of each `Union` and discard the first element of
each `FlatAlt` to produce a "flattened" version of the input document.

The result is `Flattened` if the element might change depending on the chosen
layout algorithm (i.e., the resulting document contains sub-documents that
may be rendered differently).

The result is `AlreadyFlat` if the document is static (i.e., the resulting
document contains only a plain `Empty` node).

`NeverFlat` is returned when the document cannot be flattened because it
contains either a hard `Line` or a `Fail`.

To import and use `changesUponFlattening` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.changesUponFlattening
```

**Signature**

```ts
export declare const changesUponFlattening: <A>(self: Doc<A>) => Flatten<Doc<A>>
```


# char

A document containing a single character.

**Invariants**

- Cannot be the newline (`"\n"`) character

To import and use `char` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.char
```

**Signature**

```ts
export declare const char: (char: string) => Doc<never>
```


# Char

Represents a document containing a single character.

**Invariants**

- Cannot be the newline (`"\n"`) character

To import and use `Char` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.Char
```


# colon

A document containing a single `:` character.

To import and use `colon` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.colon
```

**Signature**

```ts
export declare const colon: Doc<never>
```


# column

Lays out a document depending upon the column at which the document starts.

To import and use `column` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.column
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

// Example 1:
const example1 = Doc.column((l) => Doc.hsep([Doc.text("Columns are"), Doc.text(`${l}-based`)]))

assert.strictEqual(Doc.render(example1, { style: "pretty" }), "Columns are 0-based")

// Example 2:
const doc = Doc.hsep([Doc.text("prefix"), Doc.column((l) => Doc.text(`| <- column ${l}`))])

const example2 = Doc.vsep([0, 4, 8].map((n) => Doc.indent(n)(doc)))

assert.strictEqual(
  Doc.render(example2, { style: "pretty" }),
  String.stripMargin(
    `|prefix | <- column 7
     |    prefix | <- column 11
     |        prefix | <- column 15`
  )
)
```

**Signature**

```ts
export declare const column: <A>(react: (position: number) => Doc<A>) => Doc<A>
```


# Column

Represents a document that reacts to the current cursor position.

To import and use `Column` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.Column
```


# comma

A document containing a single `,` character.

To import and use `comma` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.comma
```

**Signature**

```ts
export declare const comma: Doc<never>
```


# concatWith

The `concatWith` combinator concatenates all documents in a collection
element-wise with the specified binary function.

To import and use `concatWith` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.concatWith
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"

const doc: Doc.Doc<never> = pipe(
  [Doc.char("a"), Doc.char("b")],
  Doc.concatWith((x, y) => Doc.catWithSpace(y)(x))
)

assert.strictEqual(Doc.render(doc, { style: "pretty" }), "a b")
```

**Signature**

```ts
export declare const concatWith: {
  <A>(f: (left: Doc<A>, right: Doc<A>) => Doc<A>): (docs: Iterable<Doc<A>>) => Doc<A>
  <A>(docs: Iterable<Doc<A>>, f: (left: Doc<A>, right: Doc<A>) => Doc<A>): Doc<A>
}
```


# curlyBraced

Encloses the input document in curly braces (`{}`).

To import and use `curlyBraced` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.curlyBraced
```

**Signature**

```ts
export declare const curlyBraced: <A>(self: Doc<A>) => Doc<A>
```


# Doc

Represents a prettified document that has been annotated with data of type
`A`.

To import and use `Doc` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.Doc
```


# dot

A document containing a single `.` character.

To import and use `dot` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.dot
```

**Signature**

```ts
export declare const dot: Doc<never>
```


# doubleQuoted

Encloses the input document in double quotes (`""`).

To import and use `doubleQuoted` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.doubleQuoted
```

**Signature**

```ts
export declare const doubleQuoted: <A>(self: Doc<A>) => Doc<A>
```


# dquote

A document containing a single `"` character.

To import and use `dquote` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.dquote
```

**Signature**

```ts
export declare const dquote: Doc<never>
```


# empty

The `empty` document behaves like a document containing the empty string
(`""`), so it has a height of `1`.

This may lead to surprising behavior if the empty document is expected to
bear no weight inside certain layout functions, such as`vcat`, where it will
render an empty line of output.

To import and use `empty` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.empty
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc = Doc.vsep([
  Doc.text("hello"),
  // `parentheses` for visibility purposes only
  Doc.parenthesized(Doc.empty),
  Doc.text("world")
])

const expected = `|hello
                  |()
                  |world`

assert.strictEqual(Doc.render(doc, { style: "pretty" }), String.stripMargin(expected))
```

**Signature**

```ts
export declare const empty: Doc<never>
```


# Empty

Represents the empty document.

Conceptually, the `Empty` document can be thought of as the unit of `Cat`.

To import and use `Empty` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.Empty
```


# encloseSep

The `encloseSep` combinator concatenates a collection of documents,
separating each document in the collection using the specified `sep`
document. After concatenation, the resulting document is enclosed by the
specified `left` and `right` documents.

To place the `sep` document at the end of each entry, see the `punctuate`
combinator.

To import and use `encloseSep` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.encloseSep
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc = Doc.hsep([
  Doc.text("list"),
  Doc.align(
    pipe(
      ["1", "20", "300", "4000"].map((n) => (n.length === 1 ? Doc.char(n) : Doc.text(n))),
      Doc.encloseSep(Doc.lbracket, Doc.rbracket, Doc.comma)
    )
  )
])

// The documents are laid out horizontally if the document fits the page
assert.strictEqual(Doc.render(doc, { style: "pretty" }), "list [1,20,300,4000]")

// Otherwise they are laid out vertically, with separators put in the front
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 10 }
  }),
  String.stripMargin(
    `|list [1
     |     ,20
     |     ,300
     |     ,4000]`
  )
)
```

**Signature**

```ts
export declare const encloseSep: {
  <A, B, C>(left: Doc<A>, right: Doc<B>, sep: Doc<C>): <D>(docs: Iterable<Doc<D>>) => Doc<A | B | C | D>
  <A, B, C, D>(docs: Iterable<Doc<D>>, left: Doc<A>, right: Doc<B>, sep: Doc<C>): Doc<A | B | C | D>
}
```


# equalSign

A document containing a single `=` character.

To import and use `equalSign` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.equalSign
```

**Signature**

```ts
export declare const equalSign: Doc<never>
```


# fail

The `fail` document is a document that cannot be rendered.

Generally occurs when flattening a line. The layout algorithms will reject
this document and choose a more suitable rendering.

To import and use `fail` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.fail
```

**Signature**

```ts
export declare const fail: Doc<never>
```


# Fail

Represents a document that cannot be rendered. Generally occurs when
flattening a line. The layout algorithms will reject this document and choose
a more suitable rendering.

To import and use `Fail` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.Fail
```


# fill

The `fill` combinator first lays out the document `x` and then appends
`space`s until the width of the document is equal to the specified `width`.
If the width of `x` is already larger than the specified `width`, nothing is
appended.

To import and use `fill` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.fill
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

type Signature = [name: string, type: string]

const signatures: Array<Signature> = [
  ["empty", "Doc"],
  ["nest", "Int -> Doc -> Doc"],
  ["fillSep", "[Doc] -> Doc"]
]

const prettySignature = <A>([name, type]: Signature): Doc.Doc<A> =>
  Doc.hsep([pipe(Doc.text(name), Doc.fill(5)), Doc.text("::"), Doc.text(type)])

const doc = Doc.hsep([Doc.text("let"), Doc.align(Doc.vcat(signatures.map(prettySignature)))])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|let empty :: Doc
     |    nest  :: Int -> Doc -> Doc
     |    fillSep :: [Doc] -> Doc`
  )
)
```

**Signature**

```ts
export declare const fill: { (w: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, w: number): Doc<A> }
```


# fillBreak

The `fillBreak` combinator first lays out the document `x` and then appends
`space`s until the width of the document is equal to the specified `width`.
If the width of `x` is already larger than the specified `width`, the nesting
level is increased by the specified `width` and a `line` is appended.

To import and use `fillBreak` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.fillBreak
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

type Signature = [name: string, type: string]

const signatures: Array<Signature> = [
  ["empty", "Doc"],
  ["nest", "Int -> Doc -> Doc"],
  ["fillSep", "[Doc] -> Doc"]
]

const prettySignature = <A>([name, type]: Signature): Doc.Doc<A> =>
  Doc.hsep([pipe(Doc.text(name), Doc.fillBreak(5)), Doc.text("::"), Doc.text(type)])

const doc = Doc.hsep([Doc.text("let"), Doc.align(Doc.vcat(signatures.map(prettySignature)))])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|let empty :: Doc
     |    nest  :: Int -> Doc -> Doc
     |    fillSep
     |          :: [Doc] -> Doc`
  )
)
```

**Signature**

```ts
export declare const fillBreak: { (w: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, w: number): Doc<A> }
```


# fillCat

The `fillCat` combinator concatenates all documents in a collection
horizontally by placing a `empty` between each pair of documents as long as
they fit the page. Once the page width is exceeded, a `lineBreak` is inserted
and the process is repeated for all documents in the collection.

**Note**: the use of `lineBreak` means that if `group`ed, the documents will
be separated with `empty` instead of newlines. See `fillSep` if you want a
`space` instead.

To import and use `fillCat` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.fillCat
```

**Signature**

```ts
export declare const fillCat: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```


# fillSep

The `fillSep` combinator concatenates all documents in a collection
horizontally by placing a `space` between each pair of documents as long as
they fit the page. Once the page width is exceeded, a `line` is inserted and
the process is repeated for all documents in the collection.

**Note**: the use of `line` means that if `group`ed, the documents will be
separated with a `space` instead of newlines. See `fillCat` if you do not
want a `space`.

To import and use `fillSep` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.fillSep
```

**Signature**

```ts
export declare const fillSep: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```


# flatAlt

The `flatAlt` document will render `left` by default. However, when
`group`ed, `y` will be preferred with `left` as the fallback for cases where
`y` does not fit onto the page.

**NOTE**:
Users should be careful to ensure that `left` is less wide than `right`.
Otherwise, if `right` ends up not fitting the page, then the layout
algorithms will fall back to an even wider layout.

To import and use `flatAlt` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.flatAlt
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const open = pipe(Doc.empty, Doc.flatAlt(Doc.text("{ ")))
const close = pipe(Doc.empty, Doc.flatAlt(Doc.text(" }")))
const separator = pipe(Doc.empty, Doc.flatAlt(Doc.text("; ")))

const prettyDo = <A>(documents: Array<Doc.Doc<A>>): Doc.Doc<A> => {
  return pipe(Doc.hsep([Doc.text("do"), pipe(documents, Doc.encloseSep(open, close, separator), Doc.align)]), Doc.group)
}

const statements = [
  Doc.text("name:_ <- getArgs"),
  Doc.text('let greet = "Hello, " <> name'),
  Doc.text("putStrLn greet")
]

// If it fits, then the content is put onto a single line with the `{;}` style
assert.strictEqual(
  pipe(
    prettyDo(statements),
    Doc.render({
      style: "pretty",
      options: { lineWidth: 80 }
    })
  ),
  'do { name:_ <- getArgs; let greet = "Hello, " <> name; putStrLn greet }'
)

// When there is not enough space, the content is broken up onto multiple lines
assert.strictEqual(
  pipe(
    prettyDo(statements),
    Doc.render({
      style: "pretty",
      options: { lineWidth: 10 }
    })
  ),
  String.stripMargin(
    `|do name:_ <- getArgs
     |   let greet = "Hello, " <> name
     |   putStrLn greet`
  )
)
```

**Signature**

```ts
export declare const flatAlt: {
  <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>
  <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>
}
```


# FlatAlt

Represents a flattened alternative of two documents. The layout algorithms
will choose the first document, but when flattened (via `group`) the second
document will be preferreinternal.

The layout algorithms operate under the assumption that the first alternative
is less wide than the flattened second alternative.

To import and use `FlatAlt` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.FlatAlt
```


# flatten

Flattens a document but does not report changes.

To import and use `flatten` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.flatten
```

**Signature**

```ts
export declare const flatten: <A>(self: Doc<A>) => Doc<A>
```


# group

The `group` combinator attempts to lay out a document onto a single line by
removing the contained line breaks. If the result does not fit the page, or
if a `hardLine` prevents flattening the document, `x` is laid out without
any changes.

The `group` function is key to layouts that adapt to available space nicely.

To import and use `group` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.group
```

**Signature**

```ts
export declare const group: <A>(self: Doc<A>) => Doc<A>
```


# hang

The `hang` combinator lays out a document with the nesting level set to
the _current column_ plus the specified `indent`. Negative values for
`indent` are allowed and decrease the nesting level accordingly.

This differs from the `nest` combinator, which is based on the _current
nesting level_ plus the specified `indent`. When you"re not sure, try the
more efficient combinator (`nest`) first.

To import and use `hang` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.hang
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc = Doc.hsep([Doc.text("prefix"), pipe(Doc.reflow("Indenting these words with hang"), Doc.hang(4))])

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 24 }
  }),
  String.stripMargin(
    `|prefix Indenting these
     |           words with
     |           hang`
  )
)
```

**Signature**

```ts
export declare const hang: { (indent: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, indent: number): Doc<A> }
```


# hardLine

The `hardLine` document is always laid out as a line break, regardless of
space or whether or not the document was `group`"ed.

To import and use `hardLine` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.hardLine
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat([Doc.text("lorem ipsum"), Doc.hardLine, Doc.text("dolor sit amet")])

// Even with enough space, a line break is introduced
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 1000 }
  }),
  String.stripMargin(
    `|lorem ipsum
     |dolor sit amet`
  )
)
```

**Signature**

```ts
export declare const hardLine: Doc<never>
```


# hcat

The `hcat` combinator concatenates all documents in a collection horizontally
without any spacing.

To import and use `hcat` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.hcat
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat(Doc.words("lorem ipsum dolor"))

assert.strictEqual(Doc.render(doc, { style: "pretty" }), "loremipsumdolor")
```

**Signature**

```ts
export declare const hcat: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```


# hsep

The `hsep` combinator concatenates all documents in a collection horizontally
by placing a `space` between each pair of documents.

For automatic line breaks, consider using `fillSep`.

To import and use `hsep` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.hsep
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"

const doc: Doc.Doc<never> = Doc.hsep(Doc.words("lorem ipsum dolor sit amet"))

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 80 }
  }),
  "lorem ipsum dolor sit amet"
)

// The `hsep` combinator will not introduce line breaks on its own, even when
// the page is too narrow
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 5 }
  }),
  "lorem ipsum dolor sit amet"
)
```

**Signature**

```ts
export declare const hsep: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```


# indent

The `indent` combinator indents a document by the specified `indent`
beginning from the current cursor position.

To import and use `indent` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.indent
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc = Doc.hcat([Doc.text("prefix"), pipe(Doc.reflow("The indent function indents these words!"), Doc.indent(4))])

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 24 }
  }),
  String.stripMargin(
    `|prefix    The indent
     |          function
     |          indents these
     |          words!`
  )
)
```

**Signature**

```ts
export declare const indent: {
  (indent: number): <A>(self: Doc<A>) => Doc<A>
  <A>(self: Doc<A>, indent: number): Doc<A>
}
```


# isAnnotated

Returns `true` if the specified `Doc` is a `Annotated`, `false` otherwise.

To import and use `isAnnotated` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.isAnnotated
```

**Signature**

```ts
export declare const isAnnotated: <A>(self: Doc<A>) => self is Annotated<A>
```


# isCat

Returns `true` if the specified `Doc` is a `Cat`, `false` otherwise.

To import and use `isCat` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.isCat
```

**Signature**

```ts
export declare const isCat: <A>(self: Doc<A>) => self is Cat<A>
```


# isChar

Returns `true` if the specified `Doc` is a `Char`, `false` otherwise.

To import and use `isChar` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.isChar
```

**Signature**

```ts
export declare const isChar: <A>(self: Doc<A>) => self is Char<A>
```


# isColumn

Returns `true` if the specified `Doc` is a `Column`, `false` otherwise.

To import and use `isColumn` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.isColumn
```

**Signature**

```ts
export declare const isColumn: <A>(self: Doc<A>) => self is Column<A>
```


# isDoc

Returns `true` if the specified value is a `Doc`, `false` otherwise.

To import and use `isDoc` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.isDoc
```

**Signature**

```ts
export declare const isDoc: (u: unknown) => u is Doc<unknown>
```


# isEmpty

Returns `true` if the specified `Doc` is an `Empty`, `false` otherwise.

To import and use `isEmpty` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.isEmpty
```

**Signature**

```ts
export declare const isEmpty: <A>(self: Doc<A>) => self is Empty<A>
```


# isFail

Returns `true` if the specified `Doc` is a `Fail`, `false` otherwise.

To import and use `isFail` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.isFail
```

**Signature**

```ts
export declare const isFail: <A>(self: Doc<A>) => self is Fail<A>
```


# isFlatAlt

Returns `true` if the specified `Doc` is a `FlatAlt`, `false` otherwise.

To import and use `isFlatAlt` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.isFlatAlt
```

**Signature**

```ts
export declare const isFlatAlt: <A>(self: Doc<A>) => self is FlatAlt<A>
```


# isLine

Returns `true` if the specified `Doc` is a `Line`, `false` otherwise.

To import and use `isLine` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.isLine
```

**Signature**

```ts
export declare const isLine: <A>(self: Doc<A>) => self is Line<A>
```


# isNest

Returns `true` if the specified `Doc` is a `Nest`, `false` otherwise.

To import and use `isNest` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.isNest
```

**Signature**

```ts
export declare const isNest: <A>(self: Doc<A>) => self is Nest<A>
```


# isNesting

Returns `true` if the specified `Doc` is a `Nesting`, `false` otherwise.

To import and use `isNesting` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.isNesting
```

**Signature**

```ts
export declare const isNesting: <A>(self: Doc<A>) => self is Nesting<A>
```


# isText

Returns `true` if the specified `Doc` is a `Text`, `false` otherwise.

To import and use `isText` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.isText
```

**Signature**

```ts
export declare const isText: <A>(self: Doc<A>) => self is Text<A>
```


# isUnion

Returns `true` if the specified `Doc` is a `Union`, `false` otherwise.

To import and use `isUnion` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.isUnion
```

**Signature**

```ts
export declare const isUnion: <A>(self: Doc<A>) => self is Union<A>
```


# isWithPageWidth

Returns `true` if the specified `Doc` is a `WithPageWidth`, `false` otherwise.

To import and use `isWithPageWidth` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.isWithPageWidth
```

**Signature**

```ts
export declare const isWithPageWidth: <A>(self: Doc<A>) => self is WithPageWidth<A>
```


# langle

A document containing a single `<` character.

To import and use `langle` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.langle
```

**Signature**

```ts
export declare const langle: Doc<never>
```


# lbrace

A document containing a single `{` character.

To import and use `lbrace` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.lbrace
```

**Signature**

```ts
export declare const lbrace: Doc<never>
```


# lbracket

A document containing a single `[` character.

To import and use `lbracket` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.lbracket
```

**Signature**

```ts
export declare const lbracket: Doc<never>
```


# line

The `line` document advances to the next line and indents to the current
nesting level. However, `line` will behave like `space` if the line break is
undone by `group`.

To import and use `line` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.line
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat([Doc.text("lorem ipsum"), Doc.line, Doc.text("dolor sit amet")])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|lorem ipsum
     |dolor sit amet`
  )
)
assert.strictEqual(Doc.render(Doc.group(doc), { style: "pretty" }), "lorem ipsum dolor sit amet")
```

**Signature**

```ts
export declare const line: Doc<never>
```


# Line

Represents a document that contains a hard line break.

To import and use `Line` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.Line
```


# lineBreak

The `lineBreak` document is like `line` but behaves like `empty` if the line
break is undone by `group` (instead of `space`).

To import and use `lineBreak` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.lineBreak
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat([Doc.text("lorem ipsum"), Doc.lineBreak, Doc.text("dolor sit amet")])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|lorem ipsum
     |dolor sit amet`
  )
)
assert.strictEqual(Doc.render(Doc.group(doc), { style: "pretty" }), "lorem ipsumdolor sit amet")
```

**Signature**

```ts
export declare const lineBreak: Doc<never>
```


# list

A Haskell-inspired variant of `encloseSep` that uses a comma as the separator
and braces as the enclosure for a collection of documents.

To import and use `list` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.list
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"

const doc = Doc.list(["1", "20", "300", "4000"].map((n) => (n.length === 1 ? Doc.char(n) : Doc.text(n))))

assert.strictEqual(Doc.render(doc, { style: "pretty" }), "[1, 20, 300, 4000]")
```

**Signature**

```ts
export declare const list: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```


# lparen

A document containing a single `(` character.

To import and use `lparen` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.lparen
```

**Signature**

```ts
export declare const lparen: Doc<never>
```


# nest

Lays out a document with the current nesting level (indentation
of the following lines) increased by the specified `indent`.
Negative values are allowed and will decrease the nesting level
accordingly.

See also:

- `hang`: nest a document relative to the current cursor
  position instead of the current nesting level
- `align`: set the nesting level to the current cursor
  position
- `indent`: increase the indentation on the spot, padding
  any empty space with spaces

To import and use `nest` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.nest
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc = Doc.vsep([pipe(Doc.vsep(Doc.words("lorem ipsum dolor")), Doc.nest(4)), Doc.text("sit"), Doc.text("amet")])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|lorem
     |    ipsum
     |    dolor
     |sit
     |amet`
  )
)
```

**Signature**

```ts
export declare const nest: { (indent: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, indent: number): Doc<A> }
```


# Nest

Represents a document that is indented by a certain number of columns.

To import and use `Nest` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.Nest
```


# nesting

Lays out a document depending upon the current nesting level (i.e., the
current indentation of the document).

To import and use `nesting` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.nesting
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc = Doc.hsep([Doc.text("prefix"), Doc.nesting((l) => Doc.squareBracketed(Doc.text(`Nested: ${l}`)))])

const example = Doc.vsep([0, 4, 8].map((n) => Doc.indent(n)(doc)))

assert.strictEqual(
  Doc.render(example, { style: "pretty" }),
  String.stripMargin(
    `|prefix [Nested: 0]
     |    prefix [Nested: 4]
     |        prefix [Nested: 8]`
  )
)
```

**Signature**

```ts
export declare const nesting: <A>(react: (level: number) => Doc<A>) => Doc<A>
```


# Nesting

Represents a document that reacts to the current nesting level.

To import and use `Nesting` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.Nesting
```


# pageWidth

Lays out a document according to the document"s`PageWidth`.

To import and use `pageWidth` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.pageWidth
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc = Doc.hsep([
  Doc.text("prefix"),
  Doc.pageWidth((pageWidth) => {
    switch (pageWidth._tag) {
      case "AvailablePerLine": {
        const { lineWidth, ribbonFraction } = pageWidth
        return Doc.squareBracketed(Doc.text(`Width: ${lineWidth}, Ribbon Fraction: ${ribbonFraction}`))
      }
      case "Unbounded": {
        return Doc.empty
      }
    }
  })
])

const example = Doc.vsep([0, 4, 8].map((n) => Doc.indent(n)(doc)))

assert.strictEqual(
  Doc.render(example, {
    style: "pretty",
    options: { lineWidth: 32 }
  }),
  String.stripMargin(
    `|prefix [Width: 32, Ribbon Fraction: 1]
     |    prefix [Width: 32, Ribbon Fraction: 1]
     |        prefix [Width: 32, Ribbon Fraction: 1]`
  )
)
```

**Signature**

```ts
export declare const pageWidth: <A>(react: (pageWidth: PageWidth) => Doc<A>) => Doc<A>
```


# parenthesized

Encloses the input document in parentheses (`()`).

To import and use `parenthesized` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.parenthesized
```

**Signature**

```ts
export declare const parenthesized: <A>(self: Doc<A>) => Doc<A>
```


# punctuate

The `punctuate` combinator appends the `punctuator` document to all but the
last document in a collection of documents. The separators are places after
the document entries, which can be observed if the result is oriented
vertically.

To import and use `punctuate` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.punctuate
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const docs = pipe(Doc.words("lorem ipsum dolor sit amet"), Doc.punctuate(Doc.comma))

assert.strictEqual(Doc.render(Doc.hsep(docs), { style: "pretty" }), "lorem, ipsum, dolor, sit, amet")

// The separators are put at the end of the entries, which can be better
// visualzied if the documents are rendered vertically
assert.strictEqual(
  Doc.render(Doc.vsep(docs), { style: "pretty" }),
  String.stripMargin(
    `|lorem,
     |ipsum,
     |dolor,
     |sit,
     |amet`
  )
)
```

**Signature**

```ts
export declare const punctuate: {
  <A, B>(punctuator: Doc<A>): (docs: Iterable<Doc<B>>) => ReadonlyArray<Doc<A | B>>
  <A, B>(docs: Iterable<Doc<B>>, punctuator: Doc<A>): ReadonlyArray<Doc<A | B>>
}
```


# rangle

A document containing a single `>` character.

To import and use `rangle` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.rangle
```

**Signature**

```ts
export declare const rangle: Doc<never>
```


# rbrace

A document containing a single `}` character.

To import and use `rbrace` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.rbrace
```

**Signature**

```ts
export declare const rbrace: Doc<never>
```


# rbracket

A document containing a single `]` character.

To import and use `rbracket` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.rbracket
```

**Signature**

```ts
export declare const rbracket: Doc<never>
```


# reAnnotate

Changes the annotation of a document. Useful for modifying documents embedded
with one form of annotation with a more general annotation.

**Note** that with each invocation, the entire document tree is traversed.
If possible, it is preferable to reannotate a document after producing the
layout using `reAnnotateS`.

To import and use `reAnnotate` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.reAnnotate
```

**Signature**

```ts
export declare const reAnnotate: {
  <A, B>(f: (a: A) => B): (self: Doc<A>) => Doc<B>
  <A, B>(self: Doc<A>, f: (a: A) => B): Doc<B>
}
```


# reflow

Splits a string of words into individual `Text` documents using the specified
`char` to split on (defaults to `" "`). In addition, a `softLine` is inserted
in between each word so that if the text exceeds the available width it will
be broken into multiple lines.

To import and use `reflow` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.reflow
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc = Doc.reflow(
  "Lorem ipsum dolor sit amet, consectetur adipisicing elit, " +
    "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
)

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 32 }
  }),
  String.stripMargin(
    `|Lorem ipsum dolor sit amet,
     |consectetur adipisicing elit,
     |sed do eiusmod tempor incididunt
     |ut labore et dolore magna
     |aliqua.`
  )
)
```

**Signature**

```ts
export declare const reflow: (s: string, char?: string) => Doc<never>
```


# rparen

A document containing a single `)` character.

To import and use `rparen` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.rparen
```

**Signature**

```ts
export declare const rparen: Doc<never>
```


# semi

A document containing a single `;` character.

To import and use `semi` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.semi
```

**Signature**

```ts
export declare const semi: Doc<never>
```


# seps

The `seps` combinator will attempt to lay out a collection of documents
separated by `space`s. If the output does not fit the page, then the
documents will be separated by newlines. This is what differentiates it from
`vsep`, which always lays out documents beneath one another.

To import and use `seps` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.seps
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hsep([Doc.text("prefix"), Doc.seps(Doc.words("text to lay out"))])

assert.strictEqual(Doc.render(doc, { style: "pretty" }), "prefix text to lay out")

// If the page width is too narrow, documents are separated by newlines
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 20 }
  }),
  String.stripMargin(
    `|prefix text
     |to
     |lay
     |out`
  )
)
```

**Signature**

```ts
export declare const seps: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```


# singleQuoted

Encloses the input document in single quotes (`""`).

To import and use `singleQuoted` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.singleQuoted
```

**Signature**

```ts
export declare const singleQuoted: <A>(self: Doc<A>) => Doc<A>
```


# slash

A document containing a single `/` character.

To import and use `slash` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.slash
```

**Signature**

```ts
export declare const slash: Doc<never>
```


# softLine

The `softLine` document behaves like `space` if the resulting output fits
onto the page, otherwise it behaves like `line`.

To import and use `softLine` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.softLine
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat([Doc.text("lorem ipsum"), Doc.softLine, Doc.text("dolor sit amet")])

// Here we have enough space to put everything onto one line
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 80 }
  }),
  "lorem ipsum dolor sit amet"
)

// If the page width is narrowed to `10`, the layout algorithm will
// introduce a line break
assert.strictEqual(
  Doc.render(Doc.group(doc), {
    style: "pretty",
    options: { lineWidth: 10 }
  }),
  String.stripMargin(
    `|lorem ipsum
     |dolor sit amet`
  )
)
```

**Signature**

```ts
export declare const softLine: Doc<never>
```


# softLineBreak

The `softLineBreak` document is similar to `softLine`, but behaves like
`empty` if the resulting output does not fit onto the page (instead of
`space`).

To import and use `softLineBreak` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.softLineBreak
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat([Doc.text("ThisText"), Doc.softLineBreak, Doc.text("IsWayTooLong")])

// With enough space, we get direct concatenation of documents:
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 80 }
  }),
  "ThisTextIsWayTooLong"
)

// If the page width is narrowed to `10`, the layout algorithm will
// introduce a line break
assert.strictEqual(
  Doc.render(Doc.group(doc), {
    style: "pretty",
    options: { lineWidth: 10 }
  }),
  String.stripMargin(
    `|ThisText
     |IsWayTooLong`
  )
)
```

**Signature**

```ts
export declare const softLineBreak: Doc<never>
```


# space

A document containing a single ` ` character.

To import and use `space` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.space
```

**Signature**

```ts
export declare const space: Doc<never>
```


# spaces

The `spaces` combinator lays out a document containing `n` spaces. Negative
values for `n` count as `0` spaces.

To import and use `spaces` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.spaces
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"

const doc = Doc.squareBracketed(Doc.doubleQuoted(Doc.spaces(5)))

assert.strictEqual(Doc.render(doc, { style: "pretty" }), '["     "]')
```

**Signature**

```ts
export declare const spaces: (n: number) => Doc<never>
```


# squareBracketed

Encloses the input document in square brackets (`[]`).

To import and use `squareBracketed` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.squareBracketed
```

**Signature**

```ts
export declare const squareBracketed: <A>(self: Doc<A>) => Doc<A>
```


# squote

A document containing a single `"` character.

To import and use `squote` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.squote
```

**Signature**

```ts
export declare const squote: Doc<never>
```


# string

Constructs a document containing a string of text.

**Note**: newline characters (`\n`) contained in the provided string will be
disregarded (i.e. not rendered) in the output document.

To import and use `string` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.string
```

**Signature**

```ts
export declare const string: (str: string) => Doc<never>
```


# surround

The `surround` combinator encloses a document in between `left` and `right`
documents.

To import and use `surround` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.surround
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"

const doc = pipe(Doc.char("-"), Doc.surround(Doc.char("A"), Doc.char("Z")))

assert.strictEqual(Doc.render(doc, { style: "pretty" }), "A-Z")
```

**Signature**

```ts
export declare const surround: {
  <A, B, C>(left: Doc<A>, right: Doc<B>): (self: Doc<C>) => Doc<A | B | C>
  <A, B, C>(self: Doc<C>, left: Doc<A>, right: Doc<B>): Doc<A | B | C>
}
```


# text

A document containing a string of text.

**Invariants**

- Text cannot be less than two characters long
- Text cannot contain a newline (`"\n"`) character

To import and use `text` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.text
```

**Signature**

```ts
export declare const text: (text: string) => Doc<never>
```


# Text

Represents a document containing a string of text.

**Invariants**

- Text cannot be less than two characters long
- Text cannot contain a newline (`"\n"`) character

To import and use `Text` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.Text
```


# tupled

A Haskell-inspired variant of `encloseSep` that uses a comma as the separator
and parentheses as the enclosure for a collection of documents.

To import and use `tupled` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.tupled
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"

const doc = Doc.tupled(["1", "20", "300", "4000"].map((n) => (n.length === 1 ? Doc.char(n) : Doc.text(n))))

assert.strictEqual(Doc.render(doc, { style: "pretty" }), "(1, 20, 300, 4000)")
```

**Signature**

```ts
export declare const tupled: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```


# unAnnotate

Removes all annotations from a document.

**Note**: with each invocation, the entire document tree is traversed.
If possible, it is preferable to unannotate a document after producing the
layout using `unAnnotateS`.

To import and use `unAnnotate` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.unAnnotate
```

**Signature**

```ts
export declare const unAnnotate: <A>(self: Doc<A>) => Doc<never>
```


# Union

Represents the union of two documents. Used to implement layout alternatives
for `group`.

**Invariants**

- The first lines of the first document should be longer than the first lines
  of the second document so that the layout algorithm can pick the document
  with the best fit.

To import and use `Union` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.Union
```


# vbar

A document containing a single `|` character.

To import and use `vbar` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.vbar
```

**Signature**

```ts
export declare const vbar: Doc<never>
```


# vcat

The `vcat` combinator concatenates all documents in a collection vertically.
If the output is grouped then the line breaks are removed.

In other words `vcat` is like `vsep`, with newlines removed instead of
replaced by spaces.

To import and use `vcat` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.vcat
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.vcat(Doc.words("lorem ipsum dolor"))

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|lorem
     |ipsum
     |dolor`
  )
)
```

**Signature**

```ts
export declare const vcat: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```


# vsep

The `vsep` combinator concatenates all documents in a collection vertically.
If a `group` undoes the line breaks inserted by `vsep`, the documents are
separated with a space instead.

When a `vsep` is `group`ed, the documents are separated with a `space` if the
layoutfits the page, otherwise nothing is done. See the `sep` convenience
function for this use case.

To import and use `vsep` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.vsep
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const unaligned = Doc.hsep([Doc.text("prefix"), Doc.vsep(Doc.words("text to lay out"))])

assert.strictEqual(
  Doc.render(unaligned, { style: "pretty" }),
  String.stripMargin(
    `|prefix text
     |to
     |lay
     |out`
  )
)

// The `align` function can be used to align the documents under their first
// element
const aligned = Doc.hsep([Doc.text("prefix"), Doc.align(Doc.vsep(Doc.words("text to lay out")))])

assert.strictEqual(
  Doc.render(aligned, { style: "pretty" }),
  String.stripMargin(
    `|prefix text
     |       to
     |       lay
     |       out`
  )
)
```

**Signature**

```ts
export declare const vsep: <A>(docs: Iterable<Doc<A>>) => Doc<A>
```


# width

The `width` combinator makes the column width of a document available to the
document while rendering.

To import and use `width` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.width
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const annotate = <A>(doc: Doc.Doc<A>): Doc.Doc<A> =>
  pipe(
    Doc.squareBracketed(doc),
    Doc.width((w) => Doc.text(` <- width: ${w}`))
  )

const docs = [
  Doc.text("---"),
  Doc.text("------"),
  Doc.indent(Doc.text("---"), 3),
  Doc.vsep([Doc.text("---"), Doc.indent(Doc.text("---"), 4)])
]

const doc = Doc.align(Doc.vsep(docs.map(annotate)))

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|[---] <- width: 5
     |[------] <- width: 8
     |[   ---] <- width: 8
     |[---
     |    ---] <- width: 8`
  )
)
```

**Signature**

```ts
export declare const width: {
  <A, B>(react: (width: number) => Doc<B>): (self: Doc<A>) => Doc<A | B>
  <A, B>(self: Doc<A>, react: (width: number) => Doc<B>): Doc<A | B>
}
```


# WithPageWidth

Represents a document that reacts to the current page width.

To import and use `WithPageWidth` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.WithPageWidth
```


# words

Splits a string of words into individual `Text` documents using the
specified `char` to split on (defaults to `" "`).

To import and use `words` from the "Doc" module:

```ts
import * as Doc from "@effect/printer/Doc"
// Can be accessed like this
Doc.words
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"

const doc = Doc.tupled(Doc.words("lorem ipsum dolor"))

assert.strictEqual(Doc.render(doc, { style: "pretty" }), "(lorem, ipsum, dolor)")
```

**Signature**

```ts
export declare const words: (s: string, char?: string) => ReadonlyArray<Doc<never>>
```


# alterAnnotations

Changes the annotation of a document to a different annotation, or to
none at all.

To import and use `alterAnnotations` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.alterAnnotations
```

**Signature**

```ts
export declare const alterAnnotations: {
  <A, B>(f: (a: A) => Option<B>): (self: DocStream<A>) => DocStream<B>
  <A, B>(self: DocStream<A>, f: (a: A) => Option<B>): DocStream<B>
}
```


# CharStream

Represents a `Doc` containing a single character.

To import and use `CharStream` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.CharStream
```


# DocStream

Represents a document that has been laid out and can be processed used by the
rendering algorithms.

A simplified view is that a `Doc` is equivalent to an array of `DocStream`,
and the layout algorithms simply pick a `DocStream` based upon which instance
best fits the layout constraints. Therefore, a `DocStream` has all complexity
contained in a `Doc` resolved, making it very easy to convert to other
formats, such as plaintext or terminal output.

To import and use `DocStream` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.DocStream
```


# EmptyStream

Represents the an empty `Doc`.

To import and use `EmptyStream` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.EmptyStream
```


# FailedStream

Represents a `Doc` that failed to be laid out.

To import and use `FailedStream` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.FailedStream
```


# isCharStream

Returns `true` if the specified `DocStream` is a `CharStream`, `false` otherwise.

To import and use `isCharStream` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.isCharStream
```

**Signature**

```ts
export declare const isCharStream: <A>(self: DocStream<A>) => self is CharStream<A>
```


# isDocStream

Returns `true` if the specified value is a `DocStream`, `false` otherwise.

To import and use `isDocStream` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.isDocStream
```

**Signature**

```ts
export declare const isDocStream: (u: unknown) => u is DocStream<unknown>
```


# isEmptyStream

Returns `true` if the specified `DocStream` is a `EmptyStream`, `false` otherwise.

To import and use `isEmptyStream` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.isEmptyStream
```

**Signature**

```ts
export declare const isEmptyStream: <A>(self: DocStream<A>) => self is EmptyStream<A>
```


# isFailedStream

Returns `true` if the specified `DocStream` is a `FailedStream`, `false` otherwise.

To import and use `isFailedStream` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.isFailedStream
```

**Signature**

```ts
export declare const isFailedStream: <A>(self: DocStream<A>) => self is FailedStream<A>
```


# isLineStream

Returns `true` if the specified `DocStream` is a `LineStream`, `false` otherwise.

To import and use `isLineStream` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.isLineStream
```

**Signature**

```ts
export declare const isLineStream: <A>(self: DocStream<A>) => self is LineStream<A>
```


# isPopAnnotationStream

Returns `true` if the specified `DocStream` is a `PopAnnotationStream`, `false` otherwise.

To import and use `isPopAnnotationStream` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.isPopAnnotationStream
```

**Signature**

```ts
export declare const isPopAnnotationStream: <A>(self: DocStream<A>) => self is PopAnnotationStream<A>
```


# isPushAnnotationStream

Returns `true` if the specified `DocStream` is a `PushAnnotationStream`, `false` otherwise.

To import and use `isPushAnnotationStream` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.isPushAnnotationStream
```

**Signature**

```ts
export declare const isPushAnnotationStream: <A>(self: DocStream<A>) => self is PushAnnotationStream<A>
```


# isTextStream

Returns `true` if the specified `DocStream` is a `TextStream`, `false` otherwise.

To import and use `isTextStream` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.isTextStream
```

**Signature**

```ts
export declare const isTextStream: <A>(self: DocStream<A>) => self is TextStream<A>
```


# LineStream

Represents a `Doc` containing a single line. The `indentation`
represents the indentation level for the subsequent line in the
`Doc`.

To import and use `LineStream` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.LineStream
```


# PopAnnotationStream

Represents the removal of a previously pushed annotation from a `Doc`.

To import and use `PopAnnotationStream` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.PopAnnotationStream
```


# PushAnnotationStream

Represents the addition of an annotation of type `A` to a `Doc`.

To import and use `PushAnnotationStream` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.PushAnnotationStream
```


# reAnnotate

Modify the annotations of a document.

To import and use `reAnnotate` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.reAnnotate
```

**Signature**

```ts
export declare const reAnnotate: {
  <A, B>(f: (a: A) => B): (self: DocStream<A>) => DocStream<B>
  <A, B>(self: DocStream<A>, f: (a: A) => B): DocStream<B>
}
```


# TextStream

Represents a `Doc` containing a string of text.

To import and use `TextStream` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.TextStream
```


# unAnnotate

Remove all annotations from a document.

To import and use `unAnnotate` from the "DocStream" module:

```ts
import * as DocStream from "@effect/printer/DocStream"
// Can be accessed like this
DocStream.unAnnotate
```

**Signature**

```ts
export declare const unAnnotate: <A>(self: DocStream<A>) => DocStream<never>
```


# alterAnnotations

Change the annotation of a document to a different annotation, or none at
all.

To import and use `alterAnnotations` from the "DocTree" module:

```ts
import * as DocTree from "@effect/printer/DocTree"
// Can be accessed like this
DocTree.alterAnnotations
```

**Signature**

```ts
export declare const alterAnnotations: {
  <A, B>(f: (a: A) => Iterable<B>): (self: DocTree<A>) => DocTree<B>
  <A, B>(self: DocTree<A>, f: (a: A) => Iterable<B>): DocTree<B>
}
```


# annotation

Annotate the specified `DocTree` with an annotation of type `A`.

To import and use `annotation` from the "DocTree" module:

```ts
import * as DocTree from "@effect/printer/DocTree"
// Can be accessed like this
DocTree.annotation
```

**Signature**

```ts
export declare const annotation: {
  <A>(annotation: A): <B>(self: DocTree<B>) => DocTree<A | B>
  <A, B>(self: DocTree<A>, annotation: B): DocTree<A | B>
}
```


# concat

Horizontally concatenates multiple `DocTree`s.

To import and use `concat` from the "DocTree" module:

```ts
import * as DocTree from "@effect/printer/DocTree"
// Can be accessed like this
DocTree.concat
```

**Signature**

```ts
export declare const concat: <A>(trees: ReadonlyArray<DocTree<A>>) => DocTree<A>
```


# DocTree

Represents a document that has been laid out into a tree-like structure.

A `DocStream` is a linked list of different annotated cons cells (i.e.
`TextStream` and then some further `DocStream`, `LineStream` and then some
further `DocStream`, etc.). The `DocStream` format is quite suitable as a
target for a layout engine, but is not suitable for rendering to a more
structured format, such as HTML, where we do not want to perform a lookahead
until the end of some pre-defined markup. These formats would benefit more
from a tree-like structure that explicitly marks its contents as annotated.
A `DocTree` is therefore much more suitable for this use case.

To import and use `DocTree` from the "DocTree" module:

```ts
import * as DocTree from "@effect/printer/DocTree"
// Can be accessed like this
DocTree.DocTree
```


# isAnnotationTree

Returns `true` if the specified `DocTree` is an `AnnotationTree`, `false` otherwise.

To import and use `isAnnotationTree` from the "DocTree" module:

```ts
import * as DocTree from "@effect/printer/DocTree"
// Can be accessed like this
DocTree.isAnnotationTree
```

**Signature**

```ts
export declare const isAnnotationTree: <A>(self: DocTree<A>) => self is AnnotationTree<A>
```


# isCharTree

Returns `true` if the specified `DocTree` is an `CharTree`, `false` otherwise.

To import and use `isCharTree` from the "DocTree" module:

```ts
import * as DocTree from "@effect/printer/DocTree"
// Can be accessed like this
DocTree.isCharTree
```

**Signature**

```ts
export declare const isCharTree: <A>(self: DocTree<A>) => self is CharTree<A>
```


# isConcatTree

Returns `true` if the specified `DocTree` is an `ConcatTree`, `false` otherwise.

To import and use `isConcatTree` from the "DocTree" module:

```ts
import * as DocTree from "@effect/printer/DocTree"
// Can be accessed like this
DocTree.isConcatTree
```

**Signature**

```ts
export declare const isConcatTree: <A>(self: DocTree<A>) => self is ConcatTree<A>
```


# isDocTree

Returns `true` if the specified value is a `DocTree`, `false` otherwise.

To import and use `isDocTree` from the "DocTree" module:

```ts
import * as DocTree from "@effect/printer/DocTree"
// Can be accessed like this
DocTree.isDocTree
```

**Signature**

```ts
export declare const isDocTree: (u: unknown) => u is DocTree<unknown>
```


# isEmptyTree

Returns `true` if the specified `DocTree` is an `EmptyTree`, `false` otherwise.

To import and use `isEmptyTree` from the "DocTree" module:

```ts
import * as DocTree from "@effect/printer/DocTree"
// Can be accessed like this
DocTree.isEmptyTree
```

**Signature**

```ts
export declare const isEmptyTree: <A>(self: DocTree<A>) => self is EmptyTree<A>
```


# isLineTree

Returns `true` if the specified `DocTree` is an `LineTree`, `false` otherwise.

To import and use `isLineTree` from the "DocTree" module:

```ts
import * as DocTree from "@effect/printer/DocTree"
// Can be accessed like this
DocTree.isLineTree
```

**Signature**

```ts
export declare const isLineTree: <A>(self: DocTree<A>) => self is LineTree<A>
```


# isTextTree

Returns `true` if the specified `DocTree` is an `TextTree`, `false` otherwise.

To import and use `isTextTree` from the "DocTree" module:

```ts
import * as DocTree from "@effect/printer/DocTree"
// Can be accessed like this
DocTree.isTextTree
```

**Signature**

```ts
export declare const isTextTree: <A>(self: DocTree<A>) => self is TextTree<A>
```


# reAnnotate

Change the annotation of a `DocTree`.

To import and use `reAnnotate` from the "DocTree" module:

```ts
import * as DocTree from "@effect/printer/DocTree"
// Can be accessed like this
DocTree.reAnnotate
```

**Signature**

```ts
export declare const reAnnotate: {
  <A, B>(f: (a: A) => B): (self: DocTree<A>) => DocTree<B>
  <A, B>(self: DocTree<A>, f: (a: A) => B): DocTree<B>
}
```


# renderSimplyDecorated

The simplest possible tree-based renderer.

For example, here is a document annotated with `void` and thee behavior is
to surround annotated regions with >>> and <<<.

To import and use `renderSimplyDecorated` from the "DocTree" module:

```ts
import * as DocTree from "@effect/printer/DocTree"
// Can be accessed like this
DocTree.renderSimplyDecorated
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as DocTree from "@effect/printer/DocTree"
import * as Layout from "@effect/printer/Layout"
import { identity, pipe } from "effect/Function"
import * as String from "@effect/typeclass/data/String"

const doc: Doc.Doc<void> = Doc.hsep([
  Doc.text("hello"),
  pipe(Doc.text("world"), Doc.annotate(undefined), Doc.cat(Doc.char("!")))
])

const tree = DocTree.treeForm(Layout.pretty(Layout.defaultOptions)(doc))

const rendered = pipe(
  tree,
  DocTree.renderSimplyDecorated(String.Monoid, identity, (_, x) => `>>>${x}<<<`)
)

assert.strictEqual(rendered, "hello >>>world<<<!")
```

**Signature**

```ts
export declare const renderSimplyDecorated: {
  <A, M>(
    M: monoid.Monoid<M>,
    renderText: (text: string) => M,
    renderAnnotation: (annotation: A, out: M) => M
  ): (self: DocTree<A>) => M
  <A, M>(
    self: DocTree<A>,
    M: monoid.Monoid<M>,
    renderText: (text: string) => M,
    renderAnnotation: (annotation: A, out: M) => M
  ): M
}
```


# treeForm

Converts a `DocStream<A>` into a `DocTree<A>`.

To import and use `treeForm` from the "DocTree" module:

```ts
import * as DocTree from "@effect/printer/DocTree"
// Can be accessed like this
DocTree.treeForm
```

**Signature**

```ts
export declare const treeForm: <A>(stream: DocStream.DocStream<A>) => DocTree<A>
```


# unAnnotate

Remove all annotations from a `DocTree`.

To import and use `unAnnotate` from the "DocTree" module:

```ts
import * as DocTree from "@effect/printer/DocTree"
// Can be accessed like this
DocTree.unAnnotate
```

**Signature**

```ts
export declare const unAnnotate: <A>(self: DocTree<A>) => DocTree<never>
```


# between

Checks if a `Duration` is between a `minimum` and `maximum` value.

To import and use `between` from the "Duration" module:

```ts
import * as Duration from "effect/Duration"
// Can be accessed like this
Duration.between
```

**Signature**

```ts
export declare const between: {
  (options: { minimum: DurationInput; maximum: DurationInput }): (self: DurationInput) => boolean
  (self: DurationInput, options: { minimum: DurationInput; maximum: DurationInput }): boolean
}
```


# format

Converts a `Duration` to a human readable string.

To import and use `format` from the "Duration" module:

```ts
import * as Duration from "effect/Duration"
// Can be accessed like this
Duration.format
```

**Example**

```ts
import { Duration } from "effect"

Duration.format(Duration.millis(1000)) // "1s"
Duration.format(Duration.millis(1001)) // "1s 1ms"
```

**Signature**

```ts
export declare const format: (self: DurationInput) => string
```


# formatIso

Formats a Duration into an ISO8601 duration string.

Months are assumed to be 30 days and years are assumed to be 365 days.

Returns `Option.none()` if the duration is infinite.

To import and use `formatIso` from the "Duration" module:

```ts
import * as Duration from "effect/Duration"
// Can be accessed like this
Duration.formatIso
```

**Example**

```ts
import { Duration, Option } from "effect"

Duration.formatIso(Duration.days(1)) // => Option.some("P1D")
Duration.formatIso(Duration.minutes(90)) // => Option.some("PT1H30M")
Duration.formatIso(Duration.millis(1500)) // => Option.some("PT1.5S")
Duration.formatIso(Duration.infinity) // => Option.none()
```

**Signature**

```ts
export declare const formatIso: (self: DurationInput) => Option.Option<string>
```


# fromIso

Parses an ISO8601 duration string into a `Duration`.

Months are assumed to be 30 days and years are assumed to be 365 days.

To import and use `fromIso` from the "Duration" module:

```ts
import * as Duration from "effect/Duration"
// Can be accessed like this
Duration.fromIso
```

**Example**

```ts
import { Duration, Option } from "effect"

Duration.fromIso("P1D") // => Option.some(Duration.days(1))
Duration.fromIso("PT1H") // => Option.some(Duration.hours(1))
Duration.fromIso("PT1M") // => Option.some(Duration.minutes(1))
Duration.fromIso("PT1.5S") // => Option.some(Duration.seconds(1.5))
```

**Signature**

```ts
export declare const fromIso: (iso: string) => Option.Option<Duration>
```


# parts

Converts a `Duration` to its parts.

To import and use `parts` from the "Duration" module:

```ts
import * as Duration from "effect/Duration"
// Can be accessed like this
Duration.parts
```

**Signature**

```ts
export declare const parts: (self: DurationInput) => {
  days: number
  hours: number
  minutes: number
  seconds: number
  millis: number
  nanos: number
}
```


# toNanos

Get the duration in nanoseconds as a bigint.

If the duration is infinite, returns `Option.none()`

To import and use `toNanos` from the "Duration" module:

```ts
import * as Duration from "effect/Duration"
// Can be accessed like this
Duration.toNanos
```

**Signature**

```ts
export declare const toNanos: (self: DurationInput) => Option.Option<bigint>
```


# unsafeFormatIso

Formats a Duration into an ISO8601 duration string.

The ISO8601 duration format is generally specified as P[n]Y[n]M[n]DT[n]H[n]M[n]S. However, since
the `Duration` type does not support years or months, this function will only output the days, hours,
minutes and seconds. Thus, the effective format is P[n]DT[n]H[n]M[n]S.

Milliseconds and nanoseconds are expressed as fractional seconds.

To import and use `unsafeFormatIso` from the "Duration" module:

```ts
import * as Duration from "effect/Duration"
// Can be accessed like this
Duration.unsafeFormatIso
```

**Example**

```ts
import { Duration } from "effect"

Duration.unsafeFormatIso(Duration.days(1)) // => "P1D"
Duration.unsafeFormatIso(Duration.minutes(90)) // => "PT1H30M"
Duration.unsafeFormatIso(Duration.millis(1500)) // => "PT1.5S"
```

**Signature**

```ts
export declare const unsafeFormatIso: (self: DurationInput) => string
```


# unsafeToNanos

Get the duration in nanoseconds as a bigint.

If the duration is infinite, it throws an error.

To import and use `unsafeToNanos` from the "Duration" module:

```ts
import * as Duration from "effect/Duration"
// Can be accessed like this
Duration.unsafeToNanos
```

**Signature**

```ts
export declare const unsafeToNanos: (self: DurationInput) => bigint
```


# acquireRelease

Creates a scoped resource using an `acquire` and `release` effect.

**Details**

This function helps manage resources by combining two `Effect` values: one
for acquiring the resource and one for releasing it.

`acquireRelease` does the following:

1. Ensures that the effect that acquires the resource will not be
   interrupted. Note that acquisition may still fail due to internal
   reasons (such as an uncaught exception).
2. Ensures that the `release` effect will not be interrupted, and will be
   executed as long as the acquisition effect successfully acquires the
   resource.

If the `acquire` function succeeds, the `release` function is added to the
list of finalizers for the scope. This ensures that the release will happen
automatically when the scope is closed.

Both `acquire` and `release` run uninterruptibly, meaning they cannot be
interrupted while they are executing.

Additionally, the `release` function can be influenced by the exit value when
the scope closes, allowing for custom handling of how the resource is
released based on the execution outcome.

**When to Use**

This function is used to ensure that an effect that represents the
acquisition of a resource (for example, opening a file, launching a thread,
etc.) will not be interrupted, and that the resource will always be released
when the `Effect` completes execution.

To import and use `acquireRelease` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.acquireRelease
```

**Example**

```ts
// Title: Defining a Simple Resource
import { Effect } from "effect"

// Define an interface for a resource
interface MyResource {
  readonly contents: string
  readonly close: () => Promise<void>
}

// Simulate resource acquisition
const getMyResource = (): Promise<MyResource> =>
  Promise.resolve({
    contents: "lorem ipsum",
    close: () =>
      new Promise((resolve) => {
        console.log("Resource released")
        resolve()
      })
  })

// Define how the resource is acquired
const acquire = Effect.tryPromise({
  try: () =>
    getMyResource().then((res) => {
      console.log("Resource acquired")
      return res
    }),
  catch: () => new Error("getMyResourceError")
})

// Define how the resource is released
const release = (res: MyResource) => Effect.promise(() => res.close())

// Create the resource management workflow
//
//       Effect<MyResource, Error, Scope>
//      
const resource = Effect.acquireRelease(acquire, release)
```

**Signature**

```ts
export declare const acquireRelease: {
  <A, X, R2>(
    release: (a: A, exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>
  ): <E, R>(acquire: Effect<A, E, R>) => Effect<A, E, Scope.Scope | R2 | R>
  <A, E, R, X, R2>(
    acquire: Effect<A, E, R>,
    release: (a: A, exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>
  ): Effect<A, E, Scope.Scope | R | R2>
}
```


# acquireReleaseInterruptible

Creates a scoped resource with an interruptible acquire action.

**Details**

This function is similar to {@link acquireRelease}, but it allows the
acquisition of the resource to be interrupted. The `acquire` effect, which
represents the process of obtaining the resource, can be interrupted if
necessary.

To import and use `acquireReleaseInterruptible` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.acquireReleaseInterruptible
```

**Signature**

```ts
export declare const acquireReleaseInterruptible: {
  <X, R2>(
    release: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>
  ): <A, E, R>(acquire: Effect<A, E, R>) => Effect<A, E, Scope.Scope | R2 | R>
  <A, E, R, X, R2>(
    acquire: Effect<A, E, R>,
    release: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>
  ): Effect<A, E, Scope.Scope | R | R2>
}
```


# acquireUseRelease

Creates a scoped resource and automatically handles the use effect during the
scope.

**Details**

This function is similar to {@link acquireRelease}, but it introduces an
additional `use` effect. This allows you to automatically execute the `use`
effect while the resource is acquired, and it also ensures that the `release`
effect is performed when the scope is closed.

The `acquire` effect is used to obtain the resource, the `use` effect
operates while the resource is in use, and the `release` effect cleans up the
resource when the scope ends.

To import and use `acquireUseRelease` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.acquireUseRelease
```

**Example**

```ts
// Title: Automatically Managing Resource Lifetime
import { Effect, Console } from "effect"

// Define an interface for a resource
interface MyResource {
  readonly contents: string
  readonly close: () => Promise<void>
}

// Simulate resource acquisition
const getMyResource = (): Promise<MyResource> =>
  Promise.resolve({
    contents: "lorem ipsum",
    close: () =>
      new Promise((resolve) => {
        console.log("Resource released")
        resolve()
      })
  })

// Define how the resource is acquired
const acquire = Effect.tryPromise({
  try: () =>
    getMyResource().then((res) => {
      console.log("Resource acquired")
      return res
    }),
  catch: () => new Error("getMyResourceError")
})

// Define how the resource is released
const release = (res: MyResource) => Effect.promise(() => res.close())

const use = (res: MyResource) => Console.log(`content is ${res.contents}`)

//       Effect<void, Error, never>
//      
const program = Effect.acquireUseRelease(acquire, use, release)

// Effect.runPromise(program)
// Output:
// Resource acquired
// content is lorem ipsum
// Resource released
```

**Signature**

```ts
export declare const acquireUseRelease: {
  <A2, E2, R2, A, X, R3>(
    use: (a: A) => Effect<A2, E2, R2>,
    release: (a: A, exit: Exit.Exit<A2, E2>) => Effect<X, never, R3>
  ): <E, R>(acquire: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R3 | R>
  <A, E, R, A2, E2, R2, X, R3>(
    acquire: Effect<A, E, R>,
    use: (a: A) => Effect<A2, E2, R2>,
    release: (a: A, exit: Exit.Exit<A2, E2>) => Effect<X, never, R3>
  ): Effect<A2, E | E2, R | R2 | R3>
}
```


# addFinalizer

Ensures a finalizer is added to the scope of the calling effect, guaranteeing
it runs when the scope is closed.

**Details**

This function adds a finalizer that will execute whenever the scope of the
effect is closed, regardless of whether the effect succeeds, fails, or is
interrupted. The finalizer receives the `Exit` value of the effect's scope,
allowing it to react differently depending on how the effect concludes.

Finalizers are a reliable way to manage resource cleanup, ensuring that
resources such as file handles, network connections, or database transactions
are properly closed even in the event of an unexpected interruption or error.

Finalizers operate in conjunction with Effect's scoped resources. If an
effect with a finalizer is wrapped in a scope, the finalizer will execute
automatically when the scope ends.

To import and use `addFinalizer` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.addFinalizer
```

**Example**

```ts
// Title: Adding a Finalizer on Success
import { Effect, Console } from "effect"

//       Effect<string, never, Scope>
//      
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) => Console.log(`Finalizer executed. Exit status: ${exit._tag}`))
  return "some result"
})

// Wrapping the effect in a scope
//
//       Effect<string, never, never>
//      
const runnable = Effect.scoped(program)

// Effect.runPromiseExit(runnable).then(console.log)
// Output:
// Finalizer executed. Exit status: Success
// { _id: 'Exit', _tag: 'Success', value: 'some result' }
```

**Example**

```ts
// Title: Adding a Finalizer on Failure
import { Effect, Console } from "effect"

//       Effect<never, string, Scope>
//      
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) => Console.log(`Finalizer executed. Exit status: ${exit._tag}`))
  return yield* Effect.fail("Uh oh!")
})

// Wrapping the effect in a scope
//
//       Effect<never, string, never>
//      
const runnable = Effect.scoped(program)

// Effect.runPromiseExit(runnable).then(console.log)
// Output:
// Finalizer executed. Exit status: Failure
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }
// }
```

**Example**

```ts
// Title: Adding a Finalizer on Interruption
import { Effect, Console } from "effect"

//       Effect<never, never, Scope>
//      
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) => Console.log(`Finalizer executed. Exit status: ${exit._tag}`))
  return yield* Effect.interrupt
})

// Wrapping the effect in a scope
//
//       Effect<never, never, never>
//      
const runnable = Effect.scoped(program)

// Effect.runPromiseExit(runnable).then(console.log)
// Output:
// Finalizer executed. Exit status: Failure
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Interrupt',
//     fiberId: {
//       _id: 'FiberId',
//       _tag: 'Runtime',
//       id: 0,
//       startTimeMillis: ...
//     }
//   }
// }
```

**Signature**

```ts
export declare const addFinalizer: <X, R>(
  finalizer: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R>
) => Effect<void, never, Scope.Scope | R>
```


# all

Combines multiple effects into one, returning results based on the input
structure.

**Details**

Use this function when you need to run multiple effects and combine their
results into a single output. It supports tuples, iterables, structs, and
records, making it flexible for different input types.

For instance, if the input is a tuple:

```ts
//          a tuple of effects
//         
Effect.all([effect1, effect2, ...])
```

the effects are executed sequentially, and the result is a new effect
containing the results as a tuple. The results in the tuple match the order
of the effects passed to `Effect.all`.

**Concurrency**

You can control the execution order (e.g., sequential vs. concurrent) using
the `concurrency` option.

**Short-Circuiting Behavior**

This function stops execution on the first error it encounters, this is
called "short-circuiting". If any effect in the collection fails, the
remaining effects will not run, and the error will be propagated. To change
this behavior, you can use the `mode` option, which allows all effects to run
and collect results as `Either` or `Option`.

**The `mode` option**

The `{ mode: "either" }` option changes the behavior of `Effect.all` to
ensure all effects run, even if some fail. Instead of stopping on the first
failure, this mode collects both successes and failures, returning an array
of `Either` instances where each result is either a `Right` (success) or a
`Left` (failure).

Similarly, the `{ mode: "validate" }` option uses `Option` to indicate
success or failure. Each effect returns `None` for success and `Some` with
the error for failure.

To import and use `all` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.all
```

**Example**

```ts
// Title: Combining Effects in Tuples
import { Effect, Console } from "effect"

const tupleOfEffects = [
  Effect.succeed(42).pipe(Effect.tap(Console.log)),
  Effect.succeed("Hello").pipe(Effect.tap(Console.log))
] as const

//       Effect<[number, string], never, never>
//      
const resultsAsTuple = Effect.all(tupleOfEffects)

// Effect.runPromise(resultsAsTuple).then(console.log)
// Output:
// 42
// Hello
// [ 42, 'Hello' ]
```

**Example**

```ts
// Title: Combining Effects in Iterables
import { Effect, Console } from "effect"

const iterableOfEffects: Iterable<Effect.Effect<number>> = [1, 2, 3].map((n) =>
  Effect.succeed(n).pipe(Effect.tap(Console.log))
)

//       Effect<number[], never, never>
//      
const resultsAsArray = Effect.all(iterableOfEffects)

// Effect.runPromise(resultsAsArray).then(console.log)
// Output:
// 1
// 2
// 3
// [ 1, 2, 3 ]
```

**Example**

```ts
// Title: Combining Effects in Structs
import { Effect, Console } from "effect"

const structOfEffects = {
  a: Effect.succeed(42).pipe(Effect.tap(Console.log)),
  b: Effect.succeed("Hello").pipe(Effect.tap(Console.log))
}

//       Effect<{ a: number; b: string; }, never, never>
//      
const resultsAsStruct = Effect.all(structOfEffects)

// Effect.runPromise(resultsAsStruct).then(console.log)
// Output:
// 42
// Hello
// { a: 42, b: 'Hello' }
```

**Example**

```ts
// Title: Combining Effects in Records
import { Effect, Console } from "effect"

const recordOfEffects: Record<string, Effect.Effect<number>> = {
  key1: Effect.succeed(1).pipe(Effect.tap(Console.log)),
  key2: Effect.succeed(2).pipe(Effect.tap(Console.log))
}

//       Effect<{ [x: string]: number; }, never, never>
//      
const resultsAsRecord = Effect.all(recordOfEffects)

// Effect.runPromise(resultsAsRecord).then(console.log)
// Output:
// 1
// 2
// { key1: 1, key2: 2 }
```

**Example**

```ts
// Title: Short-Circuiting Behavior
import { Effect, Console } from "effect"

const program = Effect.all([
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  // Won't execute due to earlier failure
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
])

// Effect.runPromiseExit(program).then(console.log)
// Output:
// Task1
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Task2: Oh no!' }
// }
```

**Example**

```ts
// Title: Collecting Results with `mode: "either"`
import { Effect, Console } from "effect"

const effects = [
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
]

const program = Effect.all(effects, { mode: "either" })

// Effect.runPromiseExit(program).then(console.log)
// Output:
// Task1
// Task3
// {
//   _id: 'Exit',
//   _tag: 'Success',
//   value: [
//     { _id: 'Either', _tag: 'Right', right: 'Task1' },
//     { _id: 'Either', _tag: 'Left', left: 'Task2: Oh no!' },
//     { _id: 'Either', _tag: 'Right', right: 'Task3' }
//   ]
// }
```

**Example**

```ts
//Example: Collecting Results with `mode: "validate"`
import { Effect, Console } from "effect"

const effects = [
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
]

const program = Effect.all(effects, { mode: "validate" })

// Effect.runPromiseExit(program).then((result) => console.log("%o", result))
// Output:
// Task1
// Task3
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: [
//       { _id: 'Option', _tag: 'None' },
//       { _id: 'Option', _tag: 'Some', value: 'Task2: Oh no!' },
//       { _id: 'Option', _tag: 'None' }
//     ]
//   }
// }
```

**Signature**

```ts
export declare const all: <
  const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>,
  O extends {
    readonly concurrency?: Concurrency | undefined
    readonly batching?: boolean | "inherit" | undefined
    readonly discard?: boolean | undefined
    readonly mode?: "default" | "validate" | "either" | undefined
    readonly concurrentFinalizers?: boolean | undefined
  }
>(
  arg: Arg,
  options?: O
) => All.Return<Arg, O>
```


# allowInterrupt

Allows interruption of the current fiber, even in uninterruptible regions.

**Details**

This effect checks whether any other fibers are attempting to interrupt the
current fiber. If so, it allows the current fiber to perform a
self-interruption.

**When to Use**

This is useful in situations where you want to allow interruption to happen
even in regions of the code that are normally uninterruptible.

To import and use `allowInterrupt` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.allowInterrupt
```

**Signature**

```ts
export declare const allowInterrupt: Effect<void, never, never>
```


# allSuccesses

Evaluates and runs each effect in the iterable, collecting only the
successful results while discarding failures.

**Details**

This function function processes an iterable of effects and runs each one. If
an effect is successful, its result is collected; if it fails, the result is
discarded. This ensures that only successful outcomes are kept.

**Options**

The function also allows you to customize how the effects are handled by
specifying options such as concurrency, batching, and how finalizers behave.
These options provide flexibility in running the effects concurrently or
adjusting other execution details.

To import and use `allSuccesses` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.allSuccesses
```

**Example**

```ts
import { Effect } from "effect"

const tasks = [Effect.succeed(1), Effect.fail("Error 1"), Effect.succeed(2), Effect.fail("Error 2")]

const program = Effect.gen(function* () {
  const successfulResults = yield* Effect.allSuccesses(tasks)
  console.log(successfulResults)
})

// Effect.runFork(program)
// Output: [1, 2]
```

**Signature**

```ts
export declare const allSuccesses: <X extends Effect<any, any, any>>(
  elements: Iterable<X>,
  options?:
    | {
        readonly concurrency?: Concurrency | undefined
        readonly batching?: boolean | "inherit" | undefined
        readonly concurrentFinalizers?: boolean | undefined
      }
    | undefined
) => Effect<Array<Effect.Success<X>>, never, Effect.Context<X>>
```


# allWith

A data-last version of {@link all}, designed for use in pipelines.

**When to Use**

This function enables you to combine multiple effects and customize execution
options such as concurrency levels. This version is useful in functional
pipelines where you first define your data and then apply operations to it.

To import and use `allWith` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.allWith
```

**Example**

```ts
import { Effect, pipe } from "effect"

const task1 = Effect.succeed(1).pipe(Effect.delay("200 millis"), Effect.tap(Effect.log("task1 done")))

const task2 = Effect.succeed("hello").pipe(Effect.delay("100 millis"), Effect.tap(Effect.log("task2 done")))

const program = pipe(
  [task1, task2],
  // Run both effects concurrently using the concurrent option
  Effect.allWith({ concurrency: 2 })
)

// Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#3 message="task2 done"
// timestamp=... level=INFO fiber=#2 message="task1 done"
// [ 1, 'hello' ]
```

**Signature**

```ts
export declare const allWith: <
  O extends {
    readonly concurrency?: Concurrency | undefined
    readonly batching?: boolean | "inherit" | undefined
    readonly discard?: boolean | undefined
    readonly mode?: "default" | "validate" | "either" | undefined
    readonly concurrentFinalizers?: boolean | undefined
  }
>(
  options?: O
) => <const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>>(
  arg: Arg
) => All.Return<Arg, O>
```


# andThen

Chains two actions, where the second action can depend on the result of the
first.

**Syntax**

```ts
const transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))
// or
const transformedEffect = Effect.andThen(myEffect, anotherEffect)
// or
const transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))
```

**When to Use**

Use `andThen` when you need to run multiple actions in sequence, with the
second action depending on the result of the first. This is useful for
combining effects or handling computations that must happen in order.

**Details**

The second action can be:

- A constant value (similar to {@link as})
- A function returning a value (similar to {@link map})
- A `Promise`
- A function returning a `Promise`
- An `Effect`
- A function returning an `Effect` (similar to {@link flatMap})

**Note:** `andThen` works well with both `Option` and `Either` types,
treating them as effects.

To import and use `andThen` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.andThen
```

**Example**

```ts
// Title: Applying a Discount Based on Fetched Amount
import { pipe, Effect } from "effect"

// Function to apply a discount safely to a transaction amount
const applyDiscount = (total: number, discountRate: number): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

// Using Effect.map and Effect.flatMap
const result1 = pipe(
  fetchTransactionAmount,
  Effect.map((amount) => amount * 2),
  Effect.flatMap((amount) => applyDiscount(amount, 5))
)

// Effect.runPromise(result1).then(console.log)
// Output: 190

// Using Effect.andThen
const result2 = pipe(
  fetchTransactionAmount,
  Effect.andThen((amount) => amount * 2),
  Effect.andThen((amount) => applyDiscount(amount, 5))
)

// Effect.runPromise(result2).then(console.log)
// Output: 190
```

**Signature**

```ts
export declare const andThen: {
  <A, X>(
    f: (a: NoInfer<A>) => X
  ): <E, R>(
    self: Effect<A, E, R>
  ) => [X] extends [Effect<infer A1, infer E1, infer R1>]
    ? Effect<A1, E | E1, R | R1>
    : [X] extends [PromiseLike<infer A1>]
      ? Effect<A1, E | Cause.UnknownException, R>
      : Effect<X, E, R>
  <X>(
    f: NotFunction<X>
  ): <A, E, R>(
    self: Effect<A, E, R>
  ) => [X] extends [Effect<infer A1, infer E1, infer R1>]
    ? Effect<A1, E | E1, R | R1>
    : [X] extends [PromiseLike<infer A1>]
      ? Effect<A1, E | Cause.UnknownException, R>
      : Effect<X, E, R>
  <A, E, R, X>(
    self: Effect<A, E, R>,
    f: (a: NoInfer<A>) => X
  ): [X] extends [Effect<infer A1, infer E1, infer R1>]
    ? Effect<A1, E | E1, R | R1>
    : [X] extends [PromiseLike<infer A1>]
      ? Effect<A1, E | Cause.UnknownException, R>
      : Effect<X, E, R>
  <A, E, R, X>(
    self: Effect<A, E, R>,
    f: NotFunction<X>
  ): [X] extends [Effect<infer A1, infer E1, infer R1>]
    ? Effect<A1, E | E1, R | R1>
    : [X] extends [PromiseLike<infer A1>]
      ? Effect<A1, E | Cause.UnknownException, R>
      : Effect<X, E, R>
}
```


# annotateCurrentSpan

Adds annotations to the currently active span for traceability.

**Details**

This function adds key-value annotations to the currently active span in the
effect's trace. These annotations help provide more context about the
operation being executed at a specific point in time. Unlike
{@link annotateSpans}, which applies to all spans in an effect, this function
focuses solely on the active span.

You can either pass a single key-value pair or a record of key-value pairs to
annotate the span. These annotations are useful for adding metadata to
operations, especially in systems with detailed observability requirements.

To import and use `annotateCurrentSpan` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.annotateCurrentSpan
```

**Signature**

```ts
export declare const annotateCurrentSpan: {
  (key: string, value: unknown): Effect<void>
  (values: Record<string, unknown>): Effect<void>
}
```


# annotateLogs

Adds custom annotations to log entries generated within an effect.

**Details**

This function allows you to enhance log messages by appending additional
context in the form of key-value pairs. These annotations are included in
every log message created during the execution of the effect, making the logs
more informative and easier to trace.

The annotations can be specified as a single key-value pair or as a record of
multiple key-value pairs. This is particularly useful for tracking
operations, debugging, or associating specific metadata with logs for better
observability.

The annotated key-value pairs will appear alongside the log message in the
output.

To import and use `annotateLogs` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.annotateLogs
```

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.log("message1")
  yield* Effect.log("message2")
}).pipe(Effect.annotateLogs("taskId", "1234")) // Annotation as key/value pair

// Effect.runFork(program)
// timestamp=... level=INFO fiber=#0 message=message1 taskId=1234
// timestamp=... level=INFO fiber=#0 message=message2 taskId=1234
```

**Signature**

```ts
export declare const annotateLogs: {
  (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>
  (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>
  <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>
}
```


# annotateLogsScoped

Adds log annotations with a limited scope to enhance contextual logging.

**Details**

This function allows you to apply key-value annotations to log entries
generated within a specific scope of your effect computations. The
annotations are restricted to the defined `Scope`, ensuring that they are
only applied to logs produced during that scope. Once the scope ends, the
annotations are automatically removed, making it easier to manage
context-specific logging without affecting other parts of your application.

The annotations can be provided as a single key-value pair or as a record of
multiple key-value pairs. This flexibility enables fine-grained control over
the additional metadata included in logs for specific tasks or operations.

To import and use `annotateLogsScoped` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.annotateLogsScoped
```

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.log("no annotations")
  yield* Effect.annotateLogsScoped({ key: "value" })
  yield* Effect.log("message1") // Annotation is applied to this log
  yield* Effect.log("message2") // Annotation is applied to this log
}).pipe(Effect.scoped, Effect.andThen(Effect.log("no annotations again")))

// Effect.runFork(program)
// timestamp=... level=INFO fiber=#0 message="no annotations"
// timestamp=... level=INFO fiber=#0 message=message1 key=value
// timestamp=... level=INFO fiber=#0 message=message2 key=value
// timestamp=... level=INFO fiber=#0 message="no annotations again"
```

**Signature**

```ts
export declare const annotateLogsScoped: {
  (key: string, value: unknown): Effect<void, never, Scope.Scope>
  (values: Record<string, unknown>): Effect<void, never, Scope.Scope>
}
```


# annotateSpans

Adds annotations to each span in the effect for enhanced traceability.

**Details**

This function lets you attach key-value annotations to all spans generated
during the execution of an effect. Annotations provide additional context,
such as metadata or labels, which can help you understand and debug
asynchronous workflows more effectively.

You can either pass a single key-value pair or a record of key-value pairs to
annotate the spans. These annotations can then be visualized in tracing tools
that support span annotations.

To import and use `annotateSpans` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.annotateSpans
```

**Signature**

```ts
export declare const annotateSpans: {
  (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>
  (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>
  <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>
}
```


# ap

Applies the function produced by one effect to the value produced by another effect.

**Details**

This function combines two effects:

- The first effect produces a function of type `(a: A) => B`.
- The second effect produces a value of type `A`.

Once both effects complete successfully, the function is applied to the value, resulting in an effect that produces a value of type `B`.

To import and use `ap` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.ap
```

**Signature**

```ts
export declare const ap: {
  <A, E2, R2>(that: Effect<A, E2, R2>): <B, R, E>(self: Effect<(a: A) => B, E, R>) => Effect<B, E | E2, R | R2>
  <A, B, E, R, E2, R2>(self: Effect<(a: A) => B, E, R>, that: Effect<A, E2, R2>): Effect<B, E | E2, R | R2>
}
```


# as

Replaces the value inside an effect with a constant value.

**Details**

This function allows you to ignore the original value inside an effect and
replace it with a constant value.

**When to Use**

It is useful when you no longer need the value produced by an effect but want
to ensure that the effect completes successfully with a specific constant
result instead. For instance, you can replace the value produced by a
computation with a predefined value, ignoring what was calculated before.

To import and use `as` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.as
```

**Example**

```ts
// Title: Replacing a Value
import { pipe, Effect } from "effect"

// Replaces the value 5 with the constant "new value"
const program = pipe(Effect.succeed(5), Effect.as("new value"))

// Effect.runPromise(program).then(console.log)
// Output: "new value"
```

**Signature**

```ts
export declare const as: {
  <B>(value: B): <A, E, R>(self: Effect<A, E, R>) => Effect<B, E, R>
  <A, E, R, B>(self: Effect<A, E, R>, value: B): Effect<B, E, R>
}
```


# asSome

This function maps the success value of an `Effect` value to a `Some` value
in an `Option` value. If the original `Effect` value fails, the returned
`Effect` value will also fail.

To import and use `asSome` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.asSome
```

**Signature**

```ts
export declare const asSome: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>
```


# asSomeError

This function maps the error value of an `Effect` value to a `Some` value
in an `Option` value. If the original `Effect` value succeeds, the returned
`Effect` value will also succeed.

To import and use `asSomeError` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.asSomeError
```

**Signature**

```ts
export declare const asSomeError: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Option.Option<E>, R>
```


# asVoid

This function maps the success value of an `Effect` value to `void`. If the
original `Effect` value succeeds, the returned `Effect` value will also
succeed. If the original `Effect` value fails, the returned `Effect` value
will fail with the same error.

To import and use `asVoid` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.asVoid
```

**Signature**

```ts
export declare const asVoid: <A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>
```


# async

Creates an `Effect` from a callback-based asynchronous function.

**Details**

The `resume` function:

- Must be called exactly once. Any additional calls will be ignored.
- Can return an optional `Effect` that will be run if the `Fiber` executing
  this `Effect` is interrupted. This can be useful in scenarios where you
  need to handle resource cleanup if the operation is interrupted.
- Can receive an `AbortSignal` to handle interruption if needed.

The `FiberId` of the fiber that may complete the async callback may also be
specified using the `blockingOn` argument. This is called the "blocking
fiber" because it suspends the fiber executing the `async` effect (i.e.
semantically blocks the fiber from making progress). Specifying this fiber id
in cases where it is known will improve diagnostics, but not affect the
behavior of the returned effect.

**When to Use**

Use `Effect.async` when dealing with APIs that use callback-style instead of
`async/await` or `Promise`.

To import and use `async` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.async
```

**Example**

```ts
// Title: Wrapping a Callback API
import { Effect } from "effect"
import * as NodeFS from "node:fs"

const readFile = (filename: string) =>
  Effect.async<Buffer, Error>((resume) => {
    NodeFS.readFile(filename, (error, data) => {
      if (error) {
        // Resume with a failed Effect if an error occurs
        resume(Effect.fail(error))
      } else {
        // Resume with a succeeded Effect if successful
        resume(Effect.succeed(data))
      }
    })
  })

//       Effect<Buffer, Error, never>
//      
const program = readFile("example.txt")
```

**Example**

```ts
// Title: Handling Interruption with Cleanup
import { Effect, Fiber } from "effect"
import * as NodeFS from "node:fs"

// Simulates a long-running operation to write to a file
const writeFileWithCleanup = (filename: string, data: string) =>
  Effect.async<void, Error>((resume) => {
    const writeStream = NodeFS.createWriteStream(filename)

    // Start writing data to the file
    writeStream.write(data)

    // When the stream is finished, resume with success
    writeStream.on("finish", () => resume(Effect.void))

    // In case of an error during writing, resume with failure
    writeStream.on("error", (err) => resume(Effect.fail(err)))

    // Handle interruption by returning a cleanup effect
    return Effect.sync(() => {
      console.log(`Cleaning up ${filename}`)
      NodeFS.unlinkSync(filename)
    })
  })

const program = Effect.gen(function* () {
  const fiber = yield* Effect.fork(writeFileWithCleanup("example.txt", "Some long data..."))
  // Simulate interrupting the fiber after 1 second
  yield* Effect.sleep("1 second")
  yield* Fiber.interrupt(fiber) // This will trigger the cleanup
})

// Run the program
// Effect.runPromise(program)
// Output:
// Cleaning up example.txt
```

**Example**

```ts
// Title: Handling Interruption with AbortSignal
import { Effect, Fiber } from "effect"

// A task that supports interruption using AbortSignal
const interruptibleTask = Effect.async<void, Error>((resume, signal) => {
  // Handle interruption
  signal.addEventListener("abort", () => {
    console.log("Abort signal received")
    clearTimeout(timeoutId)
  })

  // Simulate a long-running task
  const timeoutId = setTimeout(() => {
    console.log("Operation completed")
    resume(Effect.void)
  }, 2000)
})

const program = Effect.gen(function* () {
  const fiber = yield* Effect.fork(interruptibleTask)
  // Simulate interrupting the fiber after 1 second
  yield* Effect.sleep("1 second")
  yield* Fiber.interrupt(fiber)
})

// Run the program
// Effect.runPromise(program)
// Output:
// Abort signal received
```

**Signature**

```ts
export declare const async: <A, E = never, R = never>(
  resume: (callback: (_: Effect<A, E, R>) => void, signal: AbortSignal) => void | Effect<void, never, R>,
  blockingOn?: FiberId.FiberId
) => Effect<A, E, R>
```


# asyncEffect

A variant of {@link async} where the registration function may return an `Effect`.

To import and use `asyncEffect` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.asyncEffect
```

**Signature**

```ts
export declare const asyncEffect: <A, E, R, R3, E2, R2>(
  register: (callback: (_: Effect<A, E, R>) => void) => Effect<Effect<void, never, R3> | void, E2, R2>
) => Effect<A, E | E2, R | R2 | R3>
```


# awaitAllChildren

Returns a new effect that will not succeed with its value before first
waiting for the end of all child fibers forked by the effect.

To import and use `awaitAllChildren` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.awaitAllChildren
```

**Signature**

```ts
export declare const awaitAllChildren: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
```


# bind

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

To import and use `bind` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.bind
```

**Example**

```ts
import { Effect, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bind("y", () => Effect.succeed(3)),
  Effect.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
```

**Signature**

```ts
export declare const bind: {
  <N extends string, A extends object, B, E2, R2>(
    name: Exclude<N, keyof A>,
    f: (a: NoInfer<A>) => Effect<B, E2, R2>
  ): <E1, R1>(self: Effect<A, E1, R1>) => Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E2 | E1, R2 | R1>
  <A extends object, N extends string, E1, R1, B, E2, R2>(
    self: Effect<A, E1, R1>,
    name: Exclude<N, keyof A>,
    f: (a: NoInfer<A>) => Effect<B, E2, R2>
  ): Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E1 | E2, R1 | R2>
}
```


# bindAll

`bindAll` combines `all` with `bind`. It is useful
when you want to concurrently run multiple effects and then combine their
results in a Do notation pipeline.

To import and use `bindAll` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.bindAll
```

**Example**

```ts
import { Effect, Either, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bindAll(
    ({ x }) => ({
      a: Effect.succeed(x),
      b: Effect.fail("oops")
    }),
    { concurrency: 2, mode: "either" }
  )
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, a: Either.right(2), b: Either.left("oops") })
```

**Signature**

```ts
export declare const bindAll: {
  <
    A extends object,
    X extends Record<string, Effect<any, any, any>>,
    O extends {
      readonly concurrency?: Concurrency | undefined
      readonly batching?: boolean | "inherit" | undefined
      readonly mode?: "default" | "validate" | "either" | undefined
      readonly concurrentFinalizers?: boolean | undefined
    }
  >(
    f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : `Duplicate keys`,
    options?: undefined | O
  ): <E1, R1>(
    self: Effect<A, E1, R1>
  ) => [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>]
    ? Effect<
        { [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never },
        E1 | Error,
        R1 | Context
      >
    : never
  <
    A extends object,
    X extends Record<string, Effect<any, any, any>>,
    O extends {
      readonly concurrency?: Concurrency | undefined
      readonly batching?: boolean | "inherit" | undefined
      readonly mode?: "default" | "validate" | "either" | undefined
      readonly concurrentFinalizers?: boolean | undefined
    },
    E1,
    R1
  >(
    self: Effect<A, E1, R1>,
    f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : `Duplicate keys`,
    options?:
      | undefined
      | {
          readonly concurrency?: Concurrency | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly mode?: "default" | "validate" | "either" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
  ): [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>]
    ? Effect<
        { [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never },
        E1 | Error,
        R1 | Context
      >
    : never
}
```


# bindTo

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

To import and use `bindTo` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.bindTo
```

**Example**

```ts
import { Effect, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bind("y", () => Effect.succeed(3)),
  Effect.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
```

**Signature**

```ts
export declare const bindTo: {
  <N extends string>(name: N): <A, E, R>(self: Effect<A, E, R>) => Effect<{ [K in N]: A }, E, R>
  <A, E, R, N extends string>(self: Effect<A, E, R>, name: N): Effect<{ [K in N]: A }, E, R>
}
```


# cached

Returns an effect that lazily computes a result and caches it for subsequent
evaluations.

**Details**

This function wraps an effect and ensures that its result is computed only
once. Once the result is computed, it is cached, meaning that subsequent
evaluations of the same effect will return the cached result without
re-executing the logic.

**When to Use**

Use this function when you have an expensive or time-consuming operation that
you want to avoid repeating. The first evaluation will compute the result,
and all following evaluations will immediately return the cached value,
improving performance and reducing unnecessary work.

To import and use `cached` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.cached
```

**Example**

```ts
import { Effect, Console } from "effect"

let i = 1
const expensiveTask = Effect.promise<string>(() => {
  console.log("expensive task...")
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`result ${i++}`)
    }, 100)
  })
})

const program = Effect.gen(function* () {
  console.log("non-cached version:")
  yield* expensiveTask.pipe(Effect.andThen(Console.log))
  yield* expensiveTask.pipe(Effect.andThen(Console.log))
  console.log("cached version:")
  const cached = yield* Effect.cached(expensiveTask)
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* cached.pipe(Effect.andThen(Console.log))
})

// Effect.runFork(program)
// Output:
// non-cached version:
// expensive task...
// result 1
// expensive task...
// result 2
// cached version:
// expensive task...
// result 3
// result 3
```

**Signature**

```ts
export declare const cached: <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E, R>>
```


# cachedFunction

Returns a memoized version of a function with effects, reusing results for
the same inputs.

**Details**

This function creates a memoized version of a given function that performs an
effect. Memoization ensures that once a result is computed for a specific
input, it is stored and reused for subsequent calls with the same input,
reducing the need to recompute the result.

The function can optionally take an `Equivalence` parameter to
determine how inputs are compared for caching purposes.

**When to Use**

Use this function when you have a function that performs an effect and you
want to avoid recomputing the result for the same input multiple times.

It's ideal for functions that produce deterministic results based on their
inputs, and you want to improve performance by caching the output.

This is particularly useful in scenarios where the function involves
expensive calculations or operations that should be avoided after the first
execution with the same parameters.

To import and use `cachedFunction` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.cachedFunction
```

**Example**

```ts
import { Effect, Random } from "effect"

const program = Effect.gen(function* () {
  const randomNumber = (n: number) => Random.nextIntBetween(1, n)
  console.log("non-memoized version:")
  console.log(yield* randomNumber(10))
  console.log(yield* randomNumber(10))

  console.log("memoized version:")
  const memoized = yield* Effect.cachedFunction(randomNumber)
  console.log(yield* memoized(10))
  console.log(yield* memoized(10))
})

// Effect.runFork(program)
// Example Output:
// non-memoized version:
// 2
// 8
// memoized version:
// 5
// 5
```

**Signature**

```ts
export declare const cachedFunction: <A, B, E, R>(
  f: (a: A) => Effect<B, E, R>,
  eq?: Equivalence<A>
) => Effect<(a: A) => Effect<B, E, R>>
```


# cachedInvalidateWithTTL

Caches an effect's result for a specified duration and allows manual
invalidation before expiration.

**Details**

This function behaves similarly to {@link cachedWithTTL} by caching the
result of an effect for a specified period of time. However, it introduces an
additional feature: it provides an effect that allows you to manually
invalidate the cached result before it naturally expires.

This gives you more control over the cache, allowing you to refresh the
result when needed, even if the original cache has not yet expired.

Once the cache is invalidated, the next time the effect is evaluated, the
result will be recomputed, and the cache will be refreshed.

**When to Use**

Use this function when you have an effect whose result needs to be cached for
a certain period, but you also want the option to refresh the cache manually
before the expiration time.

This is useful when you need to ensure that the cached data remains valid for
a certain period but still want to invalidate it if the underlying data
changes or if you want to force a recomputation.

To import and use `cachedInvalidateWithTTL` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.cachedInvalidateWithTTL
```

**Example**

```ts
import { Effect, Console } from "effect"

let i = 1
const expensiveTask = Effect.promise<string>(() => {
  console.log("expensive task...")
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`result ${i++}`)
    }, 100)
  })
})

const program = Effect.gen(function* () {
  const [cached, invalidate] = yield* Effect.cachedInvalidateWithTTL(expensiveTask, "1 hour")
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* invalidate
  yield* cached.pipe(Effect.andThen(Console.log))
})

// Effect.runFork(program)
// Output:
// expensive task...
// result 1
// result 1
// expensive task...
// result 2
```

**Signature**

```ts
export declare const cachedInvalidateWithTTL: {
  (
    timeToLive: Duration.DurationInput
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<[Effect<A, E>, Effect<void>], never, R>
  <A, E, R>(self: Effect<A, E, R>, timeToLive: Duration.DurationInput): Effect<[Effect<A, E>, Effect<void>], never, R>
}
```


# cachedWithTTL

Returns an effect that caches its result for a specified `Duration`,
known as "timeToLive" (TTL).

**Details**

This function is used to cache the result of an effect for a specified amount
of time. This means that the first time the effect is evaluated, its result
is computed and stored.

If the effect is evaluated again within the specified `timeToLive`, the
cached result will be used, avoiding recomputation.

After the specified duration has passed, the cache expires, and the effect
will be recomputed upon the next evaluation.

**When to Use**

Use this function when you have an effect that involves costly operations or
computations, and you want to avoid repeating them within a short time frame.

It's ideal for scenarios where the result of an effect doesn't change
frequently and can be reused for a specified duration.

By caching the result, you can improve efficiency and reduce unnecessary
computations, especially in performance-critical applications.

To import and use `cachedWithTTL` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.cachedWithTTL
```

**Example**

```ts
import { Effect, Console } from "effect"

let i = 1
const expensiveTask = Effect.promise<string>(() => {
  console.log("expensive task...")
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`result ${i++}`)
    }, 100)
  })
})

const program = Effect.gen(function* () {
  const cached = yield* Effect.cachedWithTTL(expensiveTask, "150 millis")
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* Effect.sleep("100 millis")
  yield* cached.pipe(Effect.andThen(Console.log))
})

// Effect.runFork(program)
// Output:
// expensive task...
// result 1
// result 1
// expensive task...
// result 2
```

**Signature**

```ts
export declare const cachedWithTTL: {
  (timeToLive: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E>, never, R>
  <A, E, R>(self: Effect<A, E, R>, timeToLive: Duration.DurationInput): Effect<Effect<A, E>, never, R>
}
```


# catch

Recovers from a specified error by catching it and handling it with a provided function.

**Details**

This function allows you to recover from specific errors that occur during
the execution of an effect. It works by catching a specific type of error
(identified by a discriminator) and then handling it using a provided
handler function. The handler can return a new effect that helps recover
from the error, allowing the program to continue. If the error doesn't
match the specified type, the function allows the original effect to
continue as it was.

To import and use `catch` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.catch
```

**Example**

```ts
import { Console, Effect } from "effect"

class NetworkError {
  readonly _tag = "NetworkError"
}
class ValidationError {
  readonly _tag = "ValidationError"
}

// Simulate an effect that may fail
const task: Effect.Effect<never, NetworkError | ValidationError, never> = Effect.fail(new NetworkError())

const program = Effect.gen(function* () {
  const result = yield* Effect.catch(task, "_tag", {
    failure: "NetworkError",
    onFailure: (error) => Effect.succeed(`recovered from error: ${error._tag}`)
  })
  console.log(`Result: ${result}`)
})

// Effect.runFork(program)
// Output: Result: recovered from error: NetworkError
```


# catchAll

Handles all errors in an effect by providing a fallback effect.

**Details**

This function catches any errors that may occur during the execution of an
effect and allows you to handle them by specifying a fallback effect. This
ensures that the program continues without failing by recovering from errors
using the provided fallback logic.

**Note**: This function only handles recoverable errors. It will not recover
from unrecoverable defects.

To import and use `catchAll` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.catchAll
```

**Example**

```ts
// Title: Providing Recovery Logic for Recoverable Errors
import { Effect, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, never, never>
//      
const recovered = program.pipe(Effect.catchAll((error) => Effect.succeed(`Recovering from ${error._tag}`)))
```

**Signature**

```ts
export declare const catchAll: {
  <E, A2, E2, R2>(f: (e: E) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>
  <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<A2, E2, R2>): Effect<A2 | A, E2, R2 | R>
}
```


# catchAllCause

Handles both recoverable and unrecoverable errors by providing a recovery
effect.

**When to Use**

The `catchAllCause` function allows you to handle all errors, including
unrecoverable defects, by providing a recovery effect. The recovery logic is
based on the `Cause` of the error, which provides detailed information about
the failure.

**When to Recover from Defects**

Defects are unexpected errors that typically shouldn't be recovered from, as
they often indicate serious issues. However, in some cases, such as
dynamically loaded plugins, controlled recovery might be needed.

To import and use `catchAllCause` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.catchAllCause
```

**Example**

```ts
// Title: Recovering from All Errors
import { Cause, Effect } from "effect"

// Define an effect that may fail with a recoverable or unrecoverable error
const program = Effect.fail("Something went wrong!")

// Recover from all errors by examining the cause
const recovered = program.pipe(
  Effect.catchAllCause((cause) =>
    Cause.isFailType(cause)
      ? Effect.succeed("Recovered from a regular error")
      : Effect.succeed("Recovered from a defect")
  )
)

// Effect.runPromise(recovered).then(console.log)
// Output: "Recovered from a regular error"
```

**Signature**

```ts
export declare const catchAllCause: {
  <E, A2, E2, R2>(
    f: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>
  ): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Effect<A, E, R>,
    f: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>
  ): Effect<A | A2, E2, R | R2>
}
```


# catchAllDefect

Recovers from all defects using a provided recovery function.

**When to Use**

There is no sensible way to recover from defects. This method should be used
only at the boundary between Effect and an external system, to transmit
information on a defect for diagnostic or explanatory purposes.

**Details**

`catchAllDefect` allows you to handle defects, which are unexpected errors
that usually cause the program to terminate. This function lets you recover
from these defects by providing a function that handles the error. However,
it does not handle expected errors (like those from {@link fail}) or
execution interruptions (like those from {@link interrupt}).

**When to Recover from Defects**

Defects are unexpected errors that typically shouldn't be recovered from, as
they often indicate serious issues. However, in some cases, such as
dynamically loaded plugins, controlled recovery might be needed.

To import and use `catchAllDefect` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.catchAllDefect
```

**Example**

```ts
// Title: Handling All Defects
import { Effect, Cause, Console } from "effect"

// Simulating a runtime error
const task = Effect.dieMessage("Boom!")

const program = Effect.catchAllDefect(task, (defect) => {
  if (Cause.isRuntimeException(defect)) {
    return Console.log(`RuntimeException defect caught: ${defect.message}`)
  }
  return Console.log("Unknown defect caught.")
})

// We get an Exit.Success because we caught all defects
// Effect.runPromiseExit(program).then(console.log)
// Output:
// RuntimeException defect caught: Boom!
// {
//   _id: "Exit",
//   _tag: "Success",
//   value: undefined
// }
```

**Signature**

```ts
export declare const catchAllDefect: {
  <A2, E2, R2>(
    f: (defect: unknown) => Effect<A2, E2, R2>
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Effect<A, E, R>,
    f: (defect: unknown) => Effect<A2, E2, R2>
  ): Effect<A | A2, E | E2, R | R2>
}
```


# catchIf

Recovers from specific errors based on a predicate.

**When to Use**

`catchIf` works similarly to {@link catchSome}, but it allows you to
recover from errors by providing a predicate function. If the predicate
matches the error, the recovery effect is applied. This function doesn't
alter the error type, so the resulting effect still carries the original
error type unless a user-defined type guard is used to narrow the type.

To import and use `catchIf` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.catchIf
```

**Example**

```ts
// Title: Catching Specific Errors with a Predicate
import { Effect, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, ValidationError, never>
//      
const recovered = program.pipe(
  Effect.catchIf(
    // Only handle HttpError errors
    (error) => error._tag === "HttpError",
    () => Effect.succeed("Recovering from HttpError")
  )
)
```

**Signature**

```ts
export declare const catchIf: {
  <E, EB extends E, A2, E2, R2>(
    refinement: Refinement<NoInfer<E>, EB>,
    f: (e: EB) => Effect<A2, E2, R2>
  ): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>
  <E, A2, E2, R2>(
    predicate: Predicate<NoInfer<E>>,
    f: (e: NoInfer<E>) => Effect<A2, E2, R2>
  ): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>
  <A, E, R, EB extends E, A2, E2, R2>(
    self: Effect<A, E, R>,
    refinement: Refinement<E, EB>,
    f: (e: EB) => Effect<A2, E2, R2>
  ): Effect<A | A2, E2 | Exclude<E, EB>, R | R2>
  <A, E, R, A2, E2, R2>(
    self: Effect<A, E, R>,
    predicate: Predicate<E>,
    f: (e: E) => Effect<A2, E2, R2>
  ): Effect<A | A2, E | E2, R | R2>
}
```


# catchSome

Catches and recovers from specific types of errors, allowing you to attempt
recovery only for certain errors.

**Details**

`catchSome` lets you selectively catch and handle errors of certain
types by providing a recovery effect for specific errors. If the error
matches a condition, recovery is attempted; if not, it doesn't affect the
program. This function doesn't alter the error type, meaning the error type
remains the same as in the original effect.

To import and use `catchSome` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.catchSome
```

**Example**

```ts
// Title: Handling Specific Errors with Effect.catchSome
import { Effect, Random, Option } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, HttpError | ValidationError, never>
//      
const recovered = program.pipe(
  Effect.catchSome((error) => {
    // Only handle HttpError errors
    if (error._tag === "HttpError") {
      return Option.some(Effect.succeed("Recovering from HttpError"))
    } else {
      return Option.none()
    }
  })
)
```

**Signature**

```ts
export declare const catchSome: {
  <E, A2, E2, R2>(
    pf: (e: NoInfer<E>) => Option.Option<Effect<A2, E2, R2>>
  ): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Effect<A, E, R>,
    pf: (e: NoInfer<E>) => Option.Option<Effect<A2, E2, R2>>
  ): Effect<A | A2, E | E2, R | R2>
}
```


# catchSomeCause

Recovers from specific causes using a provided partial function.

To import and use `catchSomeCause` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.catchSomeCause
```

**Signature**

```ts
export declare const catchSomeCause: {
  <E, A2, E2, R2>(
    f: (cause: Cause.Cause<NoInfer<E>>) => Option.Option<Effect<A2, E2, R2>>
  ): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Effect<A, E, R>,
    f: (cause: Cause.Cause<NoInfer<E>>) => Option.Option<Effect<A2, E2, R2>>
  ): Effect<A2 | A, E | E2, R2 | R>
}
```


# catchSomeDefect

Recovers from specific defects using a provided partial function.

**Details**

`catchSomeDefect` allows you to handle specific defects, which are
unexpected errors that can cause the program to stop. It uses a partial
function to catch only certain defects and ignores others. The function does
not handle expected errors (such as those caused by {@link fail}) or
interruptions in execution (like those caused by {@link interrupt}).

This function provides a way to handle certain types of defects while
allowing others to propagate and cause failure in the program.

**Note**: There is no sensible way to recover from defects. This method
should be used only at the boundary between Effect and an external system, to
transmit information on a defect for diagnostic or explanatory purposes.

**How the Partial Function Works**

The function provided to `catchSomeDefect` acts as a filter and a handler for defects:

- It receives the defect as an input.
- If the defect matches a specific condition (e.g., a certain error type), the function returns
  an `Option.some` containing the recovery logic.
- If the defect does not match, the function returns `Option.none`, allowing the defect to propagate.

To import and use `catchSomeDefect` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.catchSomeDefect
```

**Example**

```ts
// Title: Handling Specific Defects
import { Effect, Cause, Option, Console } from "effect"

// Simulating a runtime error
const task = Effect.dieMessage("Boom!")

const program = Effect.catchSomeDefect(task, (defect) => {
  if (Cause.isIllegalArgumentException(defect)) {
    return Option.some(Console.log(`Caught an IllegalArgumentException defect: ${defect.message}`))
  }
  return Option.none()
})

// Since we are only catching IllegalArgumentException
// we will get an Exit.Failure because we simulated a runtime error.
// Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Die',
//     defect: { _tag: 'RuntimeException' }
//   }
// }
```

**Signature**

```ts
export declare const catchSomeDefect: {
  <A2, E2, R2>(
    pf: (defect: unknown) => Option.Option<Effect<A2, E2, R2>>
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Effect<A, E, R>,
    pf: (defect: unknown) => Option.Option<Effect<A2, E2, R2>>
  ): Effect<A | A2, E | E2, R | R2>
}
```


# catchTag

Catches and handles specific errors by their `_tag` field, which is used as a
discriminator.

**When to Use**

`catchTag` is useful when your errors are tagged with a readonly `_tag` field
that identifies the error type. You can use this function to handle specific
error types by matching the `_tag` value. This allows for precise error
handling, ensuring that only specific errors are caught and handled.

The error type must have a readonly `_tag` field to use `catchTag`. This
field is used to identify and match errors.

To import and use `catchTag` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.catchTag
```

**Example**

```ts
// Title: Handling Errors by Tag
import { Effect, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, ValidationError, never>
//      
const recovered = program.pipe(
  // Only handle HttpError errors
  Effect.catchTag("HttpError", (_HttpError) => Effect.succeed("Recovering from HttpError"))
)
```

**Signature**

```ts
export declare const catchTag: {
  <K extends E extends { _tag: string } ? E["_tag"] : never, E, A1, E1, R1>(
    k: K,
    f: (e: NoInfer<Extract<E, { _tag: K }>>) => Effect<A1, E1, R1>
  ): <A, R>(self: Effect<A, E, R>) => Effect<A1 | A, E1 | Exclude<E, { _tag: K }>, R1 | R>
  <A, E, R, K extends E extends { _tag: string } ? E["_tag"] : never, R1, E1, A1>(
    self: Effect<A, E, R>,
    k: K,
    f: (e: Extract<E, { _tag: K }>) => Effect<A1, E1, R1>
  ): Effect<A | A1, E1 | Exclude<E, { _tag: K }>, R | R1>
}
```


# catchTags

Handles multiple errors in a single block of code using their `_tag` field.

**When to Use**

`catchTags` is a convenient way to handle multiple error types at
once. Instead of using {@link catchTag} multiple times, you can pass an
object where each key is an error type's `_tag`, and the value is the handler
for that specific error. This allows you to catch and recover from multiple
error types in a single call.

The error type must have a readonly `_tag` field to use `catchTag`. This
field is used to identify and match errors.

To import and use `catchTags` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.catchTags
```

**Example**

```ts
// Title: Handling Multiple Tagged Error Types at Once
import { Effect, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, never, never>
//      
const recovered = program.pipe(
  Effect.catchTags({
    HttpError: (_HttpError) => Effect.succeed(`Recovering from HttpError`),
    ValidationError: (_ValidationError) => Effect.succeed(`Recovering from ValidationError`)
  })
)
```

**Signature**

```ts
export declare const catchTags: {
  <
    E,
    Cases extends {
      [K in Extract<E, { _tag: string }>["_tag"]]+?: (error: Extract<E, { _tag: K }>) => Effect<any, any, any>
    } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string }>["_tag"]>]: never })
  >(
    cases: Cases
  ): <A, R>(
    self: Effect<A, E, R>
  ) => Effect<
    | A
    | {
        [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never
      }[keyof Cases],
    | Exclude<E, { _tag: keyof Cases }>
    | {
        [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never
      }[keyof Cases],
    | R
    | {
        [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never
      }[keyof Cases]
  >
  <
    R,
    E,
    A,
    Cases extends {
      [K in Extract<E, { _tag: string }>["_tag"]]+?: (error: Extract<E, { _tag: K }>) => Effect<any, any, any>
    } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string }>["_tag"]>]: never })
  >(
    self: Effect<A, E, R>,
    cases: Cases
  ): Effect<
    | A
    | {
        [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never
      }[keyof Cases],
    | Exclude<E, { _tag: keyof Cases }>
    | {
        [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never
      }[keyof Cases],
    | R
    | {
        [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never
      }[keyof Cases]
  >
}
```


# cause

Retrieves the cause of a failure in an effect.

**Details**

This function allows you to expose the detailed cause of an effect, which
includes a more precise representation of failures, such as error messages
and defects.

**When to Use**

This function is helpful when you need to inspect the cause of a failure in
an effect, giving you more information than just the error message. It can be
used to log, handle, or analyze failures in more detail, including
distinguishing between different types of defects (e.g., runtime exceptions,
interruptions, etc.).

To import and use `cause` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.cause
```

**Example**

```ts
import { Effect, Console } from "effect"

//       Effect<number, string, never>
//      
const program = Effect.fail("Oh uh!").pipe(Effect.as(2))

//       Effect<void, never, never>
//      
const recovered = Effect.gen(function* () {
  const cause = yield* Effect.cause(program)
  yield* Console.log(cause)
})
```

**Signature**

```ts
export declare const cause: <A, E, R>(self: Effect<A, E, R>) => Effect<Cause.Cause<E>, never, R>
```


# checkInterruptible

Checks if interruption is allowed and executes a callback accordingly.

**Details**

This function checks the current interrupt status of the running fiber. It
then calls the provided callback, passing a boolean indicating whether
interruption is allowed.

**When to Use**

This is useful for handling specific logic based on whether the current
operation can be interrupted, such as when performing asynchronous operations
or handling cancellation.

To import and use `checkInterruptible` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.checkInterruptible
```

**Example**

```ts
import { Console, Effect } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.checkInterruptible((isInterruptible) => {
    if (isInterruptible) {
      return Console.log("You can interrupt this operation.")
    } else {
      return Console.log("This operation cannot be interrupted.")
    }
  })
})

// Effect.runPromise(program)
// Output: You can interrupt this operation.

// Effect.runPromise(program.pipe(Effect.uninterruptible))
// Output: This operation cannot be interrupted.
```

**Signature**

```ts
export declare const checkInterruptible: <A, E, R>(f: (isInterruptible: boolean) => Effect<A, E, R>) => Effect<A, E, R>
```


# clock

Retrieves the `Clock` service from the context.

To import and use `clock` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.clock
```

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function* () {
  const clock = yield* Effect.clock
  const currentTime = yield* clock.currentTimeMillis
  console.log(`Current time in milliseconds: ${currentTime}`)
})

// Effect.runFork(program)
// Example Output:
// Current time in milliseconds: 1735484796134
```

**Signature**

```ts
export declare const clock: Effect<Clock.Clock, never, never>
```


# clockWith

Retrieves the `Clock` service from the context and provides it to the
specified effectful function.

To import and use `clockWith` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.clockWith
```

**Example**

```ts
import { Console, Effect } from "effect"

const program = Effect.clockWith((clock) =>
  clock.currentTimeMillis.pipe(
    Effect.map((currentTime) => `Current time is: ${currentTime}`),
    Effect.tap(Console.log)
  )
)

// Effect.runFork(program)
// Example Output:
// Current time is: 1735484929744
```

**Signature**

```ts
export declare const clockWith: <A, E, R>(f: (clock: Clock.Clock) => Effect<A, E, R>) => Effect<A, E, R>
```


# configProviderWith

Allows working with the default configuration provider.

**Details**

This function retrieves the default configuration provider and passes it to
the provided function, which can use it to perform computations or retrieve
configuration values. The function can return an effect that leverages the
configuration provider for its operations.

To import and use `configProviderWith` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.configProviderWith
```

**Signature**

```ts
export declare const configProviderWith: <A, E, R>(f: (provider: ConfigProvider) => Effect<A, E, R>) => Effect<A, E, R>
```


# console

Retreives the `Console` service from the context

To import and use `console` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.console
```

**Signature**

```ts
export declare const console: Effect<Console, never, never>
```


# consoleWith

Retreives the `Console` service from the context and provides it to the
specified effectful function.

To import and use `consoleWith` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.consoleWith
```

**Signature**

```ts
export declare const consoleWith: <A, E, R>(f: (console: Console) => Effect<A, E, R>) => Effect<A, E, R>
```


# context

Accesses the full context of the effect.

**Details**

This function provides the ability to access the entire context required by
an effect. The context is a container that holds dependencies or environment
values needed by an effect to run. By using this function, you can retrieve
and work with the context directly within an effect.

To import and use `context` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.context
```

**Signature**

```ts
export declare const context: <R>() => Effect<Context.Context<R>, never, R>
```


# contextWith

Accesses the context and applies a transformation function.

**Details**

This function retrieves the context of the effect and applies a pure
transformation function to it. The result of the transformation is then
returned within the effect.

To import and use `contextWith` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.contextWith
```

**Signature**

```ts
export declare const contextWith: <R, A>(f: (context: Context.Context<R>) => A) => Effect<A, never, R>
```


# contextWithEffect

Accesses the context and performs an effectful transformation.

**Details**

This function retrieves the context and allows you to transform it
effectually using another effect. It is useful when the transformation
involves asynchronous or effectful operations.

To import and use `contextWithEffect` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.contextWithEffect
```

**Signature**

```ts
export declare const contextWithEffect: <R2, A, E, R>(
  f: (context: Context.Context<R2>) => Effect<A, E, R>
) => Effect<A, E, R | R2>
```


# custom

Low level constructor that enables for custom stack tracing cutpoints.

It is meant to be called with a bag of instructions that become available in
the "this" of the effect.

To import and use `custom` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.custom
```

**Example**

```ts
import { Effect } from "effect"

const throwingFunction = () => {
  throw new Error()
}
const blowUp = Effect.custom(throwingFunction, function () {
  return Effect.succeed(this.effect_instruction_i0())
})
```

**Signature**

```ts
export declare const custom: {
  <X, A, E, R>(i0: X, body: (this: { effect_instruction_i0: X }) => Effect<A, E, R>): Effect<A, E, R>
  <X, Y, A, E, R>(
    i0: X,
    i1: Y,
    body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y }) => Effect<A, E, R>
  ): Effect<A, E, R>
  <X, Y, Z, A, E, R>(
    i0: X,
    i1: Y,
    i2: Z,
    body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y; effect_instruction_i2: Z }) => Effect<A, E, R>
  ): Effect<A, E, R>
}
```


# daemonChildren

Returns a new workflow that will not supervise any fibers forked by this
workflow.

To import and use `daemonChildren` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.daemonChildren
```

**Signature**

```ts
export declare const daemonChildren: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
```


# delay

Delays the execution of an effect by a specified `Duration`.

\*\*Details

This function postpones the execution of the provided effect by the specified
duration. The duration can be provided in various formats supported by the
`Duration` module.

Internally, this function does not block the thread; instead, it uses an
efficient, non-blocking mechanism to introduce the delay.

To import and use `delay` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.delay
```

**Example**

```ts
import { Console, Effect } from "effect"

const task = Console.log("Task executed")

const program = Console.log("start").pipe(
  Effect.andThen(
    // Delays the log message by 2 seconds
    task.pipe(Effect.delay("2 seconds"))
  )
)

// Effect.runFork(program)
// Output:
// start
// Task executed
```

**Signature**

```ts
export declare const delay: {
  (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<A, E, R>
}
```


# descriptor

Constructs an effect with information about the current `Fiber`.

To import and use `descriptor` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.descriptor
```

**Signature**

```ts
export declare const descriptor: Effect<Fiber.Fiber.Descriptor, never, never>
```


# descriptorWith

Constructs an effect based on information about the current `Fiber`.

To import and use `descriptorWith` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.descriptorWith
```

**Signature**

```ts
export declare const descriptorWith: <A, E, R>(
  f: (descriptor: Fiber.Fiber.Descriptor) => Effect<A, E, R>
) => Effect<A, E, R>
```


# die

Creates an effect that terminates a fiber with a specified error.

**Details**

This function is used to signal a defect, which represents a critical and
unexpected error in the code. When invoked, it produces an effect that does
not handle the error and instead terminates the fiber.

The error channel of the resulting effect is of type `never`, indicating that
it cannot recover from this failure.

**When to Use**

Use this function when encountering unexpected conditions in your code that
should not be handled as regular errors but instead represent unrecoverable
defects.

To import and use `die` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.die
```

**Example**

```ts
// Title: Terminating on Division by Zero with a Specified Error
import { Effect } from "effect"

const divide = (a: number, b: number) =>
  b === 0 ? Effect.die(new Error("Cannot divide by zero")) : Effect.succeed(a / b)

//       Effect<number, never, never>
//      
const program = divide(1, 0)

// Effect.runPromise(program).catch(console.error)
// Output:
// (FiberFailure) Error: Cannot divide by zero
//   ...stack trace...
```

**Signature**

```ts
export declare const die: (defect: unknown) => Effect<never>
```


# dieMessage

Creates an effect that terminates a fiber with a `RuntimeException`
containing the specified message.

**Details**

This function is used to signal a defect, representing a critical and
unexpected error in the code. When invoked, it produces an effect that
terminates the fiber with a `RuntimeException` carrying the given message.

The resulting effect has an error channel of type `never`, indicating it does
not handle or recover from the error.

**When to Use**

Use this function when you want to terminate a fiber due to an unrecoverable
defect and include a clear explanation in the message.

To import and use `dieMessage` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.dieMessage
```

**Example**

```ts
// Title: Terminating on Division by Zero with a Specified Message
import { Effect } from "effect"

const divide = (a: number, b: number) => (b === 0 ? Effect.dieMessage("Cannot divide by zero") : Effect.succeed(a / b))

//       Effect<number, never, never>
//      
const program = divide(1, 0)

// Effect.runPromise(program).catch(console.error)
// Output:
// (FiberFailure) RuntimeException: Cannot divide by zero
//   ...stack trace...
```

**Signature**

```ts
export declare const dieMessage: (message: string) => Effect<never>
```


# dieSync

Creates an effect that dies with the specified error, evaluated lazily.

**Details**

This function allows you to create an effect that will terminate with a fatal error.
The error is provided as a lazy argument, meaning it will only be evaluated when the effect runs.

To import and use `dieSync` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.dieSync
```

**Signature**

```ts
export declare const dieSync: (evaluate: LazyArg<unknown>) => Effect<never>
```


# diffFiberRefs

Returns a new workflow that executes this one and captures the changes in
`FiberRef` values.

To import and use `diffFiberRefs` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.diffFiberRefs
```

**Signature**

```ts
export declare const diffFiberRefs: <A, E, R>(self: Effect<A, E, R>) => Effect<[FiberRefsPatch.FiberRefsPatch, A], E, R>
```


# disconnect

Provides a way to handle timeouts in uninterruptible effects, allowing them
to continue in the background while the main control flow proceeds with the
timeout error.

**Details**

The `disconnect` function allows an uninterruptible effect to continue
running in the background, while enabling the main control flow to
immediately recognize a timeout condition. This is useful when you want to
avoid blocking the program due to long-running tasks, especially when those
tasks do not need to affect the flow of the rest of the program.

Without `disconnect`, an uninterruptible effect will ignore the
timeout and continue executing until it completes. The timeout error will
only be assessed after the effect finishes, which can cause delays in
recognizing a timeout.

With `disconnect`, the uninterruptible effect proceeds in the
background while the main program flow can immediately handle the timeout
error or trigger alternative logic. This enables faster timeout handling
without waiting for the completion of the long-running task.

To import and use `disconnect` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.disconnect
```

**Example**

```ts
import { Effect } from "effect"

const longRunningTask = Effect.gen(function* () {
  console.log("Start heavy processing...")
  yield* Effect.sleep("5 seconds") // Simulate a long process
  console.log("Heavy processing done.")
  return "Data processed"
})

const timedEffect = longRunningTask.pipe(
  Effect.uninterruptible,
  // Allows the task to finish in the background if it times out
  Effect.disconnect,
  Effect.timeout("1 second")
)

// Effect.runPromiseExit(timedEffect).then(console.log)
// Output:
// Start heavy processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'TimeoutException' }
//   }
// }
// Heavy processing done.
```

**Signature**

```ts
export declare const disconnect: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
```


# Do

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

To import and use `Do` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.Do
```

**Example**

```ts
import { Effect, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bind("y", () => Effect.succeed(3)),
  Effect.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
```

**Signature**

```ts
export declare const Do: Effect<{}, never, never>
```


# dropUntil

Drops elements until the effectful predicate returns `true`.

**Details**

This function processes a collection of elements and uses an effectful
predicate to determine when to stop dropping elements. It drops elements from
the beginning of the collection until the predicate returns `true`.

The predicate is a function that takes an element and its index in the
collection and returns an effect that evaluates to a boolean.

Once the predicate returns `true`, the remaining elements of the collection
are returned.

**Note**: The first element for which the predicate returns `true` is also
dropped.

**When to Use**

This function allows you to conditionally skip over a part of the collection
based on some criteria defined in the predicate.

To import and use `dropUntil` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.dropUntil
```

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5, 6]
const predicate = (n: number, i: number) => Effect.succeed(n > 3)

const program = Effect.gen(function* () {
  const result = yield* Effect.dropUntil(numbers, predicate)
  console.log(result)
})

// Effect.runFork(program)
// Output: [5, 6]
```

**Signature**

```ts
export declare const dropUntil: {
  <A, E, R>(
    predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>
  ): (elements: Iterable<A>) => Effect<Array<A>, E, R>
  <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>
}
```


# dropWhile

Drops elements as long as the predicate returns `true`.

**Details**

This function processes a collection of elements and uses a predicate to
decide whether to drop an element.

The predicate is a function that takes an element and its index, and it
returns an effect that evaluates to a boolean.

As long as the predicate returns `true`, elements will continue to be dropped
from the collection.

Once the predicate returns `false`, the remaining elements are kept.

**When to Use**

This function allows you to discard elements from the start of a collection
based on a condition, and only keep the rest when the condition no longer
holds.

To import and use `dropWhile` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.dropWhile
```

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5, 6]
const predicate = (n: number, i: number) => Effect.succeed(n <= 3)

const program = Effect.gen(function* () {
  const result = yield* Effect.dropWhile(numbers, predicate)
  console.log(result)
})

// Effect.runFork(program)
// Output: [4, 5, 6]
```

**Signature**

```ts
export declare const dropWhile: {
  <A, E, R>(
    predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>
  ): (elements: Iterable<A>) => Effect<Array<A>, E, R>
  <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>
}
```


# Effect

The `Effect` interface defines a value that describes a workflow or job,
which can succeed or fail.

**Details**

The `Effect` interface represents a computation that can model a workflow
involving various types of operations, such as synchronous, asynchronous,
concurrent, and parallel interactions. It operates within a context of type
`R`, and the result can either be a success with a value of type `A` or a
failure with an error of type `E`. The `Effect` is designed to handle complex
interactions with external resources, offering advanced features such as
fiber-based concurrency, scheduling, interruption handling, and scalability.
This makes it suitable for tasks that require fine-grained control over
concurrency and error management.

To execute an `Effect` value, you need a `Runtime`, which provides the
environment necessary to run and manage the computation.

To import and use `Effect` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.Effect
```


# either

Encapsulates both success and failure of an `Effect` into an `Either` type.

**Details**

This function converts an effect that may fail into an effect that always
succeeds, wrapping the outcome in an `Either` type. The result will be
`Either.Left` if the effect fails, containing the recoverable error, or
`Either.Right` if it succeeds, containing the result.

Using this function, you can handle recoverable errors explicitly without
causing the effect to fail. This is particularly useful in scenarios where
you want to chain effects and manage both success and failure in the same
logical flow.

It's important to note that unrecoverable errors, often referred to as
"defects," are still thrown and not captured within the `Either` type. Only
failures that are explicitly represented as recoverable errors in the effect
are encapsulated.

The resulting effect cannot fail directly because all recoverable failures
are represented inside the `Either` type.

To import and use `either` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.either
```

**Example**

```ts
import { Effect, Either, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, never, never>
//      
const recovered = Effect.gen(function* () {
  //       Either<string, HttpError | ValidationError>
  //      
  const failureOrSuccess = yield* Effect.either(program)
  return Either.match(failureOrSuccess, {
    onLeft: (error) => `Recovering from ${error._tag}`,
    onRight: (value) => value // Do nothing in case of success
  })
})
```

**Signature**

```ts
export declare const either: <A, E, R>(self: Effect<A, E, R>) => Effect<Either.Either<A, E>, never, R>
```


# ensuring

Guarantees the execution of a finalizer when an effect starts execution.

**Details**

This function allows you to specify a `finalizer` effect that will always be
run once the effect starts execution, regardless of whether the effect
succeeds, fails, or is interrupted.

**When to Use**

This is useful when you need to ensure that certain cleanup or final steps
are executed in all cases, such as releasing resources or performing
necessary logging.

While this function provides strong guarantees about executing the finalizer,
it is considered a low-level tool, which may not be ideal for more complex
resource management. For higher-level resource management with automatic
acquisition and release, see the {@link acquireRelease} family of functions.
For use cases where you need access to the result of an effect, consider
using {@link onExit}.

To import and use `ensuring` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.ensuring
```

**Example**

```ts
import { Console, Effect } from "effect"

const handler = Effect.ensuring(Console.log("Cleanup completed"))

const success = Console.log("Task completed").pipe(Effect.as("some result"), handler)

// Effect.runFork(success)
// Output:
// Task completed
// Cleanup completed

const failure = Console.log("Task failed").pipe(Effect.andThen(Effect.fail("some error")), handler)

// Effect.runFork(failure)
// Output:
// Task failed
// Cleanup completed

const interruption = Console.log("Task interrupted").pipe(Effect.andThen(Effect.interrupt), handler)

// Effect.runFork(interruption)
// Output:
// Task interrupted
// Cleanup completed
```

**Signature**

```ts
export declare const ensuring: {
  <X, R1>(finalizer: Effect<X, never, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>
  <A, E, R, X, R1>(self: Effect<A, E, R>, finalizer: Effect<X, never, R1>): Effect<A, E, R1 | R>
}
```


# ensuringChild

Acts on the children of this fiber (collected into a single fiber),
guaranteeing the specified callback will be invoked, whether or not this
effect succeeds.

To import and use `ensuringChild` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.ensuringChild
```

**Signature**

```ts
export declare const ensuringChild: {
  <X, R2>(
    f: (fiber: Fiber.Fiber<ReadonlyArray<unknown>, any>) => Effect<X, never, R2>
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>
  <A, E, R, X, R2>(
    self: Effect<A, E, R>,
    f: (fiber: Fiber.Fiber<ReadonlyArray<unknown>, any>) => Effect<X, never, R2>
  ): Effect<A, E, R | R2>
}
```


# ensuringChildren

Acts on the children of this fiber, guaranteeing the specified callback
will be invoked, whether or not this effect succeeds.

To import and use `ensuringChildren` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.ensuringChildren
```

**Signature**

```ts
export declare const ensuringChildren: {
  <X, R2>(
    children: (fibers: ReadonlyArray<Fiber.RuntimeFiber<any, any>>) => Effect<X, never, R2>
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>
  <A, E, R, X, R2>(
    self: Effect<A, E, R>,
    children: (fibers: ReadonlyArray<Fiber.RuntimeFiber<any, any>>) => Effect<X, never, R2>
  ): Effect<A, E, R | R2>
}
```


# eventually

Runs an effect repeatedly until it succeeds, ignoring errors.

**Details**

This function takes an effect and runs it repeatedly until the effect
successfully completes. If the effect fails, it will ignore the error and
retry the operation. This is useful when you need to perform a task that may
fail occasionally, but you want to keep trying until it eventually succeeds.
It works by repeatedly executing the effect until it no longer throws an
error.

**When to Use**

Use this function when you want to retry an operation multiple times until it
succeeds. It is helpful in cases where the operation may fail temporarily
(e.g., a network request), and you want to keep trying without handling or
worrying about the errors.

To import and use `eventually` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.eventually
```

**Example**

```ts
import { Effect } from "effect"

let counter = 0

const effect = Effect.try(() => {
  counter++
  if (counter < 3) {
    console.log("running effect")
    throw new Error("error")
  } else {
    console.log("effect done")
    return "some result"
  }
})

const program = Effect.eventually(effect)

// Effect.runPromise(program).then(console.log)
// Output:
// running effect
// running effect
// effect done
// some result
```

**Signature**

```ts
export declare const eventually: <A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R>
```


# every

Determines whether all elements of the iterable satisfy the effectful
predicate.

**Details**

This function checks whether every element in a given collection (an
iterable) satisfies a condition defined by an effectful predicate.

The predicate is a function that takes an element and its index, and it
returns an effect that evaluates to a boolean.

The function will process each element and return `true` if all elements
satisfy the predicate; otherwise, it returns `false`.

**When to Use**

This function is useful when you need to verify that all items in a
collection meet certain criteria, even when the evaluation of each item
involves effects, such as asynchronous checks or complex computations.

To import and use `every` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.every
```

**Example**

```ts
import { Effect } from "effect"

const numbers = [2, 4, 6, 8]
const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)

const program = Effect.gen(function* () {
  const allEven = yield* Effect.every(numbers, predicate)
  console.log(allEven)
})

// Effect.runFork(program)
// Output: true
```

**Signature**

```ts
export declare const every: {
  <A, E, R>(predicate: (a: A, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<boolean, E, R>
  <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<boolean, E, R>
}
```


# exists

Determines whether any element of the iterable satisfies the effectual
predicate.

**Details**

This function checks whether any element in a given collection (an iterable)
satisfies a condition defined by an effectful predicate.

The predicate is a function that takes an element and its index, and it
returns an effect that evaluates to a boolean.

The function will process each element, and if any element satisfies the
predicate (returns `true`), the function will immediately return `true`.

If none of the elements satisfy the condition, it will return `false`.

**When to Use**

This function allows you to quickly check for a condition in a collection
without having to manually iterate over it.

To import and use `exists` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.exists
```

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4]
const predicate = (n: number, i: number) => Effect.succeed(n > 2)

const program = Effect.gen(function* () {
  const hasLargeNumber = yield* Effect.exists(numbers, predicate)
  console.log(hasLargeNumber)
})

// Effect.runFork(program)
// Output: true
```

**Signature**

```ts
export declare const exists: {
  <A, E, R>(
    predicate: (a: A, i: number) => Effect<boolean, E, R>,
    options?:
      | {
          readonly concurrency?: Concurrency | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): (elements: Iterable<A>) => Effect<boolean, E, R>
  <A, E, R>(
    elements: Iterable<A>,
    predicate: (a: A, i: number) => Effect<boolean, E, R>,
    options?:
      | {
          readonly concurrency?: Concurrency | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): Effect<boolean, E, R>
}
```


# exit

Encapsulates both success and failure of an `Effect` using the `Exit` type.

**Details**

This function converts an effect into one that always succeeds, wrapping its
outcome in the `Exit` type. The `Exit` type provides explicit handling of
both success (`Exit.Success`) and failure (`Exit.Failure`) cases, including
defects (unrecoverable errors).

Unlike {@link either} or {@link option}, this function also encapsulates
defects, which are typically unrecoverable and would otherwise terminate the
effect. With the `Exit` type, defects are represented in `Exit.Failure`,
allowing for detailed introspection and structured error handling.

This makes the resulting effect robust and incapable of direct failure (its
error type is `never`). It is particularly useful for workflows where all
outcomes, including unexpected defects, must be managed and analyzed.

To import and use `exit` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.exit
```

**Example**

```ts
import { Effect, Cause, Console, Exit } from "effect"

// Simulating a runtime error
const task = Effect.dieMessage("Boom!")

const program = Effect.gen(function* () {
  const exit = yield* Effect.exit(task)
  if (Exit.isFailure(exit)) {
    const cause = exit.cause
    if (Cause.isDieType(cause) && Cause.isRuntimeException(cause.defect)) {
      yield* Console.log(`RuntimeException defect caught: ${cause.defect.message}`)
    } else {
      yield* Console.log("Unknown failure caught.")
    }
  }
})

// We get an Exit.Success because we caught all failures
// Effect.runPromiseExit(program).then(console.log)
// Output:
// RuntimeException defect caught: Boom!
// {
//   _id: "Exit",
//   _tag: "Success",
//   value: undefined
// }
```

**Signature**

```ts
export declare const exit: <A, E, R>(self: Effect<A, E, R>) => Effect<Exit.Exit<A, E>, never, R>
```


# fail

Creates an `Effect` that represents a recoverable error.

**When to Use**

Use this function to explicitly signal an error in an `Effect`. The error
will keep propagating unless it is handled. You can handle the error with
functions like {@link catchAll} or {@link catchTag}.

To import and use `fail` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.fail
```

**Example**

```ts
// Title: Creating a Failed Effect
import { Effect } from "effect"

//       Effect<never, Error, never>
//      
const failure = Effect.fail(new Error("Operation failed due to network error"))
```

**Signature**

```ts
export declare const fail: <E>(error: E) => Effect<never, E>
```


# failCause

Creates an `Effect` that fails with the specified `Cause`.

To import and use `failCause` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.failCause
```

**Signature**

```ts
export declare const failCause: <E>(cause: Cause.Cause<E>) => Effect<never, E>
```


# failCauseSync

Creates an `Effect` that fails with the specified `Cause`, evaluated lazily.

To import and use `failCauseSync` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.failCauseSync
```

**Signature**

```ts
export declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Effect<never, E>
```


# failSync

Creates an `Effect` that fails with the specified error, evaluated lazily.

To import and use `failSync` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.failSync
```

**Signature**

```ts
export declare const failSync: <E>(evaluate: LazyArg<E>) => Effect<never, E>
```


# filter

Filters an iterable using the specified effectful predicate.

**Details**

This function filters a collection (an iterable) by applying an effectful
predicate.

The predicate is a function that takes an element and its index, and it
returns an effect that evaluates to a boolean.

The function processes each element in the collection and keeps only those
that satisfy the condition defined by the predicate.

**Options**

You can also adjust the behavior with options such as concurrency, batching,
or whether to negate the condition.

**When to Use**

This function allows you to selectively keep or remove elements based on a
condition that may involve asynchronous or side-effect-causing operations.

To import and use `filter` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.filter
```

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5]
const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)

const program = Effect.gen(function* () {
  const result = yield* Effect.filter(numbers, predicate)
  console.log(result)
})

// Effect.runFork(program)
// Output: [2, 4]
```

**Signature**

```ts
export declare const filter: {
  <A, E, R>(
    predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>,
    options?:
      | {
          readonly concurrency?: Concurrency | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly negate?: boolean | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): (elements: Iterable<A>) => Effect<Array<A>, E, R>
  <A, E, R>(
    elements: Iterable<A>,
    predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>,
    options?:
      | {
          readonly concurrency?: Concurrency | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly negate?: boolean | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): Effect<Array<A>, E, R>
}
```


# filterEffectOrElse

Filters an effect with an effectful predicate, falling back to an alternative
effect if the predicate fails.

**Details**

This function applies a predicate to the result of an effect. If the
predicate evaluates to `false`, the effect falls back to the `orElse`
effect. The `orElse` effect can produce an alternative value or perform
additional computations.

To import and use `filterEffectOrElse` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.filterEffectOrElse
```

**Example**

```ts
import { Effect, pipe } from "effect"

// Define a user interface
interface User {
  readonly name: string
}

// Simulate an asynchronous authentication function
declare const auth: () => Promise<User | null>

const program = pipe(
  Effect.promise(() => auth()),
  // Use filterEffectOrElse with an effectful predicate
  Effect.filterEffectOrElse({
    predicate: (user) => Effect.succeed(user !== null),
    orElse: (user) => Effect.fail(new Error(`Unauthorized user: ${user}`))
  })
)
```

**Signature**

```ts
export declare const filterEffectOrElse: {
  <A, E2, R2, A2, E3, R3>(options: {
    readonly predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>
    readonly orElse: (a: NoInfer<A>) => Effect<A2, E3, R3>
  }): <E, R>(self: Effect<A, E, R>) => Effect<A | A2, E | E2 | E3, R | R2 | R3>
  <A, E, R, E2, R2, A2, E3, R3>(
    self: Effect<A, E, R>,
    options: { readonly predicate: (a: A) => Effect<boolean, E2, R2>; readonly orElse: (a: A) => Effect<A2, E3, R3> }
  ): Effect<A | A2, E | E2 | E3, R | R2 | R3>
}
```


# filterEffectOrFail

Filters an effect with an effectful predicate, failing with a custom error if the predicate fails.

**Details**

This function applies a predicate to the result of an effect. If the
predicate evaluates to `false`, the effect fails with a custom error
generated by the `orFailWith` function.

**When to Use**

This is useful for enforcing constraints and treating violations as
recoverable errors.

To import and use `filterEffectOrFail` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.filterEffectOrFail
```

**Example**

```ts
import { Effect, pipe } from "effect"

// Define a user interface
interface User {
  readonly name: string
}

// Simulate an asynchronous authentication function
declare const auth: () => Promise<User | null>

const program = pipe(
  Effect.promise(() => auth()),
  // Use filterEffectOrFail with an effectful predicate
  Effect.filterEffectOrFail({
    predicate: (user) => Effect.succeed(user !== null),
    orFailWith: () => new Error("Unauthorized")
  })
)
```

**Signature**

```ts
export declare const filterEffectOrFail: {
  <A, E2, R2, E3>(options: {
    readonly predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>
    readonly orFailWith: (a: NoInfer<A>) => E3
  }): <E, R>(self: Effect<A, E, R>) => Effect<A, E | E2 | E3, R | R2>
  <A, E, R, E2, R2, E3>(
    self: Effect<A, E, R>,
    options: { readonly predicate: (a: A) => Effect<boolean, E2, R2>; readonly orFailWith: (a: A) => E3 }
  ): Effect<A, E | E2 | E3, R | R2>
}
```


# filterMap

Filters and maps elements sequentially in one operation.

This function processes each element one by one. It applies a function that
returns an `Option` to each element. If the function returns `Some`, the
element is kept; if it returns `None`, the element is removed. The operation
is done sequentially for each element.

To import and use `filterMap` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.filterMap
```

**Example**

```ts
import { Console, Effect, Option } from "effect"

const task = (n: number) =>
  Effect.succeed(n).pipe(Effect.delay(1000 - n * 100), Effect.tap(Console.log(`task${n} done`)))

const program = Effect.filterMap([task(1), task(2), task(3), task(4)], (n) =>
  n % 2 === 0 ? Option.some(n) : Option.none()
)

// Effect.runPromise(program).then(console.log)
// Output:
// task1 done
// task2 done
// task3 done
// task4 done
// [ 2, 4 ]
```

**Signature**

```ts
export declare const filterMap: {
  <Eff extends Effect<any, any, any>, B>(
    pf: (a: Effect.Success<Eff>) => Option.Option<B>
  ): (elements: Iterable<Eff>) => Effect<Array<B>, Effect.Error<Eff>, Effect.Context<Eff>>
  <Eff extends Effect<any, any, any>, B>(
    elements: Iterable<Eff>,
    pf: (a: Effect.Success<Eff>) => Option.Option<B>
  ): Effect<Array<B>, Effect.Error<Eff>, Effect.Context<Eff>>
}
```


# filterOrDie

Filters an effect, dying with a custom defect if the predicate fails.

**Details**

This function applies a predicate to the result of an effect. If the
predicate evaluates to `false`, the effect dies with a custom defect
generated by the `orDieWith` function.

**When to Use**

This is useful for enforcing constraints on values and treating violations as
fatal program errors.

To import and use `filterOrDie` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.filterOrDie
```

**Signature**

```ts
export declare const filterOrDie: {
  <A, B extends A>(
    refinement: Refinement<NoInfer<A>, B>,
    orDieWith: (a: NoInfer<A>) => unknown
  ): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>
  <A>(
    predicate: Predicate<NoInfer<A>>,
    orDieWith: (a: NoInfer<A>) => unknown
  ): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R, B extends A>(
    self: Effect<A, E, R>,
    refinement: Refinement<A, B>,
    orDieWith: (a: A) => unknown
  ): Effect<B, E, R>
  <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>, orDieWith: (a: A) => unknown): Effect<A, E, R>
}
```


# filterOrDieMessage

Filters an effect, dying with a custom message if the predicate fails.

**Details**

This function works like {@link filterOrDie} but allows you to specify a
custom error message to describe the reason for the failure. The message is
included in the defect when the predicate evaluates to `false`.

To import and use `filterOrDieMessage` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.filterOrDieMessage
```

**Signature**

```ts
export declare const filterOrDieMessage: {
  <A, B extends A>(
    refinement: Refinement<NoInfer<A>, B>,
    message: string
  ): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>
  <A>(predicate: Predicate<NoInfer<A>>, message: string): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, message: string): Effect<B, E, R>
  <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>, message: string): Effect<A, E, R>
}
```


# filterOrElse

Filters an effect, providing an alternative effect if the predicate fails.

**Details**

This function applies a predicate to the result of an effect. If the
predicate evaluates to `false`, it executes the `orElse` effect instead. The
`orElse` effect can produce an alternative value or perform additional
computations.

To import and use `filterOrElse` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.filterOrElse
```

**Signature**

```ts
export declare const filterOrElse: {
  <A, B extends A, C, E2, R2>(
    refinement: Refinement<NoInfer<A>, B>,
    orElse: (a: NoInfer<A>) => Effect<C, E2, R2>
  ): <E, R>(self: Effect<A, E, R>) => Effect<B | C, E2 | E, R2 | R>
  <A, B, E2, R2>(
    predicate: Predicate<NoInfer<A>>,
    orElse: (a: NoInfer<A>) => Effect<B, E2, R2>
  ): <E, R>(self: Effect<A, E, R>) => Effect<A | B, E2 | E, R2 | R>
  <A, E, R, B extends A, C, E2, R2>(
    self: Effect<A, E, R>,
    refinement: Refinement<A, B>,
    orElse: (a: A) => Effect<C, E2, R2>
  ): Effect<B | C, E | E2, R | R2>
  <A, E, R, B, E2, R2>(
    self: Effect<A, E, R>,
    predicate: Predicate<A>,
    orElse: (a: A) => Effect<B, E2, R2>
  ): Effect<A | B, E | E2, R | R2>
}
```


# filterOrFail

Filters an effect, failing with a custom error if the predicate fails.

**Details**

This function applies a predicate to the result of an effect. If the
predicate evaluates to `false`, the effect fails with a custom error
generated by the `orFailWith` function.

**When to Use**

This is useful for enforcing constraints and treating violations as
recoverable errors.

**Providing a Guard**

In addition to the filtering capabilities discussed earlier, you have the
option to further refine and narrow down the type of the success channel by
providing a [user-defined type
guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).
Let's explore this concept through an example:

To import and use `filterOrFail` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.filterOrFail
```

**Example**

```ts
import { Effect, pipe } from "effect"

// Define a user interface
interface User {
  readonly name: string
}

// Simulate an asynchronous authentication function
declare const auth: () => Promise<User | null>

const program = pipe(
  Effect.promise(() => auth()),
  // Use filterOrFail with a custom type guard to ensure user is not null
  Effect.filterOrFail(
    (user): user is User => user !== null, // Type guard
    () => new Error("Unauthorized")
  ),
  // 'user' now has the type `User` (not `User | null`)
  Effect.andThen((user) => user.name)
)
```

**Signature**

```ts
export declare const filterOrFail: {
  <A, B extends A, E2>(
    refinement: Refinement<NoInfer<A>, B>,
    orFailWith: (a: NoInfer<A>) => E2
  ): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R>
  <A, E2>(
    predicate: Predicate<NoInfer<A>>,
    orFailWith: (a: NoInfer<A>) => E2
  ): <E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R>
  <A, B extends A>(
    refinement: Refinement<NoInfer<A>, B>
  ): <E, R>(self: Effect<A, E, R>) => Effect<B, Cause.NoSuchElementException | E, R>
  <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Effect<A, E, R>) => Effect<A, Cause.NoSuchElementException | E, R>
  <A, E, R, B extends A, E2>(
    self: Effect<A, E, R>,
    refinement: Refinement<A, B>,
    orFailWith: (a: A) => E2
  ): Effect<B, E | E2, R>
  <A, E, R, E2>(self: Effect<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): Effect<A, E | E2, R>
  <A, E, R, B extends A>(
    self: Effect<A, E, R>,
    refinement: Refinement<A, B>
  ): Effect<B, E | Cause.NoSuchElementException, R>
  <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>): Effect<A, E | Cause.NoSuchElementException, R>
}
```


# finalizersMask

Applies a custom execution strategy to finalizers within a scoped workflow.

**Details**

This function allows you to control how finalizers are executed in a scope by
applying a specified `ExecutionStrategy`. The `strategy` can dictate whether
finalizers run (e.g., sequentially or in parallel).

Additionally, the function provides a `restore` operation, which ensures that
the effect passed to it is executed under the default execution strategy.

To import and use `finalizersMask` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.finalizersMask
```

**Signature**

```ts
export declare const finalizersMask: (
  strategy: ExecutionStrategy
) => <A, E, R>(
  self: (restore: <A1, E1, R1>(self: Effect<A1, E1, R1>) => Effect<A1, E1, R1>) => Effect<A, E, R>
) => Effect<A, E, R>
```


# findFirst

Returns the first element that satisfies the effectful predicate.

**Details**

This function processes a collection of elements and applies an effectful
predicate to each element.

The predicate is a function that takes an element and its index in the
collection, and it returns an effect that evaluates to a boolean.

The function stops as soon as it finds the first element for which the
predicate returns `true` and returns that element wrapped in an `Option`.

If no element satisfies the predicate, the result will be `None`.

**When to Use**

This function allows you to efficiently find an element that meets a specific
condition, even when the evaluation involves effects like asynchronous
operations or side effects.

To import and use `findFirst` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.findFirst
```

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5]
const predicate = (n: number, i: number) => Effect.succeed(n > 3)

const program = Effect.gen(function* () {
  const result = yield* Effect.findFirst(numbers, predicate)
  console.log(result)
})

// Effect.runFork(program)
// Output: { _id: 'Option', _tag: 'Some', value: 4 }
```

**Signature**

```ts
export declare const findFirst: {
  <A, E, R>(
    predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>
  ): (elements: Iterable<A>) => Effect<Option.Option<A>, E, R>
  <A, E, R>(
    elements: Iterable<A>,
    predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>
  ): Effect<Option.Option<A>, E, R>
}
```


# firstSuccessOf

Runs a sequence of effects and returns the result of the first successful
one.

**Details**

This function allows you to execute a collection of effects in sequence,
stopping at the first success. If an effect succeeds, its result is
immediately returned, and no further effects in the sequence are executed.
However, if all the effects fail, the function will return the error of the
last effect.

The execution is sequential, meaning that effects are evaluated one at a time
in the order they are provided. This ensures predictable behavior and avoids
unnecessary computations.

If the collection of effects is empty, an `IllegalArgumentException` is
thrown, indicating that the operation is invalid without any effects to try.

**When to Use**

This is particularly useful when you have multiple fallback strategies or
alternative sources to obtain a result, such as attempting multiple APIs,
retrieving configurations, or accessing resources in a prioritized manner.

To import and use `firstSuccessOf` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.firstSuccessOf
```

**Example**

```ts
import { Effect, Console } from "effect"

interface Config {
  host: string
  port: number
  apiKey: string
}

// Create a configuration object with sample values
const makeConfig = (name: string): Config => ({
  host: `${name}.example.com`,
  port: 8080,
  apiKey: "12345-abcde"
})

// Simulate retrieving configuration from a remote node
const remoteConfig = (name: string): Effect.Effect<Config, Error> =>
  Effect.gen(function* () {
    // Simulate node3 being the only one with available config
    if (name === "node3") {
      yield* Console.log(`Config for ${name} found`)
      return makeConfig(name)
    } else {
      yield* Console.log(`Unavailable config for ${name}`)
      return yield* Effect.fail(new Error(`Config not found for ${name}`))
    }
  })

// Define the master configuration and potential fallback nodes
const masterConfig = remoteConfig("master")
const nodeConfigs = ["node1", "node2", "node3", "node4"].map(remoteConfig)

// Attempt to find a working configuration,
// starting with the master and then falling back to other nodes
const config = Effect.firstSuccessOf([masterConfig, ...nodeConfigs])

// Run the effect to retrieve the configuration
const result = Effect.runSync(config)

console.log(result)
// Output:
// Unavailable config for master
// Unavailable config for node1
// Unavailable config for node2
// Config for node3 found
// { host: 'node3.example.com', port: 8080, apiKey: '12345-abcde' }
```

**Signature**

```ts
export declare const firstSuccessOf: <Eff extends Effect<any, any, any>>(
  effects: Iterable<Eff>
) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>>
```


# flatMap

Chains effects to produce new `Effect` instances, useful for combining
operations that depend on previous results.

**Syntax**

```ts
const flatMappedEffect = pipe(myEffect, Effect.flatMap(transformation))
// or
const flatMappedEffect = Effect.flatMap(myEffect, transformation)
// or
const flatMappedEffect = myEffect.pipe(Effect.flatMap(transformation))
```

**Details**

`flatMap` lets you sequence effects so that the result of one effect can be
used in the next step. It is similar to `flatMap` used with arrays but works
specifically with `Effect` instances, allowing you to avoid deeply nested
effect structures.

Since effects are immutable, `flatMap` always returns a new effect instead of
changing the original one.

**When to Use**

Use `flatMap` when you need to chain multiple effects, ensuring that each
step produces a new `Effect` while flattening any nested effects that may
occur.

To import and use `flatMap` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.flatMap
```

**Example**

```ts
import { pipe, Effect } from "effect"

// Function to apply a discount safely to a transaction amount
const applyDiscount = (total: number, discountRate: number): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

// Chaining the fetch and discount application using `flatMap`
const finalAmount = pipe(
  fetchTransactionAmount,
  Effect.flatMap((amount) => applyDiscount(amount, 5))
)

// Effect.runPromise(finalAmount).then(console.log)
// Output: 95
```

**Signature**

```ts
export declare const flatMap: {
  <A, B, E1, R1>(f: (a: A) => Effect<B, E1, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R1 | R>
  <A, E, R, B, E1, R1>(self: Effect<A, E, R>, f: (a: A) => Effect<B, E1, R1>): Effect<B, E | E1, R | R1>
}
```


# flip

Swaps the success and error channels of an effect.

**Details**

This function reverses the flow of an effect by swapping its success and
error channels. The success value becomes an error, and the error value
becomes a success.

To import and use `flip` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.flip
```

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, string, never>
//      
const program = Effect.fail("Oh uh!").pipe(Effect.as(2))

//       Effect<string, number, never>
//      
const flipped = Effect.flip(program)
```

**Signature**

```ts
export declare const flip: <A, E, R>(self: Effect<A, E, R>) => Effect<E, A, R>
```


# flipWith

Swaps the error/value parameters, applies the function `f` and flips the
parameters back

To import and use `flipWith` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.flipWith
```

**Signature**

```ts
export declare const flipWith: {
  <E, A, R, E2, A2, R2>(
    f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>
  ): (self: Effect<A, E, R>) => Effect<A2, E2, R2>
  <A, E, R, E2, A2, R2>(self: Effect<A, E, R>, f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>): Effect<A2, E2, R2>
}
```


# fn

Creates a function that returns an Effect, which includes a stack trace
with relevant location information if an error occurs and is automatically
traced with a span pointing to the call site.

The name passed as the first argument is used as a span.

The name is optional; if not provided, the span won't be added, but the stack trace will still be present.

The function can be created using either a generator function that can yield
effects or a normal function that returns an effect.

`Effect.fn` also acts as a `pipe` function, allowing you to create a pipeline
after the function definition using the effect returned by the generator
function as the starting value of the pipeline.

To import and use `fn` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.fn
```

**Example**

```ts
// Title: Creating a traced function with a generator function
import { Effect } from "effect"

const logExample = Effect.fn("logExample")(
  // Definition location: 4
  function* <N extends number>(n: N) {
    yield* Effect.annotateCurrentSpan("n", n)
    console.log(`got: ${n}`)
    yield* Effect.fail(new Error()) // Raise location: 8
  }
)

// Effect.runFork(
//   logExample(100).pipe( // Call location: 13
//     Effect.catchAllCause(Effect.logError)
//   )
// )
// Output:
// got: 100
// timestamp=... level=ERROR fiber=#0 cause="Error: An error has occurred
//     at <anonymous> (/.../index.ts:8:24) <= Raise location
//     at logExample (/.../index.ts:4:27)  <= Definition location
//     at logExample (/.../index.ts:13:3)" <= Call location
```

**Example**

```ts
// Title: Creating a traced function with a function
import { Effect } from "effect"

const logExample = Effect.fn("logExample")(function (n: number) {
  console.log(`got: ${n}`)
  return Effect.fail(new Error(`An error has occurred`))
})
```

**Example**

```ts
// Title: Creating a traced function and a pipeline
import { Effect } from "effect"

const logExample = Effect.fn("logExample")(
  function (n: number) {
    console.log(`got: ${n}`)
    return Effect.fail(new Error(`An error has occurred`))
  },
  // Add a delay to the effect
  Effect.delay("1 second")
)
```

**Signature**

```ts
export declare const fn: fn.Gen & fn.NonGen & ((name: string, options?: Tracer.SpanOptions) => fn.Gen & fn.NonGen)
```


# fnUntraced

Same as {@link fn}, but allows you to create a function that is not traced, for when performance is critical.

To import and use `fnUntraced` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.fnUntraced
```

**Signature**

```ts
export declare const fnUntraced: fn.Gen
```


# forEach

Executes an effectful operation for each element in an `Iterable`.

**Details**

This function applies a provided operation to each element in the iterable,
producing a new effect that returns an array of results.

If any effect fails, the iteration stops immediately (short-circuiting), and
the error is propagated.

**Concurrency**

The `concurrency` option controls how many operations are performed
concurrently. By default, the operations are performed sequentially.

**Discarding Results**

If the `discard` option is set to `true`, the intermediate results are not
collected, and the final result of the operation is `void`.

To import and use `forEach` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.forEach
```

**Example**

```ts
// Title: Applying Effects to Iterable Elements
import { Effect, Console } from "effect"

const result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>
  Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))
)

// Effect.runPromise(result).then(console.log)
// Output:
// Currently at index 0
// Currently at index 1
// Currently at index 2
// Currently at index 3
// Currently at index 4
// [ 2, 4, 6, 8, 10 ]
```

**Example**

```ts
// Title: Using discard to Ignore Results
import { Effect, Console } from "effect"

// Apply effects but discard the results
const result = Effect.forEach(
  [1, 2, 3, 4, 5],
  (n, index) => Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),
  { discard: true }
)

// Effect.runPromise(result).then(console.log)
// Output:
// Currently at index 0
// Currently at index 1
// Currently at index 2
// Currently at index 3
// Currently at index 4
// undefined
```

**Signature**

```ts
export declare const forEach: {
  <B, E, R, S extends Iterable<any>>(
    f: (a: RA.ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>,
    options?:
      | {
          readonly concurrency?: Concurrency | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly discard?: false | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): (self: S) => Effect<RA.ReadonlyArray.With<S, B>, E, R>
  <A, B, E, R>(
    f: (a: A, i: number) => Effect<B, E, R>,
    options: {
      readonly concurrency?: Concurrency | undefined
      readonly batching?: boolean | "inherit" | undefined
      readonly discard: true
      readonly concurrentFinalizers?: boolean | undefined
    }
  ): (self: Iterable<A>) => Effect<void, E, R>
  <B, E, R, S extends Iterable<any>>(
    self: S,
    f: (a: RA.ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>,
    options?:
      | {
          readonly concurrency?: Concurrency | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly discard?: false | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): Effect<RA.ReadonlyArray.With<S, B>, E, R>
  <A, B, E, R>(
    self: Iterable<A>,
    f: (a: A, i: number) => Effect<B, E, R>,
    options: {
      readonly concurrency?: Concurrency | undefined
      readonly batching?: boolean | "inherit" | undefined
      readonly discard: true
      readonly concurrentFinalizers?: boolean | undefined
    }
  ): Effect<void, E, R>
}
```


# forever

Repeats an effect indefinitely until an error occurs.

**Details**

This function executes an effect repeatedly in an infinite loop. Each
iteration is executed sequentially, and the loop continues until the first
error occurs. If the effect succeeds, it starts over from the beginning. If
the effect fails, the error is propagated, and the loop stops.

Be cautious when using this function, as it will run indefinitely unless an
error interrupts it. This makes it suitable for long-running processes or
continuous polling tasks, but you should ensure proper error handling or
combine it with other operators like `timeout` or `schedule` to prevent
unintentional infinite loops.

To import and use `forever` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.forever
```

**Signature**

```ts
export declare const forever: <A, E, R>(self: Effect<A, E, R>) => Effect<never, E, R>
```


# fork

Creates a new fiber to run an effect concurrently.

**Details**

This function takes an effect and forks it into a separate fiber, allowing it
to run concurrently without blocking the original effect. The new fiber
starts execution immediately after being created, and the fiber object is
returned immediately without waiting for the effect to begin. This is useful
when you want to run tasks concurrently while continuing other tasks in the
parent fiber.

The forked fiber is attached to the parent fiber's scope. This means that
when the parent fiber terminates, the child fiber will also be terminated
automatically. This feature, known as "auto supervision," ensures that no
fibers are left running unintentionally. If you prefer not to have this auto
supervision behavior, you can use {@link forkDaemon} or {@link forkIn}.

**When to Use**

Use this function when you need to run an effect concurrently without
blocking the current execution flow. For example, you might use it to launch
background tasks or concurrent computations. However, working with fibers can
be complex, so before using this function directly, you might want to explore
higher-level functions like {@link raceWith}, {@link zip}, or others that can
manage concurrency for you.

To import and use `fork` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.fork
```

**Example**

```ts
import { Effect } from "effect"

const fib = (n: number): Effect.Effect<number> =>
  n < 2 ? Effect.succeed(n) : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)

//       Effect<RuntimeFiber<number, never>, never, never>
//      
const fib10Fiber = Effect.fork(fib(10))
```

**Signature**

```ts
export declare const fork: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>
```


# forkAll

Returns an effect that forks all of the specified values, and returns a
composite fiber that produces a list of their results, in order.

To import and use `forkAll` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.forkAll
```

**Signature**

```ts
export declare const forkAll: {
  (
    options?: { readonly discard?: false | undefined } | undefined
  ): <Eff extends Effect<any, any, any>>(
    effects: Iterable<Eff>
  ) => Effect<Fiber.Fiber<Array<Effect.Success<Eff>>, Effect.Error<Eff>>, never, Effect.Context<Eff>>
  (options: {
    readonly discard: true
  }): <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<void, never, Effect.Context<Eff>>
  <Eff extends Effect<any, any, any>>(
    effects: Iterable<Eff>,
    options?: { readonly discard?: false | undefined } | undefined
  ): Effect<Fiber.Fiber<Array<Effect.Success<Eff>>, Effect.Error<Eff>>, never, Effect.Context<Eff>>
  <Eff extends Effect<any, any, any>>(
    effects: Iterable<Eff>,
    options: { readonly discard: true }
  ): Effect<void, never, Effect.Context<Eff>>
}
```


# forkDaemon

Creates a long-running background fiber that is independent of its parent.

**Details**

This function creates a "daemon" fiber that runs in the background and is not
tied to the lifecycle of its parent fiber. Unlike normal fibers that stop
when the parent fiber terminates, a daemon fiber will continue running until
the global scope closes or the fiber completes naturally. This makes it
useful for tasks that need to run in the background independently, such as
periodic logging, monitoring, or background data processing.

To import and use `forkDaemon` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.forkDaemon
```

**Example**

```ts
// Title: Creating a Daemon Fibe
import { Effect, Console, Schedule } from "effect"

// Daemon fiber that logs a message repeatedly every second
const daemon = Effect.repeat(Console.log("daemon: still running!"), Schedule.fixed("1 second"))

const parent = Effect.gen(function* () {
  console.log("parent: started!")
  // Daemon fiber running independently
  yield* Effect.forkDaemon(daemon)
  yield* Effect.sleep("3 seconds")
  console.log("parent: finished!")
})

// Effect.runFork(parent)
// Output:
// parent: started!
// daemon: still running!
// daemon: still running!
// daemon: still running!
// parent: finished!
// daemon: still running!
// daemon: still running!
// daemon: still running!
// daemon: still running!
// daemon: still running!
// ...etc...
```

**Signature**

```ts
export declare const forkDaemon: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>
```


# forkIn

Forks an effect in a specific scope, allowing finer control over its
execution.

**Details**

There are some cases where we need more fine-grained control, so we want to
fork a fiber in a specific scope. We can use the `Effect.forkIn` operator
which takes the target scope as an argument.

The fiber will be interrupted when the scope is closed.

To import and use `forkIn` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.forkIn
```

**Example**

```ts
// Title: Forking a Fiber in a Specific Scope
//
// In this example, the child fiber is forked into the outerScope,
// allowing it to outlive the inner scope but still be terminated
// when the outerScope is closed.
//

import { Console, Effect, Schedule } from "effect"

// Child fiber that logs a message repeatedly every second
const child = Effect.repeat(Console.log("child: still running!"), Schedule.fixed("1 second"))

const program = Effect.scoped(
  Effect.gen(function* () {
    yield* Effect.addFinalizer(() => Console.log("The outer scope is about to be closed!"))

    // Capture the outer scope
    const outerScope = yield* Effect.scope

    // Create an inner scope
    yield* Effect.scoped(
      Effect.gen(function* () {
        yield* Effect.addFinalizer(() => Console.log("The inner scope is about to be closed!"))
        // Fork the child fiber in the outer scope
        yield* Effect.forkIn(child, outerScope)
        yield* Effect.sleep("3 seconds")
      })
    )

    yield* Effect.sleep("5 seconds")
  })
)

// Effect.runFork(program)
// Output:
// child: still running!
// child: still running!
// child: still running!
// The inner scope is about to be closed!
// child: still running!
// child: still running!
// child: still running!
// child: still running!
// child: still running!
// child: still running!
// The outer scope is about to be closed!
```

**Signature**

```ts
export declare const forkIn: {
  (scope: Scope.Scope): <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>
  <A, E, R>(self: Effect<A, E, R>, scope: Scope.Scope): Effect<Fiber.RuntimeFiber<A, E>, never, R>
}
```


# forkScoped

Forks a fiber in a local scope, ensuring it outlives its parent.

**Details**

This function is used to create fibers that are tied to a local scope,
meaning they are not dependent on their parent fiber's lifecycle. Instead,
they will continue running until the scope they were created in is closed.
This is particularly useful when you need a fiber to run independently of the
parent fiber, but still want it to be terminated when the scope ends.

Fibers created with this function are isolated from the parent fibers
termination, so they can run for a longer period. This behavior is different
from fibers created with {@link fork}, which are terminated when the parent fiber
terminates. With `forkScoped`, the child fiber will keep running until the
local scope ends, regardless of the state of the parent fiber.

To import and use `forkScoped` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.forkScoped
```

**Example**

```ts
// Title: Forking a Fiber in a Local Scope
//
// In this example, the child fiber continues to run beyond the lifetime of the parent fiber.
// The child fiber is tied to the local scope and will be terminated only when the scope ends.
//

import { Effect, Console, Schedule } from "effect"

// Child fiber that logs a message repeatedly every second
const child = Effect.repeat(Console.log("child: still running!"), Schedule.fixed("1 second"))

//       Effect<void, never, Scope>
//      
const parent = Effect.gen(function* () {
  console.log("parent: started!")
  // Child fiber attached to local scope
  yield* Effect.forkScoped(child)
  yield* Effect.sleep("3 seconds")
  console.log("parent: finished!")
})

// Program runs within a local scope
const program = Effect.scoped(
  Effect.gen(function* () {
    console.log("Local scope started!")
    yield* Effect.fork(parent)
    // Scope lasts for 5 seconds
    yield* Effect.sleep("5 seconds")
    console.log("Leaving the local scope!")
  })
)

// Effect.runFork(program)
// Output:
// Local scope started!
// parent: started!
// child: still running!
// child: still running!
// child: still running!
// parent: finished!
// child: still running!
// child: still running!
// Leaving the local scope!
```

**Signature**

```ts
export declare const forkScoped: <A, E, R>(
  self: Effect<A, E, R>
) => Effect<Fiber.RuntimeFiber<A, E>, never, Scope.Scope | R>
```


# forkWithErrorHandler

Like {@link fork} but handles an error with the provided handler.

To import and use `forkWithErrorHandler` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.forkWithErrorHandler
```

**Signature**

```ts
export declare const forkWithErrorHandler: {
  <E, X>(handler: (e: E) => Effect<X>): <A, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>
  <A, E, R, X>(self: Effect<A, E, R>, handler: (e: E) => Effect<X>): Effect<Fiber.RuntimeFiber<A, E>, never, R>
}
```


# fromFiber

Creates an `Effect` value that represents the exit value of the specified
fiber.

To import and use `fromFiber` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.fromFiber
```

**Signature**

```ts
export declare const fromFiber: <A, E>(fiber: Fiber.Fiber<A, E>) => Effect<A, E>
```


# fromFiberEffect

Creates an `Effect` value that represents the exit value of a fiber obtained
from an effect.

To import and use `fromFiberEffect` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.fromFiberEffect
```

**Signature**

```ts
export declare const fromFiberEffect: <A, E, R>(fiber: Effect<Fiber.Fiber<A, E>, E, R>) => Effect<A, E, R>
```


# fromNullable

Safely handles nullable values by creating an effect that fails for `null` or
`undefined`.

**Details**

This function ensures that an input value is non-null and non-undefined
before processing it. If the value is valid, the effect succeeds with the
value. If the value is `null` or `undefined`, the effect fails with a
`NoSuchElementException`. This is particularly useful for avoiding
null-related errors by clearly separating valid values from invalid ones in
effectful computations.

The failure with `NoSuchElementException` allows you to explicitly handle
cases where a value is expected but not provided, leading to safer and more
predictable code.

**When to Use**

Use this function when working with values that may be `null` or `undefined`
and you want to ensure that only non-null values are processed. It helps
enforce null-safety and makes error handling more explicit.

To import and use `fromNullable` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.fromNullable
```

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, NoSuchElementException, never>
//      
const maybe1 = Effect.fromNullable(1)

// Effect.runPromiseExit(maybe1).then(console.log)
// Output:
// { _id: 'Exit', _tag: 'Success', value: 1 }

//       Effect<number, NoSuchElementException, never>
//      
const maybe2 = Effect.fromNullable(null as number | null)

// Effect.runPromiseExit(maybe2).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'NoSuchElementException' }
//   }
// }
```

**Signature**

```ts
export declare const fromNullable: <A>(value: A) => Effect<NonNullable<A>, Cause.NoSuchElementException>
```


# functionWithSpan

Wraps a function that returns an effect with a new span for tracing.

To import and use `functionWithSpan` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.functionWithSpan
```

**Example**

```ts
import { Effect } from "effect"

const getTodo = Effect.functionWithSpan({
  body: (id: number) => Effect.succeed(`Got todo ${id}!`),
  options: (id) => ({
    name: `getTodo-${id}`,
    attributes: { id }
  })
})
```

**Signature**

```ts
export declare const functionWithSpan: <Args extends Array<any>, Ret extends Effect<any, any, any>>(options: {
  readonly body: (...args: Args) => Ret
  readonly options: FunctionWithSpanOptions | ((...args: Args) => FunctionWithSpanOptions)
  readonly captureStackTrace?: boolean | undefined
}) => (...args: Args) => Unify.Unify<Ret>
```


# FunctionWithSpanOptions

Wraps a function that returns an effect with a new span for tracing.

To import and use `FunctionWithSpanOptions` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.FunctionWithSpanOptions
```


# gen

Provides a way to write effectful code using generator functions, simplifying
control flow and error handling.

**When to Use**

`Effect.gen` allows you to write code that looks and behaves like synchronous
code, but it can handle asynchronous tasks, errors, and complex control flow
(like loops and conditions). It helps make asynchronous code more readable
and easier to manage.

The generator functions work similarly to `async/await` but with more
explicit control over the execution of effects. You can `yield*` values from
effects and return the final result at the end.

To import and use `gen` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.gen
```

**Example**

```ts
import { Effect } from "effect"

const addServiceCharge = (amount: number) => amount + 1

const applyDiscount = (total: number, discountRate: number): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

const fetchDiscountRate = Effect.promise(() => Promise.resolve(5))

export const program = Effect.gen(function* () {
  const transactionAmount = yield* fetchTransactionAmount
  const discountRate = yield* fetchDiscountRate
  const discountedAmount = yield* applyDiscount(transactionAmount, discountRate)
  const finalAmount = addServiceCharge(discountedAmount)
  return `Final amount to charge: ${finalAmount}`
})
```

**Signature**

```ts
export declare const gen: {
  <Eff extends YieldWrap<Effect<any, any, any>>, AEff>(
    f: (resume: Adapter) => Generator<Eff, AEff, never>
  ): Effect<
    AEff,
    [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,
    [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never
  >
  <Self, Eff extends YieldWrap<Effect<any, any, any>>, AEff>(
    self: Self,
    f: (this: Self, resume: Adapter) => Generator<Eff, AEff, never>
  ): Effect<
    AEff,
    [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,
    [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never
  >
}
```


# getFiberRefs

Returns a collection of all `FiberRef` values for the fiber running this
effect.

To import and use `getFiberRefs` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.getFiberRefs
```

**Signature**

```ts
export declare const getFiberRefs: Effect<FiberRefs.FiberRefs, never, never>
```


# getRuntimeFlags

Retrieves an effect that succeeds with the current runtime flags, which
govern behavior and features of the runtime system.

To import and use `getRuntimeFlags` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.getRuntimeFlags
```

**Signature**

```ts
export declare const getRuntimeFlags: Effect<RuntimeFlags.RuntimeFlags, never, never>
```


# head

Returns the first element of the iterable if the collection is non-empty, or
fails with the error `NoSuchElementException` if the collection is empty.

**When to Use**

This function is useful when you need to retrieve the first item from a
collection and want to handle the case where the collection might be empty
without causing an unhandled exception.

To import and use `head` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.head
```

**Example**

```ts
import { Effect } from "effect"

// Simulate an async operation
const fetchNumbers = Effect.succeed([1, 2, 3]).pipe(Effect.delay("100 millis"))

const program = Effect.gen(function* () {
  const firstElement = yield* Effect.head(fetchNumbers)
  console.log(firstElement)
})

// Effect.runFork(program)
// Output: 1
```

**Signature**

```ts
export declare const head: <A, E, R>(self: Effect<Iterable<A>, E, R>) => Effect<A, Cause.NoSuchElementException | E, R>
```


# if

Executes one of two effects based on a condition evaluated by an effectful predicate.

Use `if` to run one of two effects depending on whether the predicate effect
evaluates to `true` or `false`. If the predicate is `true`, the `onTrue` effect
is executed. If it is `false`, the `onFalse` effect is executed instead.

To import and use `if` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.if
```

**Example**

```ts
// Title: Simulating a Coin Flip
import { Effect, Random, Console } from "effect"

const flipTheCoin = Effect.if(Random.nextBoolean, {
  onTrue: () => Console.log("Head"), // Runs if the predicate is true
  onFalse: () => Console.log("Tail") // Runs if the predicate is false
})

// Effect.runFork(flipTheCoin)
```


# ignore

Discards both the success and failure values of an effect.

**When to Use**

`ignore` allows you to run an effect without caring about its result, whether
it succeeds or fails. This is useful when you only care about the side
effects of the effect and do not need to handle or process its outcome.

To import and use `ignore` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.ignore
```

**Example**

```ts
// Title: Using Effect.ignore to Discard Values
import { Effect } from "effect"

//       Effect<number, string, never>
//      
const task = Effect.fail("Uh oh!").pipe(Effect.as(5))

//       Effect<void, never, never>
//      
const program = Effect.ignore(task)
```

**Signature**

```ts
export declare const ignore: <A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>
```


# ignoreLogged

Ignores the result of an effect but logs any failures.

**Details**

This function takes an effect and returns a new effect that ignores whether
the original effect succeeds or fails. However, if the effect fails, it will
log the failure at the Debug level, so you can keep track of any issues that
arise.

**When to Use**

This is useful in scenarios where you want to continue with your program
regardless of the result of the effect, but you still want to be aware of
potential failures that may need attention later.

To import and use `ignoreLogged` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.ignoreLogged
```

**Signature**

```ts
export declare const ignoreLogged: <A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>
```


# inheritFiberRefs

Inherits values from all `FiberRef` instances into current fiber.

To import and use `inheritFiberRefs` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.inheritFiberRefs
```

**Signature**

```ts
export declare const inheritFiberRefs: (childFiberRefs: FiberRefs.FiberRefs) => Effect<void>
```


# interrupt

Represents an effect that interrupts the current fiber.

**Details**

This effect models the explicit interruption of the fiber in which it runs.
When executed, it causes the fiber to stop its operation immediately,
capturing the interruption details such as the fiber's ID and its start time.
The resulting interruption can be observed in the `Exit` type if the effect
is run with functions like {@link runPromiseExit}.

To import and use `interrupt` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.interrupt
```

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function* () {
  console.log("start")
  yield* Effect.sleep("2 seconds")
  yield* Effect.interrupt
  console.log("done")
  return "some result"
})

// Effect.runPromiseExit(program).then(console.log)
// Output:
// start
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Interrupt',
//     fiberId: {
//       _id: 'FiberId',
//       _tag: 'Runtime',
//       id: 0,
//       startTimeMillis: ...
//     }
//   }
// }
```

**Signature**

```ts
export declare const interrupt: Effect<never, never, never>
```


# interruptible

Marks an effect as interruptible.

To import and use `interruptible` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.interruptible
```

**Signature**

```ts
export declare const interruptible: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
```


# interruptibleMask

This function behaves like {@link interruptible}, but it also provides a
`restore` function. This function can be used to restore the interruptibility
of any specific region of code.

To import and use `interruptibleMask` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.interruptibleMask
```

**Signature**

```ts
export declare const interruptibleMask: <A, E, R>(
  f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>
) => Effect<A, E, R>
```


# intoDeferred

Converts an `Effect` into an operation that completes a `Deferred` with its result.

**Details**

The `intoDeferred` function takes an effect and a `Deferred` and ensures that the `Deferred`
is completed based on the outcome of the effect. If the effect succeeds, the `Deferred` is
completed with the success value. If the effect fails, the `Deferred` is completed with the
failure. Additionally, if the effect is interrupted, the `Deferred` will also be interrupted.

To import and use `intoDeferred` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.intoDeferred
```

**Example**

```ts
import { Deferred, Effect } from "effect"

// Define an effect that succeeds
const successEffect = Effect.succeed(42)

const program = Effect.gen(function* () {
  // Create a deferred
  const deferred = yield* Deferred.make<number, string>()

  // Complete the deferred using the successEffect
  const isCompleted = yield* Effect.intoDeferred(successEffect, deferred)

  // Access the value of the deferred
  const value = yield* Deferred.await(deferred)
  console.log(value)

  return isCompleted
})

// Effect.runPromise(program).then(console.log)
// Output:
// 42
// true
```

**Signature**

```ts
export declare const intoDeferred: {
  <A, E>(deferred: Deferred.Deferred<A, E>): <R>(self: Effect<A, E, R>) => Effect<boolean, never, R>
  <A, E, R>(self: Effect<A, E, R>, deferred: Deferred.Deferred<A, E>): Effect<boolean, never, R>
}
```


# isEffect

Checks if a given value is an `Effect` value.

**When to Use**

This function can be useful for checking the type of a value before
attempting to operate on it as an `Effect` value. For example, you could use
`Effect.isEffect` to check the type of a value before using it as an argument
to a function that expects an `Effect` value.

To import and use `isEffect` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.isEffect
```

**Signature**

```ts
export declare const isEffect: (u: unknown) => u is Effect<unknown, unknown, unknown>
```


# isFailure

Checks if an effect has failed.

**Details**

This function evaluates whether an effect has resulted in a failure. It
returns a boolean value wrapped in an effect, with `true` indicating the
effect failed and `false` otherwise.

The resulting effect cannot fail (`never` in the error channel) but retains
the context of the original effect.

To import and use `isFailure` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.isFailure
```

**Example**

```ts
import { Effect } from "effect"

const failure = Effect.fail("Uh oh!")

// console.log(Effect.runSync(Effect.isFailure(failure)))
// Output: true

const defect = Effect.dieMessage("BOOM!")

// Effect.runSync(Effect.isFailure(defect))
// throws: BOOM!
```

**Signature**

```ts
export declare const isFailure: <A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R>
```


# isSuccess

Checks if an effect has succeeded.

**Details**

This function evaluates whether an effect has resulted in a success. It
returns a boolean value wrapped in an effect, with `true` indicating the
effect succeeded and `false` otherwise.

The resulting effect cannot fail (`never` in the error channel) but retains
the context of the original effect.

To import and use `isSuccess` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.isSuccess
```

**Signature**

```ts
export declare const isSuccess: <A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R>
```


# iterate

Repeatedly updates a state through an effectful operation until a condition
is no longer met.

**Details**

This function provides a way to implement effectful loops, similar to a
`while` loop in JavaScript.

```ts
let result = initial

while (options.while(result)) {
  result = options.body(result)
}

return result
```

It starts with an initial state, checks a
condition (`while`), and executes a body operation to update the state if the
condition evaluates to `true`. The process repeats until the condition
returns `false`.

The state is passed between iterations, allowing the body operation to modify
it dynamically. The final state after the loop ends is returned as the result
of the effect.

**When to Use**

This is particularly useful for scenarios where looping logic involves
asynchronous or side-effectful operations, such as polling or iterative
computations that depend on external factors.

To import and use `iterate` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.iterate
```

**Example**

```ts
// Title: Effectful Iteration
import { Effect } from "effect"

const result = Effect.iterate(
  // Initial result
  1,
  {
    // Condition to continue iterating
    while: (result) => result <= 5,
    // Operation to change the result
    body: (result) => Effect.succeed(result + 1)
  }
)

// Effect.runPromise(result).then(console.log)
// Output: 6
```

**Signature**

```ts
export declare const iterate: {
  <A, B extends A, R, E>(
    initial: A,
    options: { readonly while: Refinement<A, B>; readonly body: (b: B) => Effect<A, E, R> }
  ): Effect<A, E, R>
  <A, R, E>(
    initial: A,
    options: { readonly while: Predicate<A>; readonly body: (a: A) => Effect<A, E, R> }
  ): Effect<A, E, R>
}
```


# labelMetrics

Adds labels to metrics within an effect using `MetricLabel` objects.

**Details**

This function allows you to label metrics using `MetricLabel` objects. Labels
help add structured metadata to metrics for categorization and filtering in
monitoring systems. The provided labels will apply to all metrics within the
effect's execution.

To import and use `labelMetrics` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.labelMetrics
```

**Signature**

```ts
export declare const labelMetrics: {
  (labels: Iterable<MetricLabel.MetricLabel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R>(self: Effect<A, E, R>, labels: Iterable<MetricLabel.MetricLabel>): Effect<A, E, R>
}
```


# labelMetricsScoped

Adds labels to metrics within a scope using `MetricLabel` objects.

**Details**

This function allows you to apply labels to all metrics generated within a
specific scope using an array of `MetricLabel` objects. These labels provide
additional metadata to metrics, which can be used for categorization,
filtering, or monitoring purposes. The labels are scoped and will be removed
automatically once the scope is closed, ensuring they are only applied
temporarily within the defined context.

To import and use `labelMetricsScoped` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.labelMetricsScoped
```

**Signature**

```ts
export declare const labelMetricsScoped: (
  labels: ReadonlyArray<MetricLabel.MetricLabel>
) => Effect<void, never, Scope.Scope>
```


# Latch

A `Latch` is a synchronization primitive that allows you to control the
execution of fibers based on an open or closed state. It acts as a gate,
where fibers can wait for the latch to open before proceeding.

**Details**

A `Latch` can be in one of two states: open or closed. Fibers can:

- Wait for the latch to open using `await`.
- Proceed only when the latch is open using `whenOpen`.
- Open the latch to release all waiting fibers using `open`.
- Close the latch to block fibers using `close`.

Additionally, fibers can be released without changing the state of the latch
using `release`.

To import and use `Latch` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.Latch
```


# let

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

To import and use `let` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.let
```

**Example**

```ts
import { Effect, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bind("y", () => Effect.succeed(3)),
  Effect.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
```


# liftPredicate

Transforms a `Predicate` function into an `Effect` returning the input value if the predicate returns `true`
or failing with specified error if the predicate fails

To import and use `liftPredicate` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.liftPredicate
```

**Example**

```ts
import { Effect } from "effect"

const isPositive = (n: number): boolean => n > 0

// succeeds with `1`
Effect.liftPredicate(1, isPositive, (n) => `${n} is not positive`)

// fails with `"0 is not positive"`
Effect.liftPredicate(0, isPositive, (n) => `${n} is not positive`)
```

**Signature**

```ts
export declare const liftPredicate: {
  <A, B extends A, E>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: NoInfer<A>) => E): (a: A) => Effect<B, E>
  <A, E>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E): (a: A) => Effect<A, E>
  <A, E, B extends A>(self: A, refinement: Refinement<A, B>, orFailWith: (a: A) => E): Effect<B, E>
  <A, E>(self: A, predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E): Effect<A, E>
}
```


# linkSpans

For all spans in this effect, add a link with the provided span.

To import and use `linkSpans` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.linkSpans
```

**Signature**

```ts
export declare const linkSpans: {
  (span: Tracer.AnySpan, attributes?: Record<string, unknown>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R>(self: Effect<A, E, R>, span: Tracer.AnySpan, attributes?: Record<string, unknown>): Effect<A, E, R>
}
```


# log

Logs one or more messages or error causes at the current log level.

**Details**

This function provides a simple way to log messages or error causes during
the execution of your effects. By default, logs are recorded at the `INFO`
level, but this can be adjusted using other logging utilities
(`Logger.withMinimumLogLevel`). Multiple items, including `Cause` instances,
can be logged in a single call. When logging `Cause` instances, detailed
error information is included in the log output.

The log output includes useful metadata like the current timestamp, log
level, and fiber ID, making it suitable for debugging and tracking purposes.
This function does not interrupt or alter the effect's execution flow.

To import and use `log` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.log
```

**Example**

```ts
import { Cause, Effect } from "effect"

const program = Effect.log("message1", "message2", Cause.die("Oh no!"), Cause.die("Oh uh!"))

// Effect.runFork(program)
// Output:
// timestamp=... level=INFO fiber=#0 message=message1 message=message2 cause="Error: Oh no!
// Error: Oh uh!"
```

**Signature**

```ts
export declare const log: (...message: ReadonlyArray<any>) => Effect<void, never, never>
```


# logAnnotations

Retrieves the current log annotations for the current scope.

**Details**

This function provides access to the log annotations associated with the
current scope. Log annotations are key-value pairs that provide additional
context to log entries. They are often used to add metadata such as tags,
identifiers, or extra debugging information to logs.

By using this function, you can inspect or utilize the annotations applied to
the current scope, making it easier to trace and debug specific sections of
your application.

To import and use `logAnnotations` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.logAnnotations
```

**Signature**

```ts
export declare const logAnnotations: Effect<HashMap.HashMap<string, unknown>, never, never>
```


# logDebug

Logs messages at the DEBUG log level.

**Details**

This function logs messages at the DEBUG level, which is typically used for
diagnosing application behavior during development. DEBUG messages provide
less detailed information than TRACE logs but are still not shown by default.
To view these logs, adjust the log level using `Logger.withMinimumLogLevel`.

To import and use `logDebug` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.logDebug
```

**Example**

```ts
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.logDebug("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))

// Effect.runFork(program)
// timestamp=... level=DEBUG fiber=#0 message=message1
```

**Signature**

```ts
export declare const logDebug: (...message: ReadonlyArray<any>) => Effect<void, never, never>
```


# logError

Logs messages at the ERROR log level.

**Details**

This function logs messages at the ERROR level, suitable for reporting
application errors or failures. These logs are typically used for unexpected
issues that need immediate attention.

To import and use `logError` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.logError
```

**Signature**

```ts
export declare const logError: (...message: ReadonlyArray<any>) => Effect<void, never, never>
```


# logFatal

Logs messages at the FATAL log level.

**Details**

This function logs messages at the FATAL level, suitable for reporting
critical errors that cause the application to terminate or stop functioning.
These logs are typically used for unrecoverable errors that require immediate
attention.

To import and use `logFatal` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.logFatal
```

**Signature**

```ts
export declare const logFatal: (...message: ReadonlyArray<any>) => Effect<void, never, never>
```


# logInfo

Logs messages at the INFO log level.

**Details**

This function logs messages at the INFO level, suitable for general
application events or operational messages. INFO logs are shown by default
and are commonly used for highlighting normal, non-error operations.

To import and use `logInfo` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.logInfo
```

**Signature**

```ts
export declare const logInfo: (...message: ReadonlyArray<any>) => Effect<void, never, never>
```


# logTrace

Logs messages at the TRACE log level.

**Details**

This function logs the specified messages at the TRACE level. TRACE logs are
typically used for very detailed diagnostic information. These messages are
not displayed by default. To view them, you must adjust the logging
configuration by setting the minimum log level to `LogLevel.Trace` using
`Logger.withMinimumLogLevel`.

To import and use `logTrace` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.logTrace
```

**Example**

```ts
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.logTrace("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Trace))

// Effect.runFork(program)
// timestamp=... level=TRACE fiber=#0 message=message1
```

**Signature**

```ts
export declare const logTrace: (...message: ReadonlyArray<any>) => Effect<void, never, never>
```


# logWarning

Logs messages at the WARNING log level.

**Details**

This function logs messages at the WARNING level, suitable for highlighting
potential issues that are not errors but may require attention. These
messages indicate that something unexpected occurred or might lead to errors
in the future.

To import and use `logWarning` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.logWarning
```

**Signature**

```ts
export declare const logWarning: (...message: ReadonlyArray<any>) => Effect<void, never, never>
```


# logWithLevel

Logs messages or error causes at a specified log level.

**Details**

This function allows you to log one or more messages or error causes while
specifying the desired log level (e.g., DEBUG, INFO, ERROR). It provides
flexibility in categorizing logs based on their importance or severity,
making it easier to filter logs during debugging or production monitoring.

To import and use `logWithLevel` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.logWithLevel
```

**Example**

```ts
import { Cause, Effect, LogLevel } from "effect"

const program = Effect.logWithLevel(LogLevel.Error, "Critical error encountered", Cause.die("System failure!"))

// Effect.runFork(program)
// Output:
// timestamp=... level=ERROR fiber=#0 message=Critical error encountered cause="Error: System failure!"
```

**Signature**

```ts
export declare const logWithLevel: (level: LogLevel.LogLevel, ...message: ReadonlyArray<any>) => Effect<void>
```


# loop

Repeatedly executes a loop with a state, collecting results or discarding
them based on configuration.

**Details**

This function performs an effectful loop, starting with an initial state and
iterating as long as the `while` condition evaluates to `true`, similar to a
`while` loop in JavaScript.

```ts
let state = initial
const result = []

while (options.while(state)) {
  result.push(options.body(state)) // Perform the effectful operation
  state = options.step(state) // Update the state
}

return result
```

During each iteration, the `step` function updates the state, and the `body`
effect is executed.

The results of the body effect can be collected in an array or discarded
based on the `discard` option.

**Discarding Intermediate Results**

- If `discard` is `false` or not provided, the intermediate results are
  collected into an array and returned as the final result.
- If `discard` is `true`, the intermediate results are ignored, and the
  effect returns `void`.

**When to Use**

This is useful for implementing loops where you need to perform effectful
computations repeatedly, such as processing items in a list, generating
values, or performing iterative updates.

To import and use `loop` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.loop
```

**Example**

```ts
// Title: Looping with Collected Results
import { Effect } from "effect"

// A loop that runs 5 times, collecting each iteration's result
const result = Effect.loop(
  // Initial state
  1,
  {
    // Condition to continue looping
    while: (state) => state <= 5,
    // State update function
    step: (state) => state + 1,
    // Effect to be performed on each iteration
    body: (state) => Effect.succeed(state)
  }
)

// Effect.runPromise(result).then(console.log)
// Output: [1, 2, 3, 4, 5]
```

**Example**

```ts
// Title: Loop with Discarded Results
import { Effect, Console } from "effect"

const result = Effect.loop(
  // Initial state
  1,
  {
    // Condition to continue looping
    while: (state) => state <= 5,
    // State update function
    step: (state) => state + 1,
    // Effect to be performed on each iteration
    body: (state) => Console.log(`Currently at state ${state}`),
    // Discard intermediate results
    discard: true
  }
)

// Effect.runPromise(result).then(console.log)
// Output:
// Currently at state 1
// Currently at state 2
// Currently at state 3
// Currently at state 4
// Currently at state 5
// undefined
```

**Signature**

```ts
export declare const loop: {
  <A, B extends A, C, E, R>(
    initial: A,
    options: {
      readonly while: Refinement<A, B>
      readonly step: (b: B) => A
      readonly body: (b: B) => Effect<C, E, R>
      readonly discard?: false | undefined
    }
  ): Effect<Array<C>, E, R>
  <A, C, E, R>(
    initial: A,
    options: {
      readonly while: (a: A) => boolean
      readonly step: (a: A) => A
      readonly body: (a: A) => Effect<C, E, R>
      readonly discard?: false | undefined
    }
  ): Effect<Array<C>, E, R>
  <A, B extends A, C, E, R>(
    initial: A,
    options: {
      readonly while: Refinement<A, B>
      readonly step: (b: B) => A
      readonly body: (b: B) => Effect<C, E, R>
      readonly discard: true
    }
  ): Effect<void, E, R>
  <A, C, E, R>(
    initial: A,
    options: {
      readonly while: (a: A) => boolean
      readonly step: (a: A) => A
      readonly body: (a: A) => Effect<C, E, R>
      readonly discard: true
    }
  ): Effect<void, E, R>
}
```


# makeLatch

Creates a new `Latch`, starting in the specified state.

**Details**

This function initializes a `Latch` safely, ensuring proper runtime
guarantees. By default, the latch starts in the closed state.

To import and use `makeLatch` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.makeLatch
```

**Example**

```ts
import { Console, Effect } from "effect"

const program = Effect.gen(function* () {
  // Create a latch, starting in the closed state
  const latch = yield* Effect.makeLatch(false)

  // Fork a fiber that logs "open sesame" when the latch is opened
  const fiber = yield* Console.log("open sesame").pipe(latch.whenOpen, Effect.fork)

  yield* Effect.sleep("1 second")

  // Open the latch
  yield* latch.open
  yield* fiber.await
})

// Effect.runFork(program)
// Output: open sesame (after 1 second)
```

**Signature**

```ts
export declare const makeLatch: (open?: boolean | undefined) => Effect<Latch, never, never>
```


# makeSemaphore

Creates a new semaphore with the specified number of permits.

**Details**

This function initializes a semaphore that controls concurrent access to a
shared resource. The number of permits determines how many tasks can access
the resource concurrently.

To import and use `makeSemaphore` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.makeSemaphore
```

**Example**

```ts
import { Effect } from "effect"

// Create a semaphore with 3 permits
const mutex = Effect.makeSemaphore(3)
```

**Signature**

```ts
export declare const makeSemaphore: (permits: number) => Effect<Semaphore>
```


# makeSpan

Create a new span for tracing.

To import and use `makeSpan` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.makeSpan
```

**Signature**

```ts
export declare const makeSpan: (name: string, options?: Tracer.SpanOptions) => Effect<Tracer.Span>
```


# makeSpanScoped

Create a new span for tracing, and automatically close it when the Scope
finalizes.

The span is not added to the current span stack, so no child spans will be
created for it.

To import and use `makeSpanScoped` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.makeSpanScoped
```

**Signature**

```ts
export declare const makeSpanScoped: (
  name: string,
  options?: Tracer.SpanOptions | undefined
) => Effect<Tracer.Span, never, Scope.Scope>
```


# map

Transforms the value inside an effect by applying a function to it.

**Syntax**

```ts
const mappedEffect = pipe(myEffect, Effect.map(transformation))
// or
const mappedEffect = Effect.map(myEffect, transformation)
// or
const mappedEffect = myEffect.pipe(Effect.map(transformation))
```

**Details**

`map` takes a function and applies it to the value contained within an
effect, creating a new effect with the transformed value.

It's important to note that effects are immutable, meaning that the original
effect is not modified. Instead, a new effect is returned with the updated
value.

To import and use `map` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.map
```

**Example**

```ts
// Title: Adding a Service Charge
import { pipe, Effect } from "effect"

const addServiceCharge = (amount: number) => amount + 1

const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

const finalAmount = pipe(fetchTransactionAmount, Effect.map(addServiceCharge))

// Effect.runPromise(finalAmount).then(console.log)
// Output: 101
```

**Signature**

```ts
export declare const map: {
  <A, B>(f: (a: A) => B): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>
  <A, E, R, B>(self: Effect<A, E, R>, f: (a: A) => B): Effect<B, E, R>
}
```


# mapAccum

Applies a stateful transformation to each element of a collection, producing
new elements along with an updated state.

**When to Use**

Use `mapAccum` when you need to process each element of a collection while
keeping track of some state across iterations.

**Details**

`mapAccum` takes an initial state (`initial`) and a function (`f`) that is
applied to each element. This function returns a new state and a transformed
element. The final effect produces both the accumulated state and the
transformed collection.

If the input collection is a non-empty array, the return type will match the
input collection type.

To import and use `mapAccum` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.mapAccum
```

**Example**

```ts
import { Effect } from "effect"

// Define an initial state and a transformation function
const initialState = 0

const transformation = (state: number, element: string) =>
  Effect.succeed<[number, string]>([state + element.length, element.toUpperCase()])

// Apply mapAccum to transform an array of strings
const program = Effect.mapAccum(["a", "bb", "ccc"], initialState, transformation)

// Effect.runPromise(program).then(([finalState, transformedCollection]) => {
//   console.log(finalState)
//   console.log(transformedCollection)
// })
// Output:
// 6
// [ 'A', 'BB', 'CCC' ]
```

**Signature**

```ts
export declare const mapAccum: {
  <S, A, B, E, R, I extends Iterable<A> = Iterable<A>>(
    initial: S,
    f: (state: S, a: RA.ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>
  ): (elements: I) => Effect<[S, RA.ReadonlyArray.With<I, B>], E, R>
  <A, S, B, E, R, I extends Iterable<A> = Iterable<A>>(
    elements: I,
    initial: S,
    f: (state: S, a: RA.ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>
  ): Effect<[S, RA.ReadonlyArray.With<I, B>], E, R>
}
```


# mapBoth

Applies transformations to both the success and error channels of an effect.

**Details**

This function takes two map functions as arguments: one for the error channel
and one for the success channel. You can use it when you want to modify both
the error and the success values without altering the overall success or
failure status of the effect.

To import and use `mapBoth` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.mapBoth
```

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, string, never>
//      
const simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))

//       Effect<boolean, Error, never>
//      
const modified = Effect.mapBoth(simulatedTask, {
  onFailure: (message) => new Error(message),
  onSuccess: (n) => n > 0
})
```

**Signature**

```ts
export declare const mapBoth: {
  <E, E2, A, A2>(options: {
    readonly onFailure: (e: E) => E2
    readonly onSuccess: (a: A) => A2
  }): <R>(self: Effect<A, E, R>) => Effect<A2, E2, R>
  <A, E, R, E2, A2>(
    self: Effect<A, E, R>,
    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }
  ): Effect<A2, E2, R>
}
```


# mapError

Transforms or modifies the error produced by an effect without affecting its
success value.

**When to Use**

This function is helpful when you want to enhance the error with additional
information, change the error type, or apply custom error handling while
keeping the original behavior of the effect's success values intact. It only
operates on the error channel and leaves the success channel unchanged.

To import and use `mapError` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.mapError
```

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, string, never>
//      
const simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))

//       Effect<number, Error, never>
//      
const mapped = Effect.mapError(simulatedTask, (message) => new Error(message))
```

**Signature**

```ts
export declare const mapError: {
  <E, E2>(f: (e: E) => E2): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>
  <A, E, R, E2>(self: Effect<A, E, R>, f: (e: E) => E2): Effect<A, E2, R>
}
```


# mapErrorCause

Maps the cause of failure of an effect using a specified function.

To import and use `mapErrorCause` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.mapErrorCause
```

**Signature**

```ts
export declare const mapErrorCause: {
  <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>
  <A, E, R, E2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Effect<A, E2, R>
}
```


# mapInputContext

Provides part of the required context while leaving the rest unchanged.

**Details**

This function allows you to transform the context required by an effect,
providing part of the context and leaving the rest to be fulfilled later.

To import and use `mapInputContext` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.mapInputContext
```

**Example**

```ts
import { Context, Effect } from "effect"

class Service1 extends Context.Tag("Service1")<Service1, { readonly port: number }>() {}
class Service2 extends Context.Tag("Service2")<Service2, { readonly connection: string }>() {}

const program = Effect.gen(function* () {
  const service1 = yield* Service1
  console.log(service1.port)
  const service2 = yield* Service2
  console.log(service2.connection)
  return "some result"
})

//       Effect<string, never, Service2>
//      
const programWithService1 = Effect.mapInputContext(program, (ctx: Context.Context<Service2>) =>
  Context.add(ctx, Service1, { port: 3000 })
)

const runnable = programWithService1.pipe(
  Effect.provideService(Service2, { connection: "localhost" }),
  Effect.provideService(Service1, { port: 3001 })
)

Effect.runPromise(runnable)
// Output:
// 3000
// localhost
```

**Signature**

```ts
export declare const mapInputContext: {
  <R2, R>(f: (context: Context.Context<R2>) => Context.Context<R>): <A, E>(self: Effect<A, E, R>) => Effect<A, E, R2>
  <A, E, R, R2>(self: Effect<A, E, R>, f: (context: Context.Context<R2>) => Context.Context<R>): Effect<A, E, R2>
}
```


# match

Handles both success and failure cases of an effect without performing side
effects.

**Details**

`match` lets you define custom handlers for both success and failure
scenarios. You provide separate functions to handle each case, allowing you
to process the result if the effect succeeds, or handle the error if the
effect fails.

**When to Use**

This is useful for structuring your code to respond differently to success or
failure without triggering side effects.

To import and use `match` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.match
```

**Example**

```ts
// Title: Handling Both Success and Failure Cases
import { Effect } from "effect"

const success: Effect.Effect<number, Error> = Effect.succeed(42)

const program1 = Effect.match(success, {
  onFailure: (error) => `failure: ${error.message}`,
  onSuccess: (value) => `success: ${value}`
})

// Run and log the result of the successful effect
// Effect.runPromise(program1).then(console.log)
// Output: "success: 42"

const failure: Effect.Effect<number, Error> = Effect.fail(new Error("Uh oh!"))

const program2 = Effect.match(failure, {
  onFailure: (error) => `failure: ${error.message}`,
  onSuccess: (value) => `success: ${value}`
})

// Run and log the result of the failed effect
// Effect.runPromise(program2).then(console.log)
// Output: "failure: Uh oh!"
```

**Signature**

```ts
export declare const match: {
  <E, A2, A, A3>(options: {
    readonly onFailure: (error: E) => A2
    readonly onSuccess: (value: A) => A3
  }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>
  <A, E, R, A2, A3>(
    self: Effect<A, E, R>,
    options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3 }
  ): Effect<A2 | A3, never, R>
}
```


# matchCause

Handles failures by matching the cause of failure.

**Details**

The `matchCause` function allows you to handle failures with access to the
full cause of the failure within a fiber.

**When to Use**

This is useful for differentiating between different types of errors, such as
regular failures, defects, or interruptions. You can provide specific
handling logic for each failure type based on the cause.

To import and use `matchCause` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.matchCause
```

**Example**

```ts
// Title: Handling Different Failure Causes
import { Effect } from "effect"

const task: Effect.Effect<number, Error> = Effect.die("Uh oh!")

const program = Effect.matchCause(task, {
  onFailure: (cause) => {
    switch (cause._tag) {
      case "Fail":
        // Handle standard failure
        return `Fail: ${cause.error.message}`
      case "Die":
        // Handle defects (unexpected errors)
        return `Die: ${cause.defect}`
      case "Interrupt":
        // Handle interruption
        return `${cause.fiberId} interrupted!`
    }
    // Fallback for other causes
    return "failed due to other causes"
  },
  onSuccess: (value) =>
    // task completes successfully
    `succeeded with ${value} value`
})

// Effect.runPromise(program).then(console.log)
// Output: "Die: Uh oh!"
```

**Signature**

```ts
export declare const matchCause: {
  <E, A2, A, A3>(options: {
    readonly onFailure: (cause: Cause.Cause<E>) => A2
    readonly onSuccess: (a: A) => A3
  }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>
  <A, E, R, A2, A3>(
    self: Effect<A, E, R>,
    options: { readonly onFailure: (cause: Cause.Cause<E>) => A2; readonly onSuccess: (a: A) => A3 }
  ): Effect<A2 | A3, never, R>
}
```


# matchCauseEffect

Handles failures with access to the cause and allows performing side effects.

**Details**

The `matchCauseEffect` function works similarly to {@link matchCause}, but it
also allows you to perform additional side effects based on the failure
cause. This function provides access to the complete cause of the failure,
making it possible to differentiate between various failure types, and allows
you to respond accordingly while performing side effects (like logging or
other operations).

To import and use `matchCauseEffect` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.matchCauseEffect
```

**Example**

```ts
// Title: Handling Different Failure Causes with Side Effects
import { Effect, Console } from "effect"

const task: Effect.Effect<number, Error> = Effect.die("Uh oh!")

const program = Effect.matchCauseEffect(task, {
  onFailure: (cause) => {
    switch (cause._tag) {
      case "Fail":
        // Handle standard failure with a logged message
        return Console.log(`Fail: ${cause.error.message}`)
      case "Die":
        // Handle defects (unexpected errors) by logging the defect
        return Console.log(`Die: ${cause.defect}`)
      case "Interrupt":
        // Handle interruption and log the fiberId that was interrupted
        return Console.log(`${cause.fiberId} interrupted!`)
    }
    // Fallback for other causes
    return Console.log("failed due to other causes")
  },
  onSuccess: (value) =>
    // Log success if the task completes successfully
    Console.log(`succeeded with ${value} value`)
})

// Effect.runPromise(program)
// Output: "Die: Uh oh!"
```

**Signature**

```ts
export declare const matchCauseEffect: {
  <E, A2, E2, R2, A, A3, E3, R3>(options: {
    readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>
    readonly onSuccess: (a: A) => Effect<A3, E3, R3>
  }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>
  <A, E, R, A2, E2, R2, A3, E3, R3>(
    self: Effect<A, E, R>,
    options: {
      readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>
      readonly onSuccess: (a: A) => Effect<A3, E3, R3>
    }
  ): Effect<A2 | A3, E2 | E3, R2 | R3 | R>
}
```


# matchEffect

Handles both success and failure cases of an effect, allowing for additional
side effects.

**Details**

The `matchEffect` function is similar to {@link match}, but it enables you to
perform side effects in the handlers for both success and failure outcomes.

**When to Use**

This is useful when you need to execute additional actions, like logging or
notifying users, based on whether an effect succeeds or fails.

To import and use `matchEffect` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.matchEffect
```

**Example**

```ts
// Title: Handling Both Success and Failure Cases with Side Effects
import { Effect } from "effect"

const success: Effect.Effect<number, Error> = Effect.succeed(42)
const failure: Effect.Effect<number, Error> = Effect.fail(new Error("Uh oh!"))

const program1 = Effect.matchEffect(success, {
  onFailure: (error) => Effect.succeed(`failure: ${error.message}`).pipe(Effect.tap(Effect.log)),
  onSuccess: (value) => Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))
})

console.log(Effect.runSync(program1))
// Output:
// timestamp=... level=INFO fiber=#0 message="success: 42"
// success: 42

const program2 = Effect.matchEffect(failure, {
  onFailure: (error) => Effect.succeed(`failure: ${error.message}`).pipe(Effect.tap(Effect.log)),
  onSuccess: (value) => Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))
})

console.log(Effect.runSync(program2))
// Output:
// timestamp=... level=INFO fiber=#1 message="failure: Uh oh!"
// failure: Uh oh!
```

**Signature**

```ts
export declare const matchEffect: {
  <E, A2, E2, R2, A, A3, E3, R3>(options: {
    readonly onFailure: (e: E) => Effect<A2, E2, R2>
    readonly onSuccess: (a: A) => Effect<A3, E3, R3>
  }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>
  <A, E, R, A2, E2, R2, A3, E3, R3>(
    self: Effect<A, E, R>,
    options: { readonly onFailure: (e: E) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3> }
  ): Effect<A2 | A3, E2 | E3, R2 | R3 | R>
}
```


# merge

Combines both success and error channels of an effect into a single outcome.

**Details**

This function transforms an effect that may fail into one that always returns
a value, where both success and failure outcomes are handled as values in the
success channel.

**When to Use**

This can be useful when you want to continue execution regardless of the
error type and still capture both successful results and errors as part of
the outcome.

To import and use `merge` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.merge
```

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, string, never>
//      
const program = Effect.fail("Oh uh!").pipe(Effect.as(2))

//       Effect<number | string, never, never>
//      
const recovered = Effect.merge(program)
```

**Signature**

```ts
export declare const merge: <A, E, R>(self: Effect<A, E, R>) => Effect<E | A, never, R>
```


# mergeAll

Merges an `Iterable<Effect<A, E, R>>` to a single effect.

**Details**

This function takes an iterable of effects and combines them into a single
effect. It does this by iterating over each effect in the collection and
applying a function that accumulates results into a "zero" value, which
starts with an initial value and is updated with each effect's success.

The provided function `f` is called for each element in the iterable,
allowing you to specify how to combine the results.

**Options**

The function also allows you to customize how the effects are handled by
specifying options such as concurrency, batching, and how finalizers behave.
These options provide flexibility in running the effects concurrently or
adjusting other execution details.

To import and use `mergeAll` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.mergeAll
```

**Example**

```ts
import { Effect } from "effect"

const numbers = [Effect.succeed(1), Effect.succeed(2), Effect.succeed(3)]
const add = (sum: number, value: number, i: number) => sum + value
const zero = 0

const program = Effect.gen(function* () {
  const total = yield* Effect.mergeAll(numbers, zero, add)
  console.log(total)
})

// Effect.runFork(program)
// Output: 6
```

**Signature**

```ts
export declare const mergeAll: {
  <Z, Eff extends Effect<any, any, any>>(
    zero: Z,
    f: (z: Z, a: Effect.Success<Eff>, i: number) => Z,
    options?:
      | {
          readonly concurrency?: Concurrency | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): (elements: Iterable<Eff>) => Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>
  <Eff extends Effect<any, any, any>, Z>(
    elements: Iterable<Eff>,
    zero: Z,
    f: (z: Z, a: Effect.Success<Eff>, i: number) => Z,
    options?:
      | {
          readonly concurrency?: Concurrency | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>
}
```


# metricLabels

Retrieves the metric labels associated with the current scope.

To import and use `metricLabels` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.metricLabels
```

**Signature**

```ts
export declare const metricLabels: Effect<readonly MetricLabel.MetricLabel[], never, never>
```


# negate

Returns a new effect with the boolean value of this effect negated.

To import and use `negate` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.negate
```

**Signature**

```ts
export declare const negate: <E, R>(self: Effect<boolean, E, R>) => Effect<boolean, E, R>
```


# never

An effect that that runs indefinitely and never produces any result. The
moral equivalent of `while(true) {}`, only without the wasted CPU cycles.

**When to Use**

It could be useful for long-running background tasks or to simulate waiting
behavior without actually consuming resources. This effect is ideal for cases
where you want to keep the program alive or in a certain state without
performing any active work.

To import and use `never` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.never
```

**Signature**

```ts
export declare const never: Effect<never, never, never>
```


# none

Ensures the `Option` is `None`, returning `void`. Otherwise, raises a
`NoSuchElementException`.

**Details**

This function checks if the provided `Option` is `None`. If it is, it returns
an effect that produces no result (i.e., `void`). If the `Option` is not
`None` (i.e., it contains a value), the function will raise a
`NoSuchElementException` error.

**When to Use**

This is useful when you want to ensure that a certain value is absent (i.e.,
`None`) before continuing execution, and to handle cases where the value is
unexpectedly present.

To import and use `none` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.none
```

**Signature**

```ts
export declare const none: <A, E, R>(
  self: Effect<Option.Option<A>, E, R>
) => Effect<void, E | Cause.NoSuchElementException, R>
```


# once

Returns an effect that executes only once, regardless of how many times it's
called.

**Details**

This function ensures that a specific effect is executed only a single time,
no matter how many times it is invoked. The result of the effect will be
cached, and subsequent calls to the effect will immediately return the cached
result without re-executing the original logic.

**When to Use**

Use this function when you need to perform a task only once, regardless of
how many times the effect is triggered. It's particularly useful when you
have initialization tasks, logging, or other one-time actions that should not
be repeated. This can help optimize performance and avoid redundant actions.

To import and use `once` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.once
```

**Example**

```ts
import { Effect, Console } from "effect"

const program = Effect.gen(function* () {
  const task1 = Console.log("task1")
  yield* Effect.repeatN(task1, 2)
  const task2 = yield* Effect.once(Console.log("task2"))
  yield* Effect.repeatN(task2, 2)
})

// Effect.runFork(program)
// Output:
// task1
// task1
// task1
// task2
```

**Signature**

```ts
export declare const once: <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<void, E, R>>
```


# onError

Ensures a cleanup effect runs whenever the calling effect fails, providing
the failure cause to the cleanup effect.

**Details**

This function allows you to attach a cleanup effect that runs whenever the
calling effect fails. The cleanup effect receives the cause of the failure,
allowing you to perform actions such as logging, releasing resources, or
executing additional recovery logic based on the error. The cleanup effect
will execute even if the failure is due to interruption.

Importantly, the cleanup effect itself is uninterruptible, ensuring that it
completes regardless of external interruptions.

To import and use `onError` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.onError
```

**Example**

```ts
import { Console, Effect } from "effect"

// This handler logs the failure cause when the effect fails
const handler = Effect.onError((cause) => Console.log(`Cleanup completed: ${cause}`))

const success = Console.log("Task completed").pipe(Effect.as("some result"), handler)

// Effect.runFork(success)
// Output:
// Task completed

const failure = Console.log("Task failed").pipe(Effect.andThen(Effect.fail("some error")), handler)

// Effect.runFork(failure)
// Output:
// Task failed
// Cleanup completed: Error: some error

const interruption = Console.log("Task interrupted").pipe(Effect.andThen(Effect.interrupt), handler)

// Effect.runFork(interruption)
// Output:
// Task interrupted
// Cleanup completed: All fibers interrupted without errors.
```

**Signature**

```ts
export declare const onError: {
  <E, X, R2>(
    cleanup: (cause: Cause.Cause<E>) => Effect<X, never, R2>
  ): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>
  <A, E, R, X, R2>(
    self: Effect<A, E, R>,
    cleanup: (cause: Cause.Cause<E>) => Effect<X, never, R2>
  ): Effect<A, E, R2 | R>
}
```


# onExit

Guarantees that a cleanup function runs regardless of whether the effect
succeeds, fails, or is interrupted.

**Details**

This function ensures that a provided cleanup function is executed after the
effect completes, regardless of the outcome. The cleanup function is given
the `Exit` value of the effect, which provides detailed information about the
result:

- If the effect succeeds, the `Exit` contains the success value.
- If the effect fails, the `Exit` contains the error or failure cause.
- If the effect is interrupted, the `Exit` reflects the interruption.

The cleanup function is guaranteed to run uninterruptibly, ensuring reliable
resource management even in complex or high-concurrency scenarios.

To import and use `onExit` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.onExit
```

**Example**

```ts
import { Console, Effect, Exit } from "effect"

// Define a cleanup function that logs the outcome of the effect
const handler = Effect.onExit((exit) => Console.log(`Cleanup completed: ${Exit.getOrElse(exit, String)}`))

const success = Console.log("Task completed").pipe(Effect.as("some result"), handler)

// Effect.runFork(success)
// Output:
// Task completed
// Cleanup completed: some result

const failure = Console.log("Task failed").pipe(Effect.andThen(Effect.fail("some error")), handler)

// Effect.runFork(failure)
// Output:
// Task failed
// Cleanup completed: Error: some error

const interruption = Console.log("Task interrupted").pipe(Effect.andThen(Effect.interrupt), handler)

// Effect.runFork(interruption)
// Output:
// Task interrupted
// Cleanup completed: All fibers interrupted without errors.
```

**Signature**

```ts
export declare const onExit: {
  <A, E, X, R2>(
    cleanup: (exit: Exit.Exit<A, E>) => Effect<X, never, R2>
  ): <R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>
  <A, E, R, X, R2>(
    self: Effect<A, E, R>,
    cleanup: (exit: Exit.Exit<A, E>) => Effect<X, never, R2>
  ): Effect<A, E, R | R2>
}
```


# onInterrupt

Registers a cleanup effect to run when an effect is interrupted.

**Details**

This function allows you to specify an effect to run when the fiber is
interrupted. This effect will be executed when the fiber is interrupted,
allowing you to perform cleanup or other actions.

To import and use `onInterrupt` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.onInterrupt
```

**Example**

```ts
// Title: Running a Cleanup Action on Interruption
import { Console, Effect } from "effect"

// This handler is executed when the fiber is interrupted
const handler = Effect.onInterrupt((_fibers) => Console.log("Cleanup completed"))

const success = Console.log("Task completed").pipe(Effect.as("some result"), handler)

// Effect.runFork(success)
// Output:
// Task completed

const failure = Console.log("Task failed").pipe(Effect.andThen(Effect.fail("some error")), handler)

// Effect.runFork(failure)
// Output:
// Task failed

const interruption = Console.log("Task interrupted").pipe(Effect.andThen(Effect.interrupt), handler)

// Effect.runFork(interruption)
// Output:
// Task interrupted
// Cleanup completed
```

**Signature**

```ts
export declare const onInterrupt: {
  <X, R2>(
    cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect<X, never, R2>
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>
  <A, E, R, X, R2>(
    self: Effect<A, E, R>,
    cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect<X, never, R2>
  ): Effect<A, E, R | R2>
}
```


# option

Encapsulates the result of an effect in an `Option`.

**Details**

This function wraps the outcome of an effect in an `Option` type. If the
original effect succeeds, the success value is wrapped in `Option.some`. If
the effect fails, the failure is converted to `Option.none`.

This is particularly useful for scenarios where you want to represent the
absence of a value explicitly, without causing the resulting effect to fail.
The resulting effect has an error type of `never`, meaning it cannot fail
directly. However, unrecoverable errors, also referred to as defects, are
not captured and will still result in failure.

To import and use `option` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.option
```

**Example**

```ts
// Title: Using Effect.option to Handle Errors
import { Effect } from "effect"

const maybe1 = Effect.option(Effect.succeed(1))

// Effect.runPromiseExit(maybe1).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Success',
//   value: { _id: 'Option', _tag: 'Some', value: 1 }
// }

const maybe2 = Effect.option(Effect.fail("Uh oh!"))

// Effect.runPromiseExit(maybe2).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Success',
//   value: { _id: 'Option', _tag: 'None' }
// }

const maybe3 = Effect.option(Effect.die("Boom!"))

// Effect.runPromiseExit(maybe3).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Boom!' }
// }
```

**Signature**

```ts
export declare const option: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, never, R>
```


# optionFromOptional

Converts an effect that may fail with a `NoSuchElementException` into an
effect that succeeds with an `Option`.

**Details**

This function transforms an effect that might fail with
`Cause.NoSuchElementException` into an effect that succeeds with an `Option`
type. If the original effect succeeds, its value is wrapped in `Option.some`.
If it fails specifically due to a `NoSuchElementException`, the failure is
mapped to `Option.none`. Other types of failures remain unchanged and are
passed through as they are.

This is useful when working with effects where you want to gracefully handle
the absence of a value while preserving other potential failures.

**When to Use**

Use this function when you need to handle missing values as `Option.none`
rather than throwing or propagating errors like `NoSuchElementException`.
Its ideal for scenarios where you want to explicitly represent optionality
in a type-safe way while retaining other failure information.

To import and use `optionFromOptional` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.optionFromOptional
```

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, NoSuchElementException, never>
//      
const maybe1 = Effect.fromNullable(1)

//       Effect<Option<number>, never, never>
//      
const option1 = Effect.optionFromOptional(maybe1)

// Effect.runPromise(option1).then(console.log)
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

//       Effect<number, NoSuchElementException, never>
//      
const maybe2 = Effect.fromNullable(null as number | null)

//       Effect<Option<number>, never, never>
//      
const option2 = Effect.optionFromOptional(maybe2)

// Effect.runPromise(option2).then(console.log)
// Output: { _tag: 'None' }
```

**Signature**

```ts
export declare const optionFromOptional: <A, E, R>(
  self: Effect<A, E, R>
) => Effect<Option.Option<A>, Exclude<E, Cause.NoSuchElementException>, R>
```


# orDie

Converts an effect's failure into a fiber termination, removing the error
from the effect's type.

**Details**

The `orDie` function is used when you encounter errors that you do not want
to handle or recover from. It removes the error type from the effect and
ensures that any failure will terminate the fiber. This is useful for
propagating failures as defects, signaling that they should not be handled
within the effect.

\*_When to Use_

Use `orDie` when failures should be treated as unrecoverable defects and no
error handling is required.

To import and use `orDie` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.orDie
```

**Example**

```ts
// Title: Propagating an Error as a Defect
import { Effect } from "effect"

const divide = (a: number, b: number) =>
  b === 0 ? Effect.fail(new Error("Cannot divide by zero")) : Effect.succeed(a / b)

//       Effect<number, never, never>
//      
const program = Effect.orDie(divide(1, 0))

// Effect.runPromise(program).catch(console.error)
// Output:
// (FiberFailure) Error: Cannot divide by zero
//   ...stack trace...
```

**Signature**

```ts
export declare const orDie: <A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R>
```


# orDieWith

Converts an effect's failure into a fiber termination with a custom error.

**Details**

The `orDieWith` function behaves like {@link orDie}, but it allows you to provide a mapping
function to transform the error before terminating the fiber. This is useful for cases where
you want to include a more detailed or user-friendly error when the failure is propagated
as a defect.

**When to Use**

Use `orDieWith` when failures should terminate the fiber as defects, and you want to customize
the error for clarity or debugging purposes.

To import and use `orDieWith` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.orDieWith
```

**Example**

```ts
// Title: Customizing Defect
import { Effect } from "effect"

const divide = (a: number, b: number) =>
  b === 0 ? Effect.fail(new Error("Cannot divide by zero")) : Effect.succeed(a / b)

//       Effect<number, never, never>
//      
const program = Effect.orDieWith(divide(1, 0), (error) => new Error(`defect: ${error.message}`))

// Effect.runPromise(program).catch(console.error)
// Output:
// (FiberFailure) Error: defect: Cannot divide by zero
//   ...stack trace...
```

**Signature**

```ts
export declare const orDieWith: {
  <E>(f: (error: E) => unknown): <A, R>(self: Effect<A, E, R>) => Effect<A, never, R>
  <A, E, R>(self: Effect<A, E, R>, f: (error: E) => unknown): Effect<A, never, R>
}
```


# orElse

Attempts one effect, and if it fails, falls back to another effect.

**Details**

This function allows you to try executing an effect, and if it fails
(produces an error), a fallback effect is executed instead. The fallback
effect is defined as a lazy argument, meaning it will only be evaluated if
the first effect fails. This provides a way to recover from errors by
specifying an alternative path of execution.

The error type of the resulting effect will be that of the fallback effect,
as the first effect's error is replaced when the fallback is executed.

To import and use `orElse` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.orElse
```

**Example**

```ts
import { Effect } from "effect"

const success = Effect.succeed("success")
const failure = Effect.fail("failure")
const fallback = Effect.succeed("fallback")

// Try the success effect first, fallback is not used
const program1 = Effect.orElse(success, () => fallback)
console.log(Effect.runSync(program1))
// Output: "success"

// Try the failure effect first, fallback is used
const program2 = Effect.orElse(failure, () => fallback)
console.log(Effect.runSync(program2))
// Output: "fallback"
```

**Signature**

```ts
export declare const orElse: {
  <A2, E2, R2>(that: LazyArg<Effect<A2, E2, R2>>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>
  <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: LazyArg<Effect<A2, E2, R2>>): Effect<A2 | A, E2, R2 | R>
}
```


# orElseFail

Replaces the failure of an effect with a custom failure value.

**Details**

This function allows you to handle the failure of an effect by replacing it
with a predefined failure value. If the effect fails, the new failure value
provided by the `evaluate` function will be returned instead of the original
failure. If the effect succeeds, the original success value is returned
unchanged.

**When to Use**

This is particularly useful when you want to standardize error handling or
provide a consistent failure value for specific operations. It simplifies
error management by ensuring that all failures are replaced with a controlled
alternative.

To import and use `orElseFail` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.orElseFail
```

**Example**

```ts
import { Effect } from "effect"

const validate = (age: number): Effect.Effect<number, string> => {
  if (age < 0) {
    return Effect.fail("NegativeAgeError")
  } else if (age < 18) {
    return Effect.fail("IllegalAgeError")
  } else {
    return Effect.succeed(age)
  }
}

const program = Effect.orElseFail(validate(-1), () => "invalid age")

console.log(Effect.runSyncExit(program))
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'invalid age' }
// }
```

**Signature**

```ts
export declare const orElseFail: {
  <E2>(evaluate: LazyArg<E2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2, R>
  <A, E, R, E2>(self: Effect<A, E, R>, evaluate: LazyArg<E2>): Effect<A, E2, R>
}
```


# orElseSucceed

Ensures the effect always succeeds by replacing failures with a default
success value.

**Details**

This function transforms an effect that may fail into one that cannot fail by
replacing any failure with a provided success value. If the original effect
fails, the failure is "swallowed," and the specified success value is
returned instead. If the original effect succeeds, its value remains
unchanged.

**When to Use**

This is especially useful for providing default values in case of failure,
ensuring that an effect always completes successfully. By using this
function, you can avoid the need for complex error handling and guarantee a
fallback result.

To import and use `orElseSucceed` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.orElseSucceed
```

**Example**

```ts
import { Effect } from "effect"

const validate = (age: number): Effect.Effect<number, string> => {
  if (age < 0) {
    return Effect.fail("NegativeAgeError")
  } else if (age < 18) {
    return Effect.fail("IllegalAgeError")
  } else {
    return Effect.succeed(age)
  }
}

const program = Effect.orElseSucceed(validate(-1), () => 18)

console.log(Effect.runSyncExit(program))
// Output:
// { _id: 'Exit', _tag: 'Success', value: 18 }
```

**Signature**

```ts
export declare const orElseSucceed: {
  <A2>(evaluate: LazyArg<A2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, never, R>
  <A, E, R, A2>(self: Effect<A, E, R>, evaluate: LazyArg<A2>): Effect<A | A2, never, R>
}
```


# parallelErrors

Combines all errors from concurrent operations into a single error.

**Details**

This function is used when you have multiple operations running at the same
time, and you want to capture all the errors that occur across those
operations. Instead of handling each error separately, it combines all the
errors into one unified error.

**When to Use**

When using this function, any errors that occur in the concurrently running
operations will be grouped together into a single error. This helps simplify
error handling in cases where you don't need to differentiate between each
failure, but simply want to know that multiple failures occurred.

To import and use `parallelErrors` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.parallelErrors
```

**Example**

```ts
import { Effect } from "effect"

const fail1 = Effect.fail("Oh uh!")
const fail2 = Effect.fail("Oh no!")
const die = Effect.dieMessage("Boom!")

// Run all effects concurrently and capture all errors
const program = Effect.all([fail1, fail2, die], {
  concurrency: "unbounded"
}).pipe(Effect.asVoid, Effect.parallelErrors)

// Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: [ 'Oh uh!', 'Oh no!' ] }
// }
```

**Signature**

```ts
export declare const parallelErrors: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Array<E>, R>
```


# parallelFinalizers

Ensures that finalizers are run concurrently when the scope of an effect is
closed.

**Details**

This function modifies the behavior of finalizers within a scoped workflow to
allow them to run concurrently when the scope is closed.

By default, finalizers are executed sequentially in reverse order of their
addition, but this function changes that behavior to execute all finalizers
concurrently.

**When to Use**

Running finalizers concurrently can improve performance when multiple
independent cleanup tasks need to be performed. However, it requires that
these tasks do not depend on the order of execution or introduce race
conditions.

To import and use `parallelFinalizers` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.parallelFinalizers
```

**Example**

```ts
import { Console, Effect } from "effect"

// Define a program that adds multiple finalizers
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer(() => Console.log("Finalizer 1 executed").pipe(Effect.delay("300 millis")))
  yield* Effect.addFinalizer(() => Console.log("Finalizer 2 executed").pipe(Effect.delay("100 millis")))
  yield* Effect.addFinalizer(() => Console.log("Finalizer 3 executed").pipe(Effect.delay("200 millis")))
  return "some result"
})

// Modify the program to ensure finalizers run in parallel
const modified = program.pipe(Effect.parallelFinalizers)

const runnable = Effect.scoped(modified)

// Effect.runFork(runnable)
// Output:
// Finalizer 2 executed
// Finalizer 3 executed
// Finalizer 1 executed
```

**Signature**

```ts
export declare const parallelFinalizers: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
```


# partition

Processes an iterable and applies an effectful function to each element,
categorizing the results into successes and failures.

**Details**

This function processes each element in the provided iterable by applying an
effectful function to it. The results are then categorized into two separate
lists: one for failures and another for successes. This separation allows you
to handle the two categories differently. Failures are collected in a list
without interrupting the processing of the remaining elements, so the
operation continues even if some elements fail. This is particularly useful
when you need to handle both successful and failed results separately,
without stopping the entire process on encountering a failure.

**When to Use**

Use this function when you want to process a collection of items and handle
errors or failures without interrupting the processing of other items. It's
useful when you need to distinguish between successful and failed results and
process them separately, for example, when logging errors while continuing to
work with valid data. The function ensures that failures are captured, while
successes are processed normally.

To import and use `partition` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.partition
```

**Example**

```ts
import { Effect } from "effect"

//       Effect<[string[], number[]], never, never>
//      
const program = Effect.partition([0, 1, 2, 3, 4], (n) => {
  if (n % 2 === 0) {
    return Effect.succeed(n)
  } else {
    return Effect.fail(`${n} is not even`)
  }
})

// Effect.runPromise(program).then(console.log, console.error)
// Output:
// [ [ '1 is not even', '3 is not even' ], [ 0, 2, 4 ] ]
```

**Signature**

```ts
export declare const partition: {
  <A, B, E, R>(
    f: (a: A, i: number) => Effect<B, E, R>,
    options?:
      | {
          readonly concurrency?: Concurrency | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): (elements: Iterable<A>) => Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>
  <A, B, E, R>(
    elements: Iterable<A>,
    f: (a: A, i: number) => Effect<B, E, R>,
    options?:
      | {
          readonly concurrency?: Concurrency | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>
}
```


# patchFiberRefs

Applies the specified changes to the `FiberRef` values for the fiber
running this workflow.

To import and use `patchFiberRefs` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.patchFiberRefs
```

**Signature**

```ts
export declare const patchFiberRefs: (patch: FiberRefsPatch.FiberRefsPatch) => Effect<void>
```


# promise

Creates an `Effect` that represents an asynchronous computation guaranteed to
succeed.

**Details**

The provided function (`thunk`) returns a `Promise` that should never reject; if it does, the error
will be treated as a "defect".

This defect is not a standard error but indicates a flaw in the logic that
was expected to be error-free. You can think of it similar to an unexpected
crash in the program, which can be further managed or logged using tools like
{@link catchAllDefect}.

**Interruptions**

An optional `AbortSignal` can be provided to allow for interruption of the
wrapped `Promise` API.

**When to Use**

Use this function when you are sure the operation will not reject.

To import and use `promise` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.promise
```

**Example**

```ts
// Title: Delayed Message
import { Effect } from "effect"

const delay = (message: string) =>
  Effect.promise<string>(
    () =>
      new Promise((resolve) => {
        setTimeout(() => {
          resolve(message)
        }, 2000)
      })
  )

//       Effect<string, never, never>
//      
const program = delay("Async operation completed successfully!")
```

**Signature**

```ts
export declare const promise: <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>) => Effect<A>
```


# provide

Provides necessary dependencies to an effect, removing its environmental
requirements.

**Details**

This function allows you to supply the required environment for an effect.
The environment can be provided in the form of one or more `Layer`s, a
`Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is
provided, the effect can run without requiring external dependencies.

You can compose layers to create a modular and reusable way of setting up the
environment for effects. For example, layers can be used to configure
databases, logging services, or any other required dependencies.

To import and use `provide` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.provide
```

**Example**

```ts
import { Context, Effect, Layer } from "effect"

class Database extends Context.Tag("Database")<
  Database,
  { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }
>() {}

const DatabaseLive = Layer.succeed(Database, {
  // Simulate a database query
  query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))
})

//       Effect<unknown[], never, Database>
//      
const program = Effect.gen(function* () {
  const database = yield* Database
  const result = yield* database.query("SELECT * FROM users")
  return result
})

//       Effect<unknown[], never, never>
//      
const runnable = Effect.provide(program, DatabaseLive)

// Effect.runPromise(runnable).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="Executing query: SELECT * FROM users"
// []
```

**Signature**

```ts
export declare const provide: {
  <const Layers extends [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(
    layers: Layers
  ): <A, E, R>(
    self: Effect<A, E, R>
  ) => Effect<
    A,
    E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]> }[number],
    | { [k in keyof Layers]: Layer.Layer.Context<Layers[k]> }[number]
    | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]> }[number]>
  >
  <ROut, E2, RIn>(
    layer: Layer.Layer<ROut, E2, RIn>
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, RIn | Exclude<R, ROut>>
  <R2>(context: Context.Context<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>
  <R2>(runtime: Runtime.Runtime<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>
  <E2, R2>(
    managedRuntime: ManagedRuntime.ManagedRuntime<R2, E2>
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, Exclude<R, R2>>
  <A, E, R, const Layers extends [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(
    self: Effect<A, E, R>,
    layers: Layers
  ): Effect<
    A,
    E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]> }[number],
    | { [k in keyof Layers]: Layer.Layer.Context<Layers[k]> }[number]
    | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]> }[number]>
  >
  <A, E, R, ROut, E2, RIn>(
    self: Effect<A, E, R>,
    layer: Layer.Layer<ROut, E2, RIn>
  ): Effect<A, E | E2, RIn | Exclude<R, ROut>>
  <A, E, R, R2>(self: Effect<A, E, R>, context: Context.Context<R2>): Effect<A, E, Exclude<R, R2>>
  <A, E, R, R2>(self: Effect<A, E, R>, runtime: Runtime.Runtime<R2>): Effect<A, E, Exclude<R, R2>>
  <A, E, E2, R, R2>(
    self: Effect<A, E, R>,
    runtime: ManagedRuntime.ManagedRuntime<R2, E2>
  ): Effect<A, E | E2, Exclude<R, R2>>
}
```


# provideService

Provides an implementation for a service in the context of an effect.

**Details**

This function allows you to supply a specific implementation for a service
required by an effect. Services are typically defined using `Context.Tag`,
which acts as a unique identifier for the service. By using this function,
you link the service to its concrete implementation, enabling the effect to
execute successfully without additional requirements.

For example, you can use this function to provide a random number generator,
a logger, or any other service your effect depends on. Once the service is
provided, all parts of the effect that rely on the service will automatically
use the implementation you supplied.

To import and use `provideService` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.provideService
```

**Example**

```ts
import { Effect, Context } from "effect"

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag("MyRandomService")<Random, { readonly next: Effect.Effect<number> }>() {}

// Using the service
const program = Effect.gen(function* () {
  const random = yield* Random
  const randomNumber = yield* random.next
  console.log(`random number: ${randomNumber}`)
})

// Providing the implementation
//
//       Effect<void, never, never>
//      
const runnable = Effect.provideService(program, Random, {
  next: Effect.sync(() => Math.random())
})

// Run successfully
// Effect.runPromise(runnable)
// Example Output:
// random number: 0.8241872233134417
```

**Signature**

```ts
export declare const provideService: {
  <I, S>(tag: Context.Tag<I, S>, service: NoInfer<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, I>>
  <A, E, R, I, S>(self: Effect<A, E, R>, tag: Context.Tag<I, S>, service: NoInfer<S>): Effect<A, E, Exclude<R, I>>
}
```


# provideServiceEffect

Dynamically provides an implementation for a service using an effect.

**Details**

This function allows you to provide an implementation for a service
dynamically by using another effect. The provided effect is executed to
produce the service implementation, which is then made available to the
consuming effect. This is particularly useful when the service implementation
itself requires asynchronous or resource-intensive initialization.

For example, you can use this function to lazily initialize a database
connection or fetch configuration values from an external source before
making the service available to your effect.

To import and use `provideServiceEffect` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.provideServiceEffect
```

**Signature**

```ts
export declare const provideServiceEffect: {
  <I, S, E1, R1>(
    tag: Context.Tag<I, S>,
    effect: Effect<NoInfer<S>, E1, R1>
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R1 | Exclude<R, I>>
  <A, E, R, I, S, E1, R1>(
    self: Effect<A, E, R>,
    tag: Context.Tag<I, S>,
    effect: Effect<NoInfer<S>, E1, R1>
  ): Effect<A, E | E1, R1 | Exclude<R, I>>
}
```


# race

Races two effects and returns the result of the first successful one.

**Details**

This function takes two effects and runs them concurrently. The first effect
that successfully completes will determine the result of the race, and the
other effect will be interrupted.

If neither effect succeeds, the function will fail with a `Cause`
containing all the errors.

**When to Use**

This is useful when you want to run two effects concurrently, but only care
about the first one to succeed. It is commonly used in cases like timeouts,
retries, or when you want to optimize for the faster response without
worrying about the other effect.

**Handling Success or Failure with Either**

If you want to handle the result of whichever task completes first, whether
it succeeds or fails, you can use the `Effect.either` function. This function
wraps the result in an `Either` type, allowing you to see if the result
was a success (`Right`) or a failure (`Left`).

To import and use `race` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.race
```

**Example**

```ts
// Title: Both Tasks Succeed
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const program = Effect.race(task1, task2)

// Effect.runFork(program)
// Output:
// task1 done
// task2 interrupted
```

**Example**

```ts
// Title: One Task Fails, One Succeeds
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const program = Effect.race(task1, task2)

// Effect.runFork(program)
// Output:
// task2 done
```

**Example**

```ts
// Title: Both Tasks Fail
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.fail("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const program = Effect.race(task1, task2)

// Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Parallel',
//     left: { _id: 'Cause', _tag: 'Fail', failure: 'task1' },
//     right: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }
//   }
// }
```

**Example**

```ts
// Title: Handling Success or Failure with Either
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

// Run both tasks concurrently, wrapping the result
// in Either to capture success or failure
const program = Effect.race(Effect.either(task1), Effect.either(task2))

// Effect.runPromise(program).then(console.log)
// Output:
// task2 interrupted
// { _id: 'Either', _tag: 'Left', left: 'task1' }
```

**Signature**

```ts
export declare const race: {
  <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>
}
```


# raceAll

Races multiple effects and returns the first successful result.

**Details**

This function runs multiple effects concurrently and returns the result of
the first one to succeed. If one effect succeeds, the others will be
interrupted.

If none of the effects succeed, the function will fail with the last error
encountered.

**When to Use**

This is useful when you want to race multiple effects, but only care about
the first one to succeed. It is commonly used in cases like timeouts,
retries, or when you want to optimize for the faster response without
worrying about the other effects.

To import and use `raceAll` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.raceAll
```

**Example**

```ts
// Title: All Tasks Succeed
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const task3 = Effect.succeed("task3").pipe(
  Effect.delay("150 millis"),
  Effect.tap(Console.log("task3 done")),
  Effect.onInterrupt(() => Console.log("task3 interrupted"))
)

const program = Effect.raceAll([task1, task2, task3])

// Effect.runFork(program)
// Output:
// task1 done
// task2 interrupted
// task3 interrupted
```

**Example**

```ts
// Title: One Task Fails, Two Tasks Succeed
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const task3 = Effect.succeed("task3").pipe(
  Effect.delay("150 millis"),
  Effect.tap(Console.log("task3 done")),
  Effect.onInterrupt(() => Console.log("task3 interrupted"))
)

const program = Effect.raceAll([task1, task2, task3])

// Effect.runFork(program)
// Output:
// task3 done
// task2 interrupted
```

**Example**

```ts
// Title: All Tasks Fail
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.fail("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const task3 = Effect.fail("task3").pipe(
  Effect.delay("150 millis"),
  Effect.tap(Console.log("task3 done")),
  Effect.onInterrupt(() => Console.log("task3 interrupted"))
)

const program = Effect.raceAll([task1, task2, task3])

// Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }
// }
```

**Signature**

```ts
export declare const raceAll: <Eff extends Effect<any, any, any>>(
  all: Iterable<Eff>
) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>>
```


# raceFirst

Races two effects and returns the result of the first one to complete.

**Details**

This function takes two effects and runs them concurrently, returning the
result of the first one that completes, regardless of whether it succeeds or
fails.

**When to Use**

This function is useful when you want to race two operations, and you want to
proceed with whichever one finishes first, regardless of whether it succeeds
or fails.

**Disconnecting Effects**

The `Effect.raceFirst` function safely interrupts the loser effect once the other completes, but it will not resume until the loser is cleanly terminated.

If you want a quicker return, you can disconnect the interrupt signal for both effects. Instead of calling:

```ts
Effect.raceFirst(task1, task2)
```

You can use:

```ts
Effect.raceFirst(Effect.disconnect(task1), Effect.disconnect(task2))
```

This allows both effects to complete independently while still terminating the losing effect in the background.

To import and use `raceFirst` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.raceFirst
```

**Example**

```ts
// Title: Both Tasks Succeed
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted").pipe(Effect.delay("100 millis")))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted").pipe(Effect.delay("100 millis")))
)

const program = Effect.raceFirst(task1, task2).pipe(Effect.tap(Console.log("more work...")))

// Effect.runPromiseExit(program).then(console.log)
// Output:
// task1 done
// task2 interrupted
// more work...
// { _id: 'Exit', _tag: 'Success', value: 'task1' }
```

**Example**

```ts
// Title: One Task Fails, One Succeeds
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted").pipe(Effect.delay("100 millis")))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted").pipe(Effect.delay("100 millis")))
)

const program = Effect.raceFirst(task1, task2).pipe(Effect.tap(Console.log("more work...")))

// Effect.runPromiseExit(program).then(console.log)
// Output:
// task2 interrupted
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task1' }
// }
```

**Example**

```ts
// Title: Using Effect.disconnect for Quicker Return
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted").pipe(Effect.delay("100 millis")))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted").pipe(Effect.delay("100 millis")))
)

// Race the two tasks with disconnect to allow quicker return
const program = Effect.raceFirst(Effect.disconnect(task1), Effect.disconnect(task2)).pipe(
  Effect.tap(Console.log("more work..."))
)

// Effect.runPromiseExit(program).then(console.log)
// Output:
// task1 done
// more work...
// { _id: 'Exit', _tag: 'Success', value: 'task1' }
// task2 interrupted
```

**Signature**

```ts
export declare const raceFirst: {
  <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>
}
```


# raceWith

Races two effects and calls a finisher when the first one completes.

**Details**

This function runs two effects concurrently and calls a specified finisher
function once one of the effects completes, regardless of whether it succeeds
or fails.

The finisher functions for each effect allow you to handle the results of
each effect as soon as they complete.

The function takes two finisher callbacks, one for each effect, and allows
you to specify how to handle the result of the race.

**When to Use**

This function is useful when you need to react to the completion of either
effect without waiting for both to finish. It can be used whenever you want
to take action based on the first available result.

To import and use `raceWith` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.raceWith
```

**Example**

```ts
// Title: Handling Results of Concurrent Tasks
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted").pipe(Effect.delay("100 millis")))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted").pipe(Effect.delay("100 millis")))
)

const program = Effect.raceWith(task1, task2, {
  onSelfDone: (exit) => Console.log(`task1 exited with ${exit}`),
  onOtherDone: (exit) => Console.log(`task2 exited with ${exit}`)
})

// Effect.runFork(program)
// Output:
// task1 done
// task1 exited with {
//   "_id": "Exit",
//   "_tag": "Success",
//   "value": "task1"
// }
// task2 interrupted
```

**Signature**

```ts
export declare const raceWith: {
  <A1, E1, R1, E, A, A2, E2, R2, A3, E3, R3>(
    other: Effect<A1, E1, R1>,
    options: {
      readonly onSelfDone: (exit: Exit.Exit<A, E>, fiber: Fiber.Fiber<A1, E1>) => Effect<A2, E2, R2>
      readonly onOtherDone: (exit: Exit.Exit<A1, E1>, fiber: Fiber.Fiber<A, E>) => Effect<A3, E3, R3>
    }
  ): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R1 | R2 | R3 | R>
  <A, E, R, A1, E1, R1, A2, E2, R2, A3, E3, R3>(
    self: Effect<A, E, R>,
    other: Effect<A1, E1, R1>,
    options: {
      readonly onSelfDone: (exit: Exit.Exit<A, E>, fiber: Fiber.Fiber<A1, E1>) => Effect<A2, E2, R2>
      readonly onOtherDone: (exit: Exit.Exit<A1, E1>, fiber: Fiber.Fiber<A, E>) => Effect<A3, E3, R3>
    }
  ): Effect<A2 | A3, E2 | E3, R | R1 | R2 | R3>
}
```


# random

Retrieves the `Random` service from the context.

To import and use `random` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.random
```

**Signature**

```ts
export declare const random: Effect<Random.Random, never, never>
```


# randomWith

Retrieves the `Random` service from the context and uses it to run the
specified effect.

To import and use `randomWith` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.randomWith
```

**Signature**

```ts
export declare const randomWith: <A, E, R>(f: (random: Random.Random) => Effect<A, E, R>) => Effect<A, E, R>
```


# reduce

Reduces an `Iterable<A>` using an effectual function `f`, working
sequentially from left to right.

**Details**

This function takes an iterable and applies a function `f` to each element in
the iterable. The function works sequentially, starting with an initial value
`zero` and then combining it with each element in the collection. The
provided function `f` is called for each element in the iterable, allowing
you to accumulate a result based on the current value and the element being
processed.

**When to Use**

The function is often used for operations like summing a collection of
numbers or combining results from multiple tasks. It ensures that operations
are performed one after the other, maintaining the order of the elements.

To import and use `reduce` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.reduce
```

**Example**

```ts
import { Console, Effect } from "effect"

const processOrder = (id: number) =>
  Effect.succeed({ id, price: 100 * id }).pipe(
    Effect.tap(() => Console.log(`Order ${id} processed`)),
    Effect.delay(500 - id * 100)
  )

const program = Effect.reduce([1, 2, 3, 4], 0, (acc, id, i) =>
  processOrder(id).pipe(Effect.map((order) => acc + order.price))
)

// Effect.runPromise(program).then(console.log)
// Output:
// Order 1 processed
// Order 2 processed
// Order 3 processed
// Order 4 processed
// 1000
```

**Signature**

```ts
export declare const reduce: {
  <Z, A, E, R>(zero: Z, f: (z: Z, a: A, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>
  <A, Z, E, R>(elements: Iterable<A>, zero: Z, f: (z: Z, a: A, i: number) => Effect<Z, E, R>): Effect<Z, E, R>
}
```


# reduceEffect

Reduces an `Iterable<Effect<A, E, R>>` to a single effect.

**Details**

This function processes a collection of effects and combines them into one
single effect. It starts with an initial effect (`zero`) and applies a
function `f` to each element in the collection.

**Options**

The function also allows you to customize how the effects are handled by
specifying options such as concurrency, batching, and how finalizers behave.
These options provide flexibility in running the effects concurrently or
adjusting other execution details.

To import and use `reduceEffect` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.reduceEffect
```

**Example**

```ts
import { Console, Effect } from "effect"

const processOrder = (id: number) =>
  Effect.succeed({ id, price: 100 * id }).pipe(
    Effect.tap(() => Console.log(`Order ${id} processed`)),
    Effect.delay(500 - id * 100)
  )

const program = Effect.reduceEffect(
  [processOrder(1), processOrder(2), processOrder(3), processOrder(4)],
  Effect.succeed(0),
  (acc, order, i) => acc + order.price
)

// Effect.runPromise(program).then(console.log)
// Output:
// Order 1 processed
// Order 2 processed
// Order 3 processed
// Order 4 processed
// 1000
```

**Signature**

```ts
export declare const reduceEffect: {
  <Z, E, R, Eff extends Effect<any, any, any>>(
    zero: Effect<Z, E, R>,
    f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z,
    options?:
      | {
          readonly concurrency?: Concurrency | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): (elements: Iterable<Eff>) => Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>
  <Eff extends Effect<any, any, any>, Z, E, R>(
    elements: Iterable<Eff>,
    zero: Effect<Z, E, R>,
    f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z,
    options?:
      | {
          readonly concurrency?: Concurrency | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>
}
```


# reduceRight

Reduces an `Iterable<A>` using an effectual function `f`, working
sequentially from right to left.

**Details**

This function takes an iterable and applies a function `f` to each element in
the iterable. The function works sequentially, starting with an initial value
`zero` and then combining it with each element in the collection. The
provided function `f` is called for each element in the iterable, allowing
you to accumulate a result based on the current value and the element being
processed.

**When to Use**

The function is often used for operations like summing a collection of
numbers or combining results from multiple tasks. It ensures that operations
are performed one after the other, maintaining the order of the elements.

To import and use `reduceRight` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.reduceRight
```

**Example**

```ts
import { Console, Effect } from "effect"

const processOrder = (id: number) =>
  Effect.succeed({ id, price: 100 * id }).pipe(
    Effect.tap(() => Console.log(`Order ${id} processed`)),
    Effect.delay(500 - id * 100)
  )

const program = Effect.reduceRight([1, 2, 3, 4], 0, (id, acc, i) =>
  processOrder(id).pipe(Effect.map((order) => acc + order.price))
)

// Effect.runPromise(program).then(console.log)
// Output:
// Order 4 processed
// Order 3 processed
// Order 2 processed
// Order 1 processed
// 1000
```

**Signature**

```ts
export declare const reduceRight: {
  <A, Z, R, E>(zero: Z, f: (a: A, z: Z, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>
  <A, Z, R, E>(elements: Iterable<A>, zero: Z, f: (a: A, z: Z, i: number) => Effect<Z, E, R>): Effect<Z, E, R>
}
```


# reduceWhile

Reduces an `Iterable<A>` using an effectual function `body`, working
sequentially from left to right, stopping the process early when the
predicate `while` is not satisfied.

**Details**

This function processes a collection of elements, applying a function `body`
to reduce them to a single value, starting from the first element. It checks
the value of the accumulator against a predicate (`while`). If at any point
the predicate returns `false`, the reduction stops, and the accumulated
result is returned.

**When to Use**

Use this function when you need to reduce a collection of elements, but only
continue the process as long as a certain condition holds true. For example,
if you want to sum values in a list but stop as soon as the sum exceeds a
certain threshold, you can use this function.

To import and use `reduceWhile` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.reduceWhile
```

**Example**

```ts
import { Console, Effect } from "effect"

const processOrder = (id: number) =>
  Effect.succeed({ id, price: 100 * id }).pipe(
    Effect.tap(() => Console.log(`Order ${id} processed`)),
    Effect.delay(500 - id * 100)
  )

const program = Effect.reduceWhile([1, 2, 3, 4], 0, {
  body: (acc, id, i) => processOrder(id).pipe(Effect.map((order) => acc + order.price)),
  while: (acc) => acc < 500
})

// Effect.runPromise(program).then(console.log)
// Output:
// Order 1 processed
// Order 2 processed
// Order 3 processed
// 600
```

**Signature**

```ts
export declare const reduceWhile: {
  <Z, A, E, R>(
    zero: Z,
    options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R> }
  ): (elements: Iterable<A>) => Effect<Z, E, R>
  <A, Z, E, R>(
    elements: Iterable<A>,
    zero: Z,
    options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R> }
  ): Effect<Z, E, R>
}
```


# repeat

Repeats an effect based on a specified schedule or until the first failure.

**Details**

This function executes an effect repeatedly according to the given schedule.
Each repetition occurs after the initial execution of the effect, meaning
that the schedule determines the number of additional repetitions. For
example, using `Schedule.once` will result in the effect being executed twice
(once initially and once as part of the repetition).

If the effect succeeds, it is repeated according to the schedule. If it
fails, the repetition stops immediately, and the failure is returned.

The schedule can also specify delays between repetitions, making it useful
for tasks like retrying operations with backoff, periodic execution, or
performing a series of dependent actions.

You can combine schedules for more advanced repetition logic, such as adding
delays, limiting recursions, or dynamically adjusting based on the outcome of
each execution.

To import and use `repeat` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.repeat
```

**Example**

```ts
// Success Example
import { Effect, Schedule, Console } from "effect"

const action = Console.log("success")
const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")
const program = Effect.repeat(action, policy)

// Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))
```

**Example**

```ts
// Failure Example
import { Effect, Schedule } from "effect"

let count = 0

// Define an async effect that simulates an action with possible failures
const action = Effect.async<string, string>((resume) => {
  if (count > 1) {
    console.log("failure")
    resume(Effect.fail("Uh oh!"))
  } else {
    count++
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")
const program = Effect.repeat(action, policy)

// Effect.runPromiseExit(program).then(console.log)
```

**Signature**

```ts
export declare const repeat: {
  <O extends Repeat.Options<A>, A>(options: O): <E, R>(self: Effect<A, E, R>) => Repeat.Return<R, E, A, O>
  <B, A, R1>(schedule: Schedule.Schedule<B, A, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R1 | R>
  <A, E, R, O extends Repeat.Options<A>>(self: Effect<A, E, R>, options: O): Repeat.Return<R, E, A, O>
  <A, E, R, B, R1>(self: Effect<A, E, R>, schedule: Schedule.Schedule<B, A, R1>): Effect<B, E, R | R1>
}
```


# repeatN

Repeats an effect a specified number of times or until the first failure.

**Details**

This function executes an effect initially and then repeats it the specified
number of times, as long as it succeeds. For example, calling
`repeatN(action, 2)` will execute `action` once initially and then repeat it
two additional times if there are no failures.

If the effect fails during any repetition, the failure is returned, and no
further repetitions are attempted.

**When to Use**

This function is useful for tasks that need to be retried a fixed number of
times or for performing repeated actions without requiring a schedule.

To import and use `repeatN` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.repeatN
```

**Example**

```ts
import { Effect, Console } from "effect"

const action = Console.log("success")
const program = Effect.repeatN(action, 2)

// Effect.runPromise(program)
```

**Signature**

```ts
export declare const repeatN: {
  (n: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R>(self: Effect<A, E, R>, n: number): Effect<A, E, R>
}
```


# repeatOrElse

Repeats an effect with a schedule, handling failures using a custom handler.

**Details**

This function allows you to execute an effect repeatedly based on a specified
schedule. If the effect fails at any point, a custom failure handler is
invoked. The handler is provided with both the failure value and the output
of the schedule at the time of failure. This enables advanced error recovery
or alternative fallback logic while maintaining flexibility in how
repetitions are handled.

For example, using a schedule with `recurs(2)` will allow for two additional
repetitions after the initial execution, provided the effect succeeds. If a
failure occurs during any iteration, the failure handler is invoked to handle
the situation.

To import and use `repeatOrElse` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.repeatOrElse
```

**Example**

```ts
import { Effect, Schedule } from "effect"

let count = 0

// Define an async effect that simulates an action with possible failures
const action = Effect.async<string, string>((resume) => {
  if (count > 1) {
    console.log("failure")
    resume(Effect.fail("Uh oh!"))
  } else {
    count++
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

const policy = Schedule.addDelay(
  Schedule.recurs(2), // Repeat for a maximum of 2 times
  () => "100 millis" // Add a delay of 100 milliseconds between repetitions
)

const program = Effect.repeatOrElse(action, policy, () =>
  Effect.sync(() => {
    console.log("orElse")
    return count - 1
  })
)

// Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))
```

**Signature**

```ts
export declare const repeatOrElse: {
  <R2, A, B, E, E2, R3>(
    schedule: Schedule.Schedule<B, A, R2>,
    orElse: (error: E, option: Option.Option<B>) => Effect<B, E2, R3>
  ): <R>(self: Effect<A, E, R>) => Effect<B, E2, R2 | R3 | R>
  <A, E, R, R2, B, E2, R3>(
    self: Effect<A, E, R>,
    schedule: Schedule.Schedule<B, A, R2>,
    orElse: (error: E, option: Option.Option<B>) => Effect<B, E2, R3>
  ): Effect<B, E2, R | R2 | R3>
}
```


# replicate

Replicates the given effect `n` times.

**Details**

This function takes an effect and replicates it a specified number of times
(`n`). The result is an array of `n` effects, each of which is identical to
the original effect.

To import and use `replicate` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.replicate
```

**Example**

```ts
import { Console, Effect } from "effect"

const task = Effect.succeed("Hello, World!").pipe(Effect.tap(Console.log))

const program = Effect.gen(function* () {
  // Replicate the task 3 times
  const tasks = Effect.replicate(task, 3)
  for (const t of tasks) {
    // Run each task
    yield* t
  }
})

// Effect.runFork(program)
// Output:
// Hello, World!
// Hello, World!
// Hello, World!
```

**Signature**

```ts
export declare const replicate: {
  (n: number): <A, E, R>(self: Effect<A, E, R>) => Array<Effect<A, E, R>>
  <A, E, R>(self: Effect<A, E, R>, n: number): Array<Effect<A, E, R>>
}
```


# replicateEffect

Performs this effect the specified number of times and collects the results.

**Details**

This function repeats an effect multiple times and collects the results into
an array. You specify how many times to execute the effect, and it runs that
many times, either in sequence or concurrently depending on the provided
options.

**Options**

If the `discard` option is set to `true`, the intermediate results are not
collected, and the final result of the operation is `void`.

The function also allows you to customize how the effects are handled by
specifying options such as concurrency, batching, and how finalizers behave.
These options provide flexibility in running the effects concurrently or
adjusting other execution details.

To import and use `replicateEffect` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.replicateEffect
```

**Example**

```ts
import { Console, Effect } from "effect"

let counter = 0

const task = Effect.sync(() => ++counter).pipe(Effect.tap(() => Console.log(`Task completed`)))

const program = Effect.gen(function* () {
  // Replicate the task 3 times and collect the results
  const results = yield* Effect.replicateEffect(task, 3)
  yield* Console.log(`Results: ${results.join(", ")}`)
})

// Effect.runFork(program)
// Output:
// Task completed
// Task completed
// Task completed
// Results: 1, 2, 3
```

**Signature**

```ts
export declare const replicateEffect: {
  (
    n: number,
    options?: {
      readonly concurrency?: Concurrency | undefined
      readonly batching?: boolean | "inherit" | undefined
      readonly discard?: false | undefined
      readonly concurrentFinalizers?: boolean | undefined
    }
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<Array<A>, E, R>
  (
    n: number,
    options: {
      readonly concurrency?: Concurrency | undefined
      readonly batching?: boolean | "inherit" | undefined
      readonly discard: true
      readonly concurrentFinalizers?: boolean | undefined
    }
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>
  <A, E, R>(
    self: Effect<A, E, R>,
    n: number,
    options?: {
      readonly concurrency?: Concurrency | undefined
      readonly batching?: boolean | "inherit" | undefined
      readonly discard?: false | undefined
      readonly concurrentFinalizers?: boolean | undefined
    }
  ): Effect<Array<A>, E, R>
  <A, E, R>(
    self: Effect<A, E, R>,
    n: number,
    options: {
      readonly concurrency?: Concurrency | undefined
      readonly batching?: boolean | "inherit" | undefined
      readonly discard: true
      readonly concurrentFinalizers?: boolean | undefined
    }
  ): Effect<void, E, R>
}
```


# retry

Retries a failing effect based on a defined retry policy.

**Details**

The `Effect.retry` function takes an effect and a {@link Schedule} policy,
and will automatically retry the effect if it fails, following the rules of
the policy.

If the effect ultimately succeeds, the result will be returned.

If the maximum retries are exhausted and the effect still fails, the failure
is propagated.

**When to Use**

This can be useful when dealing with intermittent failures, such as network
issues or temporary resource unavailability. By defining a retry policy, you
can control the number of retries, the delay between them, and when to stop
retrying.

To import and use `retry` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.retry
```

**Example**

```ts
// Title: Retrying with a Fixed Delay
import { Effect, Schedule } from "effect"

let count = 0

// Simulates an effect with possible failures
const task = Effect.async<string, Error>((resume) => {
  if (count <= 2) {
    count++
    console.log("failure")
    resume(Effect.fail(new Error()))
  } else {
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

// Define a repetition policy using a fixed delay between retries
const policy = Schedule.fixed("100 millis")

const repeated = Effect.retry(task, policy)

// Effect.runPromise(repeated).then(console.log)
// Output:
// failure
// failure
// failure
// success
// yay!
```

**Example**

```ts
// Title: Retrying a Task up to 5 times
import { Effect } from "effect"

let count = 0

// Simulates an effect with possible failures
const task = Effect.async<string, Error>((resume) => {
  if (count <= 2) {
    count++
    console.log("failure")
    resume(Effect.fail(new Error()))
  } else {
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

// Retry the task up to 5 times
// Effect.runPromise(Effect.retry(task, { times: 5 }))
// Output:
// failure
// failure
// failure
// success
```

**Example**

```ts
// Title: Retrying Until a Specific Condition is Met
import { Effect } from "effect"

let count = 0

// Define an effect that simulates varying error on each invocation
const action = Effect.failSync(() => {
  console.log(`Action called ${++count} time(s)`)
  return `Error ${count}`
})

// Retry the action until a specific condition is met
const program = Effect.retry(action, {
  until: (err) => err === "Error 3"
})

// Effect.runPromiseExit(program).then(console.log)
// Output:
// Action called 1 time(s)
// Action called 2 time(s)
// Action called 3 time(s)
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Error 3' }
// }
```

**Signature**

```ts
export declare const retry: {
  <E, O extends Retry.Options<E>>(options: O): <A, R>(self: Effect<A, E, R>) => Retry.Return<R, E, A, O>
  <B, E, R1>(policy: Schedule.Schedule<B, NoInfer<E>, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>
  <A, E, R, O extends Retry.Options<E>>(self: Effect<A, E, R>, options: O): Retry.Return<R, E, A, O>
  <A, E, R, B, R1>(self: Effect<A, E, R>, policy: Schedule.Schedule<B, E, R1>): Effect<A, E, R1 | R>
}
```


# retryOrElse

Retries a failing effect and runs a fallback effect if retries are exhausted.

**Details**

The `Effect.retryOrElse` function attempts to retry a failing effect multiple
times according to a defined {@link Schedule} policy.

If the retries are exhausted and the effect still fails, it runs a fallback
effect instead.

**When to Use**

This function is useful when you want to handle failures gracefully by
specifying an alternative action after repeated failures.

To import and use `retryOrElse` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.retryOrElse
```

**Example**

```ts
// Title: Retrying with Fallback
import { Effect, Schedule, Console } from "effect"

let count = 0

// Simulates an effect with possible failures
const task = Effect.async<string, Error>((resume) => {
  if (count <= 2) {
    count++
    console.log("failure")
    resume(Effect.fail(new Error()))
  } else {
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

// Retry the task with a delay between retries and a maximum of 2 retries
const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")

// If all retries fail, run the fallback effect
const repeated = Effect.retryOrElse(
  task,
  policy,
  // fallback
  () => Console.log("orElse").pipe(Effect.as("default value"))
)

// Effect.runPromise(repeated).then(console.log)
// Output:
// failure
// failure
// failure
// orElse
// default value
```

**Signature**

```ts
export declare const retryOrElse: {
  <A1, E, R1, A2, E2, R2>(
    policy: Schedule.Schedule<A1, NoInfer<E>, R1>,
    orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>
  ): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R1 | R2 | R>
  <A, E, R, A1, R1, A2, E2, R2>(
    self: Effect<A, E, R>,
    policy: Schedule.Schedule<A1, NoInfer<E>, R1>,
    orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>
  ): Effect<A | A2, E2, R | R1 | R2>
}
```


# runCallback

Executes an effect asynchronously and handles the result using a callback.

**Details**

This function runs an effect asynchronously and passes the result (`Exit`) to
a specified callback. The callback is invoked with the outcome of the effect:

- On success, the callback receives the successful result.
- On failure, the callback receives the failure information.

**When to Use**

This function is effectful and should only be invoked at the edges of your
program.

To import and use `runCallback` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.runCallback
```

**Signature**

```ts
export declare const runCallback: <A, E>(
  effect: Effect<A, E>,
  options?: Runtime.RunCallbackOptions<A, E> | undefined
) => Runtime.Cancel<A, E>
```


# runFork

Runs an effect in the background, returning a fiber that can be observed or
interrupted.

Unless you specifically need a `Promise` or synchronous operation, `runFork`
is a good default choice.

**Details**

This function is the foundational way to execute an effect in the background.
It creates a "fiber," a lightweight, cooperative thread of execution that can
be observed (to access its result), interrupted, or joined. Fibers are useful
for concurrent programming and allow effects to run independently of the main
program flow.

Once the effect is running in a fiber, you can monitor its progress, cancel
it if necessary, or retrieve its result when it completes. If the effect
fails, the fiber will propagate the failure, which you can observe and
handle.

**When to Use**

Use this function when you need to run an effect in the background,
especially if the effect is long-running or performs periodic tasks. It's
suitable for tasks that need to run independently but might still need
observation or management, like logging, monitoring, or scheduled tasks.

This function is ideal if you don't need the result immediately or if the
effect is part of a larger concurrent workflow.

To import and use `runFork` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.runFork
```

**Example**

```ts
// Title: Running an Effect in the Background
import { Effect, Console, Schedule, Fiber } from "effect"

//       Effect<number, never, never>
//      
const program = Effect.repeat(Console.log("running..."), Schedule.spaced("200 millis"))

//       RuntimeFiber<number, never>
//      
const fiber = Effect.runFork(program)

setTimeout(() => {
  Effect.runFork(Fiber.interrupt(fiber))
}, 500)
```

**Signature**

```ts
export declare const runFork: <A, E>(effect: Effect<A, E>, options?: Runtime.RunForkOptions) => Fiber.RuntimeFiber<A, E>
```


# runPromise

Executes an effect and returns the result as a `Promise`.

**Details**

This function runs an effect and converts its result into a `Promise`. If the
effect succeeds, the `Promise` will resolve with the successful result. If
the effect fails, the `Promise` will reject with an error, which includes the
failure details of the effect.

The optional `options` parameter allows you to pass an `AbortSignal` for
cancellation, enabling more fine-grained control over asynchronous tasks.

**When to Use**

Use this function when you need to execute an effect and work with its result
in a promise-based system, such as when integrating with third-party
libraries that expect `Promise` results.

To import and use `runPromise` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.runPromise
```

**Example**

```ts
// Title: Running a Successful Effect as a Promise
import { Effect } from "effect"

// Effect.runPromise(Effect.succeed(1)).then(console.log)
// Output: 1
```

**Example**

```ts
//Example: Handling a Failing Effect as a Rejected Promise
import { Effect } from "effect"

// Effect.runPromise(Effect.fail("my error")).catch(console.error)
// Output:
// (FiberFailure) Error: my error
```

**Signature**

```ts
export declare const runPromise: <A, E>(
  effect: Effect<A, E, never>,
  options?: { readonly signal?: AbortSignal } | undefined
) => Promise<A>
```


# runPromiseExit

Runs an effect and returns a `Promise` that resolves to an `Exit`,
representing the outcome.

**Details**

This function executes an effect and resolves to an `Exit` object. The `Exit`
type provides detailed information about the result of the effect:

- If the effect succeeds, the `Exit` will be of type `Success` and include
  the value produced by the effect.
- If the effect fails, the `Exit` will be of type `Failure` and contain a
  `Cause` object, detailing the failure.

Using this function allows you to examine both successful results and failure
cases in a unified way, while still leveraging `Promise` for handling the
asynchronous behavior of the effect.

**When to Use**

Use this function when you need to understand the outcome of an effect,
whether it succeeded or failed, and want to work with this result using
`Promise` syntax. This is particularly useful when integrating with systems
that rely on promises but need more detailed error handling than a simple
rejection.

To import and use `runPromiseExit` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.runPromiseExit
```

**Example**

```ts
// Title: Handling Results as Exit
import { Effect } from "effect"

// Execute a successful effect and get the Exit result as a Promise
// Effect.runPromiseExit(Effect.succeed(1)).then(console.log)
// Output:
// {
//   _id: "Exit",
//   _tag: "Success",
//   value: 1
// }

// Execute a failing effect and get the Exit result as a Promise
// Effect.runPromiseExit(Effect.fail("my error")).then(console.log)
// Output:
// {
//   _id: "Exit",
//   _tag: "Failure",
//   cause: {
//     _id: "Cause",
//     _tag: "Fail",
//     failure: "my error"
//   }
// }
```

**Signature**

```ts
export declare const runPromiseExit: <A, E>(
  effect: Effect<A, E, never>,
  options?: { readonly signal?: AbortSignal } | undefined
) => Promise<Exit.Exit<A, E>>
```


# runSync

Executes an effect synchronously, running it immediately and returning the
result.

**Details**

This function evaluates the provided effect synchronously, returning its
result directly. It is ideal for effects that do not fail or include
asynchronous operations. If the effect does fail or involves async tasks, it
will throw an error. Execution stops at the point of failure or asynchronous
operation, making it unsuitable for effects that require asynchronous
handling.

**Important**: Attempting to run effects that involve asynchronous operations
or failures will result in exceptions being thrown, so use this function with
care for purely synchronous and error-free effects.

**When to Use**

Use this function when:

- You are sure that the effect will not fail or involve asynchronous
  operations.
- You need a direct, synchronous result from the effect.
- You are working within a context where asynchronous effects are not
  allowed.

Avoid using this function for effects that can fail or require asynchronous
handling. For such cases, consider using {@link runPromise} or
{@link runSyncExit}.

To import and use `runSync` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.runSync
```

**Example**

```ts
// Title: Synchronous Logging
import { Effect } from "effect"

const program = Effect.sync(() => {
  console.log("Hello, World!")
  return 1
})

const result = Effect.runSync(program)
// Output: Hello, World!

console.log(result)
// Output: 1
```

**Example**

```ts
// Title: Incorrect Usage with Failing or Async Effects
import { Effect } from "effect"

try {
  // Attempt to run an effect that fails
  Effect.runSync(Effect.fail("my error"))
} catch (e) {
  console.error(e)
}
// Output:
// (FiberFailure) Error: my error

try {
  // Attempt to run an effect that involves async work
  Effect.runSync(Effect.promise(() => Promise.resolve(1)))
} catch (e) {
  console.error(e)
}
// Output:
// (FiberFailure) AsyncFiberException: Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work
```

**Signature**

```ts
export declare const runSync: <A, E>(effect: Effect<A, E>) => A
```


# runSyncExit

Runs an effect synchronously and returns the result as an `Exit` type.

**Details**

This function executes the provided effect synchronously and returns an `Exit`
type that encapsulates the outcome of the effect:

- If the effect succeeds, the result is wrapped in a `Success`.
- If the effect fails, it returns a `Failure` containing a `Cause` that explains
  the failure.

If the effect involves asynchronous operations, this function will return a `Failure`
with a `Die` cause, indicating that it cannot resolve the effect synchronously.
This makes the function suitable for use only with effects that are synchronous
in nature.

**When to Use**

Use this function when:

- You want to handle both success and failure outcomes in a structured way using the `Exit` type.
- You are working with effects that are purely synchronous and do not involve asynchronous operations.
- You need to debug or inspect failures, including their causes, in a detailed manner.

Avoid using this function for effects that involve asynchronous operations, as it will fail with a `Die` cause.

To import and use `runSyncExit` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.runSyncExit
```

**Example**

```ts
// Title: Handling Results as Exit
import { Effect } from "effect"

console.log(Effect.runSyncExit(Effect.succeed(1)))
// Output:
// {
//   _id: "Exit",
//   _tag: "Success",
//   value: 1
// }

console.log(Effect.runSyncExit(Effect.fail("my error")))
// Output:
// {
//   _id: "Exit",
//   _tag: "Failure",
//   cause: {
//     _id: "Cause",
//     _tag: "Fail",
//     failure: "my error"
//   }
// }
```

**Example**

```ts
// Title: Asynchronous Operation Resulting in Die
import { Effect } from "effect"

console.log(Effect.runSyncExit(Effect.promise(() => Promise.resolve(1))))
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Die',
//     defect: [Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work] {
//       fiber: [FiberRuntime],
//       _tag: 'AsyncFiberException',
//       name: 'AsyncFiberException'
//     }
//   }
// }
```

**Signature**

```ts
export declare const runSyncExit: <A, E>(effect: Effect<A, E>) => Exit.Exit<A, E>
```


# runtime

Returns an effect that accesses the runtime, which can be used to (unsafely)
execute tasks.

**When to Use**

This is useful for integration with legacy code that must call back into
Effect code.

To import and use `runtime` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.runtime
```

**Signature**

```ts
export declare const runtime: <R = never>() => Effect<Runtime.Runtime<R>, never, R>
```


# sandbox

Transforms an effect to expose detailed error causes.

**Details**

This function enhances an effect by providing detailed information about any
error, defect, or interruption that may occur during its execution. It
modifies the error channel of the effect so that it includes a full cause of
the failure, wrapped in a `Cause<E>` type.

After applying this function, you can use operators like {@link catchAll} and
{@link catchTags} to handle specific types of errors.

If you no longer need the detailed cause information, you can revert the
changes using {@link unsandbox} to return to the original error-handling
behavior.

To import and use `sandbox` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.sandbox
```

**Example**

```ts
import { Effect, Console } from "effect"

//       Effect<string, Error, never>
//      
const task = Effect.fail(new Error("Oh uh!")).pipe(Effect.as("primary result"))

//       Effect<string, Cause<Error>, never>
//      
const sandboxed = Effect.sandbox(task)

const program = Effect.catchTags(sandboxed, {
  Die: (cause) => Console.log(`Caught a defect: ${cause.defect}`).pipe(Effect.as("fallback result on defect")),
  Interrupt: (cause) =>
    Console.log(`Caught a defect: ${cause.fiberId}`).pipe(Effect.as("fallback result on fiber interruption")),
  Fail: (cause) => Console.log(`Caught a defect: ${cause.error}`).pipe(Effect.as("fallback result on failure"))
})

// Restore the original error handling with unsandbox
const main = Effect.unsandbox(program)

// Effect.runPromise(main).then(console.log)
// Output:
// Caught a defect: Oh uh!
// fallback result on failure
```

**Signature**

```ts
export declare const sandbox: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Cause.Cause<E>, R>
```


# schedule

Repeats an effect based on a specified schedule.

**Details**

This function allows you to execute an effect repeatedly according to a given
schedule. The schedule determines the timing and number of repetitions. Each
repetition can also depend on the decision of the schedule, providing
flexibility for complex workflows. This function does not modify the effect's
success or failure; it only controls its repetition.

For example, you can use a schedule that recurs a specific number of times,
adds delays between repetitions, or customizes repetition behavior based on
external inputs. The effect runs initially and is repeated according to the
schedule.

To import and use `schedule` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.schedule
```

**Signature**

```ts
export declare const schedule: {
  <A, R2, Out>(
    schedule: Schedule.Schedule<Out, NoInfer<A> | undefined, R2>
  ): <E, R>(self: Effect<A, E, R>) => Effect<Out, E, R2 | R>
  <A, E, R, R2, Out>(self: Effect<A, E, R>, schedule: Schedule.Schedule<Out, A | undefined, R2>): Effect<Out, E, R | R2>
}
```


# scheduleForked

Runs an effect repeatedly on a new fiber according to a given schedule.

**Details**

This function starts the provided effect on a new fiber and runs it
repeatedly based on the specified schedule. The repetitions are managed by
the schedule's rules, which define the timing and number of iterations. The
fiber is attached to the current scope, meaning it is automatically managed
and cleaned up when the scope is closed.

The function returns a `RuntimeFiber` that allows you to monitor or interact
with the running fiber.

**When to Use**

This is particularly useful for concurrent execution of scheduled tasks or
when you want to continue processing without waiting for the repetitions to
complete.

To import and use `scheduleForked` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.scheduleForked
```

**Signature**

```ts
export declare const scheduleForked: {
  <Out, R2>(
    schedule: Schedule.Schedule<Out, unknown, R2>
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<Out, E>, never, Scope.Scope | R2 | R>
  <A, E, R, Out, R2>(
    self: Effect<A, E, R>,
    schedule: Schedule.Schedule<Out, unknown, R2>
  ): Effect<Fiber.RuntimeFiber<Out, E>, never, Scope.Scope | R | R2>
}
```


# scheduleFrom

Runs an effect repeatedly according to a schedule, starting from a specified
input value.

**Details**

This function allows you to repeatedly execute an effect based on a schedule.
The schedule starts with the given `initial` input value, which is passed to
the first execution. Subsequent executions of the effect are controlled by
the schedule's rules, using the output of the previous iteration as the input
for the next one.

The returned effect will complete when the schedule ends or the effect fails,
propagating the error.

To import and use `scheduleFrom` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.scheduleFrom
```

**Signature**

```ts
export declare const scheduleFrom: {
  <R2, In, Out>(
    initial: In,
    schedule: Schedule.Schedule<Out, In, R2>
  ): <E, R>(self: Effect<In, E, R>) => Effect<Out, E, R2 | R>
  <In, E, R, R2, Out>(
    self: Effect<In, E, R>,
    initial: In,
    schedule: Schedule.Schedule<Out, In, R2>
  ): Effect<Out, E, R | R2>
}
```


# scope

Provides access to the current scope in a scoped workflow.

To import and use `scope` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.scope
```

**Signature**

```ts
export declare const scope: Effect<Scope.Scope, never, Scope.Scope>
```


# scoped

Scopes all resources used in an effect to the lifetime of the effect.

**Details**

This function ensures that all resources used within an effect are tied to
its lifetime. Finalizers for these resources are executed automatically when
the effect completes, whether through success, failure, or interruption. This
guarantees proper resource cleanup without requiring explicit management.

To import and use `scoped` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.scoped
```

**Signature**

```ts
export declare const scoped: <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, Scope.Scope>>
```


# scopedWith

Creates a `Scope`, passes it to the specified effectful function, and closes
the scope when the effect completes (whether through success, failure, or
interruption).

To import and use `scopedWith` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.scopedWith
```

**Signature**

```ts
export declare const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect<A, E, R>) => Effect<A, E, R>
```


# scopeWith

Accesses the current scope and uses it to perform the specified effect.

To import and use `scopeWith` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.scopeWith
```

**Signature**

```ts
export declare const scopeWith: <A, E, R>(f: (scope: Scope.Scope) => Effect<A, E, R>) => Effect<A, E, R | Scope.Scope>
```


# Semaphore

A semaphore is a synchronization mechanism used to manage access to a shared
resource. In Effect, semaphores help control resource access or coordinate
tasks within asynchronous, concurrent operations.

A semaphore acts as a generalized mutex, allowing a set number of permits to
be held and released concurrently. Permits act like tickets, giving tasks or
fibers controlled access to a shared resource. When no permits are available,
tasks trying to acquire one will wait until a permit is released.

To import and use `Semaphore` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.Semaphore
```


# sequentialFinalizers

Ensures that finalizers are run sequentially in reverse order of their
addition.

**Details**

This function modifies the behavior of finalizers within a scoped workflow to
ensure they are run sequentially in reverse order when the scope is closed.

By default, finalizers are executed sequentially, so this only changes the
behavior if the scope is configured to run finalizers concurrently.

To import and use `sequentialFinalizers` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.sequentialFinalizers
```

**Signature**

```ts
export declare const sequentialFinalizers: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
```


# Service

Simplifies the creation and management of services in Effect by defining both
a `Tag` and a `Layer`.

**Details**

This function allows you to streamline the creation of services by combining
the definition of a `Context.Tag` and a `Layer` in a single step. It supports
various ways of providing the service implementation:

- Using an `effect` to define the service dynamically.
- Using `sync` or `succeed` to define the service statically.
- Using `scoped` to create services with lifecycle management.

It also allows you to specify dependencies for the service, which will be
provided automatically when the service is used. Accessors can be optionally
generated for the service, making it more convenient to use.

To import and use `Service` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.Service
```

**Example**

```ts
import { Effect } from "effect"

class Prefix extends Effect.Service<Prefix>()("Prefix", {
  sync: () => ({ prefix: "PRE" })
}) {}

class Logger extends Effect.Service<Logger>()("Logger", {
  accessors: true,
  effect: Effect.gen(function* () {
    const { prefix } = yield* Prefix
    return {
      info: (message: string) =>
        Effect.sync(() => {
          console.log(`[${prefix}][${message}]`)
        })
    }
  }),
  dependencies: [Prefix.Default]
}) {}
```

**Signature**

```ts
export declare const Service: <Self = never>() => [Self] extends [never]
  ? MissingSelfGeneric
  : {
      <
        const Key extends string,
        const Make extends
          | {
              readonly scoped: Effect<Service.AllowedType<Key, Make>, any, any>
              readonly dependencies?: ReadonlyArray<Layer.Layer.Any>
              readonly accessors?: boolean
              readonly _: never
            }
          | {
              readonly effect: Effect<Service.AllowedType<Key, Make>, any, any>
              readonly dependencies?: ReadonlyArray<Layer.Layer.Any>
              readonly accessors?: boolean
              readonly _: never
            }
          | {
              readonly sync: LazyArg<Service.AllowedType<Key, Make>>
              readonly dependencies?: ReadonlyArray<Layer.Layer.Any>
              readonly accessors?: boolean
              readonly _: never
            }
          | {
              readonly succeed: Service.AllowedType<Key, Make>
              readonly dependencies?: ReadonlyArray<Layer.Layer.Any>
              readonly accessors?: boolean
              readonly _: never
            }
      >(
        key: Key,
        make: Make
      ): Service.Class<Self, Key, Make>
      <
        const Key extends string,
        const Make extends NoExcessProperties<
          {
            readonly scoped: Effect<Service.AllowedType<Key, Make>, any, any>
            readonly dependencies?: ReadonlyArray<Layer.Layer.Any>
            readonly accessors?: boolean
          },
          Make
        >
      >(
        key: Key,
        make: Make
      ): Service.Class<Self, Key, Make>
      <
        const Key extends string,
        const Make extends NoExcessProperties<
          {
            readonly effect: Effect<Service.AllowedType<Key, Make>, any, any>
            readonly dependencies?: ReadonlyArray<Layer.Layer.Any>
            readonly accessors?: boolean
          },
          Make
        >
      >(
        key: Key,
        make: Make
      ): Service.Class<Self, Key, Make>
      <
        const Key extends string,
        const Make extends NoExcessProperties<
          {
            readonly sync: LazyArg<Service.AllowedType<Key, Make>>
            readonly dependencies?: ReadonlyArray<Layer.Layer.Any>
            readonly accessors?: boolean
          },
          Make
        >
      >(
        key: Key,
        make: Make
      ): Service.Class<Self, Key, Make>
      <
        const Key extends string,
        const Make extends NoExcessProperties<
          {
            readonly succeed: Service.AllowedType<Key, Make>
            readonly dependencies?: ReadonlyArray<Layer.Layer.Any>
            readonly accessors?: boolean
          },
          Make
        >
      >(
        key: Key,
        make: Make
      ): Service.Class<Self, Key, Make>
    }
```


# serviceFunction

Creates a function that uses a service from the context to produce a value.

To import and use `serviceFunction` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.serviceFunction
```

**Signature**

```ts
export declare const serviceFunction: <T extends Effect<any, any, any>, Args extends Array<any>, A>(
  getService: T,
  f: (_: Effect.Success<T>) => (...args: Args) => A
) => (...args: Args) => Effect<A, Effect.Error<T>, Effect.Context<T>>
```


# serviceFunctionEffect

Creates a function that uses a service from the context to produce an effect.

To import and use `serviceFunctionEffect` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.serviceFunctionEffect
```

**Signature**

```ts
export declare const serviceFunctionEffect: <T extends Effect<any, any, any>, Args extends Array<any>, A, E, R>(
  getService: T,
  f: (_: Effect.Success<T>) => (...args: Args) => Effect<A, E, R>
) => (...args: Args) => Effect<A, E | Effect.Error<T>, R | Effect.Context<T>>
```


# serviceOption

Retrieves an optional service from the context as an `Option`.

**Details**

This function retrieves a service from the context and wraps it in an
`Option`. If the service is available, it returns a `Some` containing the
service. If the service is not found, it returns a `None`. This approach is
useful when you want to handle the absence of a service gracefully without
causing an error.

**When to Use**

Use this function when:

- You need to access a service that may or may not be present in the context.
- You want to handle the absence of a service using the `Option` type instead
  of throwing an error.

To import and use `serviceOption` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.serviceOption
```

**Signature**

```ts
export declare const serviceOption: <I, S>(tag: Context.Tag<I, S>) => Effect<Option.Option<S>>
```


# serviceOptional

Retrieves a service from the context, throwing an error if it is missing.

**Details**

This function retrieves a required service from the context. If the service
is available, it returns the service. If the service is missing, it throws a
`NoSuchElementException`, which can be handled using Effect's error-handling
mechanisms. This is useful for services that are critical to the execution of
your effect.

To import and use `serviceOptional` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.serviceOptional
```

**Signature**

```ts
export declare const serviceOptional: <I, S>(tag: Context.Tag<I, S>) => Effect<S, Cause.NoSuchElementException>
```


# setFiberRefs

Sets the `FiberRef` values for the fiber running this effect to the values
in the specified collection of `FiberRef` values.

To import and use `setFiberRefs` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.setFiberRefs
```

**Signature**

```ts
export declare const setFiberRefs: (fiberRefs: FiberRefs.FiberRefs) => Effect<void>
```


# sleep

Suspends the execution of an effect for a specified `Duration`.

**Details**

This function pauses the execution of an effect for a given duration. It is
asynchronous, meaning that it does not block the fiber executing the effect.
Instead, the fiber is suspended during the delay period and can resume once
the specified time has passed.

The duration can be specified using various formats supported by the
`Duration` module, such as a string (`"2 seconds"`) or numeric value
representing milliseconds.

To import and use `sleep` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.sleep
```

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function* () {
  console.log("Starting task...")
  yield* Effect.sleep("3 seconds") // Waits for 3 seconds
  console.log("Task completed!")
})

// Effect.runFork(program)
// Output:
// Starting task...
// Task completed!
```

**Signature**

```ts
export declare const sleep: (duration: Duration.DurationInput) => Effect<void>
```


# succeed

Creates an `Effect` that always succeeds with a given value.

**When to Use**

Use this function when you need an effect that completes successfully with a
specific value without any errors or external dependencies.

To import and use `succeed` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.succeed
```

**Example**

```ts
// Title: Creating a Successful Effect
import { Effect } from "effect"

// Creating an effect that represents a successful scenario
//
//       Effect<number, never, never>
//      
const success = Effect.succeed(42)
```

**Signature**

```ts
export declare const succeed: <A>(value: A) => Effect<A>
```


# succeedNone

Returns an effect which succeeds with `None`.

**When to Use**

Use this function when you need to represent the absence of a value in your
code, especially when working with optional data. This can be helpful when
you want to indicate that no result is available without throwing an error or
performing additional logic.

To import and use `succeedNone` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.succeedNone
```

**Signature**

```ts
export declare const succeedNone: Effect<Option.Option<never>, never, never>
```


# succeedSome

Returns an effect which succeeds with the value wrapped in a `Some`.

To import and use `succeedSome` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.succeedSome
```

**Signature**

```ts
export declare const succeedSome: <A>(value: A) => Effect<Option.Option<A>>
```


# summarized

Summarizes a effect by computing some value before and after execution, and
then combining the values to produce a summary, together with the result of
execution.

To import and use `summarized` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.summarized
```

**Signature**

```ts
export declare const summarized: {
  <B, E2, R2, C>(
    summary: Effect<B, E2, R2>,
    f: (start: B, end: B) => C
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<[C, A], E2 | E, R2 | R>
  <A, E, R, B, E2, R2, C>(
    self: Effect<A, E, R>,
    summary: Effect<B, E2, R2>,
    f: (start: B, end: B) => C
  ): Effect<[C, A], E2 | E, R2 | R>
}
```


# supervised

Supervises child fibers by reporting them to a specified supervisor.

**Details**

This function takes a supervisor as an argument and returns an effect where
all child fibers forked within it are supervised by the provided supervisor.
This enables you to capture detailed information about these child fibers,
such as their status, through the supervisor.

To import and use `supervised` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.supervised
```

**Example**

```ts
// Title: Monitoring Fiber Count
import { Effect, Supervisor, Schedule, Fiber, FiberStatus } from "effect"

// Main program that monitors fibers while calculating a Fibonacci number
const program = Effect.gen(function* () {
  // Create a supervisor to track child fibers
  const supervisor = yield* Supervisor.track

  // Start a Fibonacci calculation, supervised by the supervisor
  const fibFiber = yield* fib(20).pipe(
    Effect.supervised(supervisor),
    // Fork the Fibonacci effect into a fiber
    Effect.fork
  )

  // Define a schedule to periodically monitor the fiber count every 500ms
  const policy = Schedule.spaced("500 millis").pipe(
    Schedule.whileInputEffect((_) =>
      Fiber.status(fibFiber).pipe(
        // Continue while the Fibonacci fiber is not done
        Effect.andThen((status) => status !== FiberStatus.done)
      )
    )
  )

  // Start monitoring the fibers, using the supervisor to track the count
  const monitorFiber = yield* monitorFibers(supervisor).pipe(
    // Repeat the monitoring according to the schedule
    Effect.repeat(policy),
    // Fork the monitoring into its own fiber
    Effect.fork
  )

  // Join the monitor and Fibonacci fibers to ensure they complete
  yield* Fiber.join(monitorFiber)
  const result = yield* Fiber.join(fibFiber)

  console.log(`fibonacci result: ${result}`)
})

// Function to monitor and log the number of active fibers
const monitorFibers = (supervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>): Effect.Effect<void> =>
  Effect.gen(function* () {
    const fibers = yield* supervisor.value // Get the current set of fibers
    console.log(`number of fibers: ${fibers.length}`)
  })

// Recursive Fibonacci calculation, spawning fibers for each recursive step
const fib = (n: number): Effect.Effect<number> =>
  Effect.gen(function* () {
    if (n <= 1) {
      return 1
    }
    yield* Effect.sleep("500 millis") // Simulate work by delaying

    // Fork two fibers for the recursive Fibonacci calls
    const fiber1 = yield* Effect.fork(fib(n - 2))
    const fiber2 = yield* Effect.fork(fib(n - 1))

    // Join the fibers to retrieve their results
    const v1 = yield* Fiber.join(fiber1)
    const v2 = yield* Fiber.join(fiber2)

    return v1 + v2 // Combine the results
  })

// Effect.runPromise(program)
// Output:
// number of fibers: 0
// number of fibers: 2
// number of fibers: 6
// number of fibers: 14
// number of fibers: 30
// number of fibers: 62
// number of fibers: 126
// number of fibers: 254
// number of fibers: 510
// number of fibers: 1022
// number of fibers: 2034
// number of fibers: 3795
// number of fibers: 5810
// number of fibers: 6474
// number of fibers: 4942
// number of fibers: 2515
// number of fibers: 832
// number of fibers: 170
// number of fibers: 18
// number of fibers: 0
// fibonacci result: 10946
```

**Signature**

```ts
export declare const supervised: {
  <X>(supervisor: Supervisor.Supervisor<X>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R, X>(self: Effect<A, E, R>, supervisor: Supervisor.Supervisor<X>): Effect<A, E, R>
}
```


# suspend

Delays the creation of an `Effect` until it is actually needed.

**Details**

The `Effect.suspend` function takes a thunk that represents the effect and
wraps it in a suspended effect. This means the effect will not be created
until it is explicitly needed, which is helpful in various scenarios:

- **Lazy Evaluation**: Helps optimize performance by deferring computations,
  especially when the effect might not be needed, or when its computation is
  expensive. This also ensures that any side effects or scoped captures are
  re-executed on each invocation.
- **Handling Circular Dependencies**: Useful in managing circular
  dependencies, such as recursive functions that need to avoid eager
  evaluation to prevent stack overflow.
- **Unifying Return Types**: Can help TypeScript unify return types in
  situations where multiple branches of logic return different effects,
  simplifying type inference.

**When to Use**

Use this function when you need to defer the evaluation of an effect until it
is required. This is particularly useful for optimizing expensive
computations, managing circular dependencies, or resolving type inference
issues.

To import and use `suspend` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.suspend
```

**Example**

```ts
// Title: Lazy Evaluation with Side Effects
import { Effect } from "effect"

let i = 0

const bad = Effect.succeed(i++)

const good = Effect.suspend(() => Effect.succeed(i++))

console.log(Effect.runSync(bad)) // Output: 0
console.log(Effect.runSync(bad)) // Output: 0

console.log(Effect.runSync(good)) // Output: 1
console.log(Effect.runSync(good)) // Output: 2
```

**Example**

```ts
// Title: Recursive Fibonacci
import { Effect } from "effect"

const blowsUp = (n: number): Effect.Effect<number> =>
  n < 2 ? Effect.succeed(1) : Effect.zipWith(blowsUp(n - 1), blowsUp(n - 2), (a, b) => a + b)

// console.log(Effect.runSync(blowsUp(32)))
// crash: JavaScript heap out of memory

const allGood = (n: number): Effect.Effect<number> =>
  n < 2
    ? Effect.succeed(1)
    : Effect.zipWith(
        Effect.suspend(() => allGood(n - 1)),
        Effect.suspend(() => allGood(n - 2)),
        (a, b) => a + b
      )

console.log(Effect.runSync(allGood(32)))
// Output: 3524578
```

**Example**

```ts
// Title: Using Effect.suspend to Help TypeScript Infer Types
import { Effect } from "effect"

//   Without suspend, TypeScript may struggle with type inference.
//   Inferred type:
//     (a: number, b: number) =>
//       Effect<never, Error, never> | Effect<number, never, never>
const withoutSuspend = (a: number, b: number) =>
  b === 0 ? Effect.fail(new Error("Cannot divide by zero")) : Effect.succeed(a / b)

//   Using suspend to unify return types.
//   Inferred type:
//     (a: number, b: number) => Effect<number, Error, never>
const withSuspend = (a: number, b: number) =>
  Effect.suspend(() => (b === 0 ? Effect.fail(new Error("Cannot divide by zero")) : Effect.succeed(a / b)))
```

**Signature**

```ts
export declare const suspend: <A, E, R>(effect: LazyArg<Effect<A, E, R>>) => Effect<A, E, R>
```


# sync

Creates an `Effect` that represents a synchronous side-effectful computation.

**Details**

The provided function (`thunk`) must not throw errors; if it does, the error
will be treated as a "defect".

This defect is not a standard error but indicates a flaw in the logic that
was expected to be error-free. You can think of it similar to an unexpected
crash in the program, which can be further managed or logged using tools like
{@link catchAllDefect}.

**When to Use**

Use this function when you are sure the operation will not fail.

To import and use `sync` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.sync
```

**Example**

```ts
// Title: Logging a Message
import { Effect } from "effect"

const log = (message: string) =>
  Effect.sync(() => {
    console.log(message) // side effect
  })

//       Effect<void, never, never>
//      
const program = log("Hello, World!")
```

**Signature**

```ts
export declare const sync: <A>(thunk: LazyArg<A>) => Effect<A>
```


# Tag

Creates a unique tag for a dependency, embedding the service's methods as
static properties.

**Details**

This function allows you to define a `Tag` for a service or dependency in
your application. The `Tag` not only acts as an identifier but also provides
direct access to the service's methods via static properties. This makes it
easier to access and use the service in your code without manually managing
contexts.

In the example below, the fields of the service (in this case, the `notify`
method) are turned into static properties of the Notifications class, making
it easier to access them.

To import and use `Tag` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.Tag
```

**Example**

```ts
import { Effect } from "effect"

class Notifications extends Effect.Tag("Notifications")<
  Notifications,
  { readonly notify: (message: string) => Effect.Effect<void> }
>() {}

// Create an effect that depends on the Notifications service
const action = Notifications.notify("Hello, world!")
```

**Signature**

```ts
export declare const Tag: <const Id extends string>(
  id: Id
) => <Self, Type extends Tag.AllowedType>() => Context.TagClass<Self, Id, Type> &
  (Type extends Record<PropertyKey, any> ? Tag.Proxy<Self, Type> : {}) & {
    use: <X>(
      body: (_: Type) => X
    ) => [X] extends [Effect<infer A, infer E, infer R>]
      ? Effect<A, E, R | Self>
      : [X] extends [PromiseLike<infer A>]
        ? Effect<A, Cause.UnknownException, Self>
        : Effect<X, never, Self>
  }
```


# tagMetrics

Tags each metric in an effect with specific key-value pairs.

**Details**

This function allows you to tag all metrics in an effect with a set of
key-value pairs or a single key-value pair. Tags help you add metadata to
metrics, making it easier to filter and categorize them in monitoring
systems. The provided tags will apply to all metrics generated within the
effect's scope.

To import and use `tagMetrics` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.tagMetrics
```

**Signature**

```ts
export declare const tagMetrics: {
  (key: string, value: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>
  (values: Record<string, string>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R>(effect: Effect<A, E, R>, key: string, value: string): Effect<A, E, R>
  <A, E, R>(effect: Effect<A, E, R>, values: Record<string, string>): Effect<A, E, R>
}
```


# tagMetricsScoped

Tags metrics within a scope with a specific key-value pair.

**Details**

This function tags all metrics within a scope with the provided key-value
pair. Once the scope is closed, the tag is automatically removed. This is
useful for applying temporary context-specific tags to metrics during scoped
operations.

To import and use `tagMetricsScoped` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.tagMetricsScoped
```

**Signature**

```ts
export declare const tagMetricsScoped: (key: string, value: string) => Effect<void, never, Scope.Scope>
```


# takeUntil

Takes elements from a collection until the effectful predicate returns
`true`.

**Details**

This function processes a collection of elements and uses an effectful
predicate to decide when to stop taking elements. The elements are taken from
the beginning of the collection until the predicate returns `true`.

The predicate is a function that takes an element and its index in the
collection, and returns an effect that resolves to a boolean.

Once the predicate returns `true`, the remaining elements of the collection
are discarded, and the function stops taking more elements.

**Note**: The first element for which the predicate returns `true` is also
included in the result.

**When to Use**

Use this function when you want to conditionally take elements from a
collection based on a dynamic condition. For example, you may want to collect
numbers from a list until a certain threshold is reached, or gather items
until a specific condition is met.

To import and use `takeUntil` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.takeUntil
```

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5, 6]
const predicate = (n: number, i: number) => Effect.succeed(n > 3)

const program = Effect.gen(function* () {
  const result = yield* Effect.takeUntil(numbers, predicate)
  console.log(result)
})

// Effect.runFork(program)
// Output: [ 1, 2, 3, 4 ]
```

**Signature**

```ts
export declare const takeUntil: {
  <A, R, E>(
    predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>
  ): (elements: Iterable<A>) => Effect<Array<A>, E, R>
  <A, E, R>(
    elements: Iterable<A>,
    predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>
  ): Effect<Array<A>, E, R>
}
```


# takeWhile

Takes elements as long as the predicate returns `true`.

**Details**

This function processes a collection of elements and uses a predicate to
decide whether to take an element.

The predicate is a function that takes an element and its index, and it
returns an effect that evaluates to a boolean.

As long as the predicate returns `true`, elements will continue to be taken
from the collection.

Once the predicate returns `false`, the remaining elements are discarded.

To import and use `takeWhile` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.takeWhile
```

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5, 6]
const predicate = (n: number, i: number) => Effect.succeed(n <= 3)

const program = Effect.gen(function* () {
  const result = yield* Effect.takeWhile(numbers, predicate)
  console.log(result)
})

// Effect.runFork(program)
// Output: [1, 2, 3]
```

**Signature**

```ts
export declare const takeWhile: {
  <A, E, R>(
    predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>
  ): (elements: Iterable<A>) => Effect<Array<A>, E, R>
  <A, E, R>(
    elements: Iterable<A>,
    predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>
  ): Effect<Array<A>, E, R>
}
```


# tap

Runs a side effect with the result of an effect without changing the original
value.

**Details**

This function works similarly to `flatMap`, but it ignores the result of the
function passed to it. The value from the previous effect remains available
for the next part of the chain. Note that if the side effect fails, the
entire chain will fail too.

**When to Use**

Use this function when you want to perform a side effect, like logging or
tracking, without modifying the main value. This is useful when you need to
observe or record an action but want the original value to be passed to the
next step.

To import and use `tap` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.tap
```

**Example**

```ts
// Title: Logging a step in a pipeline
import { Console, Effect, pipe } from "effect"

// Function to apply a discount safely to a transaction amount
const applyDiscount = (total: number, discountRate: number): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

const finalAmount = pipe(
  fetchTransactionAmount,
  // Log the fetched transaction amount
  Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),
  // `amount` is still available!
  Effect.flatMap((amount) => applyDiscount(amount, 5))
)

// Effect.runPromise(finalAmount).then(console.log)
// Output:
// Apply a discount to: 100
// 95
```

**Signature**

```ts
export declare const tap: {
  <A, X>(
    f: (a: NoInfer<A>) => X
  ): <E, R>(
    self: Effect<A, E, R>
  ) => [X] extends [Effect<infer _A1, infer E1, infer R1>]
    ? Effect<A, E | E1, R | R1>
    : [X] extends [PromiseLike<infer _A1>]
      ? Effect<A, E | Cause.UnknownException, R>
      : Effect<A, E, R>
  <A, X, E1, R1>(
    f: (a: NoInfer<A>) => Effect<X, E1, R1>,
    options: { onlyEffect: true }
  ): <E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R | R1>
  <X>(
    f: NotFunction<X>
  ): <A, E, R>(
    self: Effect<A, E, R>
  ) => [X] extends [Effect<infer _A1, infer E1, infer R1>]
    ? Effect<A, E | E1, R | R1>
    : [X] extends [PromiseLike<infer _A1>]
      ? Effect<A, E | Cause.UnknownException, R>
      : Effect<A, E, R>
  <X, E1, R1>(
    f: Effect<X, E1, R1>,
    options: { onlyEffect: true }
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R | R1>
  <A, E, R, X>(
    self: Effect<A, E, R>,
    f: (a: NoInfer<A>) => X
  ): [X] extends [Effect<infer _A1, infer E1, infer R1>]
    ? Effect<A, E | E1, R | R1>
    : [X] extends [PromiseLike<infer _A1>]
      ? Effect<A, E | Cause.UnknownException, R>
      : Effect<A, E, R>
  <A, E, R, X, E1, R1>(
    self: Effect<A, E, R>,
    f: (a: NoInfer<A>) => Effect<X, E1, R1>,
    options: { onlyEffect: true }
  ): Effect<A, E | E1, R | R1>
  <A, E, R, X>(
    self: Effect<A, E, R>,
    f: NotFunction<X>
  ): [X] extends [Effect<infer _A1, infer E1, infer R1>]
    ? Effect<A, E | E1, R | R1>
    : [X] extends [PromiseLike<infer _A1>]
      ? Effect<A, E | Cause.UnknownException, R>
      : Effect<A, E, R>
  <A, E, R, X, E1, R1>(
    self: Effect<A, E, R>,
    f: Effect<X, E1, R1>,
    options: { onlyEffect: true }
  ): Effect<A, E | E1, R | R1>
}
```


# tapBoth

Allows you to inspect both success and failure outcomes of an effect and
perform side effects for each.

**Details**

This function enables you to handle both success and failure cases
separately, without modifying the main effect's result. It is particularly
useful for scenarios where you need to log, monitor, or perform additional
actions depending on whether the effect succeeded or failed.

When the effect succeeds, the `onSuccess` handler is executed with the
success value. When the effect fails, the `onFailure` handler is executed
with the failure value. Both handlers can include side effects such as
logging or analytics, and neither modifies the original effect's output.

If either the success or failure handler fails, the overall effect will also
fail.

To import and use `tapBoth` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.tapBoth
```

**Example**

```ts
import { Effect, Random, Console } from "effect"

// Simulate a task that might fail
const task = Effect.filterOrFail(
  Random.nextRange(-1, 1),
  (n) => n >= 0,
  () => "random number is negative"
)

// Use tapBoth to log both success and failure outcomes
const tapping = Effect.tapBoth(task, {
  onFailure: (error) => Console.log(`failure: ${error}`),
  onSuccess: (randomNumber) => Console.log(`random number: ${randomNumber}`)
})

// Effect.runFork(tapping)
// Example Output:
// failure: random number is negative
```

**Signature**

```ts
export declare const tapBoth: {
  <E, X, E2, R2, A, X1, E3, R3>(options: {
    readonly onFailure: (e: NoInfer<E>) => Effect<X, E2, R2>
    readonly onSuccess: (a: NoInfer<A>) => Effect<X1, E3, R3>
  }): <R>(self: Effect<A, E, R>) => Effect<A, E | E2 | E3, R2 | R3 | R>
  <A, E, R, X, E2, R2, X1, E3, R3>(
    self: Effect<A, E, R>,
    options: { readonly onFailure: (e: E) => Effect<X, E2, R2>; readonly onSuccess: (a: A) => Effect<X1, E3, R3> }
  ): Effect<A, E | E2 | E3, R | R2 | R3>
}
```


# tapDefect

Inspect severe errors or defects (non-recoverable failures) in an effect.

**Details**

This function is specifically designed to handle and inspect defects, which
are critical failures in your program, such as unexpected runtime exceptions
or system-level errors. Unlike normal recoverable errors, defects typically
indicate serious issues that cannot be addressed through standard error
handling.

When a defect occurs in an effect, the function you provide to this function
will be executed, allowing you to log, monitor, or handle the defect in some
way. Importantly, this does not alter the main result of the effect. If no
defect occurs, the effect behaves as if this function was not used.

To import and use `tapDefect` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.tapDefect
```

**Example**

```ts
import { Effect, Console } from "effect"

// Simulate a task that fails with a recoverable error
const task1: Effect.Effect<number, string> = Effect.fail("NetworkError")

// tapDefect won't log anything because NetworkError is not a defect
const tapping1 = Effect.tapDefect(task1, (cause) => Console.log(`defect: ${cause}`))

// Effect.runFork(tapping1)
// No Output

// Simulate a severe failure in the system
const task2: Effect.Effect<number, string> = Effect.dieMessage("Something went wrong")

// Log the defect using tapDefect
const tapping2 = Effect.tapDefect(task2, (cause) => Console.log(`defect: ${cause}`))

// Effect.runFork(tapping2)
// Output:
// defect: RuntimeException: Something went wrong
//   ... stack trace ...
```

**Signature**

```ts
export declare const tapDefect: {
  <X, E2, R2>(
    f: (cause: Cause.Cause<never>) => Effect<X, E2, R2>
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>
  <A, E, R, X, E2, R2>(
    self: Effect<A, E, R>,
    f: (cause: Cause.Cause<never>) => Effect<X, E2, R2>
  ): Effect<A, E | E2, R | R2>
}
```


# tapError

Execute a side effect on failure without modifying the original effect.

**Details**

This function allows you to inspect and react to the failure of an effect by
executing an additional effect. The failure value is passed to the provided
function, enabling you to log it, track it, or perform any other operation.
Importantly, the original failure remains intact and is re-propagated, so the
effect's behavior is unchanged.

The side effect you provide is only executed when the effect fails. If the
effect succeeds, the function is ignored, and the success value is propagated
as usual.

To import and use `tapError` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.tapError
```

**Example**

```ts
import { Effect, Console } from "effect"

// Simulate a task that fails with an error
const task: Effect.Effect<number, string> = Effect.fail("NetworkError")

// Use tapError to log the error message when the task fails
const tapping = Effect.tapError(task, (error) => Console.log(`expected error: ${error}`))

// Effect.runFork(tapping)
// Output:
// expected error: NetworkError
```

**Signature**

```ts
export declare const tapError: {
  <E, X, E2, R2>(f: (e: NoInfer<E>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>
  <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>
}
```


# tapErrorCause

Inspect the complete cause of an error, including failures and defects.

**Details**

This function provides access to the full cause of an error, including both
recoverable failures and irrecoverable defects. It allows you to handle, log,
or monitor specific error causes without modifying the result of the effect.
The full `Cause` object encapsulates the error and its contextual
information, making it useful for debugging and understanding failure
scenarios in complex workflows.

The effect itself is not modified, and any errors or defects remain in the
error channel of the original effect.

To import and use `tapErrorCause` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.tapErrorCause
```

**Example**

```ts
import { Effect, Console } from "effect"

// Create a task that fails with a NetworkError
const task1: Effect.Effect<number, string> = Effect.fail("NetworkError")

const tapping1 = Effect.tapErrorCause(task1, (cause) => Console.log(`error cause: ${cause}`))

// Effect.runFork(tapping1)
// Output:
// error cause: Error: NetworkError

// Simulate a severe failure in the system
const task2: Effect.Effect<number, string> = Effect.dieMessage("Something went wrong")

const tapping2 = Effect.tapErrorCause(task2, (cause) => Console.log(`error cause: ${cause}`))

// Effect.runFork(tapping2)
// Output:
// error cause: RuntimeException: Something went wrong
//   ... stack trace ...
```

**Signature**

```ts
export declare const tapErrorCause: {
  <E, X, E2, R2>(
    f: (cause: Cause.Cause<NoInfer<E>>) => Effect<X, E2, R2>
  ): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>
  <A, E, R, X, E2, R2>(
    self: Effect<A, E, R>,
    f: (cause: Cause.Cause<E>) => Effect<X, E2, R2>
  ): Effect<A, E | E2, R | R2>
}
```


# tapErrorTag

Inspect errors matching a specific tag without altering the original effect.

**Details**

This function allows you to inspect and handle specific error types based on
their `_tag` property. It is particularly useful in applications where errors
are modeled with tagged types (e.g., union types with discriminating tags).
By targeting errors with a specific `_tag`, you can log or perform actions on
them while leaving the error channel and overall effect unchanged.

If the error doesn't match the specified tag, this function does nothing, and
the effect proceeds as usual.

To import and use `tapErrorTag` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.tapErrorTag
```

**Example**

```ts
import { Effect, Console } from "effect"

class NetworkError {
  readonly _tag = "NetworkError"
  constructor(readonly statusCode: number) {}
}

class ValidationError {
  readonly _tag = "ValidationError"
  constructor(readonly field: string) {}
}

// Create a task that fails with a NetworkError
const task: Effect.Effect<number, NetworkError | ValidationError> = Effect.fail(new NetworkError(504))

// Use tapErrorTag to inspect only NetworkError types and log the status code
const tapping = Effect.tapErrorTag(task, "NetworkError", (error) => Console.log(`expected error: ${error.statusCode}`))

// Effect.runFork(tapping)
// Output:
// expected error: 504
```

**Signature**

```ts
export declare const tapErrorTag: {
  <K extends E extends { _tag: string } ? E["_tag"] : never, E, A1, E1, R1>(
    k: K,
    f: (e: NoInfer<Extract<E, { _tag: K }>>) => Effect<A1, E1, R1>
  ): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R1 | R>
  <A, E, R, K extends E extends { _tag: string } ? E["_tag"] : never, A1, E1, R1>(
    self: Effect<A, E, R>,
    k: K,
    f: (e: Extract<E, { _tag: K }>) => Effect<A1, E1, R1>
  ): Effect<A, E | E1, R | R1>
}
```


# timed

Executes an effect and measures the time it takes to complete.

**Details**

This function wraps the provided effect and returns a new effect that, when
executed, performs the original effect and calculates its execution duration.

The result of the new effect includes both the execution time (as a
`Duration`) and the original effect's result. This is useful for monitoring
performance or gaining insights into the time taken by specific operations.

The original effect's behavior (success, failure, or interruption) remains
unchanged, and the timing information is provided alongside the result in a
tuple.

To import and use `timed` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.timed
```

**Example**

```ts
import { Duration, Effect } from "effect"

const task = Effect.gen(function* () {
  yield* Effect.sleep("2 seconds") // Simulates some work
  return "some result"
})

const timedTask = task.pipe(Effect.timed)

const program = Effect.gen(function* () {
  const [duration, result] = yield* timedTask
  console.log(`Task completed in ${Duration.toMillis(duration)} ms with result: ${result}`)
})

// Effect.runFork(program)
// Output: Task completed in 2003.749125 ms with result: some result
```

**Signature**

```ts
export declare const timed: <A, E, R>(self: Effect<A, E, R>) => Effect<[duration: Duration.Duration, result: A], E, R>
```


# timedWith

Executes an effect and measures its execution time using a custom clock.

**Details**

This function extends the functionality of {@link timed} by allowing you to
specify a custom clock for measuring the execution duration. The provided
effect (`nanoseconds`) represents the clock and should return the current
time in nanoseconds. The timing information is computed using this custom
clock instead of the default system clock.

To import and use `timedWith` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.timedWith
```

**Signature**

```ts
export declare const timedWith: {
  <E1, R1>(
    nanoseconds: Effect<bigint, E1, R1>
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<[Duration.Duration, A], E1 | E, R1 | R>
  <A, E, R, E1, R1>(
    self: Effect<A, E, R>,
    nanoseconds: Effect<bigint, E1, R1>
  ): Effect<[Duration.Duration, A], E | E1, R | R1>
}
```


# timeout

Adds a time limit to an effect, triggering a timeout if the effect exceeds
the duration.

**Details**

This function allows you to enforce a time limit on the execution of an
effect. If the effect does not complete within the given duration, it fails
with a `TimeoutException`. This is useful for preventing tasks from hanging
indefinitely, especially in scenarios where responsiveness or resource limits
are critical.

The returned effect will either:

- Succeed with the original effect's result if it completes within the
  specified duration.
- Fail with a `TimeoutException` if the time limit is exceeded.

To import and use `timeout` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.timeout
```

**Example**

```ts
import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

// Output will show a TimeoutException as the task takes longer
// than the specified timeout duration
const timedEffect = task.pipe(Effect.timeout("1 second"))

// Effect.runPromiseExit(timedEffect).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'TimeoutException' }
//   }
// }
```

**Signature**

```ts
export declare const timeout: {
  (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | Cause.TimeoutException, R>
  <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<A, Cause.TimeoutException | E, R>
}
```


# timeoutFail

Specifies a custom error to be produced when a timeout occurs.

**Details**

This function allows you to handle timeouts in a customized way by defining a
specific error to be raised when an effect exceeds the given duration. Unlike
default timeout behaviors that use generic exceptions, this function gives
you the flexibility to specify a meaningful error type that aligns with your
application's needs.

When you apply this function, you provide:

- A `duration`: The time limit for the effect.
- An `onTimeout` function: A lazy evaluation function that generates the
  custom error if the timeout occurs.

If the effect completes within the time limit, its result is returned
normally. Otherwise, the `onTimeout` function is triggered, and its output is
used as the error for the effect.

To import and use `timeoutFail` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.timeoutFail
```

**Example**

```ts
import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

class MyTimeoutError {
  readonly _tag = "MyTimeoutError"
}

const program = task.pipe(
  Effect.timeoutFail({
    duration: "1 second",
    onTimeout: () => new MyTimeoutError() // Custom timeout error
  })
)

// Effect.runPromiseExit(program).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: MyTimeoutError { _tag: 'MyTimeoutError' }
//   }
// }
```

**Signature**

```ts
export declare const timeoutFail: {
  <E1>(options: {
    readonly onTimeout: LazyArg<E1>
    readonly duration: Duration.DurationInput
  }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>
  <A, E, R, E1>(
    self: Effect<A, E, R>,
    options: { readonly onTimeout: LazyArg<E1>; readonly duration: Duration.DurationInput }
  ): Effect<A, E | E1, R>
}
```


# timeoutFailCause

Specifies a custom defect to be thrown when a timeout occurs.

**Details**

This function allows you to handle timeouts as exceptional cases by
generating a custom defect when an effect exceeds the specified duration. You
provide:

- A `duration`: The time limit for the effect.
- An `onTimeout` function: A lazy evaluation function that generates the
  custom defect (typically created using `Cause.die`).

If the effect completes within the time limit, its result is returned
normally. Otherwise, the custom defect is triggered, and the effect fails
with that defect.

**When to Use**

This is especially useful when you need to treat timeouts as critical
failures in your application and wish to include meaningful information in
the defect.

To import and use `timeoutFailCause` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.timeoutFailCause
```

**Example**

```ts
import { Effect, Cause } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const program = task.pipe(
  Effect.timeoutFailCause({
    duration: "1 second",
    onTimeout: () => Cause.die("Timed out!") // Custom defect for timeout
  })
)

// Effect.runPromiseExit(program).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Timed out!' }
// }
```

**Signature**

```ts
export declare const timeoutFailCause: {
  <E1>(options: {
    readonly onTimeout: LazyArg<Cause.Cause<E1>>
    readonly duration: Duration.DurationInput
  }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>
  <A, E, R, E1>(
    self: Effect<A, E, R>,
    options: { readonly onTimeout: LazyArg<Cause.Cause<E1>>; readonly duration: Duration.DurationInput }
  ): Effect<A, E | E1, R>
}
```


# timeoutOption

Gracefully handles timeouts by returning an `Option` that represents either
the result or a timeout.

**Details**

This function wraps the outcome of an effect in an `Option` type. If the
effect completes within the specified duration, it returns a `Some`
containing the result. If the effect times out, it returns a `None`. Unlike
other timeout methods, this approach does not raise errors or exceptions;
instead, it allows you to treat timeouts as a regular outcome, simplifying
the logic for handling delays.

**When to Use**

This is useful when you want to handle timeouts without causing the program
to fail, making it easier to manage situations where you expect tasks might
take too long but want to continue executing other tasks.

To import and use `timeoutOption` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.timeoutOption
```

**Example**

```ts
import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const timedOutEffect = Effect.all([
  task.pipe(Effect.timeoutOption("3 seconds")),
  task.pipe(Effect.timeoutOption("1 second"))
])

// Effect.runPromise(timedOutEffect).then(console.log)
// Output:
// Start processing...
// Processing complete.
// Start processing...
// [
//   { _id: 'Option', _tag: 'Some', value: 'Result' },
//   { _id: 'Option', _tag: 'None' }
// ]
```

**Signature**

```ts
export declare const timeoutOption: {
  (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>
  <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<Option.Option<A>, E, R>
}
```


# timeoutTo

Provides custom behavior for successful and timed-out operations.

**Details**

This function allows you to define distinct outcomes for an effect depending
on whether it completes within a specified time frame or exceeds the timeout
duration. You can provide:

- `onSuccess`: A handler for processing the result of the effect if it
  completes successfully within the time limit.
- `onTimeout`: A handler for generating a result when the effect times out.
- `duration`: The maximum allowed time for the effect to complete.

**When to Use**

Unlike {@link timeout}, which raises an exception for timeouts, this function
gives you full control over the behavior for both success and timeout
scenarios. It is particularly useful when you want to encapsulate timeouts
and successes into a specific data structure, like an `Either` type, to
represent these outcomes in a meaningful way.

To import and use `timeoutTo` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.timeoutTo
```

**Example**

```ts
import { Effect, Either } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const program = task.pipe(
  Effect.timeoutTo({
    duration: "1 second",
    onSuccess: (result): Either.Either<string, string> => Either.right(result),
    onTimeout: (): Either.Either<string, string> => Either.left("Timed out!")
  })
)

// Effect.runPromise(program).then(console.log)
// Output:
// Start processing...
// {
//   _id: "Either",
//   _tag: "Left",
//   left: "Timed out!"
// }
```

**Signature**

```ts
export declare const timeoutTo: {
  <A, B, B1>(options: {
    readonly onTimeout: LazyArg<B1>
    readonly onSuccess: (a: A) => B
    readonly duration: Duration.DurationInput
  }): <E, R>(self: Effect<A, E, R>) => Effect<B | B1, E, R>
  <A, E, R, B1, B>(
    self: Effect<A, E, R>,
    options: {
      readonly onTimeout: LazyArg<B1>
      readonly onSuccess: (a: A) => B
      readonly duration: Duration.DurationInput
    }
  ): Effect<B1 | B, E, R>
}
```


# transplant

Transplants specified effects so that when those effects fork other
effects, the forked effects will be governed by the scope of the fiber that
executes this effect.

This can be used to "graft" deep grandchildren onto a higher-level scope,
effectively extending their lifespans into the parent scope.

To import and use `transplant` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.transplant
```

**Signature**

```ts
export declare const transplant: <A, E, R>(
  f: (grafter: <A2, E2, R2>(effect: Effect<A2, E2, R2>) => Effect<A2, E2, R2>) => Effect<A, E, R>
) => Effect<A, E, R>
```


# transposeOption

Converts an `Option` of an `Effect` into an `Effect` of an `Option`.

**Details**

This function transforms an `Option<Effect<A, E, R>>` into an
`Effect<Option<A>, E, R>`. If the `Option` is `None`, the resulting `Effect`
will immediately succeed with a `None` value. If the `Option` is `Some`, the
inner `Effect` will be executed, and its result wrapped in a `Some`.

To import and use `transposeOption` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.transposeOption
```

**Example**

```ts
import { Effect, Option } from "effect"

//       Option<Effect<number, never, never>>
//      
const maybe = Option.some(Effect.succeed(42))

//       Effect<Option<number>, never, never>
//      
const result = Effect.transposeOption(maybe)

console.log(Effect.runSync(result))
// Output: { _id: 'Option', _tag: 'Some', value: 42 }
```

**Signature**

```ts
export declare const transposeOption: <A = never, E = never, R = never>(
  self: Option.Option<Effect<A, E, R>>
) => Effect<Option.Option<A>, E, R>
```


# try

Creates an `Effect` that represents a synchronous computation that might
fail.

**When to Use**

In situations where you need to perform synchronous operations that might
fail, such as parsing JSON, you can use the `try` constructor. This
constructor is designed to handle operations that could throw exceptions by
capturing those exceptions and transforming them into manageable errors.

**Error Handling**

There are two ways to handle errors with `try`:

1. If you don't provide a `catch` function, the error is caught and the
   effect fails with an `UnknownException`.
2. If you provide a `catch` function, the error is caught and the `catch`
   function maps it to an error of type `E`.

To import and use `try` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.try
```

**Example**

```ts
// Title: Safe JSON Parsing
import { Effect } from "effect"

const parse = (input: string) =>
  // This might throw an error if input is not valid JSON
  Effect.try(() => JSON.parse(input))

//       Effect<any, UnknownException, never>
//      
const program = parse("")
```

**Example**

```ts
// Title: Custom Error Handling
import { Effect } from "effect"

const parse = (input: string) =>
  Effect.try({
    // JSON.parse may throw for bad input
    try: () => JSON.parse(input),
    // remap the error
    catch: (unknown) => new Error(`something went wrong ${unknown}`)
  })

//       Effect<any, Error, never>
//      
const program = parse("")
```


# tryMap

Returns an effect that maps its success using the specified side-effecting
`try` function, converting any errors into typed failed effects using the
`catch` function.

To import and use `tryMap` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.tryMap
```

**Signature**

```ts
export declare const tryMap: {
  <A, B, E1>(options: {
    readonly try: (a: A) => B
    readonly catch: (error: unknown) => E1
  }): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>
  <A, E, R, B, E1>(
    self: Effect<A, E, R>,
    options: { readonly try: (a: A) => B; readonly catch: (error: unknown) => E1 }
  ): Effect<B, E | E1, R>
}
```


# tryMapPromise

Returns an effect that maps its success using the specified side-effecting
`try` function, converting any promise rejections into typed failed effects
using the `catch` function.

An optional `AbortSignal` can be provided to allow for interruption of the
wrapped `Promise` API.

To import and use `tryMapPromise` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.tryMapPromise
```

**Signature**

```ts
export declare const tryMapPromise: {
  <A, B, E1>(options: {
    readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>
    readonly catch: (error: unknown) => E1
  }): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>
  <A, E, R, B, E1>(
    self: Effect<A, E, R>,
    options: { readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>; readonly catch: (error: unknown) => E1 }
  ): Effect<B, E | E1, R>
}
```


# tryPromise

Creates an `Effect` that represents an asynchronous computation that might
fail.

**When to Use**

In situations where you need to perform asynchronous operations that might
fail, such as fetching data from an API, you can use the `tryPromise`
constructor. This constructor is designed to handle operations that could
throw exceptions by capturing those exceptions and transforming them into
manageable errors.

**Error Handling**

There are two ways to handle errors with `tryPromise`:

1. If you don't provide a `catch` function, the error is caught and the
   effect fails with an `UnknownException`.
2. If you provide a `catch` function, the error is caught and the `catch`
   function maps it to an error of type `E`.

**Interruptions**

An optional `AbortSignal` can be provided to allow for interruption of the
wrapped `Promise` API.

To import and use `tryPromise` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.tryPromise
```

**Example**

```ts
// Title: Fetching a TODO Item
import { Effect } from "effect"

const getTodo = (id: number) =>
  // Will catch any errors and propagate them as UnknownException
  Effect.tryPromise(() => fetch(`https://jsonplaceholder.typicode.com/todos/${id}`))

//       Effect<Response, UnknownException, never>
//      
const program = getTodo(1)
```

**Example**

```ts
// Title: Custom Error Handling
import { Effect } from "effect"

const getTodo = (id: number) =>
  Effect.tryPromise({
    try: () => fetch(`https://jsonplaceholder.typicode.com/todos/${id}`),
    // remap the error
    catch: (unknown) => new Error(`something went wrong ${unknown}`)
  })

//       Effect<Response, Error, never>
//      
const program = getTodo(1)
```

**Signature**

```ts
export declare const tryPromise: {
  <A, E>(options: {
    readonly try: (signal: AbortSignal) => PromiseLike<A>
    readonly catch: (error: unknown) => E
  }): Effect<A, E>
  <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>): Effect<A, Cause.UnknownException>
}
```


# uninterruptible

Marks an effect as uninterruptible.

To import and use `uninterruptible` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.uninterruptible
```

**Signature**

```ts
export declare const uninterruptible: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
```


# uninterruptibleMask

This function behaves like {@link uninterruptible}, but it also provides a
`restore` function. This function can be used to restore the interruptibility
of any specific region of code.

To import and use `uninterruptibleMask` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.uninterruptibleMask
```

**Signature**

```ts
export declare const uninterruptibleMask: <A, E, R>(
  f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>
) => Effect<A, E, R>
```


# unless

Executes an effect only if the condition is `false`.

To import and use `unless` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.unless
```

**Signature**

```ts
export declare const unless: {
  (condition: LazyArg<boolean>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>
  <A, E, R>(self: Effect<A, E, R>, condition: LazyArg<boolean>): Effect<Option.Option<A>, E, R>
}
```


# unlessEffect

Conditionally execute an effect based on the result of another effect.

To import and use `unlessEffect` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.unlessEffect
```

**Signature**

```ts
export declare const unlessEffect: {
  <E2, R2>(
    condition: Effect<boolean, E2, R2>
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E2 | E, R2 | R>
  <A, E, R, E2, R2>(self: Effect<A, E, R>, condition: Effect<boolean, E2, R2>): Effect<Option.Option<A>, E | E2, R | R2>
}
```


# unsafeMakeSemaphore

Unsafely creates a new Semaphore.

To import and use `unsafeMakeSemaphore` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.unsafeMakeSemaphore
```

**Signature**

```ts
export declare const unsafeMakeSemaphore: (permits: number) => Semaphore
```


# unsandbox

The `unsandbox` function is used to revert an effect that has been
sandboxed by {@link sandbox}. When you apply `unsandbox`, the
effect's error channel is restored to its original state, without the
detailed `Cause<E>` information. This means that any underlying causes of
errors, defects, or fiber interruptions are no longer exposed in the error
channel.

This function is useful when you want to remove the detailed error tracking
provided by `sandbox` and return to the standard error handling for
your effect. Once unsandboxed, the effect behaves as if `sandbox` was
never applied.

To import and use `unsandbox` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.unsandbox
```

**Signature**

```ts
export declare const unsandbox: <A, E, R>(self: Effect<A, Cause.Cause<E>, R>) => Effect<A, E, R>
```


# updateFiberRefs

Updates the `FiberRef` values for the fiber running this effect using the
specified function.

To import and use `updateFiberRefs` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.updateFiberRefs
```

**Signature**

```ts
export declare const updateFiberRefs: (
  f: (fiberId: FiberId.Runtime, fiberRefs: FiberRefs.FiberRefs) => FiberRefs.FiberRefs
) => Effect<void>
```


# updateService

Updates a service in the context with a new implementation.

**Details**

This function modifies the existing implementation of a service in the
context. It retrieves the current service, applies the provided
transformation function `f`, and replaces the old service with the
transformed one.

**When to Use**

This is useful for adapting or extending a service's behavior during the
execution of an effect.

To import and use `updateService` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.updateService
```

**Signature**

```ts
export declare const updateService: {
  <I, S>(
    tag: Context.Tag<I, S>,
    f: (service: NoInfer<S>) => NoInfer<S>
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R | I>
  <A, E, R, I, S>(
    self: Effect<A, E, R>,
    tag: Context.Tag<I, S>,
    f: (service: NoInfer<S>) => NoInfer<S>
  ): Effect<A, E, R | I>
}
```


# useSpan

Create a new span for tracing, and automatically close it when the effect
completes.

The span is not added to the current span stack, so no child spans will be
created for it.

To import and use `useSpan` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.useSpan
```

**Signature**

```ts
export declare const useSpan: {
  <A, E, R>(name: string, evaluate: (span: Tracer.Span) => Effect<A, E, R>): Effect<A, E, R>
  <A, E, R>(
    name: string,
    options: Tracer.SpanOptions,
    evaluate: (span: Tracer.Span) => Effect<A, E, R>
  ): Effect<A, E, R>
}
```


# using

Scopes all resources acquired by one effect to the lifetime of another
effect.

**Details**

This function allows you to scope the resources acquired by one effect
(`self`) to the lifetime of another effect (`use`). This ensures that the
resources are cleaned up as soon as the `use` effect completes, regardless of
how the `use` effect ends (success, failure, or interruption).

To import and use `using` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.using
```

**Example**

```ts
import { Console, Effect } from "effect"

const acquire = Console.log("Acquiring resource").pipe(
  Effect.as(1),
  Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))
)
const use = (resource: number) => Console.log(`Using resource: ${resource}`)

const program = acquire.pipe(Effect.using(use))

// Effect.runFork(program)
// Output:
// Acquiring resource
// Using resource: 1
// Releasing resource
```

**Signature**

```ts
export declare const using: {
  <A, A2, E2, R2>(
    use: (a: A) => Effect<A2, E2, R2>
  ): <E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | Exclude<R, Scope.Scope>>
  <A, E, R, A2, E2, R2>(
    self: Effect<A, E, R>,
    use: (a: A) => Effect<A2, E2, R2>
  ): Effect<A2, E | E2, R2 | Exclude<R, Scope.Scope>>
}
```


# validate

Combines multiple effects and accumulates both successes and failures.

**Details**

This function allows you to combine multiple effects, continuing through all
effects even if some of them fail. Unlike other functions that stop execution
upon encountering an error, this function collects all errors into a `Cause`.
The final result includes all successes and the accumulated failures.

By default, effects are executed sequentially, but you can control
concurrency and batching behavior using the `options` parameter. This
provides flexibility in scenarios where you want to maximize performance or
ensure specific ordering.

To import and use `validate` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.validate
```

**Example**

```ts
import { Effect, Console } from "effect"

const task1 = Console.log("task1").pipe(Effect.as(1))
const task2 = Effect.fail("Oh uh!").pipe(Effect.as(2))
const task3 = Console.log("task2").pipe(Effect.as(3))
const task4 = Effect.fail("Oh no!").pipe(Effect.as(4))

const program = task1.pipe(Effect.validate(task2), Effect.validate(task3), Effect.validate(task4))

// Effect.runPromiseExit(program).then(console.log)
// Output:
// task1
// task2
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Sequential',
//     left: { _id: 'Cause', _tag: 'Fail', failure: 'Oh uh!' },
//     right: { _id: 'Cause', _tag: 'Fail', failure: 'Oh no!' }
//   }
// }
```

**Signature**

```ts
export declare const validate: {
  <B, E1, R1>(
    that: Effect<B, E1, R1>,
    options?:
      | {
          readonly concurrent?: boolean | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, B], E1 | E, R1 | R>
  <A, E, R, B, E1, R1>(
    self: Effect<A, E, R>,
    that: Effect<B, E1, R1>,
    options?:
      | {
          readonly concurrent?: boolean | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): Effect<[A, B], E | E1, R | R1>
}
```


# validateAll

Applies an effectful operation to each element in a collection while
collecting both successes and failures.

**Details**

This function allows you to apply an effectful operation to every item in a
collection.

Unlike {@link forEach}, which would stop at the first error, this function
continues processing all elements, accumulating both successes and failures.

**When to Use**

Use this function when you want to process every item in a collection, even
if some items fail. This is particularly useful when you need to perform
operations on all elements without halting due to an error.

Keep in mind that if there are any failures, **all successes will be lost**,
so this function is not suitable when you need to keep the successful results
in case of errors.

To import and use `validateAll` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.validateAll
```

**Example**

```ts
import { Effect, Console } from "effect"

//       Effect<number[], [string, ...string[]], never>
//      
const program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {
  if (n < 4) {
    return Console.log(`item ${n}`).pipe(Effect.as(n))
  } else {
    return Effect.fail(`${n} is not less that 4`)
  }
})

// Effect.runPromiseExit(program).then(console.log)
// Output:
// item 1
// item 2
// item 3
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: [ '4 is not less that 4', '5 is not less that 4' ]
//   }
// }
```

**Signature**

```ts
export declare const validateAll: {
  <A, B, E, R>(
    f: (a: A, i: number) => Effect<B, E, R>,
    options?:
      | {
          readonly concurrency?: Concurrency | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly discard?: false | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): (elements: Iterable<A>) => Effect<Array<B>, RA.NonEmptyArray<E>, R>
  <A, B, E, R>(
    f: (a: A, i: number) => Effect<B, E, R>,
    options: {
      readonly concurrency?: Concurrency | undefined
      readonly batching?: boolean | "inherit" | undefined
      readonly discard: true
      readonly concurrentFinalizers?: boolean | undefined
    }
  ): (elements: Iterable<A>) => Effect<void, RA.NonEmptyArray<E>, R>
  <A, B, E, R>(
    elements: Iterable<A>,
    f: (a: A, i: number) => Effect<B, E, R>,
    options?:
      | {
          readonly concurrency?: Concurrency | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly discard?: false | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): Effect<Array<B>, RA.NonEmptyArray<E>, R>
  <A, B, E, R>(
    elements: Iterable<A>,
    f: (a: A, i: number) => Effect<B, E, R>,
    options: {
      readonly concurrency?: Concurrency | undefined
      readonly batching?: boolean | "inherit" | undefined
      readonly discard: true
      readonly concurrentFinalizers?: boolean | undefined
    }
  ): Effect<void, RA.NonEmptyArray<E>, R>
}
```


# validateFirst

This function is similar to {@link validateAll} but with a key difference: it
returns the first successful result or all errors if none of the operations
succeed.

**Details**

This function processes a collection of elements and applies an effectful
operation to each. Unlike {@link validateAll}, which accumulates both
successes and failures, `Effect.validateFirst` stops and returns the first
success it encounters. If no success occurs, it returns all accumulated
errors. This can be useful when you are interested in the first successful
result and want to avoid processing further once a valid result is found.

To import and use `validateFirst` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.validateFirst
```

**Example**

```ts
import { Effect, Console } from "effect"

//       Effect<number, string[], never>
//      
const program = Effect.validateFirst([1, 2, 3, 4, 5], (n) => {
  if (n < 4) {
    return Effect.fail(`${n} is not less that 4`)
  } else {
    return Console.log(`item ${n}`).pipe(Effect.as(n))
  }
})

// Effect.runPromise(program).then(console.log, console.error)
// Output:
// item 4
// 4
```

**Signature**

```ts
export declare const validateFirst: {
  <A, B, E, R>(
    f: (a: A, i: number) => Effect<B, E, R>,
    options?:
      | {
          readonly concurrency?: Concurrency | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): (elements: Iterable<A>) => Effect<B, Array<E>, R>
  <A, B, E, R>(
    elements: Iterable<A>,
    f: (a: A, i: number) => Effect<B, E, R>,
    options?:
      | {
          readonly concurrency?: Concurrency | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): Effect<B, Array<E>, R>
}
```


# validateWith

Sequentially combines two effects using a specified combiner function while
accumulating errors.

**Details**

This function combines two effects, `self` and `that`, into a single effect
by applying the provided combiner function to their results. If both effects
succeed, the combiner function is applied to their results to produce the
final value. If either effect fails, the failures are accumulated into a
combined `Cause`.

By default, effects are executed sequentially. However, the execution mode
can be controlled using the `options` parameter to enable concurrency,
batching, or customized finalizer behavior.

To import and use `validateWith` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.validateWith
```

**Signature**

```ts
export declare const validateWith: {
  <B, E1, R1, A, C>(
    that: Effect<B, E1, R1>,
    f: (a: A, b: B) => C,
    options?:
      | {
          readonly concurrent?: boolean | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): <E, R>(self: Effect<A, E, R>) => Effect<C, E1 | E, R1 | R>
  <A, E, R, B, E1, R1, C>(
    self: Effect<A, E, R>,
    that: Effect<B, E1, R1>,
    f: (a: A, b: B) => C,
    options?:
      | {
          readonly concurrent?: boolean | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): Effect<C, E | E1, R | R1>
}
```


# void

Represents an effect that does nothing and produces no value.

**When to Use**

Use this effect when you need to represent an effect that does nothing.
This is useful in scenarios where you need to satisfy an effect-based
interface or control program flow without performing any operations. For
example, it can be used in situations where you want to return an effect
from a function but do not need to compute or return any result.

To import and use `void` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.void
```


# when

Conditionally executes an effect based on a boolean condition.

**Details**

This function allows you to run an effect only if a given condition evaluates
to `true`. If the condition is `true`, the effect is executed, and its result
is wrapped in an `Option.some`. If the condition is `false`, the effect is
skipped, and the result is `Option.none`.

**When to Use**

This function is useful for scenarios where you need to dynamically decide
whether to execute an effect based on runtime logic, while also representing
the skipped case explicitly.

To import and use `when` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.when
```

**Example**

```ts
// Title: Conditional Effect Execution
import { Effect, Option } from "effect"

const validateWeightOption = (weight: number): Effect.Effect<Option.Option<number>> =>
  // Conditionally execute the effect if the weight is non-negative
  Effect.succeed(weight).pipe(Effect.when(() => weight >= 0))

// Run with a valid weight
// Effect.runPromise(validateWeightOption(100)).then(console.log)
// Output:
// {
//   _id: "Option",
//   _tag: "Some",
//   value: 100
// }

// Run with an invalid weight
// Effect.runPromise(validateWeightOption(-5)).then(console.log)
// Output:
// {
//   _id: "Option",
//   _tag: "None"
// }
```

**Signature**

```ts
export declare const when: {
  (condition: LazyArg<boolean>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>
  <A, E, R>(self: Effect<A, E, R>, condition: LazyArg<boolean>): Effect<Option.Option<A>, E, R>
}
```


# whenEffect

Conditionally executes an effect based on the result of another effect.

**Details**

This function allows you to run an effect only if a conditional effect
evaluating to a boolean resolves to `true`. If the conditional effect
evaluates to `true`, the specified effect is executed, and its result is
wrapped in `Option.some`. If the conditional effect evaluates to `false`, the
effect is skipped, and the result is `Option.none`.

**When to Use**

This function is particularly useful when the decision to execute an effect
depends on the result of another effect, such as a random value, a
user-provided input, or a network request result.

To import and use `whenEffect` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.whenEffect
```

**Example**

```ts
// Title: Using an Effect as a Condition
import { Effect, Random } from "effect"

const randomIntOption = Random.nextInt.pipe(Effect.whenEffect(Random.nextBoolean))

console.log(Effect.runSync(randomIntOption))
// Example Output:
// { _id: 'Option', _tag: 'Some', value: 8609104974198840 }
```

**Signature**

```ts
export declare const whenEffect: {
  <E, R>(
    condition: Effect<boolean, E, R>
  ): <A, E2, R2>(effect: Effect<A, E2, R2>) => Effect<Option.Option<A>, E | E2, R | R2>
  <A, E2, R2, E, R>(self: Effect<A, E2, R2>, condition: Effect<boolean, E, R>): Effect<Option.Option<A>, E2 | E, R2 | R>
}
```


# whenFiberRef

Executes an effect conditionally based on the value of a `FiberRef` that
satisfies a predicate.

**Details**

This function enables you to execute an effect only when the value of a
specified `FiberRef` meets a certain condition defined by a predicate. If the
value satisfies the predicate, the effect is executed, and the result is
wrapped in an `Option.some`. If the predicate is not satisfied, the effect is
skipped, and the result is `Option.none`. In both cases, the current value of
the `FiberRef` is included in the result.

To import and use `whenFiberRef` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.whenFiberRef
```

**Signature**

```ts
export declare const whenFiberRef: {
  <S>(
    fiberRef: FiberRef.FiberRef<S>,
    predicate: Predicate<S>
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option.Option<A>], E, R>
  <A, E, R, S>(
    self: Effect<A, E, R>,
    fiberRef: FiberRef.FiberRef<S>,
    predicate: Predicate<S>
  ): Effect<[S, Option.Option<A>], E, R>
}
```


# whenLogLevel

Conditionally executes an effect based on the specified log level and currently enabled log level.

**Details**

This function runs the provided effect only if the specified log level is
enabled. If the log level is enabled, the effect is executed and its result
is wrapped in `Some`. If the log level is not enabled, the effect is not
executed and `None` is returned.

This function is useful for conditionally executing logging-related effects
or other operations that depend on the current log level configuration.

To import and use `whenLogLevel` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.whenLogLevel
```

**Example**

```ts
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.whenLogLevel(Effect.logTrace("message1"), LogLevel.Trace) // returns `None`
  yield* Effect.whenLogLevel(Effect.logDebug("message2"), LogLevel.Debug) // returns `Some`
}).pipe(Logger.withMinimumLogLevel(LogLevel.Debug))

// Effect.runFork(program)
// timestamp=... level=DEBUG fiber=#0 message=message2
```

**Signature**

```ts
export declare const whenLogLevel: {
  (level: LogLevel.LogLevel | LogLevel.Literal): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>
  <A, E, R>(self: Effect<A, E, R>, level: LogLevel.LogLevel | LogLevel.Literal): Effect<Option.Option<A>, E, R>
}
```


# whenRef

Executes an effect conditionally based on the value of a `Ref` that satisfies
a predicate.

**Details**

This function allows you to execute an effect only when the value of a
specified `Ref` meets a condition defined by a predicate. If the value
satisfies the predicate, the effect is executed, and the result is wrapped in
an `Option.some`. If the predicate is not satisfied, the effect is skipped,
and the result is `Option.none`. In both cases, the current value of the
`Ref` is included in the result.

To import and use `whenRef` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.whenRef
```

**Signature**

```ts
export declare const whenRef: {
  <S>(ref: Ref.Ref<S>, predicate: Predicate<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option.Option<A>], E, R>
  <A, E, R, S>(self: Effect<A, E, R>, ref: Ref.Ref<S>, predicate: Predicate<S>): Effect<[S, Option.Option<A>], E, R>
}
```


# withClock

Executes the specified workflow with the specified implementation of the
`Clock` service.

To import and use `withClock` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withClock
```

**Signature**

```ts
export declare const withClock: {
  <C extends Clock.Clock>(clock: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>
  <C extends Clock.Clock, A, E, R>(effect: Effect<A, E, R>, clock: C): Effect<A, E, R>
}
```


# withClockScoped

Sets the implementation of the `Clock` service to the specified value and
restores it to its original value when the scope is closed.

To import and use `withClockScoped` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withClockScoped
```

**Signature**

```ts
export declare const withClockScoped: <C extends Clock.Clock>(clock: C) => Effect<void, never, Scope.Scope>
```


# withConfigProvider

Executes an effect using a specific configuration provider.

**Details**

This function lets you run an effect with a specified configuration provider.
The custom provider will override the default configuration provider for the
duration of the effect's execution.

**When to Use**

This is particularly useful when you need to use a different set of
configuration values or sources for specific parts of your application.

To import and use `withConfigProvider` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withConfigProvider
```

**Example**

```ts
import { Config, ConfigProvider, Effect } from "effect"

const customProvider: ConfigProvider.ConfigProvider = ConfigProvider.fromMap(new Map([["custom-key", "custom-value"]]))

const program = Effect.withConfigProvider(customProvider)(
  Effect.gen(function* () {
    const value = yield* Config.string("custom-key")
    console.log(`Config value: ${value}`)
  })
)

// Effect.runPromise(program)
// Output:
// Config value: custom-value
```

**Signature**

```ts
export declare const withConfigProvider: {
  (provider: ConfigProvider): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R>(self: Effect<A, E, R>, provider: ConfigProvider): Effect<A, E, R>
}
```


# withConfigProviderScoped

Sets a configuration provider within a scope.

**Details**

This function sets the configuration provider to a specified value and
ensures that it is restored to its original value when the scope is closed.

To import and use `withConfigProviderScoped` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withConfigProviderScoped
```

**Signature**

```ts
export declare const withConfigProviderScoped: (provider: ConfigProvider) => Effect<void, never, Scope.Scope>
```


# withConsole

Executes the specified workflow with the specified implementation of the
console service.

To import and use `withConsole` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withConsole
```

**Signature**

```ts
export declare const withConsole: {
  <C extends Console>(console: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R, C extends Console>(effect: Effect<A, E, R>, console: C): Effect<A, E, R>
}
```


# withConsoleScoped

Sets the implementation of the console service to the specified value and
restores it to its original value when the scope is closed.

To import and use `withConsoleScoped` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withConsoleScoped
```

**Signature**

```ts
export declare const withConsoleScoped: <A extends Console>(console: A) => Effect<void, never, Scope.Scope>
```


# withEarlyRelease

Returns the result of the effect and a finalizer to close its scope.

**Details**

This function allows you to retrieve both the result of an effect and a
finalizer that can be used to manually close its scope. This is useful for
workflows where you need early access to the result while retaining control
over the resource cleanup process.

To import and use `withEarlyRelease` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withEarlyRelease
```

**Example**

```ts
import { Console, Effect } from "effect"

const acquire = Console.log("Acquiring resource").pipe(
  Effect.as(1),
  Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))
)
const program = Effect.gen(function* () {
  const [finalizer, resource] = yield* Effect.withEarlyRelease(acquire)
  console.log(`Using resource: ${resource}`)
  yield* Effect.sleep("1 second")
  yield* finalizer
})

Effect.runFork(program.pipe(Effect.scoped))
// Output:
// Acquiring resource
// Using resource: 1
// Releasing resource
```

**Signature**

```ts
export declare const withEarlyRelease: <A, E, R>(
  self: Effect<A, E, R>
) => Effect<[finalizer: Effect<void>, result: A], E, R | Scope.Scope>
```


# withLogSpan

Adds a log span to an effect for tracking and logging its execution duration.

**Details**

This function wraps an effect with a log span, providing performance
monitoring and debugging capabilities. The log span tracks the duration of
the wrapped effect and logs it with the specified label. This is particularly
useful when analyzing time-sensitive operations or understanding the
execution time of specific tasks in your application.

The logged output will include the label and the total time taken for the
operation. The span information is included in the log metadata, making it
easy to trace performance metrics in logs.

To import and use `withLogSpan` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withLogSpan
```

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.sleep("1 second")
  yield* Effect.log("The job is finished!")
}).pipe(Effect.withLogSpan("myspan"))

// Effect.runFork(program)
// timestamp=... level=INFO fiber=#0 message="The job is finished!" myspan=1011ms
```

**Signature**

```ts
export declare const withLogSpan: {
  (label: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R>(effect: Effect<A, E, R>, label: string): Effect<A, E, R>
}
```


# withMaxOpsBeforeYield

Sets the maximum number of operations before yield by the default schedulers

To import and use `withMaxOpsBeforeYield` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withMaxOpsBeforeYield
```

**Signature**

```ts
export declare const withMaxOpsBeforeYield: {
  (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>
}
```


# withMetric

Associates a metric with the current effect, updating it as the effect progresses.

To import and use `withMetric` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withMetric
```

**Signature**

```ts
export declare const withMetric: {
  <Type, In, Out>(metric: Metric.Metric<Type, In, Out>): <A extends In, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
  <A extends In, E, R, Type, In, Out>(self: Effect<A, E, R>, metric: Metric.Metric<Type, In, Out>): Effect<A, E, R>
}
```


# withParentSpan

Adds the provided span to the current span stack.

To import and use `withParentSpan` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withParentSpan
```

**Signature**

```ts
export declare const withParentSpan: {
  (span: Tracer.AnySpan): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan>>
  <A, E, R>(self: Effect<A, E, R>, span: Tracer.AnySpan): Effect<A, E, Exclude<R, Tracer.ParentSpan>>
}
```


# withRandom

Executes the specified effect with the specified implementation of the
`Random` service.

To import and use `withRandom` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withRandom
```

**Signature**

```ts
export declare const withRandom: {
  <X extends Random.Random>(value: X): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>
  <X extends Random.Random, A, E, R>(effect: Effect<A, E, R>, value: X): Effect<A, E, R>
}
```


# withRandomScoped

Sets the implementation of the `Random` service to the specified value and
restores it to its original value when the scope is closed.

To import and use `withRandomScoped` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withRandomScoped
```

**Signature**

```ts
export declare const withRandomScoped: <A extends Random.Random>(value: A) => Effect<void, never, Scope.Scope>
```


# withScheduler

Sets the provided scheduler for usage in the wrapped effect

To import and use `withScheduler` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withScheduler
```

**Signature**

```ts
export declare const withScheduler: {
  (scheduler: Scheduler.Scheduler): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R>(self: Effect<A, E, R>, scheduler: Scheduler.Scheduler): Effect<A, E, R>
}
```


# withSchedulingPriority

Sets the scheduling priority used when yielding

To import and use `withSchedulingPriority` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withSchedulingPriority
```

**Signature**

```ts
export declare const withSchedulingPriority: {
  (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>
}
```


# withSpan

Wraps the effect with a new span for tracing.

To import and use `withSpan` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withSpan
```

**Signature**

```ts
export declare const withSpan: {
  (
    name: string,
    options?: Tracer.SpanOptions | undefined
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan>>
  <A, E, R>(
    self: Effect<A, E, R>,
    name: string,
    options?: Tracer.SpanOptions | undefined
  ): Effect<A, E, Exclude<R, Tracer.ParentSpan>>
}
```


# withSpanScoped

Wraps the effect with a new span for tracing.

The span is ended when the Scope is finalized.

To import and use `withSpanScoped` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withSpanScoped
```

**Signature**

```ts
export declare const withSpanScoped: {
  (
    name: string,
    options?: Tracer.SpanOptions
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan> | Scope.Scope>
  <A, E, R>(
    self: Effect<A, E, R>,
    name: string,
    options?: Tracer.SpanOptions
  ): Effect<A, E, Exclude<R, Tracer.ParentSpan> | Scope.Scope>
}
```


# withTracerEnabled

Disable the tracer for the given Effect.

To import and use `withTracerEnabled` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withTracerEnabled
```

**Example**

```ts
import { Effect } from "effect"

Effect.succeed(42).pipe(
  Effect.withSpan("my-span"),
  // the span will not be registered with the tracer
  Effect.withTracerEnabled(false)
)
```

**Signature**

```ts
export declare const withTracerEnabled: {
  (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>
}
```


# withUnhandledErrorLogLevel

Configures whether child fibers will log unhandled errors and at what log
level.

**Details**

This function allows you to control whether unhandled errors from child
fibers are logged and to specify the log level for these errors. By default,
unhandled errors are reported via the logger. However, using this function,
you can choose to suppress these logs by passing `Option.none` or adjust the
log level to a specific severity, such as `Error`, `Warning`, or `Info`.

This configuration is scoped to the effect it is applied to, meaning the
changes only apply to the child fibers created within that effect's context.
It is especially useful when you want to reduce noise in logs or prioritize
certain types of errors.

To import and use `withUnhandledErrorLogLevel` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.withUnhandledErrorLogLevel
```

**Example**

```ts
import { Effect, Fiber, LogLevel, Option } from "effect"

const program = Effect.gen(function* () {
  const fiber = yield* Effect.fork(Effect.fail("Unhandled error!"))
  yield* Fiber.join(fiber)
})

// Effect.runFork(program.pipe(Effect.withUnhandledErrorLogLevel(Option.some(LogLevel.Error))))
// Output:
// timestamp=... level=ERROR fiber=#1 message="Fiber terminated with an unhandled error" cause="Error: Unhandled error!"
```

**Signature**

```ts
export declare const withUnhandledErrorLogLevel: {
  (level: Option.Option<LogLevel.LogLevel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R>(self: Effect<A, E, R>, level: Option.Option<LogLevel.LogLevel>): Effect<A, E, R>
}
```


# zip

Combines two effects into a single effect, producing a tuple of their
results.

**Details**

This function combines two effects, `self` and `that`, into one. It executes
the first effect (`self`) and then the second effect (`that`), collecting
their results into a tuple. Both effects must succeed for the resulting
effect to succeed. If either effect fails, the entire operation fails.

By default, the effects are executed sequentially. If the `concurrent` option
is set to `true`, the effects will run concurrently, potentially improving
performance for independent operations.

To import and use `zip` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.zip
```

**Example**

```ts
// Title: Combining Two Effects Sequentially
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(Effect.delay("200 millis"), Effect.tap(Effect.log("task1 done")))
const task2 = Effect.succeed("hello").pipe(Effect.delay("100 millis"), Effect.tap(Effect.log("task2 done")))

// Combine the two effects together
//
//       Effect<[number, string], never, never>
//      
const program = Effect.zip(task1, task2)

// Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task1 done"
// timestamp=... level=INFO fiber=#0 message="task2 done"
// [ 1, 'hello' ]
```

**Example**

```ts
// Title: Combining Two Effects Concurrently
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(Effect.delay("200 millis"), Effect.tap(Effect.log("task1 done")))
const task2 = Effect.succeed("hello").pipe(Effect.delay("100 millis"), Effect.tap(Effect.log("task2 done")))

// Run both effects concurrently using the concurrent option
const program = Effect.zip(task1, task2, { concurrent: true })

// Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task2 done"
// timestamp=... level=INFO fiber=#0 message="task1 done"
// [ 1, 'hello' ]
```

**Signature**

```ts
export declare const zip: {
  <A2, E2, R2>(
    that: Effect<A2, E2, R2>,
    options?:
      | {
          readonly concurrent?: boolean | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, A2], E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Effect<A, E, R>,
    that: Effect<A2, E2, R2>,
    options?:
      | {
          readonly concurrent?: boolean | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): Effect<[A, A2], E | E2, R | R2>
}
```


# zipLeft

Executes two effects sequentially, returning the result of the first effect
and ignoring the result of the second.

**Details**

This function allows you to run two effects in sequence, where the result of
the first effect is preserved, and the result of the second effect is
discarded. By default, the two effects are executed sequentially. If you need
them to run concurrently, you can pass the `{ concurrent: true }` option.

The second effect will always be executed, even though its result is ignored.
This makes it useful for cases where you want to execute an effect for its
side effects while keeping the result of another effect.

**When to Use**

Use this function when you are only interested in the result of the first
effect but still need to run the second effect for its side effects, such as
logging or performing a cleanup action.

To import and use `zipLeft` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.zipLeft
```

**Example**

```ts
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(Effect.delay("200 millis"), Effect.tap(Effect.log("task1 done")))
const task2 = Effect.succeed("hello").pipe(Effect.delay("100 millis"), Effect.tap(Effect.log("task2 done")))

const program = Effect.zipLeft(task1, task2)

// Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task1 done"
// timestamp=... level=INFO fiber=#0 message="task2 done"
// 1
```

**Signature**

```ts
export declare const zipLeft: {
  <A2, E2, R2>(
    that: Effect<A2, E2, R2>,
    options?:
      | {
          readonly concurrent?: boolean | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Effect<A, E, R>,
    that: Effect<A2, E2, R2>,
    options?:
      | {
          readonly concurrent?: boolean | undefined
          readonly batching?: boolean | "inherit" | undefined
          readonly concurrentFinalizers?: boolean | undefined
        }
      | undefined
  ): Effect<A, E | E2, R | R2>
}
```


# zipRight

Executes two effects sequentially, returning the result of the second effect
while ignoring the result of the first.

**Details**

This function allows you to run two effects in sequence, keeping the result
of the second effect and discarding the result of the first. By default, the
two effects are executed sequentially. If you need them to run concurrently,
you can pass the `{ concurrent: true }` option.

The first effect will always be executed, even though its result is ignored.
This makes it useful for scenarios where the first effect is needed for its
side effects, but only the result of the second effect is important.

**When to Use**

Use this function when you are only interested in the result of the second
effect but still need to run the first effect for its side effects, such as
initialization or setup tasks.

To import and use `zipRight` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.zipRight
```

**Example**

```ts
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(Effect.delay("200 millis"), Effect.tap(Effect.log("task1 done")))
const task2 = Effect.succeed("hello").pipe(Effect.delay("100 millis"), Effect.tap(Effect.log("task2 done")))

const program = Effect.zipRight(task1, task2)

// Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task1 done"
// timestamp=... level=INFO fiber=#0 message="task2 done"
// hello
```

**Signature**

```ts
export declare const zipRight: {
  <A2, E2, R2>(
    that: Effect<A2, E2, R2>,
    options?: {
      readonly concurrent?: boolean | undefined
      readonly batching?: boolean | "inherit" | undefined
      readonly concurrentFinalizers?: boolean | undefined
    }
  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Effect<A, E, R>,
    that: Effect<A2, E2, R2>,
    options?: {
      readonly concurrent?: boolean | undefined
      readonly batching?: boolean | "inherit" | undefined
      readonly concurrentFinalizers?: boolean | undefined
    }
  ): Effect<A2, E2 | E, R2 | R>
}
```


# zipWith

Combines two effects sequentially and applies a function to their results to
produce a single value.

**Details**

This function runs two effects in sequence (or concurrently, if the `{
concurrent: true }` option is provided) and combines their results using a
provided function. Unlike {@link zip}, which returns a tuple of the results,
this function processes the results with a custom function to produce a
single output.

To import and use `zipWith` from the "Effect" module:

```ts
import * as Effect from "effect/Effect"
// Can be accessed like this
Effect.zipWith
```

**Example**

```ts
// Title: Combining Effects with a Custom Function
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(Effect.delay("200 millis"), Effect.tap(Effect.log("task1 done")))
const task2 = Effect.succeed("hello").pipe(Effect.delay("100 millis"), Effect.tap(Effect.log("task2 done")))

const task3 = Effect.zipWith(
  task1,
  task2,
  // Combines results into a single value
  (number, string) => number + string.length
)

// Effect.runPromise(task3).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#3 message="task1 done"
// timestamp=... level=INFO fiber=#2 message="task2 done"
// 6
```

**Signature**

```ts
export declare const zipWith: {
  <A2, E2, R2, A, B>(
    that: Effect<A2, E2, R2>,
    f: (a: A, b: A2) => B,
    options?: {
      readonly concurrent?: boolean | undefined
      readonly batching?: boolean | "inherit" | undefined
      readonly concurrentFinalizers?: boolean | undefined
    }
  ): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2, B>(
    self: Effect<A, E, R>,
    that: Effect<A2, E2, R2>,
    f: (a: A, b: A2) => B,
    options?: {
      readonly concurrent?: boolean | undefined
      readonly batching?: boolean | "inherit" | undefined
      readonly concurrentFinalizers?: boolean | undefined
    }
  ): Effect<B, E2 | E, R2 | R>
}
```


# Effectify

Converts a callback-based function to a function that returns an `Effect`.

To import and use `Effectify` from the "Effectify" module:

```ts
import * as Effectify from "@effect/platform/Effectify"
// Can be accessed like this
Effectify.Effectify
```


# all

Takes a structure of `Either`s and returns an `Either` of values with the same structure.

- If a tuple is supplied, then the returned `Either` will contain a tuple with the same length.
- If a struct is supplied, then the returned `Either` will contain a struct with the same keys.
- If an iterable is supplied, then the returned `Either` will contain an array.

To import and use `all` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.all
```

**Example**

```ts
import { Either } from "effect"

assert.deepStrictEqual(Either.all([Either.right(1), Either.right(2)]), Either.right([1, 2]))
assert.deepStrictEqual(
  Either.all({ right: Either.right(1), b: Either.right("hello") }),
  Either.right({ right: 1, b: "hello" })
)
assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.left("error") }), Either.left("error"))
```

**Signature**

```ts
export declare const all: <const I extends Iterable<Either<any, any>> | Record<string, Either<any, any>>>(
  input: I
) => [I] extends [ReadonlyArray<Either<any, any>>]
  ? Either<
      { -readonly [K in keyof I]: [I[K]] extends [Either<infer R, any>] ? R : never },
      I[number] extends never ? never : [I[number]] extends [Either<any, infer L>] ? L : never
    >
  : [I] extends [Iterable<Either<infer R, infer L>>]
    ? Either<Array<R>, L>
    : Either<
        { -readonly [K in keyof I]: [I[K]] extends [Either<infer R, any>] ? R : never },
        I[keyof I] extends never ? never : [I[keyof I]] extends [Either<any, infer L>] ? L : never
      >
```


# andThen

Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.

To import and use `andThen` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.andThen
```

**Signature**

```ts
export declare const andThen: {
  <R, R2, L2>(f: (right: R) => Either<R2, L2>): <L>(self: Either<R, L>) => Either<R2, L | L2>
  <R2, L2>(f: Either<R2, L2>): <L, R1>(self: Either<R1, L>) => Either<R2, L | L2>
  <R, R2>(f: (right: R) => R2): <L>(self: Either<R, L>) => Either<R2, L>
  <R2>(right: NotFunction<R2>): <R1, L>(self: Either<R1, L>) => Either<R2, L>
  <R, L, R2, L2>(self: Either<R, L>, f: (right: R) => Either<R2, L2>): Either<R2, L | L2>
  <R, L, R2, L2>(self: Either<R, L>, f: Either<R2, L2>): Either<R2, L | L2>
  <R, L, R2>(self: Either<R, L>, f: (right: R) => R2): Either<R2, L>
  <R, L, R2>(self: Either<R, L>, f: NotFunction<R2>): Either<R2, L>
}
```


# bind

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

To import and use `bind` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.bind
```

**Example**

```ts
import { Either, pipe } from "effect"

const result = pipe(
  Either.Do,
  Either.bind("x", () => Either.right(2)),
  Either.bind("y", () => Either.right(3)),
  Either.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))
```

**Signature**

```ts
export declare const bind: {
  <N extends string, A extends object, B, L2>(
    name: Exclude<N, keyof A>,
    f: (a: NoInfer<A>) => Either<B, L2>
  ): <L1>(self: Either<A, L1>) => Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, L1 | L2>
  <A extends object, L1, N extends string, B, L2>(
    self: Either<A, L1>,
    name: Exclude<N, keyof A>,
    f: (a: NoInfer<A>) => Either<B, L2>
  ): Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, L1 | L2>
}
```


# bindTo

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

To import and use `bindTo` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.bindTo
```

**Example**

```ts
import { Either, pipe } from "effect"

const result = pipe(
  Either.Do,
  Either.bind("x", () => Either.right(2)),
  Either.bind("y", () => Either.right(3)),
  Either.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))
```

**Signature**

```ts
export declare const bindTo: {
  <N extends string>(name: N): <R, L>(self: Either<R, L>) => Either<{ [K in N]: R }, L>
  <R, L, N extends string>(self: Either<R, L>, name: N): Either<{ [K in N]: R }, L>
}
```


# Do

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

To import and use `Do` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.Do
```

**Example**

```ts
import { Either, pipe } from "effect"

const result = pipe(
  Either.Do,
  Either.bind("x", () => Either.right(2)),
  Either.bind("y", () => Either.right(3)),
  Either.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))
```

**Signature**

```ts
export declare const Do: Either<{}, never>
```


# filterOrLeft

Filter the right value with the provided function.
If the predicate fails, set the left value with the result of the provided function.

To import and use `filterOrLeft` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.filterOrLeft
```

**Example**

```ts
import { pipe, Either } from "effect"

const isPositive = (n: number): boolean => n > 0

assert.deepStrictEqual(
  pipe(
    Either.right(1),
    Either.filterOrLeft(isPositive, (n) => `${n} is not positive`)
  ),
  Either.right(1)
)
assert.deepStrictEqual(
  pipe(
    Either.right(0),
    Either.filterOrLeft(isPositive, (n) => `${n} is not positive`)
  ),
  Either.left("0 is not positive")
)
```

**Signature**

```ts
export declare const filterOrLeft: {
  <R, B extends R, L2>(
    refinement: Refinement<NoInfer<R>, B>,
    orLeftWith: (right: NoInfer<R>) => L2
  ): <L>(self: Either<R, L>) => Either<B, L2 | L>
  <R, L2>(
    predicate: Predicate<NoInfer<R>>,
    orLeftWith: (right: NoInfer<R>) => L2
  ): <L>(self: Either<R, L>) => Either<R, L2 | L>
  <R, L, B extends R, L2>(
    self: Either<R, L>,
    refinement: Refinement<R, B>,
    orLeftWith: (right: R) => L2
  ): Either<B, L | L2>
  <R, L, E2>(self: Either<R, L>, predicate: Predicate<R>, orLeftWith: (right: R) => E2): Either<R, L | E2>
}
```


# flip

Returns an `Either` that swaps the error/success cases. This allows you to
use all methods on the error channel, possibly before flipping back.

To import and use `flip` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.flip
```

**Signature**

```ts
export declare const flip: <R, L>(self: Either<R, L>) => Either<L, R>
```


# fromNullable

Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use
the provided default as a `Left`.

To import and use `fromNullable` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.fromNullable
```

**Example**

```ts
import { Either } from "effect"

assert.deepStrictEqual(
  Either.fromNullable(1, () => "fallback"),
  Either.right(1)
)
assert.deepStrictEqual(
  Either.fromNullable(null, () => "fallback"),
  Either.left("fallback")
)
```

**Signature**

```ts
export declare const fromNullable: {
  <R, L>(onNullable: (right: R) => L): (self: R) => Either<NonNullable<R>, L>
  <R, L>(self: R, onNullable: (right: R) => L): Either<NonNullable<R>, L>
}
```


# getLeft

Converts a `Either` to an `Option` discarding the value.

To import and use `getLeft` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.getLeft
```

**Example**

```ts
import { Either, Option } from "effect"

assert.deepStrictEqual(Either.getLeft(Either.right("ok")), Option.none())
assert.deepStrictEqual(Either.getLeft(Either.left("err")), Option.some("err"))
```

**Signature**

```ts
export declare const getLeft: <R, L>(self: Either<R, L>) => Option<L>
```


# getOrElse

Returns the wrapped value if it's a `Right` or a default value if is a `Left`.

To import and use `getOrElse` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.getOrElse
```

**Example**

```ts
import { Either } from "effect"

assert.deepStrictEqual(
  Either.getOrElse(Either.right(1), (error) => error + "!"),
  1
)
assert.deepStrictEqual(
  Either.getOrElse(Either.left("not a number"), (error) => error + "!"),
  "not a number!"
)
```

**Signature**

```ts
export declare const getOrElse: {
  <L, R2>(onLeft: (left: L) => R2): <R>(self: Either<R, L>) => R2 | R
  <R, L, R2>(self: Either<R, L>, onLeft: (left: L) => R2): R | R2
}
```


# getOrThrow

Extracts the value of an `Either` or throws if the `Either` is `Left`.

The thrown error is a default error. To configure the error thrown, see {@link getOrThrowWith}.

To import and use `getOrThrow` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.getOrThrow
```

**Example**

```ts
import { Either } from "effect"

assert.deepStrictEqual(Either.getOrThrow(Either.right(1)), 1)
assert.throws(() => Either.getOrThrow(Either.left("error")))
```

**Signature**

```ts
export declare const getOrThrow: <R, L>(self: Either<R, L>) => R
```


# getOrThrowWith

Extracts the value of an `Either` or throws if the `Either` is `Left`.

If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.

To import and use `getOrThrowWith` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.getOrThrowWith
```

**Example**

```ts
import { Either } from "effect"

assert.deepStrictEqual(
  Either.getOrThrowWith(Either.right(1), () => new Error("Unexpected Left")),
  1
)
assert.throws(() => Either.getOrThrowWith(Either.left("error"), () => new Error("Unexpected Left")))
```

**Signature**

```ts
export declare const getOrThrowWith: {
  <L>(onLeft: (left: L) => unknown): <A>(self: Either<A, L>) => A
  <R, L>(self: Either<R, L>, onLeft: (left: L) => unknown): R
}
```


# getRight

Converts a `Either` to an `Option` discarding the `Left`.

To import and use `getRight` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.getRight
```

**Example**

```ts
import { Either, Option } from "effect"

assert.deepStrictEqual(Either.getRight(Either.right("ok")), Option.some("ok"))
assert.deepStrictEqual(Either.getRight(Either.left("err")), Option.none())
```

**Signature**

```ts
export declare const getRight: <R, L>(self: Either<R, L>) => Option<R>
```


# isEither

Tests if a value is a `Either`.

To import and use `isEither` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.isEither
```

**Example**

```ts
import { Either } from "effect"

assert.deepStrictEqual(Either.isEither(Either.right(1)), true)
assert.deepStrictEqual(Either.isEither(Either.left("a")), true)
assert.deepStrictEqual(Either.isEither({ right: 1 }), false)
```

**Signature**

```ts
export declare const isEither: (input: unknown) => input is Either<unknown, unknown>
```


# isLeft

Determine if a `Either` is a `Left`.

To import and use `isLeft` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.isLeft
```

**Example**

```ts
import { Either } from "effect"

assert.deepStrictEqual(Either.isLeft(Either.right(1)), false)
assert.deepStrictEqual(Either.isLeft(Either.left("a")), true)
```

**Signature**

```ts
export declare const isLeft: <R, L>(self: Either<R, L>) => self is Left<L, R>
```


# isRight

Determine if a `Either` is a `Right`.

To import and use `isRight` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.isRight
```

**Example**

```ts
import { Either } from "effect"

assert.deepStrictEqual(Either.isRight(Either.right(1)), true)
assert.deepStrictEqual(Either.isRight(Either.left("a")), false)
```

**Signature**

```ts
export declare const isRight: <R, L>(self: Either<R, L>) => self is Right<L, R>
```


# left

Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this
structure.

To import and use `left` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.left
```

**Signature**

```ts
export declare const left: <L>(left: L) => Either<never, L>
```


# let

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

To import and use `let` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.let
```

**Example**

```ts
import { Either, pipe } from "effect"

const result = pipe(
  Either.Do,
  Either.bind("x", () => Either.right(2)),
  Either.bind("y", () => Either.right(3)),
  Either.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))
```


# liftPredicate

Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`
or `Left` of the result of the provided function if the predicate returns false

To import and use `liftPredicate` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.liftPredicate
```

**Example**

```ts
import { pipe, Either } from "effect"

const isPositive = (n: number): boolean => n > 0

assert.deepStrictEqual(
  pipe(
    1,
    Either.liftPredicate(isPositive, (n) => `${n} is not positive`)
  ),
  Either.right(1)
)
assert.deepStrictEqual(
  pipe(
    0,
    Either.liftPredicate(isPositive, (n) => `${n} is not positive`)
  ),
  Either.left("0 is not positive")
)
```

**Signature**

```ts
export declare const liftPredicate: {
  <A, B extends A, E>(refinement: Refinement<NoInfer<A>, B>, orLeftWith: (a: NoInfer<A>) => E): (a: A) => Either<B, E>
  <A, E>(predicate: Predicate<NoInfer<A>>, orLeftWith: (a: NoInfer<A>) => E): (a: A) => Either<A, E>
  <A, E, B extends A>(self: A, refinement: Refinement<A, B>, orLeftWith: (a: A) => E): Either<B, E>
  <A, E>(self: A, predicate: Predicate<NoInfer<A>>, orLeftWith: (a: NoInfer<A>) => E): Either<A, E>
}
```


# map

Maps the `Right` side of an `Either` value to a new `Either` value.

To import and use `map` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.map
```

**Signature**

```ts
export declare const map: {
  <R, R2>(f: (right: R) => R2): <L>(self: Either<R, L>) => Either<R2, L>
  <R, L, R2>(self: Either<R, L>, f: (right: R) => R2): Either<R2, L>
}
```


# mapLeft

Maps the `Left` side of an `Either` value to a new `Either` value.

To import and use `mapLeft` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.mapLeft
```

**Signature**

```ts
export declare const mapLeft: {
  <L, L2>(f: (left: L) => L2): <R>(self: Either<R, L>) => Either<R, L2>
  <R, L, L2>(self: Either<R, L>, f: (left: L) => L2): Either<R, L2>
}
```


# match

Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,
if the value is a `Right`the inner value is applied to the`onRight` function.

To import and use `match` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.match
```

**Example**

```ts
import { pipe, Either } from "effect"

const onLeft = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(", ")}`

const onRight = (value: number): string => `Ok: ${value}`

assert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), "Ok: 1")
assert.deepStrictEqual(
  pipe(Either.left(["string 1", "string 2"]), Either.match({ onLeft, onRight })),
  "strings: string 1, string 2"
)
```

**Signature**

```ts
export declare const match: {
  <L, B, R, C = B>(options: {
    readonly onLeft: (left: L) => B
    readonly onRight: (right: R) => C
  }): (self: Either<R, L>) => B | C
  <R, L, B, C = B>(
    self: Either<R, L>,
    options: { readonly onLeft: (left: L) => B; readonly onRight: (right: R) => C }
  ): B | C
}
```


# orElse

Returns `self` if it is a `Right` or `that` otherwise.

To import and use `orElse` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.orElse
```

**Signature**

```ts
export declare const orElse: {
  <L, R2, L2>(that: (left: L) => Either<R2, L2>): <R>(self: Either<R, L>) => Either<R | R2, L2>
  <R, L, R2, L2>(self: Either<R, L>, that: (left: L) => Either<R2, L2>): Either<R | R2, L2>
}
```


# right

Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias
of this structure.

To import and use `right` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.right
```

**Signature**

```ts
export declare const right: <R>(right: R) => Either<R>
```


# try

Imports a synchronous side-effect into a pure `Either` value, translating any
thrown exceptions into typed failed eithers creating with `Either.left`.

To import and use `try` from the "Either" module:

```ts
import * as Either from "effect/Either"
// Can be accessed like this
Either.try
```


# decodeBase64

Decodes a base64 (RFC4648) encoded `string` into a `Uint8Array`.

To import and use `decodeBase64` from the "Encoding" module:

```ts
import * as Encoding from "effect/Encoding"
// Can be accessed like this
Encoding.decodeBase64
```

**Signature**

```ts
export declare const decodeBase64: (str: string) => Either.Either<Uint8Array, DecodeException>
```


# decodeBase64String

Decodes a base64 (RFC4648) encoded `string` into a UTF-8 `string`.

To import and use `decodeBase64String` from the "Encoding" module:

```ts
import * as Encoding from "effect/Encoding"
// Can be accessed like this
Encoding.decodeBase64String
```

**Signature**

```ts
export declare const decodeBase64String: (str: string) => Either.Either<string, DecodeException>
```


# decodeBase64Url

Decodes a base64 (URL) encoded `string` into a `Uint8Array`.

To import and use `decodeBase64Url` from the "Encoding" module:

```ts
import * as Encoding from "effect/Encoding"
// Can be accessed like this
Encoding.decodeBase64Url
```

**Signature**

```ts
export declare const decodeBase64Url: (str: string) => Either.Either<Uint8Array, DecodeException>
```


# decodeBase64UrlString

Decodes a base64 (URL) encoded `string` into a UTF-8 `string`.

To import and use `decodeBase64UrlString` from the "Encoding" module:

```ts
import * as Encoding from "effect/Encoding"
// Can be accessed like this
Encoding.decodeBase64UrlString
```

**Signature**

```ts
export declare const decodeBase64UrlString: (str: string) => Either.Either<string, DecodeException>
```


# DecodeException

Represents a checked exception which occurs when decoding fails.

To import and use `DecodeException` from the "Encoding" module:

```ts
import * as Encoding from "effect/Encoding"
// Can be accessed like this
Encoding.DecodeException
```


# decodeHex

Decodes a hex encoded `string` into a `Uint8Array`.

To import and use `decodeHex` from the "Encoding" module:

```ts
import * as Encoding from "effect/Encoding"
// Can be accessed like this
Encoding.decodeHex
```

**Signature**

```ts
export declare const decodeHex: (str: string) => Either.Either<Uint8Array, DecodeException>
```


# decodeHexString

Decodes a hex encoded `string` into a UTF-8 `string`.

To import and use `decodeHexString` from the "Encoding" module:

```ts
import * as Encoding from "effect/Encoding"
// Can be accessed like this
Encoding.decodeHexString
```

**Signature**

```ts
export declare const decodeHexString: (str: string) => Either.Either<string, DecodeException>
```


# decodeUriComponent

Decodes a URI component `string` into a UTF-8 `string`.

To import and use `decodeUriComponent` from the "Encoding" module:

```ts
import * as Encoding from "effect/Encoding"
// Can be accessed like this
Encoding.decodeUriComponent
```

**Signature**

```ts
export declare const decodeUriComponent: (str: string) => Either.Either<string, DecodeException>
```


# encodeBase64

Encodes the given value into a base64 (RFC4648) `string`.

To import and use `encodeBase64` from the "Encoding" module:

```ts
import * as Encoding from "effect/Encoding"
// Can be accessed like this
Encoding.encodeBase64
```

**Signature**

```ts
export declare const encodeBase64: (input: Uint8Array | string) => string
```


# encodeBase64Url

Encodes the given value into a base64 (URL) `string`.

To import and use `encodeBase64Url` from the "Encoding" module:

```ts
import * as Encoding from "effect/Encoding"
// Can be accessed like this
Encoding.encodeBase64Url
```

**Signature**

```ts
export declare const encodeBase64Url: (input: Uint8Array | string) => string
```


# EncodeException

Represents a checked exception which occurs when encoding fails.

To import and use `EncodeException` from the "Encoding" module:

```ts
import * as Encoding from "effect/Encoding"
// Can be accessed like this
Encoding.EncodeException
```


# encodeHex

Encodes the given value into a hex `string`.

To import and use `encodeHex` from the "Encoding" module:

```ts
import * as Encoding from "effect/Encoding"
// Can be accessed like this
Encoding.encodeHex
```

**Signature**

```ts
export declare const encodeHex: (input: Uint8Array | string) => string
```


# encodeUriComponent

Encodes a UTF-8 `string` into a URI component `string`.

To import and use `encodeUriComponent` from the "Encoding" module:

```ts
import * as Encoding from "effect/Encoding"
// Can be accessed like this
Encoding.encodeUriComponent
```

**Signature**

```ts
export declare const encodeUriComponent: (str: string) => Either.Either<string, EncodeException>
```


# isDecodeException

Returns `true` if the specified value is an `DecodeException`, `false` otherwise.

To import and use `isDecodeException` from the "Encoding" module:

```ts
import * as Encoding from "effect/Encoding"
// Can be accessed like this
Encoding.isDecodeException
```

**Signature**

```ts
export declare const isDecodeException: (u: unknown) => u is DecodeException
```


# isEncodeException

Returns `true` if the specified value is an `Exception`, `false` otherwise.

To import and use `isEncodeException` from the "Encoding" module:

```ts
import * as Encoding from "effect/Encoding"
// Can be accessed like this
Encoding.isEncodeException
```

**Signature**

```ts
export declare const isEncodeException: (u: unknown) => u is EncodeException
```


# array

Creates a new `Equivalence` for an array of values based on a given `Equivalence` for the elements of the array.

To import and use `array` from the "Equivalence" module:

```ts
import * as Equivalence from "effect/Equivalence"
// Can be accessed like this
Equivalence.array
```

**Signature**

```ts
export declare const array: <A>(item: Equivalence<A>) => Equivalence<ReadonlyArray<A>>
```


# strict

Return an `Equivalence` that uses strict equality (===) to compare values.

To import and use `strict` from the "Equivalence" module:

```ts
import * as Equivalence from "effect/Equivalence"
// Can be accessed like this
Equivalence.strict
```

**Signature**

```ts
export declare const strict: <A>() => Equivalence<A>
```


# struct

Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct
by applying each `Equivalence` to the corresponding property of the struct.

To import and use `struct` from the "Equivalence" module:

```ts
import * as Equivalence from "effect/Equivalence"
// Can be accessed like this
Equivalence.struct
```

**Signature**

```ts
export declare const struct: <R extends Record<string, Equivalence<any>>>(
  fields: R
) => Equivalence<{ readonly [K in keyof R]: [R[K]] extends [Equivalence<infer A>] ? A : never }>
```


# tuple

Similar to `Promise.all` but operates on `Equivalence`s.

```
[Equivalence<A>, Equivalence<B>, ...] -> Equivalence<[A, B, ...]>
```

Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple
by applying each `Equivalence` to the corresponding element of the tuple.

To import and use `tuple` from the "Equivalence" module:

```ts
import * as Equivalence from "effect/Equivalence"
// Can be accessed like this
Equivalence.tuple
```

**Signature**

```ts
export declare const tuple: <T extends ReadonlyArray<Equivalence<any>>>(
  ...elements: T
) => Equivalence<Readonly<{ [I in keyof T]: [T[I]] extends [Equivalence<infer A>] ? A : never }>>
```


# Event

Represents an event in an EventLog.

To import and use `Event` from the "Event" module:

```ts
import * as Event from "@effect/experimental/Event"
// Can be accessed like this
Event.Event
```


# empty

An `EventGroup` is a collection of `Event`s. You can use an `EventGroup` to
represent a portion of your domain.

The events can be implemented later using the `EventLog.group` api.

To import and use `empty` from the "EventGroup" module:

```ts
import * as EventGroup from "@effect/experimental/EventGroup"
// Can be accessed like this
EventGroup.empty
```

**Signature**

```ts
export declare const empty: EventGroup<never>
```


# EventGroup

An `EventGroup` is a collection of `Event`s. You can use an `EventGroup` to
represent a portion of your domain.

The events can be implemented later using the `EventLogBuilder.group` api.

To import and use `EventGroup` from the "EventGroup" module:

```ts
import * as EventGroup from "@effect/experimental/EventGroup"
// Can be accessed like this
EventGroup.EventGroup
```


# Handlers

Represents a handled `EventGroup`.

To import and use `Handlers` from the "EventLog" module:

```ts
import * as EventLog from "@effect/experimental/EventLog"
// Can be accessed like this
EventLog.Handlers
```


# ExecutionStrategy

Describes a strategy for evaluating multiple effects, potentially in
parallel.

There are 3 possible execution strategies: `Sequential`, `Parallel`,
`ParallelN`.

To import and use `ExecutionStrategy` from the "ExecutionStrategy" module:

```ts
import * as ExecutionStrategy from "effect/ExecutionStrategy"
// Can be accessed like this
ExecutionStrategy.ExecutionStrategy
```


# isParallel

Returns `true` if the specified `ExecutionStrategy` is an instance of
`Sequential`, `false` otherwise.

To import and use `isParallel` from the "ExecutionStrategy" module:

```ts
import * as ExecutionStrategy from "effect/ExecutionStrategy"
// Can be accessed like this
ExecutionStrategy.isParallel
```

**Signature**

```ts
export declare const isParallel: (self: ExecutionStrategy) => self is Parallel
```


# isParallelN

Returns `true` if the specified `ExecutionStrategy` is an instance of
`Sequential`, `false` otherwise.

To import and use `isParallelN` from the "ExecutionStrategy" module:

```ts
import * as ExecutionStrategy from "effect/ExecutionStrategy"
// Can be accessed like this
ExecutionStrategy.isParallelN
```

**Signature**

```ts
export declare const isParallelN: (self: ExecutionStrategy) => self is ParallelN
```


# isSequential

Returns `true` if the specified `ExecutionStrategy` is an instance of
`Sequential`, `false` otherwise.

To import and use `isSequential` from the "ExecutionStrategy" module:

```ts
import * as ExecutionStrategy from "effect/ExecutionStrategy"
// Can be accessed like this
ExecutionStrategy.isSequential
```

**Signature**

```ts
export declare const isSequential: (self: ExecutionStrategy) => self is Sequential
```


# match

Folds over the specified `ExecutionStrategy` using the provided case
functions.

To import and use `match` from the "ExecutionStrategy" module:

```ts
import * as ExecutionStrategy from "effect/ExecutionStrategy"
// Can be accessed like this
ExecutionStrategy.match
```

**Signature**

```ts
export declare const match: {
  <A>(options: {
    readonly onSequential: LazyArg<A>
    readonly onParallel: LazyArg<A>
    readonly onParallelN: (n: number) => A
  }): (self: ExecutionStrategy) => A
  <A>(
    self: ExecutionStrategy,
    options: {
      readonly onSequential: LazyArg<A>
      readonly onParallel: LazyArg<A>
      readonly onParallelN: (n: number) => A
    }
  ): A
}
```


# parallel

Execute effects in parallel.

To import and use `parallel` from the "ExecutionStrategy" module:

```ts
import * as ExecutionStrategy from "effect/ExecutionStrategy"
// Can be accessed like this
ExecutionStrategy.parallel
```

**Signature**

```ts
export declare const parallel: ExecutionStrategy
```


# Parallel

Execute effects in parallel.

To import and use `Parallel` from the "ExecutionStrategy" module:

```ts
import * as ExecutionStrategy from "effect/ExecutionStrategy"
// Can be accessed like this
ExecutionStrategy.Parallel
```


# parallelN

Execute effects in parallel, up to the specified number of concurrent fibers.

To import and use `parallelN` from the "ExecutionStrategy" module:

```ts
import * as ExecutionStrategy from "effect/ExecutionStrategy"
// Can be accessed like this
ExecutionStrategy.parallelN
```

**Signature**

```ts
export declare const parallelN: (parallelism: number) => ExecutionStrategy
```


# ParallelN

Execute effects in parallel, up to the specified number of concurrent fibers.

To import and use `ParallelN` from the "ExecutionStrategy" module:

```ts
import * as ExecutionStrategy from "effect/ExecutionStrategy"
// Can be accessed like this
ExecutionStrategy.ParallelN
```


# sequential

Execute effects sequentially.

To import and use `sequential` from the "ExecutionStrategy" module:

```ts
import * as ExecutionStrategy from "effect/ExecutionStrategy"
// Can be accessed like this
ExecutionStrategy.sequential
```

**Signature**

```ts
export declare const sequential: ExecutionStrategy
```


# Sequential

Execute effects sequentially.

To import and use `Sequential` from the "ExecutionStrategy" module:

```ts
import * as ExecutionStrategy from "effect/ExecutionStrategy"
// Can be accessed like this
ExecutionStrategy.Sequential
```


# all

Collects all of the specified exit values into a `Some<Exit<List<A>, E>>`. If
the provided iterable contains no elements, `None` will be returned.

To import and use `all` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.all
```

**Signature**

```ts
export declare const all: <A, E>(
  exits: Iterable<Exit<A, E>>,
  options?: { readonly parallel?: boolean | undefined } | undefined
) => Option.Option<Exit<Array<A>, E>>
```


# as

Maps the `Success` value of the specified exit to the provided constant
value.

To import and use `as` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.as
```

**Signature**

```ts
export declare const as: {
  <A2>(value: A2): <A, E>(self: Exit<A, E>) => Exit<A2, E>
  <A, E, A2>(self: Exit<A, E>, value: A2): Exit<A2, E>
}
```


# asVoid

Maps the `Success` value of the specified exit to a void.

To import and use `asVoid` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.asVoid
```

**Signature**

```ts
export declare const asVoid: <A, E>(self: Exit<A, E>) => Exit<void, E>
```


# causeOption

Returns a `Some<Cause<E>>` if the specified exit is a `Failure`, `None`
otherwise.

To import and use `causeOption` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.causeOption
```

**Signature**

```ts
export declare const causeOption: <A, E>(self: Exit<A, E>) => Option.Option<Cause.Cause<E>>
```


# die

Constructs a new `Exit.Failure` from the specified unrecoverable defect.

To import and use `die` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.die
```

**Signature**

```ts
export declare const die: (defect: unknown) => Exit<never>
```


# exists

Executes the predicate on the value of the specified exit if it is a
`Success`, otherwise returns `false`.

To import and use `exists` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.exists
```

**Signature**

```ts
export declare const exists: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E>(self: Exit<A, E>) => self is Exit<B>
  <A>(predicate: Predicate<NoInfer<A>>): <E>(self: Exit<A, E>) => boolean
  <A, E, B extends A>(self: Exit<A, E>, refinement: Refinement<A, B>): self is Exit<B>
  <A, E>(self: Exit<A, E>, predicate: Predicate<A>): boolean
}
```


# Exit

An `Exit<A, E = never>` describes the result of a executing an `Effect` workflow.

There are two possible values for an `Exit<A, E>`:

- `Exit.Success` contain a success value of type `A`
- `Exit.Failure` contains a failure `Cause` of type `E`

To import and use `Exit` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.Exit
```


# fail

Constructs a new `Exit.Failure` from the specified recoverable error of type
`E`.

To import and use `fail` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.fail
```

**Signature**

```ts
export declare const fail: <E>(error: E) => Exit<never, E>
```


# failCause

Constructs a new `Exit.Failure` from the specified `Cause` of type `E`.

To import and use `failCause` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.failCause
```

**Signature**

```ts
export declare const failCause: <E>(cause: Cause.Cause<E>) => Exit<never, E>
```


# Failure

Represents a failed `Effect` workflow containing the `Cause` of the failure
of type `E`.

To import and use `Failure` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.Failure
```


# fromEither

Converts an `Either<R, L>` into an `Exit<R, L>`.

To import and use `fromEither` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.fromEither
```

**Signature**

```ts
export declare const fromEither: <R, L>(either: Either.Either<R, L>) => Exit<R, L>
```


# fromOption

Converts an `Option<A>` into an `Exit<void, A>`.

To import and use `fromOption` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.fromOption
```

**Signature**

```ts
export declare const fromOption: <A>(option: Option.Option<A>) => Exit<A, void>
```


# getOrElse

Returns the `A` if specified exit is a `Success`, otherwise returns the
alternate `A` value computed from the specified function which receives the
`Cause<E>` of the exit `Failure`.

To import and use `getOrElse` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.getOrElse
```

**Signature**

```ts
export declare const getOrElse: {
  <E, A2>(orElse: (cause: Cause.Cause<E>) => A2): <A>(self: Exit<A, E>) => A2 | A
  <A, E, A2>(self: Exit<A, E>, orElse: (cause: Cause.Cause<E>) => A2): A | A2
}
```


# interrupt

Constructs a new `Exit.Failure` from the specified `FiberId` indicating that
the `Fiber` running an `Effect` workflow was terminated due to interruption.

To import and use `interrupt` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.interrupt
```

**Signature**

```ts
export declare const interrupt: (fiberId: FiberId.FiberId) => Exit<never>
```


# isExit

Returns `true` if the specified value is an `Exit`, `false` otherwise.

To import and use `isExit` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.isExit
```

**Signature**

```ts
export declare const isExit: (u: unknown) => u is Exit<unknown, unknown>
```


# isFailure

Returns `true` if the specified `Exit` is a `Failure`, `false` otherwise.

To import and use `isFailure` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.isFailure
```

**Signature**

```ts
export declare const isFailure: <A, E>(self: Exit<A, E>) => self is Failure<A, E>
```


# isInterrupted

Returns `true` if the specified exit is a `Failure` **and** the `Cause` of
the failure was due to interruption, `false` otherwise.

To import and use `isInterrupted` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.isInterrupted
```

**Signature**

```ts
export declare const isInterrupted: <A, E>(self: Exit<A, E>) => boolean
```


# isSuccess

Returns `true` if the specified `Exit` is a `Success`, `false` otherwise.

To import and use `isSuccess` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.isSuccess
```

**Signature**

```ts
export declare const isSuccess: <A, E>(self: Exit<A, E>) => self is Success<A, E>
```


# map

Maps over the `Success` value of the specified exit using the provided
function.

To import and use `map` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.map
```

**Signature**

```ts
export declare const map: {
  <A, B>(f: (a: A) => B): <E>(self: Exit<A, E>) => Exit<B, E>
  <A, E, B>(self: Exit<A, E>, f: (a: A) => B): Exit<B, E>
}
```


# mapBoth

Maps over the `Success` and `Failure` cases of the specified exit using the
provided functions.

To import and use `mapBoth` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.mapBoth
```

**Signature**

```ts
export declare const mapBoth: {
  <E, A, E2, A2>(options: {
    readonly onFailure: (e: E) => E2
    readonly onSuccess: (a: A) => A2
  }): (self: Exit<A, E>) => Exit<A2, E2>
  <A, E, E2, A2>(
    self: Exit<A, E>,
    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }
  ): Exit<A2, E2>
}
```


# mapError

Maps over the error contained in the `Failure` of the specified exit using
the provided function.

To import and use `mapError` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.mapError
```

**Signature**

```ts
export declare const mapError: {
  <E, E2>(f: (e: E) => E2): <A>(self: Exit<A, E>) => Exit<A, E2>
  <A, E, E2>(self: Exit<A, E>, f: (e: E) => E2): Exit<A, E2>
}
```


# mapErrorCause

Maps over the `Cause` contained in the `Failure` of the specified exit using
the provided function.

To import and use `mapErrorCause` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.mapErrorCause
```

**Signature**

```ts
export declare const mapErrorCause: {
  <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A>(self: Exit<A, E>) => Exit<A, E2>
  <E, A, E2>(self: Exit<A, E>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Exit<A, E2>
}
```


# succeed

Constructs a new `Exit.Success` containing the specified value of type `A`.

To import and use `succeed` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.succeed
```

**Signature**

```ts
export declare const succeed: <A>(value: A) => Exit<A>
```


# Success

Represents a successful `Effect` workflow and containing the returned value
of type `A`.

To import and use `Success` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.Success
```


# void

Represents an `Exit` which succeeds with `undefined`.

To import and use `void` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.void
```


# zip

Sequentially zips the this result with the specified result or else returns
the failed `Cause<E | E2>`.

To import and use `zip` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.zip
```

**Signature**

```ts
export declare const zip: {
  <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<[A, A2], E2 | E>
  <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<[A, A2], E | E2>
}
```


# zipLeft

Sequentially zips the this result with the specified result discarding the
second element of the tuple or else returns the failed `Cause<E | E2>`.

To import and use `zipLeft` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.zipLeft
```

**Signature**

```ts
export declare const zipLeft: {
  <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A, E2 | E>
  <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A, E | E2>
}
```


# zipPar

Parallelly zips the this result with the specified result or else returns
the failed `Cause<E | E2>`.

To import and use `zipPar` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.zipPar
```

**Signature**

```ts
export declare const zipPar: {
  <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<[A, A2], E2 | E>
  <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<[A, A2], E | E2>
}
```


# zipParLeft

Parallelly zips the this result with the specified result discarding the
second element of the tuple or else returns the failed `Cause<E | E2>`.

To import and use `zipParLeft` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.zipParLeft
```

**Signature**

```ts
export declare const zipParLeft: {
  <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A, E2 | E>
  <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A, E | E2>
}
```


# zipParRight

Parallelly zips the this result with the specified result discarding the
first element of the tuple or else returns the failed `Cause<E | E2>`.

To import and use `zipParRight` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.zipParRight
```

**Signature**

```ts
export declare const zipParRight: {
  <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A2, E2 | E>
  <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A2, E | E2>
}
```


# zipRight

Sequentially zips the this result with the specified result discarding the
first element of the tuple or else returns the failed `Cause<E | E2>`.

To import and use `zipRight` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.zipRight
```

**Signature**

```ts
export declare const zipRight: {
  <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A2, E2 | E>
  <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A2, E | E2>
}
```


# zipWith

Zips this exit together with that exit using the specified combination
functions.

To import and use `zipWith` from the "Exit" module:

```ts
import * as Exit from "effect/Exit"
// Can be accessed like this
Exit.zipWith
```

**Signature**

```ts
export declare const zipWith: {
  <B, E2, A, C, E>(
    that: Exit<B, E2>,
    options: {
      readonly onSuccess: (a: A, b: B) => C
      readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<any>
    }
  ): (self: Exit<A, E>) => Exit<C, any>
  <A, E, B, E2, C>(
    self: Exit<A, E>,
    that: Exit<B, E2>,
    options: {
      readonly onSuccess: (a: A, b: B) => C
      readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<E | E2>
    }
  ): Exit<C, E | E2>
}
```


# all

Collects all fibers into a single fiber producing an in-order list of the
results.

To import and use `all` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.all
```

**Signature**

```ts
export declare const all: <A, E>(fibers: Iterable<Fiber<A, E>>) => Fiber<ReadonlyArray<A>, E>
```


# await

Awaits the fiber, which suspends the awaiting fiber until the result of the
fiber has been determined.

To import and use `await` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.await
```


# awaitAll

Awaits on all fibers to be completed, successfully or not.

To import and use `awaitAll` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.awaitAll
```

**Signature**

```ts
export declare const awaitAll: <const T extends Iterable<Fiber<any, any>>>(
  fibers: T
) => Effect.Effect<
  [T] extends [ReadonlyArray<infer U>]
    ? number extends T["length"]
      ? Array<U extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never>
      : { -readonly [K in keyof T]: T[K] extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never }
    : Array<T extends Iterable<infer U> ? (U extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never) : never>
>
```


# children

Retrieves the immediate children of the fiber.

To import and use `children` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.children
```

**Signature**

```ts
export declare const children: <A, E>(self: Fiber<A, E>) => Effect.Effect<Array<RuntimeFiber<any, any>>>
```


# done

A fiber that is done with the specified `Exit` value.

To import and use `done` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.done
```

**Signature**

```ts
export declare const done: <A, E>(exit: Exit.Exit<A, E>) => Fiber<A, E>
```


# fail

A fiber that has already failed with the specified value.

To import and use `fail` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.fail
```

**Signature**

```ts
export declare const fail: <E>(error: E) => Fiber<never, E>
```


# failCause

Creates a `Fiber` that has already failed with the specified cause.

To import and use `failCause` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.failCause
```

**Signature**

```ts
export declare const failCause: <E>(cause: Cause.Cause<E>) => Fiber<never, E>
```


# Fiber

A fiber is a lightweight thread of execution that never consumes more than a
whole thread (but may consume much less, depending on contention and
asynchronicity). Fibers are spawned by forking effects, which run
concurrently with the parent effect.

Fibers can be joined, yielding their result to other fibers, or interrupted,
which terminates the fiber, safely releasing all resources.

To import and use `Fiber` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.Fiber
```


# fromEffect

Lifts an `Effect` into a `Fiber`.

To import and use `fromEffect` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.fromEffect
```

**Signature**

```ts
export declare const fromEffect: <A, E>(effect: Effect.Effect<A, E>) => Effect.Effect<Fiber<A, E>>
```


# getCurrentFiber

Gets the current fiber if one is running.

To import and use `getCurrentFiber` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.getCurrentFiber
```

**Signature**

```ts
export declare const getCurrentFiber: () => Option.Option<RuntimeFiber<any, any>>
```


# id

The identity of the fiber.

To import and use `id` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.id
```

**Signature**

```ts
export declare const id: <A, E>(self: Fiber<A, E>) => FiberId.FiberId
```


# inheritAll

Inherits values from all `FiberRef` instances into current fiber. This
will resume immediately.

To import and use `inheritAll` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.inheritAll
```

**Signature**

```ts
export declare const inheritAll: <A, E>(self: Fiber<A, E>) => Effect.Effect<void>
```


# interrupt

Interrupts the fiber from whichever fiber is calling this method. If the
fiber has already exited, the returned effect will resume immediately.
Otherwise, the effect will resume when the fiber exits.

To import and use `interrupt` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.interrupt
```

**Signature**

```ts
export declare const interrupt: <A, E>(self: Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>
```


# interruptAll

Interrupts all fibers, awaiting their interruption.

To import and use `interruptAll` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.interruptAll
```

**Signature**

```ts
export declare const interruptAll: (fibers: Iterable<Fiber<any, any>>) => Effect.Effect<void>
```


# interruptAllAs

Interrupts all fibers as by the specified fiber, awaiting their
interruption.

To import and use `interruptAllAs` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.interruptAllAs
```

**Signature**

```ts
export declare const interruptAllAs: {
  (fiberId: FiberId.FiberId): (fibers: Iterable<Fiber<any, any>>) => Effect.Effect<void>
  (fibers: Iterable<Fiber<any, any>>, fiberId: FiberId.FiberId): Effect.Effect<void>
}
```


# interruptAs

Interrupts the fiber as if interrupted from the specified fiber. If the
fiber has already exited, the returned effect will resume immediately.
Otherwise, the effect will resume when the fiber exits.

To import and use `interruptAs` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.interruptAs
```

**Signature**

```ts
export declare const interruptAs: {
  (fiberId: FiberId.FiberId): <A, E>(self: Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>
  <A, E>(self: Fiber<A, E>, fiberId: FiberId.FiberId): Effect.Effect<Exit.Exit<A, E>>
}
```


# interruptAsFork

Interrupts the fiber as if interrupted from the specified fiber. If the
fiber has already exited, the returned effect will resume immediately.
Otherwise, the effect will resume when the fiber exits.

To import and use `interruptAsFork` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.interruptAsFork
```

**Signature**

```ts
export declare const interruptAsFork: {
  (fiberId: FiberId.FiberId): <A, E>(self: Fiber<A, E>) => Effect.Effect<void>
  <A, E>(self: Fiber<A, E>, fiberId: FiberId.FiberId): Effect.Effect<void>
}
```


# interrupted

Constructrs a `Fiber` that is already interrupted.

To import and use `interrupted` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.interrupted
```

**Signature**

```ts
export declare const interrupted: (fiberId: FiberId.FiberId) => Fiber<never>
```


# interruptFork

Interrupts the fiber from whichever fiber is calling this method. The
interruption will happen in a separate daemon fiber, and the returned
effect will always resume immediately without waiting.

To import and use `interruptFork` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.interruptFork
```

**Signature**

```ts
export declare const interruptFork: <A, E>(self: Fiber<A, E>) => Effect.Effect<void>
```


# isFiber

Returns `true` if the specified value is a `Fiber`, `false` otherwise.

To import and use `isFiber` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.isFiber
```

**Signature**

```ts
export declare const isFiber: (u: unknown) => u is Fiber<unknown, unknown>
```


# isRuntimeFiber

Returns `true` if the specified `Fiber` is a `RuntimeFiber`, `false`
otherwise.

To import and use `isRuntimeFiber` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.isRuntimeFiber
```

**Signature**

```ts
export declare const isRuntimeFiber: <A, E>(self: Fiber<A, E>) => self is RuntimeFiber<A, E>
```


# join

Joins the fiber, which suspends the joining fiber until the result of the
fiber has been determined. Attempting to join a fiber that has erred will
result in a catchable error. Joining an interrupted fiber will result in an
"inner interruption" of this fiber, unlike interruption triggered by
another fiber, "inner interruption" can be caught and recovered.

To import and use `join` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.join
```

**Signature**

```ts
export declare const join: <A, E>(self: Fiber<A, E>) => Effect.Effect<A, E>
```


# joinAll

Joins all fibers, awaiting their _successful_ completion. Attempting to
join a fiber that has erred will result in a catchable error, _if_ that
error does not result from interruption.

To import and use `joinAll` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.joinAll
```

**Signature**

```ts
export declare const joinAll: <A, E>(fibers: Iterable<Fiber<A, E>>) => Effect.Effect<Array<A>, E>
```


# map

Maps over the value the Fiber computes.

To import and use `map` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.map
```

**Signature**

```ts
export declare const map: {
  <A, B>(f: (a: A) => B): <E>(self: Fiber<A, E>) => Fiber<B, E>
  <A, E, B>(self: Fiber<A, E>, f: (a: A) => B): Fiber<B, E>
}
```


# mapEffect

Effectually maps over the value the fiber computes.

To import and use `mapEffect` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.mapEffect
```

**Signature**

```ts
export declare const mapEffect: {
  <A, A2, E2>(f: (a: A) => Effect.Effect<A2, E2>): <E>(self: Fiber<A, E>) => Fiber<A2, E2 | E>
  <A, E, A2, E2>(self: Fiber<A, E>, f: (a: A) => Effect.Effect<A2, E2>): Fiber<A2, E | E2>
}
```


# mapFiber

Passes the success of this fiber to the specified callback, and continues
with the fiber that it returns.

To import and use `mapFiber` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.mapFiber
```

**Signature**

```ts
export declare const mapFiber: {
  <E, E2, A, B>(f: (a: A) => Fiber<B, E2>): (self: Fiber<A, E>) => Effect.Effect<Fiber<B, E | E2>>
  <A, E, E2, B>(self: Fiber<A, E>, f: (a: A) => Fiber<B, E2>): Effect.Effect<Fiber<B, E | E2>>
}
```


# match

Folds over the `Fiber` or `RuntimeFiber`.

To import and use `match` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.match
```

**Signature**

```ts
export declare const match: {
  <A, E, Z>(options: {
    readonly onFiber: (fiber: Fiber<A, E>) => Z
    readonly onRuntimeFiber: (fiber: RuntimeFiber<A, E>) => Z
  }): (self: Fiber<A, E>) => Z
  <A, E, Z>(
    self: Fiber<A, E>,
    options: { readonly onFiber: (fiber: Fiber<A, E>) => Z; readonly onRuntimeFiber: (fiber: RuntimeFiber<A, E>) => Z }
  ): Z
}
```


# never

A fiber that never fails or succeeds.

To import and use `never` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.never
```

**Signature**

```ts
export declare const never: Fiber<never, never>
```


# orElse

Returns a fiber that prefers `this` fiber, but falls back to the `that` one
when `this` one fails. Interrupting the returned fiber will interrupt both
fibers, sequentially, from left to right.

To import and use `orElse` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.orElse
```

**Signature**

```ts
export declare const orElse: {
  <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A2 | A, E2 | E>
  <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A | A2, E | E2>
}
```


# orElseEither

Returns a fiber that prefers `this` fiber, but falls back to the `that` one
when `this` one fails. Interrupting the returned fiber will interrupt both
fibers, sequentially, from left to right.

To import and use `orElseEither` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.orElseEither
```

**Signature**

```ts
export declare const orElseEither: {
  <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<Either.Either<A2, A>, E2 | E>
  <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<Either.Either<A2, A>, E | E2>
}
```


# poll

Tentatively observes the fiber, but returns immediately if it is not
already done.

To import and use `poll` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.poll
```

**Signature**

```ts
export declare const poll: <A, E>(self: Fiber<A, E>) => Effect.Effect<Option.Option<Exit.Exit<A, E>>>
```


# pretty

Pretty-prints a `RuntimeFiber`.

To import and use `pretty` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.pretty
```

**Signature**

```ts
export declare const pretty: <A, E>(self: RuntimeFiber<A, E>) => Effect.Effect<string>
```


# roots

Returns a chunk containing all root fibers.

To import and use `roots` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.roots
```

**Signature**

```ts
export declare const roots: Effect.Effect<RuntimeFiber<any, any>[], never, never>
```


# RuntimeFiber

A runtime fiber that is executing an effect. Runtime fibers have an
identity and a trace.

To import and use `RuntimeFiber` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.RuntimeFiber
```


# scoped

Converts this fiber into a scoped effect. The fiber is interrupted when the
scope is closed.

To import and use `scoped` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.scoped
```

**Signature**

```ts
export declare const scoped: <A, E>(self: Fiber<A, E>) => Effect.Effect<Fiber<A, E>, never, Scope.Scope>
```


# status

Returns the `FiberStatus` of a `RuntimeFiber`.

To import and use `status` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.status
```

**Signature**

```ts
export declare const status: <A, E>(self: RuntimeFiber<A, E>) => Effect.Effect<FiberStatus.FiberStatus>
```


# succeed

Returns a fiber that has already succeeded with the specified value.

To import and use `succeed` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.succeed
```

**Signature**

```ts
export declare const succeed: <A>(value: A) => Fiber<A>
```


# unsafeRoots

Returns a chunk containing all root fibers.

To import and use `unsafeRoots` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.unsafeRoots
```

**Signature**

```ts
export declare const unsafeRoots: (_: void) => Array<RuntimeFiber<any, any>>
```


# void

A fiber that has already succeeded with unit.

To import and use `void` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.void
```


# zip

Zips this fiber and the specified fiber together, producing a tuple of
their output.

To import and use `zip` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.zip
```

**Signature**

```ts
export declare const zip: {
  <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<[A, A2], E2 | E>
  <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<[A, A2], E | E2>
}
```


# zipLeft

Same as `zip` but discards the output of that `Fiber`.

To import and use `zipLeft` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.zipLeft
```

**Signature**

```ts
export declare const zipLeft: {
  <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A, E2 | E>
  <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A, E | E2>
}
```


# zipRight

Same as `zip` but discards the output of this `Fiber`.

To import and use `zipRight` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.zipRight
```

**Signature**

```ts
export declare const zipRight: {
  <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A2, E2 | E>
  <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A2, E | E2>
}
```


# zipWith

Zips this fiber with the specified fiber, combining their results using the
specified combiner function. Both joins and interruptions are performed in
sequential order from left to right.

To import and use `zipWith` from the "Fiber" module:

```ts
import * as Fiber from "effect/Fiber"
// Can be accessed like this
Fiber.zipWith
```

**Signature**

```ts
export declare const zipWith: {
  <B, E2, A, C>(that: Fiber<B, E2>, f: (a: A, b: B) => C): <E>(self: Fiber<A, E>) => Fiber<C, E2 | E>
  <A, E, B, E2, C>(self: Fiber<A, E>, that: Fiber<B, E2>, f: (a: A, b: B) => C): Fiber<C, E | E2>
}
```


# awaitEmpty

Wait for the fiber in the FiberHandle to complete.

To import and use `awaitEmpty` from the "FiberHandle" module:

```ts
import * as FiberHandle from "effect/FiberHandle"
// Can be accessed like this
FiberHandle.awaitEmpty
```

**Signature**

```ts
export declare const awaitEmpty: <A, E>(self: FiberHandle<A, E>) => Effect.Effect<void, E>
```


# get

Retrieve the fiber from the FiberHandle.

To import and use `get` from the "FiberHandle" module:

```ts
import * as FiberHandle from "effect/FiberHandle"
// Can be accessed like this
FiberHandle.get
```

**Signature**

```ts
export declare const get: <A, E>(
  self: FiberHandle<A, E>
) => Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>
```


# join

If any of the Fiber's in the handle terminate with a failure,
the returned Effect will terminate with the first failure that occurred.

To import and use `join` from the "FiberHandle" module:

```ts
import * as FiberHandle from "effect/FiberHandle"
// Can be accessed like this
FiberHandle.join
```

**Example**

```ts
import { Effect, FiberHandle } from "effect"

Effect.gen(function* (_) {
  const handle = yield* _(FiberHandle.make())
  yield* _(FiberHandle.set(handle, Effect.runFork(Effect.fail("error"))))

  // parent fiber will fail with "error"
  yield* _(FiberHandle.join(handle))
})
```

**Signature**

```ts
export declare const join: <A, E>(self: FiberHandle<A, E>) => Effect.Effect<void, E>
```


# make

A FiberHandle can be used to store a single fiber.
When the associated Scope is closed, the contained fiber will be interrupted.

You can add a fiber to the handle using `FiberHandle.run`, and the fiber will
be automatically removed from the FiberHandle when it completes.

To import and use `make` from the "FiberHandle" module:

```ts
import * as FiberHandle from "effect/FiberHandle"
// Can be accessed like this
FiberHandle.make
```

**Example**

```ts
import { Effect, FiberHandle } from "effect"

Effect.gen(function* () {
  const handle = yield* FiberHandle.make()

  // run some effects
  yield* FiberHandle.run(handle, Effect.never)
  // this will interrupt the previous fiber
  yield* FiberHandle.run(handle, Effect.never)

  yield* Effect.sleep(1000)
}).pipe(
  Effect.scoped // The fiber will be interrupted when the scope is closed
)
```

**Signature**

```ts
export declare const make: <A = unknown, E = unknown>() => Effect.Effect<FiberHandle<A, E>, never, Scope.Scope>
```


# makeRuntime

Create an Effect run function that is backed by a FiberHandle.

To import and use `makeRuntime` from the "FiberHandle" module:

```ts
import * as FiberHandle from "effect/FiberHandle"
// Can be accessed like this
FiberHandle.makeRuntime
```

**Signature**

```ts
export declare const makeRuntime: <R, E = unknown, A = unknown>() => Effect.Effect<
  <XE extends E, XA extends A>(
    effect: Effect.Effect<XA, XE, R>,
    options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined }) | undefined
  ) => Fiber.RuntimeFiber<XA, XE>,
  never,
  Scope.Scope | R
>
```


# makeRuntimePromise

Create an Effect run function that is backed by a FiberHandle.

To import and use `makeRuntimePromise` from the "FiberHandle" module:

```ts
import * as FiberHandle from "effect/FiberHandle"
// Can be accessed like this
FiberHandle.makeRuntimePromise
```

**Signature**

```ts
export declare const makeRuntimePromise: <R = never, A = unknown, E = unknown>() => Effect.Effect<
  <XE extends E, XA extends A>(
    effect: Effect.Effect<XA, XE, R>,
    options?: Runtime.RunForkOptions | undefined
  ) => Promise<XA>,
  never,
  Scope.Scope | R
>
```


# run

Run an Effect and add the forked fiber to the FiberHandle.
When the fiber completes, it will be removed from the FiberHandle.

To import and use `run` from the "FiberHandle" module:

```ts
import * as FiberHandle from "effect/FiberHandle"
// Can be accessed like this
FiberHandle.run
```

**Signature**

```ts
export declare const run: {
  <A, E>(
    self: FiberHandle<A, E>,
    options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined }
  ): <R, XE extends E, XA extends A>(
    effect: Effect.Effect<XA, XE, R>
  ) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>
  <A, E, R, XE extends E, XA extends A>(
    self: FiberHandle<A, E>,
    effect: Effect.Effect<XA, XE, R>,
    options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined }
  ): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>
}
```


# runtime

Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberHandle.

To import and use `runtime` from the "FiberHandle" module:

```ts
import * as FiberHandle from "effect/FiberHandle"
// Can be accessed like this
FiberHandle.runtime
```

**Example**

```ts
import { Context, Effect, FiberHandle } from "effect"

interface Users {
  readonly _: unique symbol
}
const Users = Context.GenericTag<
  Users,
  {
    getAll: Effect.Effect<Array<unknown>>
  }
>("Users")

Effect.gen(function* () {
  const handle = yield* FiberHandle.make()
  const run = yield* FiberHandle.runtime(handle)<Users>()

  // run an effect and set the fiber in the handle
  run(Effect.andThen(Users, (_) => _.getAll))

  // this will interrupt the previous fiber
  run(Effect.andThen(Users, (_) => _.getAll))
}).pipe(
  Effect.scoped // The fiber will be interrupted when the scope is closed
)
```

**Signature**

```ts
export declare const runtime: <A, E>(
  self: FiberHandle<A, E>
) => <R = never>() => Effect.Effect<
  <XE extends E, XA extends A>(
    effect: Effect.Effect<XA, XE, R>,
    options?:
      | (Runtime.RunForkOptions & {
          readonly onlyIfMissing?: boolean | undefined
          readonly propagateInterruption?: boolean | undefined
        })
      | undefined
  ) => Fiber.RuntimeFiber<XA, XE>,
  never,
  R
>
```


# runtimePromise

Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberHandle.

The returned run function will return Promise's that will resolve when the
fiber completes.

To import and use `runtimePromise` from the "FiberHandle" module:

```ts
import * as FiberHandle from "effect/FiberHandle"
// Can be accessed like this
FiberHandle.runtimePromise
```

**Signature**

```ts
export declare const runtimePromise: <A, E>(
  self: FiberHandle<A, E>
) => <R = never>() => Effect.Effect<
  <XE extends E, XA extends A>(
    effect: Effect.Effect<XA, XE, R>,
    options?: (Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined }) | undefined
  ) => Promise<XA>,
  never,
  R
>
```


# set

Set the fiber in the FiberHandle. When the fiber completes, it will be removed from the FiberHandle.
If a fiber already exists in the FiberHandle, it will be interrupted unless `options.onlyIfMissing` is set.

To import and use `set` from the "FiberHandle" module:

```ts
import * as FiberHandle from "effect/FiberHandle"
// Can be accessed like this
FiberHandle.set
```

**Signature**

```ts
export declare const set: {
  <A, E, XE extends E, XA extends A>(
    fiber: Fiber.RuntimeFiber<XA, XE>,
    options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined }
  ): (self: FiberHandle<A, E>) => Effect.Effect<void>
  <A, E, XE extends E, XA extends A>(
    self: FiberHandle<A, E>,
    fiber: Fiber.RuntimeFiber<XA, XE>,
    options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined }
  ): Effect.Effect<void>
}
```


# unsafeGet

Retrieve the fiber from the FiberHandle.

To import and use `unsafeGet` from the "FiberHandle" module:

```ts
import * as FiberHandle from "effect/FiberHandle"
// Can be accessed like this
FiberHandle.unsafeGet
```

**Signature**

```ts
export declare const unsafeGet: <A, E>(self: FiberHandle<A, E>) => Option.Option<Fiber.RuntimeFiber<A, E>>
```


# unsafeSet

Set the fiber in a FiberHandle. When the fiber completes, it will be removed from the FiberHandle.
If a fiber is already running, it will be interrupted unless `options.onlyIfMissing` is set.

To import and use `unsafeSet` from the "FiberHandle" module:

```ts
import * as FiberHandle from "effect/FiberHandle"
// Can be accessed like this
FiberHandle.unsafeSet
```

**Signature**

```ts
export declare const unsafeSet: {
  <A, E, XE extends E, XA extends A>(
    fiber: Fiber.RuntimeFiber<XA, XE>,
    options?: {
      readonly interruptAs?: FiberId.FiberId | undefined
      readonly onlyIfMissing?: boolean | undefined
      readonly propagateInterruption?: boolean | undefined
    }
  ): (self: FiberHandle<A, E>) => void
  <A, E, XE extends E, XA extends A>(
    self: FiberHandle<A, E>,
    fiber: Fiber.RuntimeFiber<XA, XE>,
    options?: {
      readonly interruptAs?: FiberId.FiberId | undefined
      readonly onlyIfMissing?: boolean | undefined
      readonly propagateInterruption?: boolean | undefined
    }
  ): void
}
```


# combine

Combine two `FiberId`s.

To import and use `combine` from the "FiberId" module:

```ts
import * as FiberId from "effect/FiberId"
// Can be accessed like this
FiberId.combine
```

**Signature**

```ts
export declare const combine: { (that: FiberId): (self: FiberId) => FiberId; (self: FiberId, that: FiberId): FiberId }
```


# combineAll

Combines a set of `FiberId`s into a single `FiberId`.

To import and use `combineAll` from the "FiberId" module:

```ts
import * as FiberId from "effect/FiberId"
// Can be accessed like this
FiberId.combineAll
```

**Signature**

```ts
export declare const combineAll: (fiberIds: HashSet.HashSet<FiberId>) => FiberId
```


# getOrElse

Returns this `FiberId` if it is not `None`, otherwise returns that `FiberId`.

To import and use `getOrElse` from the "FiberId" module:

```ts
import * as FiberId from "effect/FiberId"
// Can be accessed like this
FiberId.getOrElse
```

**Signature**

```ts
export declare const getOrElse: { (that: FiberId): (self: FiberId) => FiberId; (self: FiberId, that: FiberId): FiberId }
```


# ids

Get the set of identifiers for this `FiberId`.

To import and use `ids` from the "FiberId" module:

```ts
import * as FiberId from "effect/FiberId"
// Can be accessed like this
FiberId.ids
```

**Signature**

```ts
export declare const ids: (self: FiberId) => HashSet.HashSet<number>
```


# isComposite

Returns `true` if the `FiberId` is a `Composite`, `false` otherwise.

To import and use `isComposite` from the "FiberId" module:

```ts
import * as FiberId from "effect/FiberId"
// Can be accessed like this
FiberId.isComposite
```

**Signature**

```ts
export declare const isComposite: (self: FiberId) => self is Composite
```


# isFiberId

Returns `true` if the specified unknown value is a `FiberId`, `false`
otherwise.

To import and use `isFiberId` from the "FiberId" module:

```ts
import * as FiberId from "effect/FiberId"
// Can be accessed like this
FiberId.isFiberId
```

**Signature**

```ts
export declare const isFiberId: (self: unknown) => self is FiberId
```


# isNone

Returns `true` if the `FiberId` is a `None`, `false` otherwise.

To import and use `isNone` from the "FiberId" module:

```ts
import * as FiberId from "effect/FiberId"
// Can be accessed like this
FiberId.isNone
```

**Signature**

```ts
export declare const isNone: (self: FiberId) => self is None
```


# isRuntime

Returns `true` if the `FiberId` is a `Runtime`, `false` otherwise.

To import and use `isRuntime` from the "FiberId" module:

```ts
import * as FiberId from "effect/FiberId"
// Can be accessed like this
FiberId.isRuntime
```

**Signature**

```ts
export declare const isRuntime: (self: FiberId) => self is Runtime
```


# make

Creates a new `FiberId`.

To import and use `make` from the "FiberId" module:

```ts
import * as FiberId from "effect/FiberId"
// Can be accessed like this
FiberId.make
```

**Signature**

```ts
export declare const make: (id: number, startTimeSeconds: number) => FiberId
```


# threadName

Creates a string representing the name of the current thread of execution
represented by the specified `FiberId`.

To import and use `threadName` from the "FiberId" module:

```ts
import * as FiberId from "effect/FiberId"
// Can be accessed like this
FiberId.threadName
```

**Signature**

```ts
export declare const threadName: (self: FiberId) => string
```


# toOption

Convert a `FiberId` into an `Option<FiberId>`.

To import and use `toOption` from the "FiberId" module:

```ts
import * as FiberId from "effect/FiberId"
// Can be accessed like this
FiberId.toOption
```

**Signature**

```ts
export declare const toOption: (self: FiberId) => Option.Option<FiberId>
```


# toSet

Convert a `FiberId` into a `HashSet<FiberId>`.

To import and use `toSet` from the "FiberId" module:

```ts
import * as FiberId from "effect/FiberId"
// Can be accessed like this
FiberId.toSet
```

**Signature**

```ts
export declare const toSet: (self: FiberId) => HashSet.HashSet<Runtime>
```


# unsafeMake

Unsafely creates a new `FiberId`.

To import and use `unsafeMake` from the "FiberId" module:

```ts
import * as FiberId from "effect/FiberId"
// Can be accessed like this
FiberId.unsafeMake
```

**Signature**

```ts
export declare const unsafeMake: (_: void) => Runtime
```


# awaitEmpty

Wait for the FiberMap to be empty.

To import and use `awaitEmpty` from the "FiberMap" module:

```ts
import * as FiberMap from "effect/FiberMap"
// Can be accessed like this
FiberMap.awaitEmpty
```

**Signature**

```ts
export declare const awaitEmpty: <K, A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void, E>
```


# get

Retrieve a fiber from the FiberMap.

To import and use `get` from the "FiberMap" module:

```ts
import * as FiberMap from "effect/FiberMap"
// Can be accessed like this
FiberMap.get
```

**Signature**

```ts
export declare const get: {
  <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>
  <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>
}
```


# has

Check if a key exists in the FiberMap.

To import and use `has` from the "FiberMap" module:

```ts
import * as FiberMap from "effect/FiberMap"
// Can be accessed like this
FiberMap.has
```

**Signature**

```ts
export declare const has: {
  <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<boolean>
  <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<boolean>
}
```


# join

Join all fibers in the FiberMap. If any of the Fiber's in the map terminate with a failure,
the returned Effect will terminate with the first failure that occurred.

To import and use `join` from the "FiberMap" module:

```ts
import * as FiberMap from "effect/FiberMap"
// Can be accessed like this
FiberMap.join
```

**Example**

```ts
import { Effect, FiberMap } from "effect"

Effect.gen(function* (_) {
  const map = yield* _(FiberMap.make())
  yield* _(FiberMap.set(map, "a", Effect.runFork(Effect.fail("error"))))

  // parent fiber will fail with "error"
  yield* _(FiberMap.join(map))
})
```

**Signature**

```ts
export declare const join: <K, A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void, E>
```


# make

A FiberMap can be used to store a collection of fibers, indexed by some key.
When the associated Scope is closed, all fibers in the map will be interrupted.

You can add fibers to the map using `FiberMap.set` or `FiberMap.run`, and the fibers will
be automatically removed from the FiberMap when they complete.

To import and use `make` from the "FiberMap" module:

```ts
import * as FiberMap from "effect/FiberMap"
// Can be accessed like this
FiberMap.make
```

**Example**

```ts
import { Effect, FiberMap } from "effect"

Effect.gen(function* () {
  const map = yield* FiberMap.make<string>()

  // run some effects and add the fibers to the map
  yield* FiberMap.run(map, "fiber a", Effect.never)
  yield* FiberMap.run(map, "fiber b", Effect.never)

  yield* Effect.sleep(1000)
}).pipe(
  Effect.scoped // The fibers will be interrupted when the scope is closed
)
```

**Signature**

```ts
export declare const make: <K, A = unknown, E = unknown>() => Effect.Effect<FiberMap<K, A, E>, never, Scope.Scope>
```


# makeRuntime

Create an Effect run function that is backed by a FiberMap.

To import and use `makeRuntime` from the "FiberMap" module:

```ts
import * as FiberMap from "effect/FiberMap"
// Can be accessed like this
FiberMap.makeRuntime
```

**Signature**

```ts
export declare const makeRuntime: <R, K, E = unknown, A = unknown>() => Effect.Effect<
  <XE extends E, XA extends A>(
    key: K,
    effect: Effect.Effect<XA, XE, R>,
    options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined }) | undefined
  ) => Fiber.RuntimeFiber<XA, XE>,
  never,
  Scope.Scope | R
>
```


# makeRuntimePromise

Create an Effect run function that is backed by a FiberMap.

To import and use `makeRuntimePromise` from the "FiberMap" module:

```ts
import * as FiberMap from "effect/FiberMap"
// Can be accessed like this
FiberMap.makeRuntimePromise
```

**Signature**

```ts
export declare const makeRuntimePromise: <R, K, A = unknown, E = unknown>() => Effect.Effect<
  <XE extends E, XA extends A>(
    key: K,
    effect: Effect.Effect<XA, XE, R>,
    options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined }) | undefined
  ) => Promise<XA>,
  never,
  Scope.Scope | R
>
```


# remove

Remove a fiber from the FiberMap, interrupting it if it exists.

To import and use `remove` from the "FiberMap" module:

```ts
import * as FiberMap from "effect/FiberMap"
// Can be accessed like this
FiberMap.remove
```

**Signature**

```ts
export declare const remove: {
  <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void>
  <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<void>
}
```


# run

Run an Effect and add the forked fiber to the FiberMap.
When the fiber completes, it will be removed from the FiberMap.

To import and use `run` from the "FiberMap" module:

```ts
import * as FiberMap from "effect/FiberMap"
// Can be accessed like this
FiberMap.run
```

**Signature**

```ts
export declare const run: {
  <K, A, E>(
    self: FiberMap<K, A, E>,
    key: K,
    options?:
      | { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined }
      | undefined
  ): <R, XE extends E, XA extends A>(
    effect: Effect.Effect<XA, XE, R>
  ) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>
  <K, A, E, R, XE extends E, XA extends A>(
    self: FiberMap<K, A, E>,
    key: K,
    effect: Effect.Effect<XA, XE, R>,
    options?:
      | { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined }
      | undefined
  ): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>
}
```


# runtime

Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberMap.

To import and use `runtime` from the "FiberMap" module:

```ts
import * as FiberMap from "effect/FiberMap"
// Can be accessed like this
FiberMap.runtime
```

**Example**

```ts
import { Context, Effect, FiberMap } from "effect"

interface Users {
  readonly _: unique symbol
}
const Users = Context.GenericTag<
  Users,
  {
    getAll: Effect.Effect<Array<unknown>>
  }
>("Users")

Effect.gen(function* () {
  const map = yield* FiberMap.make<string>()
  const run = yield* FiberMap.runtime(map)<Users>()

  // run some effects and add the fibers to the map
  run(
    "effect-a",
    Effect.andThen(Users, (_) => _.getAll)
  )
  run(
    "effect-b",
    Effect.andThen(Users, (_) => _.getAll)
  )
}).pipe(
  Effect.scoped // The fibers will be interrupted when the scope is closed
)
```

**Signature**

```ts
export declare const runtime: <K, A, E>(
  self: FiberMap<K, A, E>
) => <R = never>() => Effect.Effect<
  <XE extends E, XA extends A>(
    key: K,
    effect: Effect.Effect<XA, XE, R>,
    options?:
      | (Runtime.RunForkOptions & {
          readonly onlyIfMissing?: boolean | undefined
          readonly propagateInterruption?: boolean | undefined
        })
      | undefined
  ) => Fiber.RuntimeFiber<XA, XE>,
  never,
  R
>
```


# runtimePromise

Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberMap.

To import and use `runtimePromise` from the "FiberMap" module:

```ts
import * as FiberMap from "effect/FiberMap"
// Can be accessed like this
FiberMap.runtimePromise
```

**Signature**

```ts
export declare const runtimePromise: <K, A, E>(
  self: FiberMap<K, A, E>
) => <R = never>() => Effect.Effect<
  <XE extends E, XA extends A>(
    key: K,
    effect: Effect.Effect<XA, XE, R>,
    options?:
      | (Runtime.RunForkOptions & {
          readonly onlyIfMissing?: boolean | undefined
          readonly propagateInterruption?: boolean | undefined
        })
      | undefined
  ) => Promise<XA>,
  never,
  R
>
```


# set

Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.
If the key already exists in the FiberMap, the previous fiber will be interrupted.

To import and use `set` from the "FiberMap" module:

```ts
import * as FiberMap from "effect/FiberMap"
// Can be accessed like this
FiberMap.set
```

**Signature**

```ts
export declare const set: {
  <K, A, E, XE extends E, XA extends A>(
    key: K,
    fiber: Fiber.RuntimeFiber<XA, XE>,
    options?:
      | { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined }
      | undefined
  ): (self: FiberMap<K, A, E>) => Effect.Effect<void>
  <K, A, E, XE extends E, XA extends A>(
    self: FiberMap<K, A, E>,
    key: K,
    fiber: Fiber.RuntimeFiber<XA, XE>,
    options?:
      | { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined }
      | undefined
  ): Effect.Effect<void>
}
```


# unsafeGet

Retrieve a fiber from the FiberMap.

To import and use `unsafeGet` from the "FiberMap" module:

```ts
import * as FiberMap from "effect/FiberMap"
// Can be accessed like this
FiberMap.unsafeGet
```

**Signature**

```ts
export declare const unsafeGet: {
  <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Option.Option<Fiber.RuntimeFiber<A, E>>
  <K, A, E>(self: FiberMap<K, A, E>, key: K): Option.Option<Fiber.RuntimeFiber<A, E>>
}
```


# unsafeHas

Check if a key exists in the FiberMap.

To import and use `unsafeHas` from the "FiberMap" module:

```ts
import * as FiberMap from "effect/FiberMap"
// Can be accessed like this
FiberMap.unsafeHas
```

**Signature**

```ts
export declare const unsafeHas: {
  <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => boolean
  <K, A, E>(self: FiberMap<K, A, E>, key: K): boolean
}
```


# unsafeSet

Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.
If the key already exists in the FiberMap, the previous fiber will be interrupted.

To import and use `unsafeSet` from the "FiberMap" module:

```ts
import * as FiberMap from "effect/FiberMap"
// Can be accessed like this
FiberMap.unsafeSet
```

**Signature**

```ts
export declare const unsafeSet: {
  <K, A, E, XE extends E, XA extends A>(
    key: K,
    fiber: Fiber.RuntimeFiber<XA, XE>,
    options?:
      | {
          readonly interruptAs?: FiberId.FiberId | undefined
          readonly onlyIfMissing?: boolean | undefined
          readonly propagateInterruption?: boolean | undefined
        }
      | undefined
  ): (self: FiberMap<K, A, E>) => void
  <K, A, E, XE extends E, XA extends A>(
    self: FiberMap<K, A, E>,
    key: K,
    fiber: Fiber.RuntimeFiber<XA, XE>,
    options?:
      | {
          readonly interruptAs?: FiberId.FiberId | undefined
          readonly onlyIfMissing?: boolean | undefined
          readonly propagateInterruption?: boolean | undefined
        }
      | undefined
  ): void
}
```


# delete

Deletes the specified `FiberRef` from the `FibterRefs`.

To import and use `delete` from the "FiberRefs" module:

```ts
import * as FiberRefs from "effect/FiberRefs"
// Can be accessed like this
FiberRefs.delete
```


# empty

The empty collection of `FiberRef` values.

To import and use `empty` from the "FiberRefs" module:

```ts
import * as FiberRefs from "effect/FiberRefs"
// Can be accessed like this
FiberRefs.empty
```

**Signature**

```ts
export declare const empty: () => FiberRefs
```


# fiberRefs

Returns a set of each `FiberRef` in this collection.

To import and use `fiberRefs` from the "FiberRefs" module:

```ts
import * as FiberRefs from "effect/FiberRefs"
// Can be accessed like this
FiberRefs.fiberRefs
```

**Signature**

```ts
export declare const fiberRefs: (self: FiberRefs) => HashSet.HashSet<FiberRef.FiberRef<any>>
```


# FiberRefs

`FiberRefs` is a data type that represents a collection of `FiberRef` values.

This allows safely propagating `FiberRef` values across fiber boundaries, for
example between an asynchronous producer and consumer.

To import and use `FiberRefs` from the "FiberRefs" module:

```ts
import * as FiberRefs from "effect/FiberRefs"
// Can be accessed like this
FiberRefs.FiberRefs
```


# forkAs

Forks this collection of fiber refs as the specified child fiber id. This
will potentially modify the value of the fiber refs, as determined by the
individual fiber refs that make up the collection.

To import and use `forkAs` from the "FiberRefs" module:

```ts
import * as FiberRefs from "effect/FiberRefs"
// Can be accessed like this
FiberRefs.forkAs
```

**Signature**

```ts
export declare const forkAs: {
  (childId: FiberId.Single): (self: FiberRefs) => FiberRefs
  (self: FiberRefs, childId: FiberId.Single): FiberRefs
}
```


# get

Gets the value of the specified `FiberRef` in this collection of `FiberRef`
values if it exists or `None` otherwise.

To import and use `get` from the "FiberRefs" module:

```ts
import * as FiberRefs from "effect/FiberRefs"
// Can be accessed like this
FiberRefs.get
```

**Signature**

```ts
export declare const get: {
  <A>(fiberRef: FiberRef.FiberRef<A>): (self: FiberRefs) => Option.Option<A>
  <A>(self: FiberRefs, fiberRef: FiberRef.FiberRef<A>): Option.Option<A>
}
```


# getOrDefault

Gets the value of the specified `FiberRef` in this collection of `FiberRef`
values if it exists or the `initial` value of the `FiberRef` otherwise.

To import and use `getOrDefault` from the "FiberRefs" module:

```ts
import * as FiberRefs from "effect/FiberRefs"
// Can be accessed like this
FiberRefs.getOrDefault
```

**Signature**

```ts
export declare const getOrDefault: {
  <A>(fiberRef: FiberRef.FiberRef<A>): (self: FiberRefs) => A
  <A>(self: FiberRefs, fiberRef: FiberRef.FiberRef<A>): A
}
```


# joinAs

Joins this collection of fiber refs to the specified collection, as the
specified fiber id. This will perform diffing and merging to ensure
preservation of maximum information from both child and parent refs.

To import and use `joinAs` from the "FiberRefs" module:

```ts
import * as FiberRefs from "effect/FiberRefs"
// Can be accessed like this
FiberRefs.joinAs
```

**Signature**

```ts
export declare const joinAs: {
  (fiberId: FiberId.Single, that: FiberRefs): (self: FiberRefs) => FiberRefs
  (self: FiberRefs, fiberId: FiberId.Single, that: FiberRefs): FiberRefs
}
```


# setAll

Set each ref to either its value or its default.

To import and use `setAll` from the "FiberRefs" module:

```ts
import * as FiberRefs from "effect/FiberRefs"
// Can be accessed like this
FiberRefs.setAll
```

**Signature**

```ts
export declare const setAll: (self: FiberRefs) => Effect.Effect<void>
```


# unsafeMake

Note: it will not copy the provided Map, make sure to provide a fresh one.

To import and use `unsafeMake` from the "FiberRefs" module:

```ts
import * as FiberRefs from "effect/FiberRefs"
// Can be accessed like this
FiberRefs.unsafeMake
```

**Signature**

```ts
export declare const unsafeMake: (
  fiberRefLocals: Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>>
) => FiberRefs
```


# updateAs

Updates the value of the specified `FiberRef` using the provided `FiberId`

To import and use `updateAs` from the "FiberRefs" module:

```ts
import * as FiberRefs from "effect/FiberRefs"
// Can be accessed like this
FiberRefs.updateAs
```

**Signature**

```ts
export declare const updateAs: {
  <A>(options: {
    readonly fiberId: FiberId.Single
    readonly fiberRef: FiberRef.FiberRef<A>
    readonly value: A
  }): (self: FiberRefs) => FiberRefs
  <A>(
    self: FiberRefs,
    options: { readonly fiberId: FiberId.Single; readonly fiberRef: FiberRef.FiberRef<A>; readonly value: A }
  ): FiberRefs
}
```


# updateManyAs

Updates the values of the specified `FiberRef` & value pairs using the provided `FiberId`

To import and use `updateManyAs` from the "FiberRefs" module:

```ts
import * as FiberRefs from "effect/FiberRefs"
// Can be accessed like this
FiberRefs.updateManyAs
```

**Signature**

```ts
export declare const updateManyAs: {
  (options: {
    readonly forkAs?: FiberId.Single | undefined
    readonly entries: readonly [
      readonly [
        FiberRef.FiberRef<any>,
        readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]
      ],
      ...Array<
        readonly [
          FiberRef.FiberRef<any>,
          readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]
        ]
      >
    ]
  }): (self: FiberRefs) => FiberRefs
  (
    self: FiberRefs,
    options: {
      readonly forkAs?: FiberId.Single | undefined
      readonly entries: readonly [
        readonly [
          FiberRef.FiberRef<any>,
          readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]
        ],
        ...Array<
          readonly [
            FiberRef.FiberRef<any>,
            readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]
          ]
        >
      ]
    }
  ): FiberRefs
}
```


# combine

Combines this patch and the specified patch to create a new patch that
describes applying the changes from this patch and the specified patch
sequentially.

To import and use `combine` from the "FiberRefsPatch" module:

```ts
import * as FiberRefsPatch from "effect/FiberRefsPatch"
// Can be accessed like this
FiberRefsPatch.combine
```

**Signature**

```ts
export declare const combine: {
  (that: FiberRefsPatch): (self: FiberRefsPatch) => FiberRefsPatch
  (self: FiberRefsPatch, that: FiberRefsPatch): FiberRefsPatch
}
```


# diff

Constructs a patch that describes the changes between the specified
collections of `FiberRef`

To import and use `diff` from the "FiberRefsPatch" module:

```ts
import * as FiberRefsPatch from "effect/FiberRefsPatch"
// Can be accessed like this
FiberRefsPatch.diff
```

**Signature**

```ts
export declare const diff: (oldValue: FiberRefs.FiberRefs, newValue: FiberRefs.FiberRefs) => FiberRefsPatch
```


# FiberRefsPatch

A `FiberRefsPatch` captures the changes in `FiberRef` values made by a single
fiber as a value. This allows fibers to apply the changes made by a workflow
without inheriting all the `FiberRef` values of the fiber that executed the
workflow.

To import and use `FiberRefsPatch` from the "FiberRefsPatch" module:

```ts
import * as FiberRefsPatch from "effect/FiberRefsPatch"
// Can be accessed like this
FiberRefsPatch.FiberRefsPatch
```


# patch

Applies the changes described by this patch to the specified collection
of `FiberRef` values.

To import and use `patch` from the "FiberRefsPatch" module:

```ts
import * as FiberRefsPatch from "effect/FiberRefsPatch"
// Can be accessed like this
FiberRefsPatch.patch
```

**Signature**

```ts
export declare const patch: {
  (fiberId: FiberId.Runtime, oldValue: FiberRefs.FiberRefs): (self: FiberRefsPatch) => FiberRefs.FiberRefs
  (self: FiberRefsPatch, fiberId: FiberId.Runtime, oldValue: FiberRefs.FiberRefs): FiberRefs.FiberRefs
}
```


# add

Add a fiber to the FiberSet. When the fiber completes, it will be removed.

To import and use `add` from the "FiberSet" module:

```ts
import * as FiberSet from "effect/FiberSet"
// Can be accessed like this
FiberSet.add
```

**Signature**

```ts
export declare const add: {
  <A, E, XE extends E, XA extends A>(
    fiber: Fiber.RuntimeFiber<XA, XE>,
    options?: { readonly propagateInterruption?: boolean | undefined } | undefined
  ): (self: FiberSet<A, E>) => Effect.Effect<void>
  <A, E, XE extends E, XA extends A>(
    self: FiberSet<A, E>,
    fiber: Fiber.RuntimeFiber<XA, XE>,
    options?: { readonly propagateInterruption?: boolean | undefined } | undefined
  ): Effect.Effect<void>
}
```


# awaitEmpty

Wait until the fiber set is empty.

To import and use `awaitEmpty` from the "FiberSet" module:

```ts
import * as FiberSet from "effect/FiberSet"
// Can be accessed like this
FiberSet.awaitEmpty
```

**Signature**

```ts
export declare const awaitEmpty: <A, E>(self: FiberSet<A, E>) => Effect.Effect<void>
```


# join

Join all fibers in the FiberSet. If any of the Fiber's in the set terminate with a failure,
the returned Effect will terminate with the first failure that occurred.

To import and use `join` from the "FiberSet" module:

```ts
import * as FiberSet from "effect/FiberSet"
// Can be accessed like this
FiberSet.join
```

**Example**

```ts
import { Effect, FiberSet } from "effect"

Effect.gen(function* (_) {
  const set = yield* _(FiberSet.make())
  yield* _(FiberSet.add(set, Effect.runFork(Effect.fail("error"))))

  // parent fiber will fail with "error"
  yield* _(FiberSet.join(set))
})
```

**Signature**

```ts
export declare const join: <A, E>(self: FiberSet<A, E>) => Effect.Effect<void, E>
```


# make

A FiberSet can be used to store a collection of fibers.
When the associated Scope is closed, all fibers in the set will be interrupted.

You can add fibers to the set using `FiberSet.add` or `FiberSet.run`, and the fibers will
be automatically removed from the FiberSet when they complete.

To import and use `make` from the "FiberSet" module:

```ts
import * as FiberSet from "effect/FiberSet"
// Can be accessed like this
FiberSet.make
```

**Example**

```ts
import { Effect, FiberSet } from "effect"

Effect.gen(function* () {
  const set = yield* FiberSet.make()

  // run some effects and add the fibers to the set
  yield* FiberSet.run(set, Effect.never)
  yield* FiberSet.run(set, Effect.never)

  yield* Effect.sleep(1000)
}).pipe(
  Effect.scoped // The fibers will be interrupted when the scope is closed
)
```

**Signature**

```ts
export declare const make: <A = unknown, E = unknown>() => Effect.Effect<FiberSet<A, E>, never, Scope.Scope>
```


# makeRuntime

Create an Effect run function that is backed by a FiberSet.

To import and use `makeRuntime` from the "FiberSet" module:

```ts
import * as FiberSet from "effect/FiberSet"
// Can be accessed like this
FiberSet.makeRuntime
```

**Signature**

```ts
export declare const makeRuntime: <R = never, A = unknown, E = unknown>() => Effect.Effect<
  <XE extends E, XA extends A>(
    effect: Effect.Effect<XA, XE, R>,
    options?: Runtime.RunForkOptions | undefined
  ) => Fiber.RuntimeFiber<XA, XE>,
  never,
  Scope.Scope | R
>
```


# makeRuntimePromise

Create an Effect run function that is backed by a FiberSet.

To import and use `makeRuntimePromise` from the "FiberSet" module:

```ts
import * as FiberSet from "effect/FiberSet"
// Can be accessed like this
FiberSet.makeRuntimePromise
```

**Signature**

```ts
export declare const makeRuntimePromise: <R = never, A = unknown, E = unknown>() => Effect.Effect<
  <XE extends E, XA extends A>(
    effect: Effect.Effect<XA, XE, R>,
    options?: Runtime.RunForkOptions | undefined
  ) => Promise<XA>,
  never,
  Scope.Scope | R
>
```


# run

Fork an Effect and add the forked fiber to the FiberSet.
When the fiber completes, it will be removed from the FiberSet.

To import and use `run` from the "FiberSet" module:

```ts
import * as FiberSet from "effect/FiberSet"
// Can be accessed like this
FiberSet.run
```

**Signature**

```ts
export declare const run: {
  <A, E>(
    self: FiberSet<A, E>,
    options?: { readonly propagateInterruption?: boolean | undefined } | undefined
  ): <R, XE extends E, XA extends A>(
    effect: Effect.Effect<XA, XE, R>
  ) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>
  <A, E, R, XE extends E, XA extends A>(
    self: FiberSet<A, E>,
    effect: Effect.Effect<XA, XE, R>,
    options?: { readonly propagateInterruption?: boolean | undefined } | undefined
  ): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>
}
```


# runtime

Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberSet.

To import and use `runtime` from the "FiberSet" module:

```ts
import * as FiberSet from "effect/FiberSet"
// Can be accessed like this
FiberSet.runtime
```

**Example**

```ts
import { Context, Effect, FiberSet } from "effect"

interface Users {
  readonly _: unique symbol
}
const Users = Context.GenericTag<
  Users,
  {
    getAll: Effect.Effect<Array<unknown>>
  }
>("Users")

Effect.gen(function* () {
  const set = yield* FiberSet.make()
  const run = yield* FiberSet.runtime(set)<Users>()

  // run some effects and add the fibers to the set
  run(Effect.andThen(Users, (_) => _.getAll))
}).pipe(
  Effect.scoped // The fibers will be interrupted when the scope is closed
)
```

**Signature**

```ts
export declare const runtime: <A, E>(
  self: FiberSet<A, E>
) => <R = never>() => Effect.Effect<
  <XE extends E, XA extends A>(
    effect: Effect.Effect<XA, XE, R>,
    options?: (Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined }) | undefined
  ) => Fiber.RuntimeFiber<XA, XE>,
  never,
  R
>
```


# runtimePromise

Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberSet.

The returned run function will return Promise's.

To import and use `runtimePromise` from the "FiberSet" module:

```ts
import * as FiberSet from "effect/FiberSet"
// Can be accessed like this
FiberSet.runtimePromise
```

**Signature**

```ts
export declare const runtimePromise: <A, E>(
  self: FiberSet<A, E>
) => <R = never>() => Effect.Effect<
  <XE extends E, XA extends A>(
    effect: Effect.Effect<XA, XE, R>,
    options?: (Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined }) | undefined
  ) => Promise<XA>,
  never,
  R
>
```


# unsafeAdd

Add a fiber to the FiberSet. When the fiber completes, it will be removed.

To import and use `unsafeAdd` from the "FiberSet" module:

```ts
import * as FiberSet from "effect/FiberSet"
// Can be accessed like this
FiberSet.unsafeAdd
```

**Signature**

```ts
export declare const unsafeAdd: {
  <A, E, XE extends E, XA extends A>(
    fiber: Fiber.RuntimeFiber<XA, XE>,
    options?:
      | { readonly interruptAs?: FiberId.FiberId | undefined; readonly propagateInterruption?: boolean | undefined }
      | undefined
  ): (self: FiberSet<A, E>) => void
  <A, E, XE extends E, XA extends A>(
    self: FiberSet<A, E>,
    fiber: Fiber.RuntimeFiber<XA, XE>,
    options?:
      | { readonly interruptAs?: FiberId.FiberId | undefined; readonly propagateInterruption?: boolean | undefined }
      | undefined
  ): void
}
```


# isDone

Returns `true` if the specified `FiberStatus` is `Done`, `false` otherwise.

To import and use `isDone` from the "FiberStatus" module:

```ts
import * as FiberStatus from "effect/FiberStatus"
// Can be accessed like this
FiberStatus.isDone
```

**Signature**

```ts
export declare const isDone: (self: FiberStatus) => self is Done
```


# isFiberStatus

Returns `true` if the specified value is a `FiberStatus`, `false` otherwise.

To import and use `isFiberStatus` from the "FiberStatus" module:

```ts
import * as FiberStatus from "effect/FiberStatus"
// Can be accessed like this
FiberStatus.isFiberStatus
```

**Signature**

```ts
export declare const isFiberStatus: (u: unknown) => u is FiberStatus
```


# isRunning

Returns `true` if the specified `FiberStatus` is `Running`, `false`
otherwise.

To import and use `isRunning` from the "FiberStatus" module:

```ts
import * as FiberStatus from "effect/FiberStatus"
// Can be accessed like this
FiberStatus.isRunning
```

**Signature**

```ts
export declare const isRunning: (self: FiberStatus) => self is Running
```


# isSuspended

Returns `true` if the specified `FiberStatus` is `Suspended`, `false`
otherwise.

To import and use `isSuspended` from the "FiberStatus" module:

```ts
import * as FiberStatus from "effect/FiberStatus"
// Can be accessed like this
FiberStatus.isSuspended
```

**Signature**

```ts
export declare const isSuspended: (self: FiberStatus) => self is Suspended
```


# layerNoop

Create a no-op file system that can be used for testing.

To import and use `layerNoop` from the "FileSystem" module:

```ts
import * as FileSystem from "@effect/platform/FileSystem"
// Can be accessed like this
FileSystem.layerNoop
```

**Signature**

```ts
export declare const layerNoop: (fileSystem: Partial<FileSystem>) => Layer<FileSystem>
```


# makeNoop

Create a no-op file system that can be used for testing.

To import and use `makeNoop` from the "FileSystem" module:

```ts
import * as FileSystem from "@effect/platform/FileSystem"
// Can be accessed like this
FileSystem.makeNoop
```

**Signature**

```ts
export declare const makeNoop: (fileSystem: Partial<FileSystem>) => FileSystem
```


# Size

Represents a size in bytes.

To import and use `Size` from the "FileSystem" module:

```ts
import * as FileSystem from "@effect/platform/FileSystem"
// Can be accessed like this
FileSystem.Size
```


# SizeInput

Represents a size in bytes.

To import and use `SizeInput` from the "FileSystem" module:

```ts
import * as FileSystem from "@effect/platform/FileSystem"
// Can be accessed like this
FileSystem.SizeInput
```


# filterMapComposition

Returns a default binary `filterMap` composition.

To import and use `filterMapComposition` from the "Filterable" module:

```ts
import * as Filterable from "@effect/typeclass/Filterable"
// Can be accessed like this
Filterable.filterMapComposition
```

**Signature**

```ts
export declare const filterMapComposition: <F extends TypeLambda, G extends TypeLambda>(
  F: Covariant<F>,
  G: Filterable<G>
) => <FR, FO, FE, GR, GO, GE, A, B>(
  self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>,
  f: (a: A) => Option.Option<B>
) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>
```


# partitionMapComposition

Returns a default binary `partitionMap` composition.

To import and use `partitionMapComposition` from the "Filterable" module:

```ts
import * as Filterable from "@effect/typeclass/Filterable"
// Can be accessed like this
Filterable.partitionMapComposition
```

**Signature**

```ts
export declare const partitionMapComposition: <F extends TypeLambda, G extends TypeLambda>(
  F: Covariant<F>,
  G: Filterable<G>
) => <FR, FO, FE, GR, GO, GE, A, B, C>(
  self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>,
  f: (a: A) => Either.Either<C, B>
) => [Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>, Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, C>>]
```


# zipRight

A variant of `flatMap` that ignores the value produced by this effect.

To import and use `zipRight` from the "FlatMap" module:

```ts
import * as FlatMap from "@effect/typeclass/FlatMap"
// Can be accessed like this
FlatMap.zipRight
```

**Signature**

```ts
export declare const zipRight: <F extends TypeLambda>(
  F: FlatMap<F>
) => {
  <R2, O2, E2, B>(
    that: Kind<F, R2, O2, E2, B>
  ): <R1, O1, E1, _>(self: Kind<F, R1, O1, E1, _>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, B>
  <R1, O1, E1, _, R2, O2, E2, B>(
    self: Kind<F, R1, O1, E1, _>,
    that: Kind<F, R2, O2, E2, B>
  ): Kind<F, R1 & R2, O1 | O2, E1 | E2, B>
}
```


# AlreadyFlat

Represents a `FlattenResult` where the input was already flat.

To import and use `AlreadyFlat` from the "Flatten" module:

```ts
import * as Flatten from "@effect/printer/Flatten"
// Can be accessed like this
Flatten.AlreadyFlat
```


# Flatten

Because certain documents do not change after removal of newlines, etc, there
is no point in creating a `Union` of the flattened and unflattened versions.
All this leads to is the introduction of two possible branches for a layout
algorithm to take, resulting in potentially exponential behavior on deeply
nested examples.

To import and use `Flatten` from the "Flatten" module:

```ts
import * as Flatten from "@effect/printer/Flatten"
// Can be accessed like this
Flatten.Flatten
```


# Flattened

Represents a `FlattenResult` where `A` is likely flatter than the input.

To import and use `Flattened` from the "Flatten" module:

```ts
import * as Flatten from "@effect/printer/Flatten"
// Can be accessed like this
Flatten.Flattened
```


# isAlreadyFlat

Returns `true` if the specified `Flatten` is an `AlreadyFlat`, `false` otherwise.

To import and use `isAlreadyFlat` from the "Flatten" module:

```ts
import * as Flatten from "@effect/printer/Flatten"
// Can be accessed like this
Flatten.isAlreadyFlat
```

**Signature**

```ts
export declare const isAlreadyFlat: <A>(a: Flatten<A>) => a is AlreadyFlat<A>
```


# isFlatten

Returns `true` if the specified value is a `Flatten`, `false` otherwise.

To import and use `isFlatten` from the "Flatten" module:

```ts
import * as Flatten from "@effect/printer/Flatten"
// Can be accessed like this
Flatten.isFlatten
```

**Signature**

```ts
export declare const isFlatten: (u: unknown) => u is Flatten<unknown>
```


# isFlattened

Returns `true` if the specified `Flatten` is a `Flattened`, `false` otherwise.

To import and use `isFlattened` from the "Flatten" module:

```ts
import * as Flatten from "@effect/printer/Flatten"
// Can be accessed like this
Flatten.isFlattened
```

**Signature**

```ts
export declare const isFlattened: <A>(a: Flatten<A>) => a is Flattened<A>
```


# isNeverFlat

Returns `true` if the specified `Flatten` is a `NeverFlat`, `false` otherwise.

To import and use `isNeverFlat` from the "Flatten" module:

```ts
import * as Flatten from "@effect/printer/Flatten"
// Can be accessed like this
Flatten.isNeverFlat
```

**Signature**

```ts
export declare const isNeverFlat: <A>(a: Flatten<A>) => a is NeverFlat<A>
```


# NeverFlat

Represents a `FlattenResult` where the input cannot be flattened.

To import and use `NeverFlat` from the "Flatten" module:

```ts
import * as Flatten from "@effect/printer/Flatten"
// Can be accessed like this
Flatten.NeverFlat
```


# reduceComposition

Returns a default ternary `reduce` composition.

To import and use `reduceComposition` from the "Foldable" module:

```ts
import * as Foldable from "@effect/typeclass/Foldable"
// Can be accessed like this
Foldable.reduceComposition
```

**Signature**

```ts
export declare const reduceComposition: <F extends TypeLambda, G extends TypeLambda>(
  F: Foldable<F>,
  G: Foldable<G>
) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, b: B, f: (b: B, a: A) => B) => B
```


# absurd

The `absurd` function is a stub for cases where a value of type `never` is encountered in your code,
meaning that it should be impossible for this code to be executed.

This function is particularly useful when it's necessary to specify that certain cases are impossible.

To import and use `absurd` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.absurd
```

**Signature**

```ts
export declare const absurd: <A>(_: never) => A
```


# apply

Apply a function to a given value.

To import and use `apply` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.apply
```

**Example**

```ts
import { pipe, apply } from "effect/Function"
import { length } from "effect/String"

assert.deepStrictEqual(pipe(length, apply("hello")), 5)
```

**Signature**

```ts
export declare const apply: <A>(a: A) => <B>(self: (a: A) => B) => B
```


# compose

Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.
The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.

To import and use `compose` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.compose
```

**Example**

```ts
import { compose } from "effect/Function"

const increment = (n: number) => n + 1
const square = (n: number) => n * n

assert.strictEqual(compose(increment, square)(2), 9)
```

**Signature**

```ts
export declare const compose: {
  <B, C>(bc: (b: B) => C): <A>(self: (a: A) => B) => (a: A) => C
  <A, B, C>(self: (a: A) => B, bc: (b: B) => C): (a: A) => C
}
```


# constant

Creates a constant value that never changes.

This is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)
and want that inner function to always use the same value, no matter how many times it is called.

To import and use `constant` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.constant
```

**Example**

```ts
import { constant } from "effect/Function"

const constNull = constant(null)

assert.deepStrictEqual(constNull(), null)
assert.deepStrictEqual(constNull(), null)
```

**Signature**

```ts
export declare const constant: <A>(value: A) => LazyArg<A>
```


# constFalse

A thunk that returns always `false`.

To import and use `constFalse` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.constFalse
```

**Example**

```ts
import { constFalse } from "effect/Function"

assert.deepStrictEqual(constFalse(), false)
```

**Signature**

```ts
export declare const constFalse: LazyArg<boolean>
```


# constNull

A thunk that returns always `null`.

To import and use `constNull` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.constNull
```

**Example**

```ts
import { constNull } from "effect/Function"

assert.deepStrictEqual(constNull(), null)
```

**Signature**

```ts
export declare const constNull: LazyArg<null>
```


# constTrue

A thunk that returns always `true`.

To import and use `constTrue` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.constTrue
```

**Example**

```ts
import { constTrue } from "effect/Function"

assert.deepStrictEqual(constTrue(), true)
```

**Signature**

```ts
export declare const constTrue: LazyArg<boolean>
```


# constUndefined

A thunk that returns always `undefined`.

To import and use `constUndefined` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.constUndefined
```

**Example**

```ts
import { constUndefined } from "effect/Function"

assert.deepStrictEqual(constUndefined(), undefined)
```

**Signature**

```ts
export declare const constUndefined: LazyArg<undefined>
```


# constVoid

A thunk that returns always `void`.

To import and use `constVoid` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.constVoid
```

**Example**

```ts
import { constVoid } from "effect/Function"

assert.deepStrictEqual(constVoid(), undefined)
```

**Signature**

```ts
export declare const constVoid: LazyArg<void>
```


# dual

Creates a function that can be used in a data-last (aka `pipe`able) or
data-first style.

The first parameter to `dual` is either the arity of the uncurried function
or a predicate that determines if the function is being used in a data-first
or data-last style.

Using the arity is the most common use case, but there are some cases where
you may want to use a predicate. For example, if you have a function that
takes an optional argument, you can use a predicate to determine if the
function is being used in a data-first or data-last style.

To import and use `dual` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.dual
```

**Example**

```ts
import { dual, pipe } from "effect/Function"

// Exampe using arity to determine data-first or data-last style
const sum: {
  (that: number): (self: number) => number
  (self: number, that: number): number
} = dual(2, (self: number, that: number): number => self + that)

assert.deepStrictEqual(sum(2, 3), 5)
assert.deepStrictEqual(pipe(2, sum(3)), 5)

// Example using a predicate to determine data-first or data-last style
const sum2: {
  (that: number): (self: number) => number
  (self: number, that: number): number
} = dual(
  (args) => args.length === 1,
  (self: number, that: number): number => self + that
)

assert.deepStrictEqual(sum(2, 3), 5)
assert.deepStrictEqual(pipe(2, sum(3)), 5)
```

**Signature**

```ts
export declare const dual: {
  <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(
    arity: Parameters<DataFirst>["length"],
    body: DataFirst
  ): DataLast & DataFirst
  <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(
    isDataFirst: (args: IArguments) => boolean,
    body: DataFirst
  ): DataLast & DataFirst
}
```


# flip

Reverses the order of arguments for a curried function.

To import and use `flip` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.flip
```

**Example**

```ts
import { flip } from "effect/Function"

const f = (a: number) => (b: string) => a - b.length

assert.deepStrictEqual(flip(f)("aaa")(2), -1)
```

**Signature**

```ts
export declare const flip: <A extends Array<unknown>, B extends Array<unknown>, C>(
  f: (...a: A) => (...b: B) => C
) => (...b: B) => (...a: A) => C
```


# flow

Performs left-to-right function composition. The first argument may have any arity, the remaining arguments must be unary.

See also [`pipe`](#pipe).

To import and use `flow` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.flow
```

**Example**

```ts
import { flow } from "effect/Function"

const len = (s: string): number => s.length
const double = (n: number): number => n * 2

const f = flow(len, double)

assert.strictEqual(f("aaa"), 6)
```

**Signature**

```ts
export declare function flow<A extends ReadonlyArray<unknown>, B = never>(ab: (...a: A) => B): (...a: A) => B
export declare function flow<A extends ReadonlyArray<unknown>, B = never, C = never>(
  ab: (...a: A) => B,
  bc: (b: B) => C
): (...a: A) => C
export declare function flow<A extends ReadonlyArray<unknown>, B = never, C = never, D = never>(
  ab: (...a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D
): (...a: A) => D
export declare function flow<A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never>(
  ab: (...a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E
): (...a: A) => E
export declare function flow<A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never>(
  ab: (...a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F
): (...a: A) => F
export declare function flow<
  A extends ReadonlyArray<unknown>,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never
>(
  ab: (...a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G
): (...a: A) => G
export declare function flow<
  A extends ReadonlyArray<unknown>,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never
>(
  ab: (...a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H
): (...a: A) => H
export declare function flow<
  A extends ReadonlyArray<unknown>,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never
>(
  ab: (...a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I
): (...a: A) => I
export declare function flow<
  A extends ReadonlyArray<unknown>,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never
>(
  ab: (...a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J
): (...a: A) => J
```


# hole

Type hole simulation.

To import and use `hole` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.hole
```

**Signature**

```ts
export declare const hole: <T>() => T
```


# identity

The identity function, i.e. A function that returns its input argument.

To import and use `identity` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.identity
```

**Example**

```ts
import { identity } from "effect/Function"

assert.deepStrictEqual(identity(5), 5)
```

**Signature**

```ts
export declare const identity: <A>(a: A) => A
```


# isFunction

Tests if a value is a `function`.

To import and use `isFunction` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.isFunction
```

**Example**

```ts
import { isFunction } from "effect/Predicate"

assert.deepStrictEqual(isFunction(isFunction), true)
assert.deepStrictEqual(isFunction("function"), false)
```

**Signature**

```ts
export declare const isFunction: (input: unknown) => input is Function
```


# LazyArg

A lazy argument.

To import and use `LazyArg` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.LazyArg
```

**Example**

```ts
import { LazyArg, constant } from "effect/Function"

const constNull: LazyArg<null> = constant(null)
```


# pipe

Pipes the value of an expression into a pipeline of functions.

**When to Use**

This is useful in combination with data-last functions as a simulation of
methods:

```ts
as.map(f).filter(g)
```

becomes:

```ts
import { pipe, Array } from "effect"

pipe(as, Array.map(f), Array.filter(g))
```

**Details**

The `pipe` function is a utility that allows us to compose functions in a
readable and sequential manner. It takes the output of one function and
passes it as the input to the next function in the pipeline. This enables us
to build complex transformations by chaining multiple functions together.

```ts
import { pipe } from "effect"

const result = pipe(input, func1, func2, ..., funcN)
```

In this syntax, `input` is the initial value, and `func1`, `func2`, ...,
`funcN` are the functions to be applied in sequence. The result of each
function becomes the input for the next function, and the final result is
returned.

Here's an illustration of how `pipe` works:

```text
                    
 input  func1  func2   ...   funcN  result 
                    
```

It's important to note that functions passed to `pipe` must have a **single
argument** because they are only called with a single argument.

To import and use `pipe` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.pipe
```

**Example**

```ts
// Example: Chaining Arithmetic Operations
import { pipe } from "effect"

// Define simple arithmetic operations
const increment = (x: number) => x + 1
const double = (x: number) => x * 2
const subtractTen = (x: number) => x - 10

// Sequentially apply these operations using `pipe`
const result = pipe(5, increment, double, subtractTen)

console.log(result)
// Output: 2
```

**Signature**

```ts
export declare function pipe<A>(a: A): A
export declare function pipe<A, B = never>(a: A, ab: (a: A) => B): B
export declare function pipe<A, B = never, C = never>(a: A, ab: (a: A) => B, bc: (b: B) => C): C
export declare function pipe<A, B = never, C = never, D = never>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D
): D
export declare function pipe<A, B = never, C = never, D = never, E = never>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E
): E
export declare function pipe<A, B = never, C = never, D = never, E = never, F = never>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F
): F
export declare function pipe<A, B = never, C = never, D = never, E = never, F = never, G = never>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G
): G
export declare function pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H
): H
export declare function pipe<A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I
): I
export declare function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J
): J
export declare function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K
): K
export declare function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L
): L
export declare function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M
): M
export declare function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N
): N
export declare function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O
): O
export declare function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P
): P
export declare function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
  Q = never
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
  pq: (p: P) => Q
): Q
export declare function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
  Q = never,
  R = never
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
  pq: (p: P) => Q,
  qr: (q: Q) => R
): R
export declare function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
  Q = never,
  R = never,
  S = never
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
  pq: (p: P) => Q,
  qr: (q: Q) => R,
  rs: (r: R) => S
): S
export declare function pipe<
  A,
  B = never,
  C = never,
  D = never,
  E = never,
  F = never,
  G = never,
  H = never,
  I = never,
  J = never,
  K = never,
  L = never,
  M = never,
  N = never,
  O = never,
  P = never,
  Q = never,
  R = never,
  S = never,
  T = never
>(
  a: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E,
  ef: (e: E) => F,
  fg: (f: F) => G,
  gh: (g: G) => H,
  hi: (h: H) => I,
  ij: (i: I) => J,
  jk: (j: J) => K,
  kl: (k: K) => L,
  lm: (l: L) => M,
  mn: (m: M) => N,
  no: (n: N) => O,
  op: (o: O) => P,
  pq: (p: P) => Q,
  qr: (q: Q) => R,
  rs: (r: R) => S,
  st: (s: S) => T
): T
```


# satisfies

A function that ensures that the type of an expression matches some type,
without changing the resulting type of that expression.

To import and use `satisfies` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.satisfies
```

**Example**

```ts
import { satisfies } from "effect/Function"

const test1 = satisfies<number>()(5 as const)
//^? const test: 5
// @ts-expect-error
const test2 = satisfies<string>()(5)
//^? Argument of type 'number' is not assignable to parameter of type 'string'

assert.deepStrictEqual(satisfies<number>()(5), 5)
```

**Signature**

```ts
export declare const satisfies: <A>() => <B extends A>(b: B) => B
```


# SK

The SK combinator, also known as the "S-K combinator" or "S-combinator", is a fundamental combinator in the
lambda calculus and the SKI combinator calculus.

This function is useful for discarding the first argument passed to it and returning the second argument.

To import and use `SK` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.SK
```

**Example**

```ts
import { SK } from "effect/Function"

assert.deepStrictEqual(SK(0, "hello"), "hello")
```

**Signature**

```ts
export declare const SK: <A, B>(_: A, b: B) => B
```


# tupled

Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.

To import and use `tupled` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.tupled
```

**Example**

```ts
import { tupled } from "effect/Function"

const sumTupled = tupled((x: number, y: number): number => x + y)

assert.deepStrictEqual(sumTupled([1, 2]), 3)
```

**Signature**

```ts
export declare const tupled: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B) => (a: A) => B
```


# unsafeCoerce

Casts the result to the specified type.

To import and use `unsafeCoerce` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.unsafeCoerce
```

**Example**

```ts
import { unsafeCoerce, identity } from "effect/Function"

assert.deepStrictEqual(unsafeCoerce, identity)
```

**Signature**

```ts
export declare const unsafeCoerce: <A, B>(a: A) => B
```


# untupled

Inverse function of `tupled`

To import and use `untupled` from the "Function" module:

```ts
import * as Function from "effect/Function"
// Can be accessed like this
Function.untupled
```

**Example**

```ts
import { untupled } from "effect/Function"

const getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])

assert.deepStrictEqual(getFirst(1, 2), 1)
```

**Signature**

```ts
export declare const untupled: <A extends ReadonlyArray<unknown>, B>(f: (a: A) => B) => (...a: A) => B
```


# globalValue

Retrieves or computes a global value associated with the given `id`. If the value for this `id`
has already been computed, it will be returned from the global store. If it does not exist yet,
the provided `compute` function will be executed to compute the value, store it, and then return it.

This ensures that even in cases where the module is imported multiple times (e.g., in mixed environments
like CommonJS and ESM, or during hot-reloading in development), the value is computed only once and reused
thereafter.

To import and use `globalValue` from the "GlobalValue" module:

```ts
import * as GlobalValue from "effect/GlobalValue"
// Can be accessed like this
GlobalValue.globalValue
```

**Example**

```ts
import { globalValue } from "effect/GlobalValue"

// This cache will persist as long as the module is running,
// even if reloaded or imported elsewhere
const myCache = globalValue(Symbol.for("myCache"), () => new WeakMap<object, number>())
```

**Signature**

```ts
export declare const globalValue: <A>(id: unknown, compute: () => A) => A
```


# evaluate

Run the function across all groups, collecting the results in an
arbitrary order.

To import and use `evaluate` from the "GroupBy" module:

```ts
import * as GroupBy from "effect/GroupBy"
// Can be accessed like this
GroupBy.evaluate
```

**Signature**

```ts
export declare const evaluate: {
  <K, V, E, A, E2, R2>(
    f: (key: K, stream: Stream.Stream<V, E, never>) => Stream.Stream<A, E2, R2>,
    options?: { readonly bufferSize?: number | undefined } | undefined
  ): <R>(self: GroupBy<K, V, E, R>) => Stream.Stream<A, E | E2, R2 | R>
  <K, V, E, R, A, E2, R2>(
    self: GroupBy<K, V, E, R>,
    f: (key: K, stream: Stream.Stream<V, E, never>) => Stream.Stream<A, E2, R2>,
    options?: { readonly bufferSize?: number | undefined } | undefined
  ): Stream.Stream<A, E | E2, R | R2>
}
```


# filter

Filter the groups to be processed.

To import and use `filter` from the "GroupBy" module:

```ts
import * as GroupBy from "effect/GroupBy"
// Can be accessed like this
GroupBy.filter
```

**Signature**

```ts
export declare const filter: {
  <K>(predicate: Predicate<NoInfer<K>>): <V, E, R>(self: GroupBy<K, V, E, R>) => GroupBy<K, V, E, R>
  <K, V, E, R>(self: GroupBy<K, V, E, R>, predicate: Predicate<K>): GroupBy<K, V, E, R>
}
```


# first

Only consider the first `n` groups found in the `Stream`.

To import and use `first` from the "GroupBy" module:

```ts
import * as GroupBy from "effect/GroupBy"
// Can be accessed like this
GroupBy.first
```

**Signature**

```ts
export declare const first: {
  (n: number): <K, V, E, R>(self: GroupBy<K, V, E, R>) => GroupBy<K, V, E, R>
  <K, V, E, R>(self: GroupBy<K, V, E, R>, n: number): GroupBy<K, V, E, R>
}
```


# GroupBy

Representation of a grouped stream. This allows to filter which groups will
be processed. Once this is applied all groups will be processed in parallel
and the results will be merged in arbitrary order.

To import and use `GroupBy` from the "GroupBy" module:

```ts
import * as GroupBy from "effect/GroupBy"
// Can be accessed like this
GroupBy.GroupBy
```


# make

Constructs a `GroupBy` from a `Stream`.

To import and use `make` from the "GroupBy" module:

```ts
import * as GroupBy from "effect/GroupBy"
// Can be accessed like this
GroupBy.make
```

**Signature**

```ts
export declare const make: <K, V, E, R>(
  grouped: Stream.Stream<readonly [K, Queue.Dequeue<Take.Take<V, E>>], E, R>
) => GroupBy<K, V, E, R>
```


# beginMutation

Marks the `HashMap` as mutable.

To import and use `beginMutation` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.beginMutation
```

**Signature**

```ts
export declare const beginMutation: <K, V>(self: HashMap<K, V>) => HashMap<K, V>
```


# compact

Filters out `None` values from a `HashMap` of `Options`s.

To import and use `compact` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.compact
```

**Signature**

```ts
export declare const compact: <K, A>(self: HashMap<K, Option<A>>) => HashMap<K, A>
```


# empty

Creates a new `HashMap`.

To import and use `empty` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.empty
```

**Signature**

```ts
export declare const empty: <K = never, V = never>() => HashMap<K, V>
```


# endMutation

Marks the `HashMap` as immutable.

To import and use `endMutation` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.endMutation
```

**Signature**

```ts
export declare const endMutation: <K, V>(self: HashMap<K, V>) => HashMap<K, V>
```


# entries

Returns an `IterableIterator` of the entries within the `HashMap`.

To import and use `entries` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.entries
```

**Signature**

```ts
export declare const entries: <K, V>(self: HashMap<K, V>) => IterableIterator<[K, V]>
```


# filter

Filters entries out of a `HashMap` using the specified predicate.

To import and use `filter` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.filter
```

**Signature**

```ts
export declare const filter: {
  <K, A, B extends A>(f: (a: NoInfer<A>, k: K) => a is B): (self: HashMap<K, A>) => HashMap<K, B>
  <K, A>(f: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => HashMap<K, A>
  <K, A, B extends A>(self: HashMap<K, A>, f: (a: A, k: K) => a is B): HashMap<K, B>
  <K, A>(self: HashMap<K, A>, f: (a: A, k: K) => boolean): HashMap<K, A>
}
```


# filterMap

Maps over the entries of the `HashMap` using the specified partial function
and filters out `None` values.

To import and use `filterMap` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.filterMap
```

**Signature**

```ts
export declare const filterMap: {
  <A, K, B>(f: (value: A, key: K) => Option<B>): (self: HashMap<K, A>) => HashMap<K, B>
  <K, A, B>(self: HashMap<K, A>, f: (value: A, key: K) => Option<B>): HashMap<K, B>
}
```


# findFirst

Returns the first element that satisfies the specified
predicate, or `None` if no such element exists.

To import and use `findFirst` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.findFirst
```

**Signature**

```ts
export declare const findFirst: {
  <K, A, B extends A>(predicate: (a: NoInfer<A>, k: K) => a is B): (self: HashMap<K, A>) => Option<[K, B]>
  <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => Option<[K, A]>
  <K, A, B extends A>(self: HashMap<K, A>, predicate: (a: A, k: K) => a is B): Option<[K, B]>
  <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): Option<[K, A]>
}
```


# flatMap

Chains over the entries of the `HashMap` using the specified function.

**NOTE**: the hash and equal of both maps have to be the same.

To import and use `flatMap` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.flatMap
```

**Signature**

```ts
export declare const flatMap: {
  <A, K, B>(f: (value: A, key: K) => HashMap<K, B>): (self: HashMap<K, A>) => HashMap<K, B>
  <K, A, B>(self: HashMap<K, A>, f: (value: A, key: K) => HashMap<K, B>): HashMap<K, B>
}
```


# forEach

Applies the specified function to the entries of the `HashMap`.

To import and use `forEach` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.forEach
```

**Signature**

```ts
export declare const forEach: {
  <V, K>(f: (value: V, key: K) => void): (self: HashMap<K, V>) => void
  <V, K>(self: HashMap<K, V>, f: (value: V, key: K) => void): void
}
```


# fromIterable

Creates a new `HashMap` from an iterable collection of key/value pairs.

To import and use `fromIterable` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.fromIterable
```

**Signature**

```ts
export declare const fromIterable: <K, V>(entries: Iterable<readonly [K, V]>) => HashMap<K, V>
```


# get

Safely lookup the value for the specified key in the `HashMap` using the
internal hashing function.

To import and use `get` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.get
```

**Signature**

```ts
export declare const get: {
  <K1>(key: K1): <K, V>(self: HashMap<K, V>) => Option<V>
  <K, V, K1>(self: HashMap<K, V>, key: K1): Option<V>
}
```


# getHash

Lookup the value for the specified key in the `HashMap` using a custom hash.

To import and use `getHash` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.getHash
```

**Signature**

```ts
export declare const getHash: {
  <K1>(key: K1, hash: number): <K, V>(self: HashMap<K, V>) => Option<V>
  <K, V, K1>(self: HashMap<K, V>, key: K1, hash: number): Option<V>
}
```


# has

Checks if the specified key has an entry in the `HashMap`.

To import and use `has` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.has
```

**Signature**

```ts
export declare const has: {
  <K1>(key: K1): <K, V>(self: HashMap<K, V>) => boolean
  <K, V, K1>(self: HashMap<K, V>, key: K1): boolean
}
```


# hasHash

Checks if the specified key has an entry in the `HashMap` using a custom
hash.

To import and use `hasHash` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.hasHash
```

**Signature**

```ts
export declare const hasHash: {
  <K1>(key: K1, hash: number): <K, V>(self: HashMap<K, V>) => boolean
  <K, V, K1>(self: HashMap<K, V>, key: K1, hash: number): boolean
}
```


# isEmpty

Checks if the `HashMap` contains any entries.

To import and use `isEmpty` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.isEmpty
```

**Signature**

```ts
export declare const isEmpty: <K, V>(self: HashMap<K, V>) => boolean
```


# keys

Returns an `IterableIterator` of the keys within the `HashMap`.

To import and use `keys` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.keys
```

**Signature**

```ts
export declare const keys: <K, V>(self: HashMap<K, V>) => IterableIterator<K>
```


# keySet

Returns a `HashSet` of keys within the `HashMap`.

To import and use `keySet` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.keySet
```

**Signature**

```ts
export declare const keySet: <K, V>(self: HashMap<K, V>) => HashSet<K>
```


# make

Constructs a new `HashMap` from an array of key/value pairs.

To import and use `make` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.make
```

**Signature**

```ts
export declare const make: <Entries extends ReadonlyArray<readonly [any, any]>>(
  ...entries: Entries
) => HashMap<
  Entries[number] extends readonly [infer K, any] ? K : never,
  Entries[number] extends readonly [any, infer V] ? V : never
>
```


# map

Maps over the entries of the `HashMap` using the specified function.

To import and use `map` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.map
```

**Signature**

```ts
export declare const map: {
  <A, V, K>(f: (value: V, key: K) => A): (self: HashMap<K, V>) => HashMap<K, A>
  <K, V, A>(self: HashMap<K, V>, f: (value: V, key: K) => A): HashMap<K, A>
}
```


# modify

Updates the value of the specified key within the `HashMap` if it exists.

To import and use `modify` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.modify
```

**Signature**

```ts
export declare const modify: {
  <K, V>(key: K, f: (v: V) => V): (self: HashMap<K, V>) => HashMap<K, V>
  <K, V>(self: HashMap<K, V>, key: K, f: (v: V) => V): HashMap<K, V>
}
```


# modifyAt

Set or remove the specified key in the `HashMap` using the specified
update function. The value of the specified key will be computed using the
provided hash.

The update function will be invoked with the current value of the key if it
exists, or `None` if no such value exists.

To import and use `modifyAt` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.modifyAt
```

**Signature**

```ts
export declare const modifyAt: {
  <K, V>(key: K, f: HashMap.UpdateFn<V>): (self: HashMap<K, V>) => HashMap<K, V>
  <K, V>(self: HashMap<K, V>, key: K, f: HashMap.UpdateFn<V>): HashMap<K, V>
}
```


# modifyHash

Alter the value of the specified key in the `HashMap` using the specified
update function. The value of the specified key will be computed using the
provided hash.

The update function will be invoked with the current value of the key if it
exists, or `None` if no such value exists.

This function will always either update or insert a value into the `HashMap`.

To import and use `modifyHash` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.modifyHash
```

**Signature**

```ts
export declare const modifyHash: {
  <K, V>(key: K, hash: number, f: HashMap.UpdateFn<V>): (self: HashMap<K, V>) => HashMap<K, V>
  <K, V>(self: HashMap<K, V>, key: K, hash: number, f: HashMap.UpdateFn<V>): HashMap<K, V>
}
```


# mutate

Mutates the `HashMap` within the context of the provided function.

To import and use `mutate` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.mutate
```

**Signature**

```ts
export declare const mutate: {
  <K, V>(f: (self: HashMap<K, V>) => void): (self: HashMap<K, V>) => HashMap<K, V>
  <K, V>(self: HashMap<K, V>, f: (self: HashMap<K, V>) => void): HashMap<K, V>
}
```


# reduce

Reduces the specified state over the entries of the `HashMap`.

To import and use `reduce` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.reduce
```

**Signature**

```ts
export declare const reduce: {
  <Z, V, K>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: HashMap<K, V>) => Z
  <K, V, Z>(self: HashMap<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z
}
```


# remove

Remove the entry for the specified key in the `HashMap` using the internal
hashing function.

To import and use `remove` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.remove
```

**Signature**

```ts
export declare const remove: {
  <K>(key: K): <V>(self: HashMap<K, V>) => HashMap<K, V>
  <K, V>(self: HashMap<K, V>, key: K): HashMap<K, V>
}
```


# removeMany

Removes all entries in the `HashMap` which have the specified keys.

To import and use `removeMany` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.removeMany
```

**Signature**

```ts
export declare const removeMany: {
  <K>(keys: Iterable<K>): <V>(self: HashMap<K, V>) => HashMap<K, V>
  <K, V>(self: HashMap<K, V>, keys: Iterable<K>): HashMap<K, V>
}
```


# set

Sets the specified key to the specified value using the internal hashing
function.

To import and use `set` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.set
```

**Signature**

```ts
export declare const set: {
  <K, V>(key: K, value: V): (self: HashMap<K, V>) => HashMap<K, V>
  <K, V>(self: HashMap<K, V>, key: K, value: V): HashMap<K, V>
}
```


# size

Returns the number of entries within the `HashMap`.

To import and use `size` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.size
```

**Signature**

```ts
export declare const size: <K, V>(self: HashMap<K, V>) => number
```


# some

Checks if any entry in a hashmap meets a specific condition.

To import and use `some` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.some
```

**Signature**

```ts
export declare const some: {
  <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => boolean
  <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean
}
```


# toEntries

Returns an `Array<[K, V]>` of the entries within the `HashMap`.

To import and use `toEntries` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.toEntries
```

**Signature**

```ts
export declare const toEntries: <K, V>(self: HashMap<K, V>) => Array<[K, V]>
```


# toValues

Returns an `Array` of the values within the `HashMap`.

To import and use `toValues` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.toValues
```

**Signature**

```ts
export declare const toValues: <K, V>(self: HashMap<K, V>) => Array<V>
```


# union

Performs a union of this `HashMap` and that `HashMap`.

To import and use `union` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.union
```

**Signature**

```ts
export declare const union: {
  <K1, V1>(that: HashMap<K1, V1>): <K0, V0>(self: HashMap<K0, V0>) => HashMap<K1 | K0, V1 | V0>
  <K0, V0, K1, V1>(self: HashMap<K0, V0>, that: HashMap<K1, V1>): HashMap<K0 | K1, V0 | V1>
}
```


# unsafeGet

Unsafely lookup the value for the specified key in the `HashMap` using the
internal hashing function.

To import and use `unsafeGet` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.unsafeGet
```

**Signature**

```ts
export declare const unsafeGet: {
  <K1>(key: K1): <K, V>(self: HashMap<K, V>) => V
  <K, V, K1>(self: HashMap<K, V>, key: K1): V
}
```


# values

Returns an `IterableIterator` of the values within the `HashMap`.

To import and use `values` from the "HashMap" module:

```ts
import * as HashMap from "effect/HashMap"
// Can be accessed like this
HashMap.values
```

**Signature**

```ts
export declare const values: <K, V>(self: HashMap<K, V>) => IterableIterator<V>
```


# add

Adds a value to the `HashSet`.

To import and use `add` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.add
```

**Signature**

```ts
export declare const add: {
  <A>(value: A): (self: HashSet<A>) => HashSet<A>
  <A>(self: HashSet<A>, value: A): HashSet<A>
}
```


# beginMutation

Marks the `HashSet` as mutable.

To import and use `beginMutation` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.beginMutation
```

**Signature**

```ts
export declare const beginMutation: <A>(self: HashSet<A>) => HashSet<A>
```


# difference

Computes the set difference between this `HashSet` and the specified
`Iterable<A>`.

**NOTE**: the hash and equal of the values in both the set and the iterable
must be the same.

To import and use `difference` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.difference
```

**Signature**

```ts
export declare const difference: {
  <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>
  <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>
}
```


# empty

Creates an empty `HashSet`.

To import and use `empty` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.empty
```

**Signature**

```ts
export declare const empty: <A = never>() => HashSet<A>
```


# endMutation

Marks the `HashSet` as immutable.

To import and use `endMutation` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.endMutation
```

**Signature**

```ts
export declare const endMutation: <A>(self: HashSet<A>) => HashSet<A>
```


# every

Check if a predicate holds true for every `HashSet` element.

To import and use `every` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.every
```

**Signature**

```ts
export declare const every: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => self is HashSet<B>
  <A>(predicate: Predicate<A>): (self: HashSet<A>) => boolean
  <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): self is HashSet<B>
  <A>(self: HashSet<A>, predicate: Predicate<A>): boolean
}
```


# filter

Filters values out of a `HashSet` using the specified predicate.

To import and use `filter` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.filter
```

**Signature**

```ts
export declare const filter: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => HashSet<B>
  <A>(predicate: Predicate<NoInfer<A>>): (self: HashSet<A>) => HashSet<A>
  <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): HashSet<B>
  <A>(self: HashSet<A>, predicate: Predicate<A>): HashSet<A>
}
```


# flatMap

Chains over the values of the `HashSet` using the specified function.

To import and use `flatMap` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.flatMap
```

**Signature**

```ts
export declare const flatMap: {
  <A, B>(f: (a: A) => Iterable<B>): (self: HashSet<A>) => HashSet<B>
  <A, B>(self: HashSet<A>, f: (a: A) => Iterable<B>): HashSet<B>
}
```


# forEach

Applies the specified function to the values of the `HashSet`.

To import and use `forEach` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.forEach
```

**Signature**

```ts
export declare const forEach: {
  <A>(f: (value: A) => void): (self: HashSet<A>) => void
  <A>(self: HashSet<A>, f: (value: A) => void): void
}
```


# fromIterable

Creates a new `HashSet` from an iterable collection of values.

To import and use `fromIterable` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.fromIterable
```

**Signature**

```ts
export declare const fromIterable: <A>(elements: Iterable<A>) => HashSet<A>
```


# has

Checks if the specified value exists in the `HashSet`.

To import and use `has` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.has
```

**Signature**

```ts
export declare const has: { <A>(value: A): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, value: A): boolean }
```


# intersection

Returns a `HashSet` of values which are present in both this set and that
`Iterable<A>`.

**NOTE**: the hash and equal of the values in both the set and the iterable
must be the same.

To import and use `intersection` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.intersection
```

**Signature**

```ts
export declare const intersection: {
  <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>
  <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>
}
```


# isSubset

Returns `true` if and only if every element in the this `HashSet` is an
element of the second set,

**NOTE**: the hash and equal of both sets must be the same.

To import and use `isSubset` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.isSubset
```

**Signature**

```ts
export declare const isSubset: {
  <A>(that: HashSet<A>): (self: HashSet<A>) => boolean
  <A>(self: HashSet<A>, that: HashSet<A>): boolean
}
```


# make

Construct a new `HashSet` from a variable number of values.

To import and use `make` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.make
```

**Signature**

```ts
export declare const make: <As extends ReadonlyArray<any>>(...elements: As) => HashSet<As[number]>
```


# map

Maps over the values of the `HashSet` using the specified function.

To import and use `map` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.map
```

**Signature**

```ts
export declare const map: {
  <A, B>(f: (a: A) => B): (self: HashSet<A>) => HashSet<B>
  <A, B>(self: HashSet<A>, f: (a: A) => B): HashSet<B>
}
```


# mutate

Mutates the `HashSet` within the context of the provided function.

To import and use `mutate` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.mutate
```

**Signature**

```ts
export declare const mutate: {
  <A>(f: (set: HashSet<A>) => void): (self: HashSet<A>) => HashSet<A>
  <A>(self: HashSet<A>, f: (set: HashSet<A>) => void): HashSet<A>
}
```


# partition

Partition the values of a `HashSet` using the specified predicate.

If a value matches the predicate, it will be placed into the `HashSet` on the
right side of the resulting `Tuple`, otherwise the value will be placed into
the left side.

To import and use `partition` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.partition
```

**Signature**

```ts
export declare const partition: {
  <A, B extends A>(
    refinement: Refinement<NoInfer<A>, B>
  ): (self: HashSet<A>) => [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]
  <A>(predicate: Predicate<NoInfer<A>>): (self: HashSet<A>) => [excluded: HashSet<A>, satisfying: HashSet<A>]
  <A, B extends A>(
    self: HashSet<A>,
    refinement: Refinement<A, B>
  ): [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]
  <A>(self: HashSet<A>, predicate: Predicate<A>): [excluded: HashSet<A>, satisfying: HashSet<A>]
}
```


# reduce

Reduces the specified state over the values of the `HashSet`.

To import and use `reduce` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.reduce
```

**Signature**

```ts
export declare const reduce: {
  <A, Z>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: HashSet<A>) => Z
  <A, Z>(self: HashSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z
}
```


# remove

Removes a value from the `HashSet`.

To import and use `remove` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.remove
```

**Signature**

```ts
export declare const remove: {
  <A>(value: A): (self: HashSet<A>) => HashSet<A>
  <A>(self: HashSet<A>, value: A): HashSet<A>
}
```


# size

Calculates the number of values in the `HashSet`.

To import and use `size` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.size
```

**Signature**

```ts
export declare const size: <A>(self: HashSet<A>) => number
```


# some

Check if a predicate holds true for some `HashSet` element.

To import and use `some` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.some
```

**Signature**

```ts
export declare const some: {
  <A>(f: Predicate<A>): (self: HashSet<A>) => boolean
  <A>(self: HashSet<A>, f: Predicate<A>): boolean
}
```


# toggle

Checks if a value is present in the `HashSet`. If it is present, the value
will be removed from the `HashSet`, otherwise the value will be added to the
`HashSet`.

To import and use `toggle` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.toggle
```

**Signature**

```ts
export declare const toggle: {
  <A>(value: A): (self: HashSet<A>) => HashSet<A>
  <A>(self: HashSet<A>, value: A): HashSet<A>
}
```


# toValues

Returns an `Array` of the values within the `HashSet`.

To import and use `toValues` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.toValues
```

**Signature**

```ts
export declare const toValues: <A>(self: HashSet<A>) => Array<A>
```


# union

Computes the set union `(`self`+`that`)` between this `HashSet` and the
specified `Iterable<A>`.

**NOTE**: the hash and equal of the values in both the set and the iterable
must be the same.

To import and use `union` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.union
```

**Signature**

```ts
export declare const union: {
  <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>
  <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>
}
```


# values

Returns an `IterableIterator` of the values in the `HashSet`.

To import and use `values` from the "HashSet" module:

```ts
import * as HashSet from "effect/HashSet"
// Can be accessed like this
HashSet.values
```

**Signature**

```ts
export declare const values: <A>(self: HashSet<A>) => IterableIterator<A>
```


# HelpDoc

A `HelpDoc` models the full documentation for a command-line application.

`HelpDoc` is composed of optional header and footers, and in-between, a
list of HelpDoc-level content items.

HelpDoc-level content items, in turn, can be headers, paragraphs, description
lists, and enumerations.

A `HelpDoc` can be converted into plaintext, JSON, and HTML.

To import and use `HelpDoc` from the "HelpDoc" module:

```ts
import * as HelpDoc from "@effect/cli/HelpDoc"
// Can be accessed like this
HelpDoc.HelpDoc
```


# AdditionalSchemas

Adds additional schemas to components/schemas.
The provided schemas must have a `identifier` annotation.

To import and use `AdditionalSchemas` from the "HttpApi" module:

```ts
import * as HttpApi from "@effect/platform/HttpApi"
// Can be accessed like this
HttpApi.AdditionalSchemas
```


# HttpApi

An `HttpApi` is a collection of `HttpApiEndpoint`s. You can use an `HttpApi` to
represent a portion of your domain.

The endpoints can be implemented later using the `HttpApiBuilder.make` api.

To import and use `HttpApi` from the "HttpApi" module:

```ts
import * as HttpApi from "@effect/platform/HttpApi"
// Can be accessed like this
HttpApi.HttpApi
```


# make

An `HttpApi` is a collection of `HttpApiEndpoint`s. You can use an `HttpApi` to
represent a portion of your domain.

The endpoints can be implemented later using the `HttpApiBuilder.make` api.

To import and use `make` from the "HttpApi" module:

```ts
import * as HttpApi from "@effect/platform/HttpApi"
// Can be accessed like this
HttpApi.make
```

**Signature**

```ts
export declare const make: <const Id extends string>(identifier: Id) => HttpApi<Id, never, HttpApiDecodeError>
```


# reflect

Extract metadata from an `HttpApi`, which can be used to generate documentation
or other tooling.

See the `OpenApi` & `HttpApiClient` modules for examples of how to use this function.

To import and use `reflect` from the "HttpApi" module:

```ts
import * as HttpApi from "@effect/platform/HttpApi"
// Can be accessed like this
HttpApi.reflect
```

**Signature**

```ts
export declare const reflect: <Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, R>(
  self: HttpApi<Id, Groups, Error, R>,
  options: {
    readonly predicate?: Predicate.Predicate<{
      readonly endpoint: HttpApiEndpoint.HttpApiEndpoint.AnyWithProps
      readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps
    }>
    readonly onGroup: (options: {
      readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps
      readonly mergedAnnotations: Context.Context<never>
    }) => void
    readonly onEndpoint: (options: {
      readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps
      readonly endpoint: HttpApiEndpoint.HttpApiEndpoint<string, HttpMethod>
      readonly mergedAnnotations: Context.Context<never>
      readonly middleware: ReadonlySet<HttpApiMiddleware.TagClassAny>
      readonly payloads: ReadonlyMap<string, { readonly encoding: HttpApiSchema.Encoding; readonly ast: AST.AST }>
      readonly successes: ReadonlyMap<
        number,
        { readonly ast: Option.Option<AST.AST>; readonly description: Option.Option<string> }
      >
      readonly errors: ReadonlyMap<
        number,
        { readonly ast: Option.Option<AST.AST>; readonly description: Option.Option<string> }
      >
    }) => void
  }
) => void
```


# api

Create a top-level `HttpApi` layer.

To import and use `api` from the "HttpApiBuilder" module:

```ts
import * as HttpApiBuilder from "@effect/platform/HttpApiBuilder"
// Can be accessed like this
HttpApiBuilder.api
```

**Signature**

```ts
export declare const api: <Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, E, R>(
  api: HttpApi.HttpApi<Id, Groups, E, R>
) => Layer.Layer<
  HttpApi.Api,
  never,
  HttpApiGroup.HttpApiGroup.ToService<Id, Groups> | R | HttpApiGroup.HttpApiGroup.ErrorContext<Groups>
>
```


# group

Create a `Layer` that will implement all the endpoints in an `HttpApi`.

An unimplemented `Handlers` instance is passed to the `build` function, which
you can use to add handlers to the group.

You can implement endpoints using the `handlers.handle` api.

To import and use `group` from the "HttpApiBuilder" module:

```ts
import * as HttpApiBuilder from "@effect/platform/HttpApiBuilder"
// Can be accessed like this
HttpApiBuilder.group
```

**Signature**

```ts
export declare const group: <
  ApiId extends string,
  Groups extends HttpApiGroup.HttpApiGroup.Any,
  ApiError,
  ApiR,
  const Name extends HttpApiGroup.HttpApiGroup.Name<Groups>,
  Return
>(
  api: HttpApi.HttpApi<ApiId, Groups, ApiError, ApiR>,
  groupName: Name,
  build: (
    handlers: Handlers.FromGroup<ApiError, ApiR, HttpApiGroup.HttpApiGroup.WithName<Groups, Name>>
  ) => Handlers.ValidateReturn<Return>
) => Layer.Layer<
  HttpApiGroup.ApiGroup<ApiId, Name>,
  Handlers.Error<Return>,
  Exclude<Handlers.Context<Return> | HttpApiGroup.HttpApiGroup.MiddlewareWithName<Groups, Name>, Scope>
>
```


# handler

Create a `Handler` for a single endpoint.

To import and use `handler` from the "HttpApiBuilder" module:

```ts
import * as HttpApiBuilder from "@effect/platform/HttpApiBuilder"
// Can be accessed like this
HttpApiBuilder.handler
```

**Signature**

```ts
export declare const handler: <
  ApiId extends string,
  Groups extends HttpApiGroup.HttpApiGroup.Any,
  ApiError,
  ApiR,
  const GroupName extends Groups["identifier"],
  const Name extends HttpApiGroup.HttpApiGroup.EndpointsWithName<Groups, GroupName>["name"],
  R
>(
  _api: HttpApi.HttpApi<ApiId, Groups, ApiError, ApiR>,
  _groupName: GroupName,
  _name: Name,
  f: HttpApiEndpoint.HttpApiEndpoint.HandlerWithName<
    HttpApiGroup.HttpApiGroup.EndpointsWithName<Groups, GroupName>,
    Name,
    ApiError | HttpApiGroup.HttpApiGroup.ErrorWithName<Groups, GroupName>,
    R
  >
) => HttpApiEndpoint.HttpApiEndpoint.HandlerWithName<
  HttpApiGroup.HttpApiGroup.EndpointsWithName<Groups, GroupName>,
  Name,
  ApiError | HttpApiGroup.HttpApiGroup.ErrorWithName<Groups, GroupName>,
  R
>
```


# Handlers

Represents a handled `HttpApi`.

To import and use `Handlers` from the "HttpApiBuilder" module:

```ts
import * as HttpApiBuilder from "@effect/platform/HttpApiBuilder"
// Can be accessed like this
HttpApiBuilder.Handlers
```


# httpApp

Construct an `HttpApp` from an `HttpApi` instance.

To import and use `httpApp` from the "HttpApiBuilder" module:

```ts
import * as HttpApiBuilder from "@effect/platform/HttpApiBuilder"
// Can be accessed like this
HttpApiBuilder.httpApp
```

**Signature**

```ts
export declare const httpApp: Effect.Effect<
  HttpApp.Default<never, HttpRouter.HttpRouter.DefaultServices>,
  never,
  HttpApi.Api | Router | Middleware
>
```


# middleware

Create an `HttpApi` level middleware `Layer`.

To import and use `middleware` from the "HttpApiBuilder" module:

```ts
import * as HttpApiBuilder from "@effect/platform/HttpApiBuilder"
// Can be accessed like this
HttpApiBuilder.middleware
```

**Signature**

```ts
export declare const middleware: {
  <EX = never, RX = never>(
    middleware: MiddlewareFn<never> | Effect.Effect<MiddlewareFn<never>, EX, RX>,
    options?: { readonly withContext?: false | undefined }
  ): Layer.Layer<never, EX, Exclude<RX, Scope>>
  <R, EX = never, RX = never>(
    middleware: MiddlewareFn<never, R> | Effect.Effect<MiddlewareFn<never, R>, EX, RX>,
    options: { readonly withContext: true }
  ): Layer.Layer<never, EX, Exclude<HttpRouter.HttpRouter.ExcludeProvided<R> | RX, Scope>>
  <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR, EX = never, RX = never>(
    api: HttpApi.HttpApi<ApiId, Groups, Error, ErrorR>,
    middleware: MiddlewareFn<NoInfer<Error>> | Effect.Effect<MiddlewareFn<NoInfer<Error>>, EX, RX>,
    options?: { readonly withContext?: false | undefined }
  ): Layer.Layer<never, EX, Exclude<RX, Scope>>
  <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR, R, EX = never, RX = never>(
    api: HttpApi.HttpApi<ApiId, Groups, Error, ErrorR>,
    middleware: MiddlewareFn<NoInfer<Error>, R> | Effect.Effect<MiddlewareFn<NoInfer<Error>, R>, EX, RX>,
    options: { readonly withContext: true }
  ): Layer.Layer<never, EX, Exclude<HttpRouter.HttpRouter.ExcludeProvided<R> | RX, Scope>>
}
```


# middlewareCors

A CORS middleware layer that can be provided to the `HttpApiBuilder.serve` layer.

To import and use `middlewareCors` from the "HttpApiBuilder" module:

```ts
import * as HttpApiBuilder from "@effect/platform/HttpApiBuilder"
// Can be accessed like this
HttpApiBuilder.middlewareCors
```

**Signature**

```ts
export declare const middlewareCors: (
  options?:
    | {
        readonly allowedOrigins?: ReadonlyArray<string> | undefined
        readonly allowedMethods?: ReadonlyArray<string> | undefined
        readonly allowedHeaders?: ReadonlyArray<string> | undefined
        readonly exposedHeaders?: ReadonlyArray<string> | undefined
        readonly maxAge?: number | undefined
        readonly credentials?: boolean | undefined
      }
    | undefined
) => Layer.Layer<never>
```


# middlewareOpenApi

A middleware that adds an openapi.json endpoint to the API.

To import and use `middlewareOpenApi` from the "HttpApiBuilder" module:

```ts
import * as HttpApiBuilder from "@effect/platform/HttpApiBuilder"
// Can be accessed like this
HttpApiBuilder.middlewareOpenApi
```

**Signature**

```ts
export declare const middlewareOpenApi: (
  options?: { readonly path?: HttpApiEndpoint.PathSegment | undefined } | undefined
) => Layer.Layer<never, never, HttpApi.Api>
```


# Router

The router that the API endpoints are attached to.

To import and use `Router` from the "HttpApiBuilder" module:

```ts
import * as HttpApiBuilder from "@effect/platform/HttpApiBuilder"
// Can be accessed like this
HttpApiBuilder.Router
```


# securitySetCookie

Set a cookie from an `HttpApiSecurity.HttpApiKey` instance.

You can use this api before returning a response from an endpoint handler.

```ts
handlers.handle("authenticate", (_) => HttpApiBuilder.securitySetCookie(security, "secret123"))
```

To import and use `securitySetCookie` from the "HttpApiBuilder" module:

```ts
import * as HttpApiBuilder from "@effect/platform/HttpApiBuilder"
// Can be accessed like this
HttpApiBuilder.securitySetCookie
```

**Signature**

```ts
export declare const securitySetCookie: (
  self: HttpApiSecurity.ApiKey,
  value: string | Redacted.Redacted,
  options?: Cookie["options"]
) => Effect.Effect<void>
```


# serve

Build an `HttpApp` from an `HttpApi` instance, and serve it using an
`HttpServer`.

Optionally, you can provide a middleware function that will be applied to
the `HttpApp` before serving.

To import and use `serve` from the "HttpApiBuilder" module:

```ts
import * as HttpApiBuilder from "@effect/platform/HttpApiBuilder"
// Can be accessed like this
HttpApiBuilder.serve
```

**Signature**

```ts
export declare const serve: <R = never>(
  middleware?: (httpApp: HttpApp.Default) => HttpApp.Default<never, R>
) => Layer.Layer<
  never,
  never,
  | HttpServer.HttpServer
  | HttpRouter.HttpRouter.DefaultServices
  | Exclude<R, Scope | HttpServerRequest.HttpServerRequest>
  | HttpApi.Api
>
```


# toWebHandler

Construct an http web handler from an `HttpApi` instance.

To import and use `toWebHandler` from the "HttpApiBuilder" module:

```ts
import * as HttpApiBuilder from "@effect/platform/HttpApiBuilder"
// Can be accessed like this
HttpApiBuilder.toWebHandler
```

**Example**

```ts
import { HttpApi, HttpApiBuilder, HttpServer } from "@effect/platform"
import { Layer } from "effect"

class MyApi extends HttpApi.make("api") {}

const MyApiLive = HttpApiBuilder.api(MyApi)

const { dispose, handler } = HttpApiBuilder.toWebHandler(
  Layer.mergeAll(
    MyApiLive,
    // you could also use NodeHttpServer.layerContext, depending on your
    // server's platform
    HttpServer.layerContext
  )
)
```

**Signature**

```ts
export declare const toWebHandler: <LA, LE>(
  layer: Layer.Layer<LA | HttpApi.Api | HttpRouter.HttpRouter.DefaultServices, LE>,
  options?: {
    readonly middleware?: (
      httpApp: HttpApp.Default
    ) => HttpApp.Default<never, HttpApi.Api | Router | HttpRouter.HttpRouter.DefaultServices>
    readonly memoMap?: Layer.MemoMap
  }
) => {
  readonly handler: (request: Request, context?: Context.Context<never> | undefined) => Promise<Response>
  readonly dispose: () => Promise<void>
}
```


# HttpApiEndpoint

Represents an API endpoint. An API endpoint is mapped to a single route on
the underlying `HttpRouter`.

To import and use `HttpApiEndpoint` from the "HttpApiEndpoint" module:

```ts
import * as HttpApiEndpoint from "@effect/platform/HttpApiEndpoint"
// Can be accessed like this
HttpApiEndpoint.HttpApiEndpoint
```


# PathSegment

Represents a path segment. A path segment is a string that represents a
segment of a URL path.

To import and use `PathSegment` from the "HttpApiEndpoint" module:

```ts
import * as HttpApiEndpoint from "@effect/platform/HttpApiEndpoint"
// Can be accessed like this
HttpApiEndpoint.PathSegment
```


# HttpApiGroup

An `HttpApiGroup` is a collection of `HttpApiEndpoint`s. You can use an `HttpApiGroup` to
represent a portion of your domain.

The endpoints can be implemented later using the `HttpApiBuilder.group` api.

To import and use `HttpApiGroup` from the "HttpApiGroup" module:

```ts
import * as HttpApiGroup from "@effect/platform/HttpApiGroup"
// Can be accessed like this
HttpApiGroup.HttpApiGroup
```


# make

An `HttpApiGroup` is a collection of `HttpApiEndpoint`s. You can use an `HttpApiGroup` to
represent a portion of your domain.

The endpoints can be implemented later using the `HttpApiBuilder.group` api.

To import and use `make` from the "HttpApiGroup" module:

```ts
import * as HttpApiGroup from "@effect/platform/HttpApiGroup"
// Can be accessed like this
HttpApiGroup.make
```

**Signature**

```ts
export declare const make: <const Id extends string, const TopLevel extends true | false = false>(
  identifier: Id,
  options?: { readonly topLevel?: TopLevel | undefined }
) => HttpApiGroup<Id, never, never, never, TopLevel>
```


# apiKey

Create an API key security scheme.

You can implement some api middleware for this security scheme using
`HttpApiBuilder.middlewareSecurity`.

To set the correct cookie in a handler, you can use
`HttpApiBuilder.securitySetCookie`.

The default value for `in` is "header".

To import and use `apiKey` from the "HttpApiSecurity" module:

```ts
import * as HttpApiSecurity from "@effect/platform/HttpApiSecurity"
// Can be accessed like this
HttpApiSecurity.apiKey
```

**Signature**

```ts
export declare const apiKey: (options: {
  readonly key: string
  readonly in?: "header" | "query" | "cookie" | undefined
}) => ApiKey
```


# bearer

Create an Bearer token security scheme.

You can implement some api middleware for this security scheme using
`HttpApiBuilder.middlewareSecurity`.

To import and use `bearer` from the "HttpApiSecurity" module:

```ts
import * as HttpApiSecurity from "@effect/platform/HttpApiSecurity"
// Can be accessed like this
HttpApiSecurity.bearer
```

**Signature**

```ts
export declare const bearer: Bearer
```


# filterOrElse

Filters the result of a response, or runs an alternative effect if the predicate fails.

To import and use `filterOrElse` from the "HttpClient" module:

```ts
import * as HttpClient from "@effect/platform/HttpClient"
// Can be accessed like this
HttpClient.filterOrElse
```

**Signature**

```ts
export declare const filterOrElse: {
  <E2, R2>(
    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,
    orElse: (response: ClientResponse.HttpClientResponse) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>
  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R2 | R>
  <E, R, E2, R2>(
    self: HttpClient.With<E, R>,
    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,
    orElse: (response: ClientResponse.HttpClientResponse) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>
  ): HttpClient.With<E2 | E, R2 | R>
}
```


# filterOrFail

Filters the result of a response, or throws an error if the predicate fails.

To import and use `filterOrFail` from the "HttpClient" module:

```ts
import * as HttpClient from "@effect/platform/HttpClient"
// Can be accessed like this
HttpClient.filterOrFail
```

**Signature**

```ts
export declare const filterOrFail: {
  <E2>(
    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,
    orFailWith: (response: ClientResponse.HttpClientResponse) => E2
  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R>
  <E, R, E2>(
    self: HttpClient.With<E, R>,
    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,
    orFailWith: (response: ClientResponse.HttpClientResponse) => E2
  ): HttpClient.With<E2 | E, R>
}
```


# filterStatus

Filters responses by HTTP status code.

To import and use `filterStatus` from the "HttpClient" module:

```ts
import * as HttpClient from "@effect/platform/HttpClient"
// Can be accessed like this
HttpClient.filterStatus
```

**Signature**

```ts
export declare const filterStatus: {
  (f: (status: number) => boolean): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | Error.ResponseError, R>
  <E, R>(self: HttpClient.With<E, R>, f: (status: number) => boolean): HttpClient.With<E | Error.ResponseError, R>
}
```


# filterStatusOk

Filters responses that return a 2xx status code.

To import and use `filterStatusOk` from the "HttpClient" module:

```ts
import * as HttpClient from "@effect/platform/HttpClient"
// Can be accessed like this
HttpClient.filterStatusOk
```

**Signature**

```ts
export declare const filterStatusOk: <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | Error.ResponseError, R>
```


# followRedirects

Follows HTTP redirects up to a specified number of times.

To import and use `followRedirects` from the "HttpClient" module:

```ts
import * as HttpClient from "@effect/platform/HttpClient"
// Can be accessed like this
HttpClient.followRedirects
```

**Signature**

```ts
export declare const followRedirects: {
  (maxRedirects?: number | undefined): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>
  <E, R>(self: HttpClient.With<E, R>, maxRedirects?: number | undefined): HttpClient.With<E, R>
}
```


# mapRequest

Appends a transformation of the request object before sending it.

To import and use `mapRequest` from the "HttpClient" module:

```ts
import * as HttpClient from "@effect/platform/HttpClient"
// Can be accessed like this
HttpClient.mapRequest
```

**Signature**

```ts
export declare const mapRequest: {
  (
    f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest
  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>
  <E, R>(
    self: HttpClient.With<E, R>,
    f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest
  ): HttpClient.With<E, R>
}
```


# mapRequestEffect

Appends an effectful transformation of the request object before sending it.

To import and use `mapRequestEffect` from the "HttpClient" module:

```ts
import * as HttpClient from "@effect/platform/HttpClient"
// Can be accessed like this
HttpClient.mapRequestEffect
```

**Signature**

```ts
export declare const mapRequestEffect: {
  <E2, R2>(
    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>
  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>
  <E, R, E2, R2>(
    self: HttpClient.With<E, R>,
    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>
  ): HttpClient.With<E | E2, R | R2>
}
```


# mapRequestInput

Prepends a transformation of the request object before sending it.

To import and use `mapRequestInput` from the "HttpClient" module:

```ts
import * as HttpClient from "@effect/platform/HttpClient"
// Can be accessed like this
HttpClient.mapRequestInput
```

**Signature**

```ts
export declare const mapRequestInput: {
  (
    f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest
  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>
  <E, R>(
    self: HttpClient.With<E, R>,
    f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest
  ): HttpClient.With<E, R>
}
```


# mapRequestInputEffect

Prepends an effectful transformation of the request object before sending it.

To import and use `mapRequestInputEffect` from the "HttpClient" module:

```ts
import * as HttpClient from "@effect/platform/HttpClient"
// Can be accessed like this
HttpClient.mapRequestInputEffect
```

**Signature**

```ts
export declare const mapRequestInputEffect: {
  <E2, R2>(
    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>
  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>
  <E, R, E2, R2>(
    self: HttpClient.With<E, R>,
    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>
  ): HttpClient.With<E | E2, R | R2>
}
```


# retry

Retries the request based on a provided schedule or policy.

To import and use `retry` from the "HttpClient" module:

```ts
import * as HttpClient from "@effect/platform/HttpClient"
// Can be accessed like this
HttpClient.retry
```

**Signature**

```ts
export declare const retry: {
  <E, O extends Effect.Retry.Options<E>>(options: O): <R>(self: HttpClient.With<E, R>) => Retry.Return<R, E, O>
  <B, E, R1>(
    policy: Schedule.Schedule<B, NoInfer<E>, R1>
  ): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R1 | R>
  <E, R, O extends Effect.Retry.Options<E>>(self: HttpClient.With<E, R>, options: O): Retry.Return<R, E, O>
  <E, R, B, R1>(self: HttpClient.With<E, R>, policy: Schedule.Schedule<B, E, R1>): HttpClient.With<E, R1 | R>
}
```


# retryTransient

Retries common transient errors, such as rate limiting, timeouts or network issues.

Specifying a `while` predicate allows you to consider other errors as
transient.

To import and use `retryTransient` from the "HttpClient" module:

```ts
import * as HttpClient from "@effect/platform/HttpClient"
// Can be accessed like this
HttpClient.retryTransient
```

**Signature**

```ts
export declare const retryTransient: {
  <B, E, R1 = never>(
    options:
      | {
          readonly while?: Predicate.Predicate<NoInfer<E>>
          readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>
          readonly times?: number
        }
      | Schedule.Schedule<B, NoInfer<E>, R1>
  ): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R1 | R>
  <E, R, B, R1 = never>(
    self: HttpClient.With<E, R>,
    options:
      | {
          readonly while?: Predicate.Predicate<NoInfer<E>>
          readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>
          readonly times?: number
        }
      | Schedule.Schedule<B, NoInfer<E>, R1>
  ): HttpClient.With<E, R1 | R>
}
```


# tap

Performs an additional effect after a successful request.

To import and use `tap` from the "HttpClient" module:

```ts
import * as HttpClient from "@effect/platform/HttpClient"
// Can be accessed like this
HttpClient.tap
```

**Signature**

```ts
export declare const tap: {
  <_, E2, R2>(
    f: (response: ClientResponse.HttpClientResponse) => Effect.Effect<_, E2, R2>
  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>
  <E, R, _, E2, R2>(
    self: HttpClient.With<E, R>,
    f: (response: ClientResponse.HttpClientResponse) => Effect.Effect<_, E2, R2>
  ): HttpClient.With<E | E2, R | R2>
}
```


# tapError

Performs an additional effect after an unsuccessful request.

To import and use `tapError` from the "HttpClient" module:

```ts
import * as HttpClient from "@effect/platform/HttpClient"
// Can be accessed like this
HttpClient.tapError
```

**Signature**

```ts
export declare const tapError: {
  <_, E, E2, R2>(
    f: (e: NoInfer<E>) => Effect.Effect<_, E2, R2>
  ): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>
  <E, R, _, E2, R2>(
    self: HttpClient.With<E, R>,
    f: (e: NoInfer<E>) => Effect.Effect<_, E2, R2>
  ): HttpClient.With<E | E2, R | R2>
}
```


# tapRequest

Performs an additional effect on the request before sending it.

To import and use `tapRequest` from the "HttpClient" module:

```ts
import * as HttpClient from "@effect/platform/HttpClient"
// Can be accessed like this
HttpClient.tapRequest
```

**Signature**

```ts
export declare const tapRequest: {
  <_, E2, R2>(
    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<_, E2, R2>
  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>
  <E, R, _, E2, R2>(
    self: HttpClient.With<E, R>,
    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<_, E2, R2>
  ): HttpClient.With<E | E2, R | R2>
}
```


# withCookiesRef

Associates a `Ref` of cookies with the client for handling cookies across requests.

To import and use `withCookiesRef` from the "HttpClient" module:

```ts
import * as HttpClient from "@effect/platform/HttpClient"
// Can be accessed like this
HttpClient.withCookiesRef
```

**Signature**

```ts
export declare const withCookiesRef: {
  (ref: Ref<Cookies>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>
  <E, R>(self: HttpClient.With<E, R>, ref: Ref<Cookies>): HttpClient.With<E, R>
}
```


# withTracerDisabledWhen

Disables tracing for specific requests based on a provided predicate.

To import and use `withTracerDisabledWhen` from the "HttpClient" module:

```ts
import * as HttpClient from "@effect/platform/HttpClient"
// Can be accessed like this
HttpClient.withTracerDisabledWhen
```

**Signature**

```ts
export declare const withTracerDisabledWhen: {
  (
    predicate: Predicate.Predicate<ClientRequest.HttpClientRequest>
  ): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
  <A, E, R>(
    effect: Effect.Effect<A, E, R>,
    predicate: Predicate.Predicate<ClientRequest.HttpClientRequest>
  ): Effect.Effect<A, E, R>
}
```


# withTracerPropagation

Enables or disables tracing propagation for the request.

To import and use `withTracerPropagation` from the "HttpClient" module:

```ts
import * as HttpClient from "@effect/platform/HttpClient"
// Can be accessed like this
HttpClient.withTracerPropagation
```

**Signature**

```ts
export declare const withTracerPropagation: {
  (enabled: boolean): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
  <A, E, R>(effect: Effect.Effect<A, E, R>, enabled: boolean): Effect.Effect<A, E, R>
}
```


# isHttpMethod

Tests if a value is a `HttpMethod`.

To import and use `isHttpMethod` from the "HttpMethod" module:

```ts
import * as HttpMethod from "@effect/platform/HttpMethod"
// Can be accessed like this
HttpMethod.isHttpMethod
```

**Example**

```ts
import { HttpMethod } from "@effect/platform"

assert.deepStrictEqual(HttpMethod.isHttpMethod("GET"), true)
assert.deepStrictEqual(HttpMethod.isHttpMethod("get"), false)
assert.deepStrictEqual(HttpMethod.isHttpMethod(1), false)
```

**Signature**

```ts
export declare const isHttpMethod: (u: unknown) => u is HttpMethod
```


# layerContext

A Layer providing the `HttpPlatform`, `FileSystem`, `Etag.Generator`, and `Path`
services.

The `FileSystem` service is a no-op implementation, so this layer is only
useful for platforms that have no file system.

To import and use `layerContext` from the "HttpServer" module:

```ts
import * as HttpServer from "@effect/platform/HttpServer"
// Can be accessed like this
HttpServer.layerContext
```

**Signature**

```ts
export declare const layerContext: Layer.Layer<FileSystem | Path | HttpPlatform | Generator, never, never>
```


# layerTestClient

Layer producing an `HttpClient` with prepended url of the running http server.

To import and use `layerTestClient` from the "HttpServer" module:

```ts
import * as HttpServer from "@effect/platform/HttpServer"
// Can be accessed like this
HttpServer.layerTestClient
```

**Signature**

```ts
export declare const layerTestClient: Layer.Layer<Client.HttpClient, never, HttpServer | Client.HttpClient>
```


# layer

Share a `Layer` between multiple tests, optionally wrapping
the tests in a `describe` block if a name is provided.

To import and use `layer` from the "index" module:

```ts
import * as index from "@effect/vitest/index"
// Can be accessed like this
index.layer
```

**Signature**

```ts
export declare const layer: <R, E>(
  layer_: Layer.Layer<R, E>,
  options?: { readonly memoMap?: Layer.MemoMap; readonly timeout?: Duration.DurationInput }
) => {
  (f: (it: Vitest.MethodsNonLive<R>) => void): void
  (name: string, f: (it: Vitest.MethodsNonLive<R>) => void): void
}
```


# imapComposition

Returns a default ternary `imap` composition.

To import and use `imapComposition` from the "Invariant" module:

```ts
import * as Invariant from "@effect/typeclass/Invariant"
// Can be accessed like this
Invariant.imapComposition
```

**Signature**

```ts
export declare const imapComposition: <F extends TypeLambda, G extends TypeLambda>(
  F: Invariant<F>,
  G: Invariant<G>
) => <FR, FO, FE, GR, GO, GE, A, B>(
  self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>,
  to: (a: A) => B,
  from: (b: B) => A
) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>
```


# tupled

Convert a value in a singleton array in a given effect.

To import and use `tupled` from the "Invariant" module:

```ts
import * as Invariant from "@effect/typeclass/Invariant"
// Can be accessed like this
Invariant.tupled
```

**Signature**

```ts
export declare const tupled: <F extends TypeLambda>(
  F: Invariant<F>
) => <R, O, E, A>(self: Kind<F, R, O, E, A>) => Kind<F, R, O, E, [A]>
```


# append

Append an element to the end of an `Iterable`, creating a new `Iterable`.

To import and use `append` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.append
```

**Signature**

```ts
export declare const append: {
  <B>(last: B): <A>(self: Iterable<A>) => Iterable<A | B>
  <A, B>(self: Iterable<A>, last: B): Iterable<A | B>
}
```


# appendAll

Concatenates two iterables, combining their elements.

To import and use `appendAll` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.appendAll
```

**Signature**

```ts
export declare const appendAll: {
  <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<A | B>
  <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<A | B>
}
```


# cartesian

Zips this Iterable crosswise with the specified Iterable.

To import and use `cartesian` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.cartesian
```

**Signature**

```ts
export declare const cartesian: {
  <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<[A, B]>
  <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]>
}
```


# cartesianWith

Zips this Iterable crosswise with the specified Iterable using the specified combiner.

To import and use `cartesianWith` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.cartesianWith
```

**Signature**

```ts
export declare const cartesianWith: {
  <A, B, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Iterable<C>
  <A, B, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C>
}
```


# chunksOf

Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
the `Iterable`.

To import and use `chunksOf` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.chunksOf
```

**Signature**

```ts
export declare const chunksOf: {
  (n: number): <A>(self: Iterable<A>) => Iterable<Array<A>>
  <A>(self: Iterable<A>, n: number): Iterable<Array<A>>
}
```


# contains

Returns a function that checks if a `Iterable` contains a given value using the default `Equivalence`.

To import and use `contains` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.contains
```

**Signature**

```ts
export declare const contains: { <A>(a: A): (self: Iterable<A>) => boolean; <A>(self: Iterable<A>, a: A): boolean }
```


# containsWith

Returns a function that checks if an `Iterable` contains a given value using a provided `isEquivalent` function.

To import and use `containsWith` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.containsWith
```

**Signature**

```ts
export declare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => {
  (a: A): (self: Iterable<A>) => boolean
  (self: Iterable<A>, a: A): boolean
}
```


# dedupeAdjacent

Deduplicates adjacent elements that are identical.

To import and use `dedupeAdjacent` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.dedupeAdjacent
```

**Signature**

```ts
export declare const dedupeAdjacent: <A>(self: Iterable<A>) => Iterable<A>
```


# dedupeAdjacentWith

Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.

To import and use `dedupeAdjacentWith` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.dedupeAdjacentWith
```

**Signature**

```ts
export declare const dedupeAdjacentWith: {
  <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Iterable<A>
  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<A>
}
```


# drop

Drop a max number of elements from the start of an `Iterable`

**Note**. `n` is normalized to a non negative integer.

To import and use `drop` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.drop
```

**Signature**

```ts
export declare const drop: {
  (n: number): <A>(self: Iterable<A>) => Iterable<A>
  <A>(self: Iterable<A>, n: number): Iterable<A>
}
```


# filterMapWhile

Transforms all elements of the `Iterable` for as long as the specified function returns some value

To import and use `filterMapWhile` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.filterMapWhile
```

**Signature**

```ts
export declare const filterMapWhile: {
  <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Iterable<B>
  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Iterable<B>
}
```


# findFirst

Returns the first element that satisfies the specified
predicate, or `None` if no such element exists.

To import and use `findFirst` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.findFirst
```

**Signature**

```ts
export declare const findFirst: {
  <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>
  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>
  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>
  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>
  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>
  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>
}
```


# findLast

Find the last element for which a predicate holds.

To import and use `findLast` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.findLast
```

**Signature**

```ts
export declare const findLast: {
  <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>
  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>
  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>
  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>
  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>
  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>
}
```


# flatMap

Applies a function to each element in an Iterable and returns a new Iterable containing the concatenated mapped elements.

To import and use `flatMap` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.flatMap
```

**Signature**

```ts
export declare const flatMap: {
  <A, B>(f: (a: NoInfer<A>, i: number) => Iterable<B>): (self: Iterable<A>) => Iterable<B>
  <A, B>(self: Iterable<A>, f: (a: NoInfer<A>, i: number) => Iterable<B>): Iterable<B>
}
```


# flatten

Flattens an Iterable of Iterables into a single Iterable

To import and use `flatten` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.flatten
```

**Signature**

```ts
export declare const flatten: <A>(self: Iterable<Iterable<A>>) => Iterable<A>
```


# forEach

Iterate over the `Iterable` applying `f`.

To import and use `forEach` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.forEach
```

**Signature**

```ts
export declare const forEach: {
  <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void
  <A>(self: Iterable<A>, f: (a: A, i: number) => void): void
}
```


# fromRecord

Takes a record and returns an Iterable of tuples containing its keys and values.

To import and use `fromRecord` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.fromRecord
```

**Example**

```ts
import { fromRecord } from "effect/Iterable"

const x = { a: 1, b: 2, c: 3 }
assert.deepStrictEqual(Array.from(fromRecord(x)), [
  ["a", 1],
  ["b", 2],
  ["c", 3]
])
```

**Signature**

```ts
export declare const fromRecord: <K extends string, A>(self: Readonly<Record<K, A>>) => Iterable<[K, A]>
```


# getLefts

Retrieves the `Left` values from an `Iterable` of `Either`s.

To import and use `getLefts` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.getLefts
```

**Example**

```ts
import { Iterable, Either } from "effect"

assert.deepStrictEqual(Array.from(Iterable.getLefts([Either.right(1), Either.left("err"), Either.right(2)])), ["err"])
```

**Signature**

```ts
export declare const getLefts: <R, L>(self: Iterable<Either<R, L>>) => Iterable<L>
```


# getRights

Retrieves the `Right` values from an `Iterable` of `Either`s.

To import and use `getRights` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.getRights
```

**Example**

```ts
import { Iterable, Either } from "effect"

assert.deepStrictEqual(Array.from(Iterable.getRights([Either.right(1), Either.left("err"), Either.right(2)])), [1, 2])
```

**Signature**

```ts
export declare const getRights: <R, L>(self: Iterable<Either<R, L>>) => Iterable<R>
```


# getSomes

Retrieves the `Some` values from an `Iterable` of `Option`s.

To import and use `getSomes` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.getSomes
```

**Example**

```ts
import { Iterable, Option } from "effect"

assert.deepStrictEqual(Array.from(Iterable.getSomes([Option.some(1), Option.none(), Option.some(2)])), [1, 2])
```

**Signature**

```ts
export declare const getSomes: <A>(self: Iterable<Option<A>>) => Iterable<A>
```


# group

Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s.

To import and use `group` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.group
```

**Signature**

```ts
export declare const group: <A>(self: Iterable<A>) => Iterable<NonEmptyArray<A>>
```


# groupBy

Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning
function on each element, and grouping the results according to values returned

To import and use `groupBy` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.groupBy
```

**Signature**

```ts
export declare const groupBy: {
  <A, K extends string | symbol>(
    f: (a: A) => K
  ): (self: Iterable<A>) => Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>
  <A, K extends string | symbol>(
    self: Iterable<A>,
    f: (a: A) => K
  ): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>
}
```


# groupWith

Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s using the provided `isEquivalent` function.

To import and use `groupWith` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.groupWith
```

**Signature**

```ts
export declare const groupWith: {
  <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Iterable<NonEmptyArray<A>>
  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<NonEmptyArray<A>>
}
```


# head

Get the first element of a `Iterable`, or `None` if the `Iterable` is empty.

To import and use `head` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.head
```

**Signature**

```ts
export declare const head: <A>(self: Iterable<A>) => Option<A>
```


# intersperse

Places an element in between members of an `Iterable`.
If the input is a non-empty array, the result is also a non-empty array.

To import and use `intersperse` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.intersperse
```

**Signature**

```ts
export declare const intersperse: {
  <B>(middle: B): <A>(self: Iterable<A>) => Iterable<A | B>
  <A, B>(self: Iterable<A>, middle: B): Iterable<A | B>
}
```


# isEmpty

Determine if an `Iterable` is empty

To import and use `isEmpty` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.isEmpty
```

**Example**

```ts
import { isEmpty } from "effect/Iterable"

assert.deepStrictEqual(isEmpty([]), true)
assert.deepStrictEqual(isEmpty([1, 2, 3]), false)
```

**Signature**

```ts
export declare const isEmpty: <A>(self: Iterable<A>) => self is Iterable<never>
```


# makeBy

Return a `Iterable` with element `i` initialized with `f(i)`.

If the `length` is not specified, the `Iterable` will be infinite.

**Note**. `length` is normalized to an integer >= 1.

To import and use `makeBy` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.makeBy
```

**Example**

```ts
import { makeBy } from "effect/Iterable"

assert.deepStrictEqual(Array.from(makeBy((n) => n * 2, { length: 5 })), [0, 2, 4, 6, 8])
```

**Signature**

```ts
export declare const makeBy: <A>(f: (i: number) => A, options?: { readonly length?: number }) => Iterable<A>
```


# of

Constructs a new `Iterable<A>` from the specified value.

To import and use `of` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.of
```

**Signature**

```ts
export declare const of: <A>(a: A) => Iterable<A>
```


# prepend

Prepend an element to the front of an `Iterable`, creating a new `Iterable`.

To import and use `prepend` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.prepend
```

**Signature**

```ts
export declare const prepend: {
  <B>(head: B): <A>(self: Iterable<A>) => Iterable<A | B>
  <A, B>(self: Iterable<A>, head: B): Iterable<A | B>
}
```


# prependAll

Prepends the specified prefix iterable to the beginning of the specified iterable.

To import and use `prependAll` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.prependAll
```

**Example**

```ts
import { Iterable } from "effect"

assert.deepStrictEqual(Array.from(Iterable.prependAll([1, 2], ["a", "b"])), ["a", "b", 1, 2])
```

**Signature**

```ts
export declare const prependAll: {
  <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<A | B>
  <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<A | B>
}
```


# range

Return a `Iterable` containing a range of integers, including both endpoints.

If `end` is omitted, the range will not have an upper bound.

To import and use `range` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.range
```

**Example**

```ts
import { range } from "effect/Iterable"

assert.deepStrictEqual(Array.from(range(1, 3)), [1, 2, 3])
```

**Signature**

```ts
export declare const range: (start: number, end?: number) => Iterable<number>
```


# replicate

Return a `Iterable` containing a value repeated the specified number of times.

**Note**. `n` is normalized to an integer >= 1.

To import and use `replicate` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.replicate
```

**Example**

```ts
import { replicate } from "effect/Iterable"

assert.deepStrictEqual(Array.from(replicate("a", 3)), ["a", "a", "a"])
```

**Signature**

```ts
export declare const replicate: { (n: number): <A>(a: A) => Iterable<A>; <A>(a: A, n: number): Iterable<A> }
```


# scan

Reduce an `Iterable` from the left, keeping all intermediate results instead of only the final result.

To import and use `scan` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.scan
```

**Signature**

```ts
export declare const scan: {
  <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => Iterable<B>
  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): Iterable<B>
}
```


# size

Return the number of elements in a `Iterable`.

To import and use `size` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.size
```

**Signature**

```ts
export declare const size: <A>(self: Iterable<A>) => number
```


# some

Check if a predicate holds true for some `Iterable` element.

To import and use `some` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.some
```

**Signature**

```ts
export declare const some: {
  <A>(predicate: (a: A, i: number) => boolean): (self: Iterable<A>) => boolean
  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): boolean
}
```


# take

Keep only a max number of elements from the start of an `Iterable`, creating a new `Iterable`.

**Note**. `n` is normalized to a non negative integer.

To import and use `take` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.take
```

**Signature**

```ts
export declare const take: {
  (n: number): <A>(self: Iterable<A>) => Iterable<A>
  <A>(self: Iterable<A>, n: number): Iterable<A>
}
```


# takeWhile

Calculate the longest initial Iterable for which all element satisfy the specified predicate, creating a new `Iterable`.

To import and use `takeWhile` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.takeWhile
```

**Signature**

```ts
export declare const takeWhile: {
  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Iterable<B>
  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Iterable<A>
  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Iterable<B>
  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Iterable<A>
}
```


# unsafeHead

Get the first element of a `Iterable`, or throw an error if the `Iterable` is empty.

To import and use `unsafeHead` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.unsafeHead
```

**Signature**

```ts
export declare const unsafeHead: <A>(self: Iterable<A>) => A
```


# zip

Takes two `Iterable`s and returns an `Iterable` of corresponding pairs.

To import and use `zip` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.zip
```

**Signature**

```ts
export declare const zip: {
  <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<[A, B]>
  <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]>
}
```


# zipWith

Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results. If one
input `Iterable` is short, excess elements of the longer `Iterable` are discarded.

To import and use `zipWith` from the "Iterable" module:

```ts
import * as Iterable from "effect/Iterable"
// Can be accessed like this
Iterable.zipWith
```

**Signature**

```ts
export declare const zipWith: {
  <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Iterable<C>
  <A, B, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C>
}
```


# fromAST

Returns a JSON Schema with additional options and definitions.

**Warning**

This function is experimental and subject to change.

**Details**

- `definitions`: A record of definitions that are included in the schema.
- `definitionPath`: The path to the definitions within the schema (defaults
  to "#/$defs/").
- `target`: Which spec to target. Possible values are:
  - `'jsonSchema7'`: JSON Schema draft-07 (default behavior).
  - `'jsonSchema2019-09'`: JSON Schema draft-2019-09.
  - `'openApi3.1'`: OpenAPI 3.1.
- `topLevelReferenceStrategy`: Controls the handling of the top-level
  reference. Possible values are:
  - `"keep"`: Keep the top-level reference (default behavior).
  - `"skip"`: Skip the top-level reference.

To import and use `fromAST` from the "JSONSchema" module:

```ts
import * as JSONSchema from "effect/JSONSchema"
// Can be accessed like this
JSONSchema.fromAST
```

**Signature**

```ts
export declare const fromAST: (
  ast: AST.AST,
  options: {
    readonly definitions: Record<string, JsonSchema7>
    readonly definitionPath?: string
    readonly target?: Target
    readonly topLevelReferenceStrategy?: TopLevelReferenceStrategy
  }
) => JsonSchema7
```


# get

Retrieves an item from the pool belonging to the given key in a scoped
effect. Note that if acquisition fails, then the returned effect will fail
for that same reason. Retrying a failed acquisition attempt will repeat the
acquisition attempt.

To import and use `get` from the "KeyedPool" module:

```ts
import * as KeyedPool from "effect/KeyedPool"
// Can be accessed like this
KeyedPool.get
```

**Signature**

```ts
export declare const get: {
  <K>(key: K): <A, E>(self: KeyedPool<K, A, E>) => Effect.Effect<A, E, Scope.Scope>
  <K, A, E>(self: KeyedPool<K, A, E>, key: K): Effect.Effect<A, E, Scope.Scope>
}
```


# invalidate

Invalidates the specified item. This will cause the pool to eventually
reallocate the item, although this reallocation may occur lazily rather
than eagerly.

To import and use `invalidate` from the "KeyedPool" module:

```ts
import * as KeyedPool from "effect/KeyedPool"
// Can be accessed like this
KeyedPool.invalidate
```

**Signature**

```ts
export declare const invalidate: {
  <A>(item: A): <K, E>(self: KeyedPool<K, A, E>) => Effect.Effect<void>
  <K, A, E>(self: KeyedPool<K, A, E>, item: A): Effect.Effect<void>
}
```


# KeyedPool

A `KeyedPool<K, A, E>` is a pool of `Pool`s of items of type `A`. Each pool
in the `KeyedPool` is associated with a key of type `K`.

To import and use `KeyedPool` from the "KeyedPool" module:

```ts
import * as KeyedPool from "effect/KeyedPool"
// Can be accessed like this
KeyedPool.KeyedPool
```


# make

Makes a new pool of the specified fixed size. The pool is returned in a
`Scope`, which governs the lifetime of the pool. When the pool is shutdown
because the `Scope` is closed, the individual items allocated by the pool
will be released in some unspecified order.

To import and use `make` from the "KeyedPool" module:

```ts
import * as KeyedPool from "effect/KeyedPool"
// Can be accessed like this
KeyedPool.make
```

**Signature**

```ts
export declare const make: <K, A, E, R>(options: {
  readonly acquire: (key: K) => Effect.Effect<A, E, R>
  readonly size: number
}) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>
```


# makeWith

Makes a new pool of the specified fixed size. The pool is returned in a
`Scope`, which governs the lifetime of the pool. When the pool is shutdown
because the `Scope` is closed, the individual items allocated by the pool
will be released in some unspecified order.

The size of the underlying pools can be configured per key.

To import and use `makeWith` from the "KeyedPool" module:

```ts
import * as KeyedPool from "effect/KeyedPool"
// Can be accessed like this
KeyedPool.makeWith
```

**Signature**

```ts
export declare const makeWith: <K, A, E, R>(options: {
  readonly acquire: (key: K) => Effect.Effect<A, E, R>
  readonly size: (key: K) => number
}) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>
```


# makeWithTTL

Makes a new pool with the specified minimum and maximum sizes and time to
live before a pool whose excess items are not being used will be shrunk
down to the minimum size. The pool is returned in a `Scope`, which governs
the lifetime of the pool. When the pool is shutdown because the `Scope` is
used, the individual items allocated by the pool will be released in some
unspecified order.

The size of the underlying pools can be configured per key.

To import and use `makeWithTTL` from the "KeyedPool" module:

```ts
import * as KeyedPool from "effect/KeyedPool"
// Can be accessed like this
KeyedPool.makeWithTTL
```

**Signature**

```ts
export declare const makeWithTTL: <K, A, E, R>(options: {
  readonly acquire: (key: K) => Effect.Effect<A, E, R>
  readonly min: (key: K) => number
  readonly max: (key: K) => number
  readonly timeToLive: Duration.DurationInput
}) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>
```


# makeWithTTLBy

Makes a new pool with the specified minimum and maximum sizes and time to
live before a pool whose excess items are not being used will be shrunk
down to the minimum size. The pool is returned in a `Scope`, which governs
the lifetime of the pool. When the pool is shutdown because the `Scope` is
used, the individual items allocated by the pool will be released in some
unspecified order.

The size of the underlying pools can be configured per key.

To import and use `makeWithTTLBy` from the "KeyedPool" module:

```ts
import * as KeyedPool from "effect/KeyedPool"
// Can be accessed like this
KeyedPool.makeWithTTLBy
```

**Signature**

```ts
export declare const makeWithTTLBy: <K, A, E, R>(options: {
  readonly acquire: (key: K) => Effect.Effect<A, E, R>
  readonly min: (key: K) => number
  readonly max: (key: K) => number
  readonly timeToLive: (key: K) => Duration.DurationInput
}) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>
```


# layerStorage

Creates an KeyValueStorage from an instance of the `Storage` api.

To import and use `layerStorage` from the "KeyValueStore" module:

```ts
import * as KeyValueStore from "@effect/platform/KeyValueStore"
// Can be accessed like this
KeyValueStore.layerStorage
```

**Signature**

```ts
export declare const layerStorage: (evaluate: LazyArg<Storage>) => Layer.Layer<KeyValueStore>
```


# build

Builds a layer into a scoped value.

To import and use `build` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.build
```

**Signature**

```ts
export declare const build: <RIn, E, ROut>(
  self: Layer<ROut, E, RIn>
) => Effect.Effect<Context.Context<ROut>, E, Scope.Scope | RIn>
```


# buildWithMemoMap

Builds a layer into an `Effect` value, using the specified `MemoMap` to memoize
the layer construction.

To import and use `buildWithMemoMap` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.buildWithMemoMap
```

**Signature**

```ts
export declare const buildWithMemoMap: {
  (
    memoMap: MemoMap,
    scope: Scope.Scope
  ): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, RIn>
  <RIn, E, ROut>(
    self: Layer<ROut, E, RIn>,
    memoMap: MemoMap,
    scope: Scope.Scope
  ): Effect.Effect<Context.Context<ROut>, E, RIn>
}
```


# buildWithScope

Builds a layer into an `Effect` value. Any resources associated with this
layer will be released when the specified scope is closed unless their scope
has been extended. This allows building layers where the lifetime of some of
the services output by the layer exceed the lifetime of the effect the
layer is provided to.

To import and use `buildWithScope` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.buildWithScope
```

**Signature**

```ts
export declare const buildWithScope: {
  (scope: Scope.Scope): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, RIn>
  <RIn, E, ROut>(self: Layer<ROut, E, RIn>, scope: Scope.Scope): Effect.Effect<Context.Context<ROut>, E, RIn>
}
```


# catchAll

Recovers from all errors.

To import and use `catchAll` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.catchAll
```

**Signature**

```ts
export declare const catchAll: {
  <E, RIn2, E2, ROut2>(
    onError: (error: E) => Layer<ROut2, E2, RIn2>
  ): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut & ROut2, E2, RIn2 | RIn>
  <RIn, E, ROut, RIn2, E2, ROut2>(
    self: Layer<ROut, E, RIn>,
    onError: (error: E) => Layer<ROut2, E2, RIn2>
  ): Layer<ROut & ROut2, E2, RIn | RIn2>
}
```


# catchAllCause

Recovers from all errors.

To import and use `catchAllCause` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.catchAllCause
```

**Signature**

```ts
export declare const catchAllCause: {
  <E, RIn2, E2, ROut2>(
    onError: (cause: Cause.Cause<E>) => Layer<ROut2, E2, RIn2>
  ): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut & ROut2, E2, RIn2 | RIn>
  <RIn, E, ROut, RIn2, E2, ROut22>(
    self: Layer<ROut, E, RIn>,
    onError: (cause: Cause.Cause<E>) => Layer<ROut22, E2, RIn2>
  ): Layer<ROut & ROut22, E2, RIn | RIn2>
}
```


# context

Constructs a `Layer` that passes along the specified context as an
output.

To import and use `context` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.context
```

**Signature**

```ts
export declare const context: <R>() => Layer<R, never, R>
```


# die

Constructs a layer that dies with the specified defect.

To import and use `die` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.die
```

**Signature**

```ts
export declare const die: (defect: unknown) => Layer<unknown>
```


# dieSync

Constructs a layer that dies with the specified defect.

To import and use `dieSync` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.dieSync
```

**Signature**

```ts
export declare const dieSync: (evaluate: LazyArg<unknown>) => Layer<unknown>
```


# discard

Replaces the layer's output with `void` and includes the layer only for its
side-effects.

To import and use `discard` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.discard
```

**Signature**

```ts
export declare const discard: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<never, E, RIn>
```


# effect

Constructs a layer from the specified effect.

To import and use `effect` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.effect
```

**Signature**

```ts
export declare const effect: {
  <I, S>(tag: Context.Tag<I, S>): <E, R>(effect: Effect.Effect<Types.NoInfer<S>, E, R>) => Layer<I, E, R>
  <I, S, E, R>(tag: Context.Tag<I, S>, effect: Effect.Effect<Types.NoInfer<S>, E, R>): Layer<I, E, R>
}
```


# effectContext

Constructs a layer from the specified effect, which must return one or more
services.

To import and use `effectContext` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.effectContext
```

**Signature**

```ts
export declare const effectContext: <A, E, R>(effect: Effect.Effect<Context.Context<A>, E, R>) => Layer<A, E, R>
```


# effectDiscard

Constructs a layer from the specified effect, discarding its output.

To import and use `effectDiscard` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.effectDiscard
```

**Signature**

```ts
export declare const effectDiscard: <X, E, R>(effect: Effect.Effect<X, E, R>) => Layer<never, E, R>
```


# empty

A Layer that constructs an empty Context.

To import and use `empty` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.empty
```

**Signature**

```ts
export declare const empty: Layer<never, never, never>
```


# extendScope

Extends the scope of this layer, returning a new layer that when provided
to an effect will not immediately release its associated resources when
that effect completes execution but instead when the scope the resulting
effect depends on is closed.

To import and use `extendScope` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.extendScope
```

**Signature**

```ts
export declare const extendScope: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E, Scope.Scope | RIn>
```


# fail

Constructs a layer that fails with the specified error.

To import and use `fail` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.fail
```

**Signature**

```ts
export declare const fail: <E>(error: E) => Layer<unknown, E>
```


# failCause

Constructs a layer that fails with the specified cause.

To import and use `failCause` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.failCause
```

**Signature**

```ts
export declare const failCause: <E>(cause: Cause.Cause<E>) => Layer<unknown, E>
```


# failCauseSync

Constructs a layer that fails with the specified cause.

To import and use `failCauseSync` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.failCauseSync
```

**Signature**

```ts
export declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Layer<unknown, E>
```


# failSync

Constructs a layer that fails with the specified error.

To import and use `failSync` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.failSync
```

**Signature**

```ts
export declare const failSync: <E>(evaluate: LazyArg<E>) => Layer<unknown, E>
```


# flatMap

Constructs a layer dynamically based on the output of this layer.

To import and use `flatMap` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.flatMap
```

**Signature**

```ts
export declare const flatMap: {
  <A, A2, E2, R2>(
    f: (context: Context.Context<A>) => Layer<A2, E2, R2>
  ): <E, R>(self: Layer<A, E, R>) => Layer<A2, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Layer<A, E, R>,
    f: (context: Context.Context<A>) => Layer<A2, E2, R2>
  ): Layer<A2, E | E2, R | R2>
}
```


# flatten

Flattens layers nested in the context of an effect.

To import and use `flatten` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.flatten
```

**Signature**

```ts
export declare const flatten: {
  <I, A, E2, R2>(tag: Context.Tag<I, Layer<A, E2, R2>>): <E, R>(self: Layer<I, E, R>) => Layer<A, E2 | E, R2 | R>
  <I, E, R, A, E2, R2>(self: Layer<I, E, R>, tag: Context.Tag<I, Layer<A, E2, R2>>): Layer<A, E | E2, R | R2>
}
```


# fresh

Creates a fresh version of this layer that will not be shared.

To import and use `fresh` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.fresh
```

**Signature**

```ts
export declare const fresh: <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>
```


# function

Constructs a layer from the context using the specified function.

To import and use `function` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.function
```


# isFresh

Returns `true` if the specified `Layer` is a fresh version that will not be
shared, `false` otherwise.

To import and use `isFresh` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.isFresh
```

**Signature**

```ts
export declare const isFresh: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => boolean
```


# isLayer

Returns `true` if the specified value is a `Layer`, `false` otherwise.

To import and use `isLayer` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.isLayer
```

**Signature**

```ts
export declare const isLayer: (u: unknown) => u is Layer<unknown, unknown, unknown>
```


# launch

Builds this layer and uses it until it is interrupted. This is useful when
your entire application is a layer, such as an HTTP server.

To import and use `launch` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.launch
```

**Signature**

```ts
export declare const launch: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<never, E, RIn>
```


# makeMemoMap

Constructs a `MemoMap` that can be used to build additional layers.

To import and use `makeMemoMap` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.makeMemoMap
```

**Signature**

```ts
export declare const makeMemoMap: Effect.Effect<MemoMap, never, never>
```


# map

Returns a new layer whose output is mapped by the specified function.

To import and use `map` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.map
```

**Signature**

```ts
export declare const map: {
  <A, B>(f: (context: Context.Context<A>) => Context.Context<B>): <E, R>(self: Layer<A, E, R>) => Layer<B, E, R>
  <A, E, R, B>(self: Layer<A, E, R>, f: (context: Context.Context<A>) => Context.Context<B>): Layer<B, E, R>
}
```


# mapError

Returns a layer with its error channel mapped using the specified function.

To import and use `mapError` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.mapError
```

**Signature**

```ts
export declare const mapError: {
  <E, E2>(f: (error: E) => E2): <A, R>(self: Layer<A, E, R>) => Layer<A, E2, R>
  <A, E, R, E2>(self: Layer<A, E, R>, f: (error: E) => E2): Layer<A, E2, R>
}
```


# match

Feeds the error or output services of this layer into the input of either
the specified `failure` or `success` layers, resulting in a new layer with
the inputs of this layer, and the error or outputs of the specified layer.

To import and use `match` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.match
```

**Signature**

```ts
export declare const match: {
  <E, A2, E2, R2, A, A3, E3, R3>(options: {
    readonly onFailure: (error: E) => Layer<A2, E2, R2>
    readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>
  }): <R>(self: Layer<A, E, R>) => Layer<A2 & A3, E2 | E3, R2 | R3 | R>
  <A, E, R, A2, E2, R2, A3, E3, R3>(
    self: Layer<A, E, R>,
    options: {
      readonly onFailure: (error: E) => Layer<A2, E2, R2>
      readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>
    }
  ): Layer<A2 & A3, E2 | E3, R | R2 | R3>
}
```


# matchCause

Feeds the error or output services of this layer into the input of either
the specified `failure` or `success` layers, resulting in a new layer with
the inputs of this layer, and the error or outputs of the specified layer.

To import and use `matchCause` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.matchCause
```

**Signature**

```ts
export declare const matchCause: {
  <E, A2, E2, R2, A, A3, E3, R3>(options: {
    readonly onFailure: (cause: Cause.Cause<E>) => Layer<A2, E2, R2>
    readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>
  }): <R>(self: Layer<A, E, R>) => Layer<A2 & A3, E2 | E3, R2 | R3 | R>
  <A, E, R, A2, E2, R2, A3, E3, R3>(
    self: Layer<A, E, R>,
    options: {
      readonly onFailure: (cause: Cause.Cause<E>) => Layer<A2, E2, R2>
      readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>
    }
  ): Layer<A2 & A3, E2 | E3, R | R2 | R3>
}
```


# memoize

Returns a scoped effect that, if evaluated, will return the lazily computed
result of this layer.

To import and use `memoize` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.memoize
```

**Signature**

```ts
export declare const memoize: <RIn, E, ROut>(
  self: Layer<ROut, E, RIn>
) => Effect.Effect<Layer<ROut, E, RIn>, never, Scope.Scope>
```


# merge

Merges this layer with the specified layer concurrently, producing a new layer with combined input and output types.

To import and use `merge` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.merge
```

**Signature**

```ts
export declare const merge: {
  <RIn2, E2, ROut2>(
    that: Layer<ROut2, E2, RIn2>
  ): <RIn, E1, ROut>(self: Layer<ROut, E1, RIn>) => Layer<ROut2 | ROut, E2 | E1, RIn2 | RIn>
  <RIn, E1, ROut, RIn2, E2, ROut2>(
    self: Layer<ROut, E1, RIn>,
    that: Layer<ROut2, E2, RIn2>
  ): Layer<ROut | ROut2, E1 | E2, RIn | RIn2>
}
```


# mergeAll

Combines all the provided layers concurrently, creating a new layer with merged input, error, and output types.

To import and use `mergeAll` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.mergeAll
```

**Signature**

```ts
export declare const mergeAll: <Layers extends [Layer<never, any, any>, ...Array<Layer<never, any, any>>]>(
  ...layers: Layers
) => Layer<
  { [k in keyof Layers]: Layer.Success<Layers[k]> }[number],
  { [k in keyof Layers]: Layer.Error<Layers[k]> }[number],
  { [k in keyof Layers]: Layer.Context<Layers[k]> }[number]
>
```


# orDie

Translates effect failure into death of the fiber, making all failures
unchecked and not a part of the type of the layer.

To import and use `orDie` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.orDie
```

**Signature**

```ts
export declare const orDie: <A, E, R>(self: Layer<A, E, R>) => Layer<A, never, R>
```


# orElse

Executes this layer and returns its output, if it succeeds, but otherwise
executes the specified layer.

To import and use `orElse` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.orElse
```

**Signature**

```ts
export declare const orElse: {
  <A2, E2, R2>(that: LazyArg<Layer<A2, E2, R2>>): <A, E, R>(self: Layer<A, E, R>) => Layer<A & A2, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(self: Layer<A, E, R>, that: LazyArg<Layer<A2, E2, R2>>): Layer<A & A2, E | E2, R | R2>
}
```


# parentSpan

Adds the provided span to the span stack.

To import and use `parentSpan` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.parentSpan
```

**Signature**

```ts
export declare const parentSpan: (span: Tracer.AnySpan) => Layer<Tracer.ParentSpan>
```


# passthrough

Returns a new layer that produces the outputs of this layer but also
passes through the inputs.

To import and use `passthrough` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.passthrough
```

**Signature**

```ts
export declare const passthrough: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<RIn | ROut, E, RIn>
```


# project

Projects out part of one of the services output by this layer using the
specified function.

To import and use `project` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.project
```

**Signature**

```ts
export declare const project: {
  <I1, S1, I2, S2>(
    tagA: Context.Tag<I1, S1>,
    tagB: Context.Tag<I2, S2>,
    f: (a: Types.NoInfer<S1>) => Types.NoInfer<S2>
  ): <RIn, E>(self: Layer<I1, E, RIn>) => Layer<I2, E, RIn>
  <RIn, E, I1, S1, I2, S2>(
    self: Layer<I1, E, RIn>,
    tagA: Context.Tag<I1, S1>,
    tagB: Context.Tag<I2, S2>,
    f: (a: Types.NoInfer<S1>) => Types.NoInfer<S2>
  ): Layer<I2, E, RIn>
}
```


# provide

Feeds the output services of this builder into the input of the specified
builder, resulting in a new builder with the inputs of this builder as
well as any leftover inputs, and the outputs of the specified builder.

To import and use `provide` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.provide
```

**Signature**

```ts
export declare const provide: {
  <RIn, E, ROut>(
    that: Layer<ROut, E, RIn>
  ): <RIn2, E2, ROut2>(self: Layer<ROut2, E2, RIn2>) => Layer<ROut2, E | E2, RIn | Exclude<RIn2, ROut>>
  <const Layers extends [Layer.Any, ...Array<Layer.Any>]>(
    that: Layers
  ): <A, E, R>(
    self: Layer<A, E, R>
  ) => Layer<
    A,
    E | { [k in keyof Layers]: Layer.Error<Layers[k]> }[number],
    | { [k in keyof Layers]: Layer.Context<Layers[k]> }[number]
    | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]> }[number]>
  >
  <RIn2, E2, ROut2, RIn, E, ROut>(
    self: Layer<ROut2, E2, RIn2>,
    that: Layer<ROut, E, RIn>
  ): Layer<ROut2, E | E2, RIn | Exclude<RIn2, ROut>>
  <A, E, R, const Layers extends [Layer.Any, ...Array<Layer.Any>]>(
    self: Layer<A, E, R>,
    that: Layers
  ): Layer<
    A,
    E | { [k in keyof Layers]: Layer.Error<Layers[k]> }[number],
    | { [k in keyof Layers]: Layer.Context<Layers[k]> }[number]
    | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]> }[number]>
  >
}
```


# provideMerge

Feeds the output services of this layer into the input of the specified
layer, resulting in a new layer with the inputs of this layer, and the
outputs of both layers.

To import and use `provideMerge` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.provideMerge
```

**Signature**

```ts
export declare const provideMerge: {
  <RIn, E, ROut>(
    self: Layer<ROut, E, RIn>
  ): <RIn2, E2, ROut2>(that: Layer<ROut2, E2, RIn2>) => Layer<ROut | ROut2, E | E2, RIn | Exclude<RIn2, ROut>>
  <RIn2, E2, ROut2, RIn, E, ROut>(
    that: Layer<ROut2, E2, RIn2>,
    self: Layer<ROut, E, RIn>
  ): Layer<ROut2 | ROut, E2 | E, RIn | Exclude<RIn2, ROut>>
}
```


# retry

Retries constructing this layer according to the specified schedule.

To import and use `retry` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.retry
```

**Signature**

```ts
export declare const retry: {
  <X, E, RIn2>(
    schedule: Schedule.Schedule<X, NoInfer<E>, RIn2>
  ): <ROut, RIn>(self: Layer<ROut, E, RIn>) => Layer<ROut, E, RIn2 | RIn>
  <ROut, E, RIn, X, RIn2>(
    self: Layer<ROut, E, RIn>,
    schedule: Schedule.Schedule<X, E, RIn2>
  ): Layer<ROut, E, RIn | RIn2>
}
```


# scope

A layer that constructs a scope and closes it when the workflow the layer
is provided to completes execution, whether by success, failure, or
interruption. This can be used to close a scope when providing a layer to a
workflow.

To import and use `scope` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.scope
```

**Signature**

```ts
export declare const scope: Layer<Scope.Scope, never, never>
```


# scoped

Constructs a layer from the specified scoped effect.

To import and use `scoped` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.scoped
```

**Signature**

```ts
export declare const scoped: {
  <I, S>(
    tag: Context.Tag<I, S>
  ): <E, R>(effect: Effect.Effect<Types.NoInfer<S>, E, R>) => Layer<I, E, Exclude<R, Scope.Scope>>
  <I, S, E, R>(
    tag: Context.Tag<I, S>,
    effect: Effect.Effect<Types.NoInfer<S>, E, R>
  ): Layer<I, E, Exclude<R, Scope.Scope>>
}
```


# scopedContext

Constructs a layer from the specified scoped effect, which must return one
or more services.

To import and use `scopedContext` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.scopedContext
```

**Signature**

```ts
export declare const scopedContext: <A, E, R>(
  effect: Effect.Effect<Context.Context<A>, E, R>
) => Layer<A, E, Exclude<R, Scope.Scope>>
```


# scopedDiscard

Constructs a layer from the specified scoped effect.

To import and use `scopedDiscard` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.scopedDiscard
```

**Signature**

```ts
export declare const scopedDiscard: <X, E, R>(
  effect: Effect.Effect<X, E, R>
) => Layer<never, E, Exclude<R, Scope.Scope>>
```


# service

Constructs a layer that accesses and returns the specified service from the
context.

To import and use `service` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.service
```

**Signature**

```ts
export declare const service: <I, S>(tag: Context.Tag<I, S>) => Layer<I, never, I>
```


# setConfigProvider

Sets the current `ConfigProvider`.

To import and use `setConfigProvider` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.setConfigProvider
```

**Signature**

```ts
export declare const setConfigProvider: (configProvider: ConfigProvider) => Layer<never>
```


# setTracer

Create a Layer that sets the current Tracer

To import and use `setTracer` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.setTracer
```

**Signature**

```ts
export declare const setTracer: (tracer: Tracer.Tracer) => Layer<never>
```


# span

Create and add a span to the current span stack.

The span is ended when the Layer is released.

To import and use `span` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.span
```

**Signature**

```ts
export declare const span: (
  name: string,
  options?: Tracer.SpanOptions & {
    readonly onEnd?: ((span: Tracer.Span, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>) | undefined
  }
) => Layer<Tracer.ParentSpan>
```


# succeed

Constructs a layer from the specified value.

To import and use `succeed` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.succeed
```

**Signature**

```ts
export declare const succeed: {
  <I, S>(tag: Context.Tag<I, S>): (resource: Types.NoInfer<S>) => Layer<I>
  <I, S>(tag: Context.Tag<I, S>, resource: Types.NoInfer<S>): Layer<I>
}
```


# succeedContext

Constructs a layer from the specified value, which must return one or more
services.

To import and use `succeedContext` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.succeedContext
```

**Signature**

```ts
export declare const succeedContext: <A>(context: Context.Context<A>) => Layer<A>
```


# suspend

Lazily constructs a layer. This is useful to avoid infinite recursion when
creating layers that refer to themselves.

To import and use `suspend` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.suspend
```

**Signature**

```ts
export declare const suspend: <RIn, E, ROut>(evaluate: LazyArg<Layer<ROut, E, RIn>>) => Layer<ROut, E, RIn>
```


# sync

Lazily constructs a layer from the specified value.

To import and use `sync` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.sync
```

**Signature**

```ts
export declare const sync: {
  <I, S>(tag: Context.Tag<I, S>): (evaluate: LazyArg<Types.NoInfer<S>>) => Layer<I>
  <I, S>(tag: Context.Tag<I, S>, evaluate: LazyArg<Types.NoInfer<S>>): Layer<I>
}
```


# syncContext

Lazily constructs a layer from the specified value, which must return one or more
services.

To import and use `syncContext` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.syncContext
```

**Signature**

```ts
export declare const syncContext: <A>(evaluate: LazyArg<Context.Context<A>>) => Layer<A>
```


# tap

Performs the specified effect if this layer succeeds.

To import and use `tap` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.tap
```

**Signature**

```ts
export declare const tap: {
  <ROut, XR extends ROut, RIn2, E2, X>(
    f: (context: Context.Context<XR>) => Effect.Effect<X, E2, RIn2>
  ): <RIn, E>(self: Layer<ROut, E, RIn>) => Layer<ROut, E2 | E, RIn2 | RIn>
  <RIn, E, ROut, XR extends ROut, RIn2, E2, X>(
    self: Layer<ROut, E, RIn>,
    f: (context: Context.Context<XR>) => Effect.Effect<X, E2, RIn2>
  ): Layer<ROut, E | E2, RIn | RIn2>
}
```


# tapError

Performs the specified effect if this layer fails.

To import and use `tapError` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.tapError
```

**Signature**

```ts
export declare const tapError: {
  <E, XE extends E, RIn2, E2, X>(
    f: (e: XE) => Effect.Effect<X, E2, RIn2>
  ): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E | E2, RIn2 | RIn>
  <RIn, E, XE extends E, ROut, RIn2, E2, X>(
    self: Layer<ROut, E, RIn>,
    f: (e: XE) => Effect.Effect<X, E2, RIn2>
  ): Layer<ROut, E | E2, RIn | RIn2>
}
```


# tapErrorCause

Performs the specified effect if this layer fails.

To import and use `tapErrorCause` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.tapErrorCause
```

**Signature**

```ts
export declare const tapErrorCause: {
  <E, XE extends E, RIn2, E2, X>(
    f: (cause: Cause.Cause<XE>) => Effect.Effect<X, E2, RIn2>
  ): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E | E2, RIn2 | RIn>
  <RIn, E, XE extends E, ROut, RIn2, E2, X>(
    self: Layer<ROut, E, RIn>,
    f: (cause: Cause.Cause<XE>) => Effect.Effect<X, E2, RIn2>
  ): Layer<ROut, E | E2, RIn | RIn2>
}
```


# toRuntime

Converts a layer that requires no services into a scoped runtime, which can
be used to execute effects.

To import and use `toRuntime` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.toRuntime
```

**Signature**

```ts
export declare const toRuntime: <RIn, E, ROut>(
  self: Layer<ROut, E, RIn>
) => Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>
```


# toRuntimeWithMemoMap

Converts a layer that requires no services into a scoped runtime, which can
be used to execute effects.

To import and use `toRuntimeWithMemoMap` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.toRuntimeWithMemoMap
```

**Signature**

```ts
export declare const toRuntimeWithMemoMap: {
  (
    memoMap: MemoMap
  ): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>
  <RIn, E, ROut>(
    self: Layer<ROut, E, RIn>,
    memoMap: MemoMap
  ): Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>
}
```


# updateService

Updates a service in the context with a new implementation.

**Details**

This function modifies the existing implementation of a service in the
context. It retrieves the current service, applies the provided
transformation function `f`, and replaces the old service with the
transformed one.

**When to Use**

This is useful for adapting or extending a service's behavior during the
creation of a layer.

To import and use `updateService` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.updateService
```

**Signature**

```ts
export declare const updateService: (<I, A>(
  tag: Context.Tag<I, A>,
  f: (a: A) => A
) => <A1, E1, R1>(layer: Layer<A1, E1, R1>) => Layer<A1, E1, I | R1>) &
  (<A1, E1, R1, I, A>(layer: Layer<A1, E1, R1>, tag: Context.Tag<I, A>, f: (a: A) => A) => Layer<A1, E1, I | R1>)
```


# zipWith

Combines this layer with the specified layer concurrently, creating a new layer with merged input types and
combined output types using the provided function.

To import and use `zipWith` from the "Layer" module:

```ts
import * as Layer from "effect/Layer"
// Can be accessed like this
Layer.zipWith
```

**Signature**

```ts
export declare const zipWith: {
  <B, E2, R2, A, C>(
    that: Layer<B, E2, R2>,
    f: (a: Context.Context<A>, b: Context.Context<B>) => Context.Context<C>
  ): <E, R>(self: Layer<A, E, R>) => Layer<C, E2 | E, R2 | R>
  <A, E, R, B, E2, R2, C>(
    self: Layer<A, E, R>,
    that: Layer<B, E2, R2>,
    f: (a: Context.Context<A>, b: Context.Context<B>) => Context.Context<C>
  ): Layer<C, E | E2, R | R2>
}
```


# compact

A layout algorithm which will lay out a document without adding any
indentation and without preserving annotations.

Since no pretty-printing is involved, this layout algorithm is very fast. The
resulting output contains fewer characters than a pretty-printed version and
can be used for output that is read by other programs.

To import and use `compact` from the "Layout" module:

```ts
import * as Layout from "@effect/printer/Layout"
// Can be accessed like this
Layout.compact
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc = pipe(
  Doc.vsep([Doc.text("lorem"), Doc.text("ipsum"), pipe(Doc.vsep([Doc.text("dolor"), Doc.text("sit")]), Doc.hang(4))]),
  Doc.hang(4)
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|lorem
     |    ipsum
     |    dolor
     |        sit`
  )
)

assert.strictEqual(
  Doc.render(doc, { style: "compact" }),
  String.stripMargin(
    `|lorem
     |ipsum
     |dolor
     |sit`
  )
)
```

**Signature**

```ts
export declare const compact: <A>(self: Doc<A>) => DocStream<A>
```


# defaultOptions

The default layout options, which are suitable when you want to obtain output
but do not care about the details.

To import and use `defaultOptions` from the "Layout" module:

```ts
import * as Layout from "@effect/printer/Layout"
// Can be accessed like this
Layout.defaultOptions
```

**Signature**

```ts
export declare const defaultOptions: Layout.Options
```


# pretty

The `pretty` layout algorithm is the default algorithm for rendering
documents.

`pretty` commits to rendering something in a certain way if the next
element fits the layout constrants. In other words, it has one `DocStream`
element lookahead when rendering.

Consider using the smarter, but slightly less performant `smart`
algorithm if the results seem to run off to the right before having lots of
line breaks.

To import and use `pretty` from the "Layout" module:

```ts
import * as Layout from "@effect/printer/Layout"
// Can be accessed like this
Layout.pretty
```

**Signature**

```ts
export declare const pretty: {
  (options: Layout.Options): <A>(self: Doc<A>) => DocStream<A>
  <A>(self: Doc<A>, options: Layout.Options): DocStream<A>
}
```


# smart

A layout algorithm with more look ahead than `pretty`, which will introduce
line breaks into a document earlier if the content does not, or will not, fit
onto one line.

To import and use `smart` from the "Layout" module:

```ts
import * as Layout from "@effect/printer/Layout"
// Can be accessed like this
Layout.smart
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import type * as DocStream from "@effect/printer/DocStream"
import * as Layout from "@effect/printer/Layout"
import * as PageWidth from "@effect/printer/PageWidth"
import { pipe } from "effect/Function"
import * as String from "effect/String"

// Consider the following python-ish document:
const fun = <A>(doc: Doc.Doc<A>): Doc.Doc<A> =>
  Doc.hcat([pipe(Doc.hcat([Doc.text("fun("), Doc.softLineBreak, doc]), Doc.hang(2)), Doc.text(")")])

const funs = <A>(doc: Doc.Doc<A>): Doc.Doc<A> => pipe(doc, fun, fun, fun, fun, fun)

const doc = funs(Doc.align(Doc.list(Doc.words("abcdef ghijklm"))))

// The document will be rendered using the following pipeline, where the choice
// of layout algorithm has been left open:
const pageWidth = PageWidth.availablePerLine(26, 1)
const layoutOptions = Layout.options(pageWidth)
const dashes = Doc.text(Array.from({ length: 26 - 2 }, () => "-").join(""))
const hr = Doc.hcat([Doc.vbar, dashes, Doc.vbar])

const render =
  <A>(doc: Doc.Doc<A>) =>
  (layoutAlgorithm: (options: Layout.Layout.Options) => (doc: Doc.Doc<A>) => DocStream.DocStream<A>): string =>
    pipe(Doc.vsep([hr, doc, hr]), layoutAlgorithm(layoutOptions), Doc.renderStream)

// If rendered using `Layout.pretty`, with a page width of `26` characters per line,
// all the calls to `fun` will fit into the first line. However, this exceeds the
// desired `26` character page width.
assert.strictEqual(
  render(doc)(Layout.pretty),
  String.stripMargin(
    `||------------------------|
     |fun(fun(fun(fun(fun(
     |                  [ abcdef
     |                  , ghijklm ])))))
     ||------------------------|`
  )
)

// The same document, rendered with `Layout.smart`, fits the layout contstraints:
assert.strictEqual(
  render(doc)(Layout.smart),
  String.stripMargin(
    `||------------------------|
     |fun(
     |  fun(
     |    fun(
     |      fun(
     |        fun(
     |          [ abcdef
     |          , ghijklm ])))))
     ||------------------------|`
  )
)

// The key difference between `Layout.pretty` and `Layout.smart` is that the
// latter will check the potential document until it encounters a line with the
// same indentation or less than the start of the document. Any line encountered
// earlier is assumed to belong to the same syntactic structure. In contrast,
// `Layout.pretty` checks only the first line.

// Consider for example the question of whether the `A`s fit into the document
// below:
// > 1 A
// > 2   A
// > 3  A
// > 4 B
// > 5   B

// `pretty` will check only the first line, ignoring whether the second line
// may already be too wide. In contrast, `Layout.smart` stops only once it reaches
// the fourth line 4, where the `B` has the same indentation as the first `A`.
```

**Signature**

```ts
export declare const smart: {
  (options: Layout.Options): <A>(self: Doc<A>) => DocStream<A>
  <A>(self: Doc<A>, options: Layout.Options): DocStream<A>
}
```


# unbounded

The `unbounded` layout algorithm will lay out a document an `Unbounded`
page width.

To import and use `unbounded` from the "Layout" module:

```ts
import * as Layout from "@effect/printer/Layout"
// Can be accessed like this
Layout.unbounded
```

**Signature**

```ts
export declare const unbounded: <A>(self: Doc<A>) => DocStream<A>
```


# append

Appends the specified element to the end of the `List`, creating a new `Cons`.

To import and use `append` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.append
```

**Signature**

```ts
export declare const append: {
  <B>(element: B): <A>(self: List<A>) => Cons<A | B>
  <A, B>(self: List<A>, element: B): Cons<A | B>
}
```


# appendAll

Concatenates two lists, combining their elements.
If either list is non-empty, the result is also a non-empty list.

To import and use `appendAll` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.appendAll
```

**Example**

```ts
import { List } from "effect"

assert.deepStrictEqual(List.make(1, 2).pipe(List.appendAll(List.make("a", "b")), List.toArray), [1, 2, "a", "b"])
```

**Signature**

```ts
export declare const appendAll: {
  <S extends List<any>, T extends List<any>>(that: T): (self: S) => List.OrNonEmpty<S, T, List.Infer<S> | List.Infer<T>>
  <A, B>(self: List<A>, that: Cons<B>): Cons<A | B>
  <A, B>(self: Cons<A>, that: List<B>): Cons<A | B>
  <A, B>(self: List<A>, that: List<B>): List<A | B>
}
```


# compact

Removes all `None` values from the specified list.

To import and use `compact` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.compact
```

**Signature**

```ts
export declare const compact: <A>(self: List<Option.Option<A>>) => List<A>
```


# cons

Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.

To import and use `cons` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.cons
```

**Signature**

```ts
export declare const cons: <A>(head: A, tail: List<A>) => Cons<A>
```


# drop

Drops the first `n` elements from the specified list.

To import and use `drop` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.drop
```

**Signature**

```ts
export declare const drop: { (n: number): <A>(self: List<A>) => List<A>; <A>(self: List<A>, n: number): List<A> }
```


# empty

Constructs a new empty `List<A>`.

Alias of {@link nil}.

To import and use `empty` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.empty
```

**Signature**

```ts
export declare const empty: <A = never>() => List<A>
```


# every

Check if a predicate holds true for every `List` element.

To import and use `every` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.every
```

**Signature**

```ts
export declare const every: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => self is List<B>
  <A>(predicate: Predicate<A>): (self: List<A>) => boolean
  <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): self is List<B>
  <A>(self: List<A>, predicate: Predicate<A>): boolean
}
```


# filter

Filters a list using the specified predicate.

To import and use `filter` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.filter
```

**Signature**

```ts
export declare const filter: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => List<B>
  <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => List<A>
  <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): List<B>
  <A>(self: List<A>, predicate: Predicate<A>): List<A>
}
```


# filterMap

Filters and maps a list using the specified partial function. The resulting
list may be smaller than the input list due to the possibility of the partial
function not being defined for some elements.

To import and use `filterMap` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.filterMap
```

**Signature**

```ts
export declare const filterMap: {
  <A, B>(f: (a: A) => Option.Option<B>): (self: List<A>) => List<B>
  <A, B>(self: List<A>, f: (a: A) => Option.Option<B>): List<B>
}
```


# findFirst

Returns the first element that satisfies the specified
predicate, or `None` if no such element exists.

To import and use `findFirst` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.findFirst
```

**Signature**

```ts
export declare const findFirst: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => Option.Option<B>
  <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => Option.Option<A>
  <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): Option.Option<B>
  <A>(self: List<A>, predicate: Predicate<A>): Option.Option<A>
}
```


# flatMap

Applies a function to each element in a list and returns a new list containing the concatenated mapped elements.

To import and use `flatMap` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.flatMap
```

**Signature**

```ts
export declare const flatMap: {
  <S extends List<any>, T extends List<any>>(
    f: (a: List.Infer<S>, i: number) => T
  ): (self: S) => List.AndNonEmpty<S, T, List.Infer<T>>
  <A, B>(self: Cons<A>, f: (a: A, i: number) => Cons<B>): Cons<B>
  <A, B>(self: List<A>, f: (a: A, i: number) => List<B>): List<B>
}
```


# forEach

Applies the specified function to each element of the `List`.

To import and use `forEach` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.forEach
```

**Signature**

```ts
export declare const forEach: {
  <A, B>(f: (a: A) => B): (self: List<A>) => void
  <A, B>(self: List<A>, f: (a: A) => B): void
}
```


# fromIterable

Creates a new `List` from an iterable collection of values.

To import and use `fromIterable` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.fromIterable
```

**Signature**

```ts
export declare const fromIterable: <A>(prefix: Iterable<A>) => List<A>
```


# head

Returns the first element of the specified list, or `None` if the list is
empty.

To import and use `head` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.head
```

**Signature**

```ts
export declare const head: <A>(self: List<A>) => Option.Option<A>
```


# isCons

Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.

To import and use `isCons` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.isCons
```

**Signature**

```ts
export declare const isCons: <A>(self: List<A>) => self is Cons<A>
```


# isList

Returns `true` if the specified value is a `List`, `false` otherwise.

To import and use `isList` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.isList
```

**Signature**

```ts
export declare const isList: { <A>(u: Iterable<A>): u is List<A>; (u: unknown): u is List<unknown> }
```


# isNil

Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.

To import and use `isNil` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.isNil
```

**Signature**

```ts
export declare const isNil: <A>(self: List<A>) => self is Nil<A>
```


# last

Returns the last element of the specified list, or `None` if the list is
empty.

To import and use `last` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.last
```

**Signature**

```ts
export declare const last: <A>(self: List<A>) => Option.Option<A>
```


# List

Represents an immutable linked list of elements of type `A`.

A `List` is optimal for last-in-first-out (LIFO), stack-like access patterns.
If you need another access pattern, for example, random access or FIFO,
consider using a collection more suited for that other than `List`.

To import and use `List` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.List
```


# make

Constructs a new `List<A>` from the specified values.

To import and use `make` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.make
```

**Signature**

```ts
export declare const make: <Elements extends readonly [any, ...Array<any>]>(
  ...elements: Elements
) => Cons<Elements[number]>
```


# map

Applies the specified mapping function to each element of the list.

To import and use `map` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.map
```

**Signature**

```ts
export declare const map: {
  <S extends List<any>, B>(f: (a: List.Infer<S>, i: number) => B): (self: S) => List.With<S, B>
  <S extends List<any>, B>(self: S, f: (a: List.Infer<S>, i: number) => B): List.With<S, B>
}
```


# nil

Constructs a new empty `List<A>`.

To import and use `nil` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.nil
```

**Signature**

```ts
export declare const nil: <A = never>() => List<A>
```


# of

Constructs a new `List<A>` from the specified value.

To import and use `of` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.of
```

**Signature**

```ts
export declare const of: <A>(value: A) => Cons<A>
```


# partition

Partition a list into two lists, where the first list contains all elements
that did not satisfy the specified predicate, and the second list contains
all elements that did satisfy the specified predicate.

To import and use `partition` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.partition
```

**Signature**

```ts
export declare const partition: {
  <A, B extends A>(
    refinement: Refinement<NoInfer<A>, B>
  ): (self: List<A>) => [excluded: List<Exclude<A, B>>, satisfying: List<B>]
  <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => [excluded: List<A>, satisfying: List<A>]
  <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): [excluded: List<Exclude<A, B>>, satisfying: List<B>]
  <A>(self: List<A>, predicate: Predicate<A>): [excluded: List<A>, satisfying: List<A>]
}
```


# partitionMap

Partition a list into two lists, where the first list contains all elements
for which the specified function returned a `Left`, and the second list
contains all elements for which the specified function returned a `Right`.

To import and use `partitionMap` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.partitionMap
```

**Signature**

```ts
export declare const partitionMap: {
  <A, B, C>(f: (a: A) => Either.Either<C, B>): (self: List<A>) => [left: List<B>, right: List<C>]
  <A, B, C>(self: List<A>, f: (a: A) => Either.Either<C, B>): [left: List<B>, right: List<C>]
}
```


# prepend

Prepends the specified element to the beginning of the list.

To import and use `prepend` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.prepend
```

**Signature**

```ts
export declare const prepend: {
  <B>(element: B): <A>(self: List<A>) => Cons<A | B>
  <A, B>(self: List<A>, element: B): Cons<A | B>
}
```


# prependAll

Prepends the specified prefix list to the beginning of the specified list.
If either list is non-empty, the result is also a non-empty list.

To import and use `prependAll` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.prependAll
```

**Example**

```ts
import { List } from "effect"

assert.deepStrictEqual(List.make(1, 2).pipe(List.prependAll(List.make("a", "b")), List.toArray), ["a", "b", 1, 2])
```

**Signature**

```ts
export declare const prependAll: {
  <S extends List<any>, T extends List<any>>(that: T): (self: S) => List.OrNonEmpty<S, T, List.Infer<S> | List.Infer<T>>
  <A, B>(self: List<A>, that: Cons<B>): Cons<A | B>
  <A, B>(self: Cons<A>, that: List<B>): Cons<A | B>
  <A, B>(self: List<A>, that: List<B>): List<A | B>
}
```


# prependAllReversed

Prepends the specified prefix list (in reverse order) to the beginning of the
specified list.

To import and use `prependAllReversed` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.prependAllReversed
```

**Signature**

```ts
export declare const prependAllReversed: {
  <B>(prefix: List<B>): <A>(self: List<A>) => List<A | B>
  <A, B>(self: List<A>, prefix: List<B>): List<A | B>
}
```


# reduce

Folds over the elements of the list using the specified function, using the
specified initial value.

To import and use `reduce` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.reduce
```

**Signature**

```ts
export declare const reduce: {
  <Z, A>(zero: Z, f: (b: Z, a: A) => Z): (self: List<A>) => Z
  <A, Z>(self: List<A>, zero: Z, f: (b: Z, a: A) => Z): Z
}
```


# reduceRight

Folds over the elements of the list using the specified function, beginning
with the last element of the list, using the specified initial value.

To import and use `reduceRight` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.reduceRight
```

**Signature**

```ts
export declare const reduceRight: {
  <Z, A>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: List<A>) => Z
  <Z, A>(self: List<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z
}
```


# reverse

Returns a new list with the elements of the specified list in reverse order.

To import and use `reverse` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.reverse
```

**Signature**

```ts
export declare const reverse: <A>(self: List<A>) => List<A>
```


# size

Returns the number of elements contained in the specified `List`

To import and use `size` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.size
```

**Signature**

```ts
export declare const size: <A>(self: List<A>) => number
```


# some

Check if a predicate holds true for some `List` element.

To import and use `some` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.some
```

**Signature**

```ts
export declare const some: {
  <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => self is Cons<A>
  <A>(self: List<A>, predicate: Predicate<A>): self is Cons<A>
}
```


# splitAt

Splits the specified list into two lists at the specified index.

To import and use `splitAt` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.splitAt
```

**Signature**

```ts
export declare const splitAt: {
  (n: number): <A>(self: List<A>) => [beforeIndex: List<A>, fromIndex: List<A>]
  <A>(self: List<A>, n: number): [beforeIndex: List<A>, fromIndex: List<A>]
}
```


# tail

Returns the tail of the specified list, or `None` if the list is empty.

To import and use `tail` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.tail
```

**Signature**

```ts
export declare const tail: <A>(self: List<A>) => Option.Option<List<A>>
```


# take

Takes the specified number of elements from the beginning of the specified
list.

To import and use `take` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.take
```

**Signature**

```ts
export declare const take: { (n: number): <A>(self: List<A>) => List<A>; <A>(self: List<A>, n: number): List<A> }
```


# toArray

Converts the specified `List` to an `Array`.

To import and use `toArray` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.toArray
```

**Signature**

```ts
export declare const toArray: <A>(self: List<A>) => Array<A>
```


# toChunk

Converts the specified `List` to a `Chunk`.

To import and use `toChunk` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.toChunk
```

**Signature**

```ts
export declare const toChunk: <A>(self: List<A>) => Chunk.Chunk<A>
```


# unsafeHead

Unsafely returns the first element of the specified `List`.

To import and use `unsafeHead` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.unsafeHead
```

**Signature**

```ts
export declare const unsafeHead: <A>(self: List<A>) => A
```


# unsafeLast

Unsafely returns the last element of the specified `List`.

To import and use `unsafeLast` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.unsafeLast
```

**Signature**

```ts
export declare const unsafeLast: <A>(self: List<A>) => A
```


# unsafeTail

Unsafely returns the tail of the specified `List`.

To import and use `unsafeTail` from the "List" module:

```ts
import * as List from "effect/List"
// Can be accessed like this
List.unsafeTail
```

**Signature**

```ts
export declare const unsafeTail: <A>(self: List<A>) => List<A>
```


# batched

Creates a batched logger that groups log messages together and processes them
in intervals.

To import and use `batched` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.batched
```

**Example**

```ts
import { Console, Effect, Logger } from "effect"

const LoggerLive = Logger.replaceScoped(
  Logger.defaultLogger,
  Logger.logfmtLogger.pipe(
    Logger.batched("500 millis", (messages) => Console.log("BATCH", `[\n${messages.join("\n")}\n]`))
  )
)

const program = Effect.gen(function* () {
  yield* Effect.log("one")
  yield* Effect.log("two")
  yield* Effect.log("three")
}).pipe(Effect.provide(LoggerLive))

// Effect.runFork(program)
// BATCH [
// timestamp=... level=INFO fiber=#0 message=one
// timestamp=... level=INFO fiber=#0 message=two
// timestamp=... level=INFO fiber=#0 message=three
// ]
```

**Signature**

```ts
export declare const batched: {
  <Output, R>(
    window: DurationInput,
    f: (messages: Array<Types.NoInfer<Output>>) => Effect<void, never, R>
  ): <Message>(self: Logger<Message, Output>) => Effect<Logger<Message, void>, never, R | Scope>
  <Message, Output, R>(
    self: Logger<Message, Output>,
    window: DurationInput,
    f: (messages: Array<Types.NoInfer<Output>>) => Effect<void, never, R>
  ): Effect<Logger<Message, void>, never, Scope | R>
}
```


# filterLogLevel

Returns a version of this logger that only logs messages when the log level
satisfies the specified predicate.

To import and use `filterLogLevel` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.filterLogLevel
```

**Signature**

```ts
export declare const filterLogLevel: {
  (
    f: (logLevel: LogLevel.LogLevel) => boolean
  ): <Message, Output>(self: Logger<Message, Output>) => Logger<Message, Option.Option<Output>>
  <Message, Output>(
    self: Logger<Message, Output>,
    f: (logLevel: LogLevel.LogLevel) => boolean
  ): Logger<Message, Option.Option<Output>>
}
```


# isLogger

Returns `true` if the specified value is a `Logger`, otherwise returns `false`.

To import and use `isLogger` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.isLogger
```

**Signature**

```ts
export declare const isLogger: (u: unknown) => u is Logger<unknown, unknown>
```


# json

The `json` logger formats log entries as JSON objects, making them easy to
integrate with logging systems that consume JSON data.

To import and use `json` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.json
```

**Example**

```ts
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

// Effect.runFork(program.pipe(Effect.provide(Logger.json)))
// {"message":["message1","message2"],"logLevel":"INFO","timestamp":"...","annotations":{"key2":"value2","key1":"value1"},"spans":{"myspan":0},"fiberId":"#0"}
```

**Signature**

```ts
export declare const json: Layer.Layer<never, never, never>
```


# jsonLogger

The `jsonLogger` logger formats log entries as JSON objects, making them easy to
integrate with logging systems that consume JSON data.

To import and use `jsonLogger` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.jsonLogger
```

**Example**

```ts
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

// Effect.runFork(program.pipe(Effect.provide(Logger.json)))
// {"message":["message1","message2"],"logLevel":"INFO","timestamp":"...","annotations":{"key2":"value2","key1":"value1"},"spans":{"myspan":0},"fiberId":"#0"}
```

**Signature**

```ts
export declare const jsonLogger: Logger<unknown, string>
```


# logFmt

This logger outputs logs in a human-readable format that is easy to read
during development or in a production console.

To import and use `logFmt` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.logFmt
```

**Example**

```ts
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

// Effect.runFork(program.pipe(Effect.provide(Logger.logFmt)))
// timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1
```

**Signature**

```ts
export declare const logFmt: Layer.Layer<never, never, never>
```


# logfmtLogger

This logger outputs logs in a human-readable format that is easy to read
during development or in a production console.

To import and use `logfmtLogger` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.logfmtLogger
```

**Example**

```ts
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

// Effect.runFork(program.pipe(Effect.provide(Logger.logFmt)))
// timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1
```

**Signature**

```ts
export declare const logfmtLogger: Logger<unknown, string>
```


# make

Creates a custom logger that formats log messages according to the provided
function.

To import and use `make` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.make
```

**Example**

```ts
import { Effect, Logger, LogLevel } from "effect"

const logger = Logger.make(({ logLevel, message }) => {
  globalThis.console.log(`[${logLevel.label}] ${message}`)
})

const task1 = Effect.logDebug("task1 done")
const task2 = Effect.logDebug("task2 done")

const program = Effect.gen(function* () {
  yield* Effect.log("start")
  yield* task1
  yield* task2
  yield* Effect.log("done")
}).pipe(Logger.withMinimumLogLevel(LogLevel.Debug), Effect.provide(Logger.replace(Logger.defaultLogger, logger)))

// Effect.runFork(program)
// [INFO] start
// [DEBUG] task1 done
// [DEBUG] task2 done
// [INFO] done
```

**Signature**

```ts
export declare const make: <Message, Output>(
  log: (options: Logger.Options<Message>) => Output
) => Logger<Message, Output>
```


# minimumLogLevel

Sets the minimum log level for logging operations, allowing control over
which log messages are displayed based on their severity.

To import and use `minimumLogLevel` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.minimumLogLevel
```

**Example**

```ts
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.log("Executing task...")
  yield* Effect.sleep("100 millis")
  console.log("task done")
})

// Logging disabled using a layer
// Effect.runFork(program.pipe(Effect.provide(Logger.minimumLogLevel(LogLevel.None))))
// task done
```

**Signature**

```ts
export declare const minimumLogLevel: (level: LogLevel.LogLevel) => Layer.Layer<never>
```


# none

A logger that does nothing in response to logging events.

To import and use `none` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.none
```

**Signature**

```ts
export declare const none: Logger<unknown, void>
```


# pretty

The pretty logger utilizes the capabilities of the console API to generate
visually engaging and color-enhanced log outputs. This feature is
particularly useful for improving the readability of log messages during
development and debugging processes.

To import and use `pretty` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.pretty
```

**Example**

```ts
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

// Effect.runFork(program.pipe(Effect.provide(Logger.pretty)))
//         green --v                      v-- bold and cyan
// [07:51:54.434] INFO (#0) myspan=1ms: message1
//   message2
//    v-- bold
//   key2: value2
//   key1: value1
```

**Signature**

```ts
export declare const pretty: Layer.Layer<never, never, never>
```


# prettyLogger

The pretty logger utilizes the capabilities of the console API to generate
visually engaging and color-enhanced log outputs. This feature is
particularly useful for improving the readability of log messages during
development and debugging processes.

To import and use `prettyLogger` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.prettyLogger
```

**Example**

```ts
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

// Effect.runFork(program.pipe(Effect.provide(Logger.pretty)))
//         green --v                      v-- bold and cyan
// [07:51:54.434] INFO (#0) myspan=1ms: message1
//   message2
//    v-- bold
//   key2: value2
//   key1: value1
```

**Signature**

```ts
export declare const prettyLogger: (options?: {
  readonly colors?: "auto" | boolean | undefined
  readonly stderr?: boolean | undefined
  readonly formatDate?: ((date: Date) => string) | undefined
  readonly mode?: "browser" | "tty" | "auto" | undefined
}) => Logger<unknown, void>
```


# prettyLoggerDefault

A default version of the pretty logger.

To import and use `prettyLoggerDefault` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.prettyLoggerDefault
```

**Signature**

```ts
export declare const prettyLoggerDefault: Logger<unknown, void>
```


# structured

The structured logger provides detailed log outputs, structured in a way that
retains comprehensive traceability of the events, suitable for deeper
analysis and troubleshooting.

To import and use `structured` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.structured
```

**Example**

```ts
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

// Effect.runFork(program.pipe(Effect.provide(Logger.structured)))
// {
//   message: [ 'message1', 'message2' ],
//   logLevel: 'INFO',
//   timestamp: '2024-07-09T14:05:41.623Z',
//   cause: undefined,
//   annotations: { key2: 'value2', key1: 'value1' },
//   spans: { myspan: 0 },
//   fiberId: '#0'
// }
```

**Signature**

```ts
export declare const structured: Layer.Layer<never, never, never>
```


# structuredLogger

The structured logger provides detailed log outputs, structured in a way that
retains comprehensive traceability of the events, suitable for deeper
analysis and troubleshooting.

To import and use `structuredLogger` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.structuredLogger
```

**Example**

```ts
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

// Effect.runFork(program.pipe(Effect.provide(Logger.structured)))
// {
//   message: [ 'message1', 'message2' ],
//   logLevel: 'INFO',
//   timestamp: '2024-07-09T14:05:41.623Z',
//   cause: undefined,
//   annotations: { key2: 'value2', key1: 'value1' },
//   spans: { myspan: 0 },
//   fiberId: '#0'
// }
```

**Signature**

```ts
export declare const structuredLogger: Logger<
  unknown,
  {
    readonly logLevel: string
    readonly fiberId: string
    readonly timestamp: string
    readonly message: unknown
    readonly cause: string | undefined
    readonly annotations: Record<string, unknown>
    readonly spans: Record<string, number>
  }
>
```


# withLeveledConsole

Takes a `Logger<M, O>` and returns a logger that calls the respective `Console` method
based on the log level.

To import and use `withLeveledConsole` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.withLeveledConsole
```

**Example**

```ts
import { Logger, Effect } from "effect"

const loggerLayer = Logger.replace(Logger.defaultLogger, Logger.withLeveledConsole(Logger.stringLogger))

Effect.gen(function* () {
  yield* Effect.logError("an error")
  yield* Effect.logInfo("an info")
}).pipe(Effect.provide(loggerLayer))
```

**Signature**

```ts
export declare const withLeveledConsole: <M, O>(self: Logger<M, O>) => Logger<M, void>
```


# withMinimumLogLevel

Sets the minimum log level for subsequent logging operations, allowing
control over which log messages are displayed based on their severity.

To import and use `withMinimumLogLevel` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.withMinimumLogLevel
```

**Example**

```ts
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.logDebug("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))

// Effect.runFork(program)
// timestamp=... level=DEBUG fiber=#0 message=message1
```

**Signature**

```ts
export declare const withMinimumLogLevel: {
  (level: LogLevel.LogLevel): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>
  <A, E, R>(self: Effect<A, E, R>, level: LogLevel.LogLevel): Effect<A, E, R>
}
```


# zip

Combines this logger with the specified logger to produce a new logger that
logs to both this logger and that logger.

To import and use `zip` from the "Logger" module:

```ts
import * as Logger from "effect/Logger"
// Can be accessed like this
Logger.zip
```

**Signature**

```ts
export declare const zip: {
  <Message2, Output2>(
    that: Logger<Message2, Output2>
  ): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, [Output, Output2]>
  <Message, Output, Message2, Output2>(
    self: Logger<Message, Output>,
    that: Logger<Message2, Output2>
  ): Logger<Message & Message2, [Output, Output2]>
}
```


# locally

Temporarily sets a `LogLevel` for an `Effect` workflow.

**Details**

This function allows you to apply a specific `LogLevel` locally to an
`Effect` workflow. Once the workflow completes, the `LogLevel` reverts to its
previous state.

**When to Use**

This is particularly useful when you want to adjust the verbosity of logging
for specific parts of your program without affecting the global log level.

To import and use `locally` from the "LogLevel" module:

```ts
import * as LogLevel from "effect/LogLevel"
// Can be accessed like this
LogLevel.locally
```

**Example**

```ts
import { Effect, LogLevel } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.log("message1")
  yield* Effect.gen(function* () {
    yield* Effect.log("message2")
    yield* Effect.log("message3")
  }).pipe(LogLevel.locally(LogLevel.Warning))
})

// Effect.runFork(program)
// timestamp=... level=INFO fiber=#0 message=message1
// timestamp=... level=WARN fiber=#0 message=message2
// timestamp=... level=WARN fiber=#0 message=message3
```

**Signature**

```ts
export declare const locally: {
  (self: LogLevel): <A, E, R>(use: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
  <A, E, R>(use: Effect.Effect<A, E, R>, self: LogLevel): Effect.Effect<A, E, R>
}
```


# LogLevel

A `LogLevel` represents the log level associated with an individual logging
operation. Log levels are used both to describe the granularity (or
importance) of individual log statements, as well as to enable tuning
verbosity of log output.

To import and use `LogLevel` from the "LogLevel" module:

```ts
import * as LogLevel from "effect/LogLevel"
// Can be accessed like this
LogLevel.LogLevel
```


# fromStream

Create a `ReadonlyMailbox` from a `Stream`.

To import and use `fromStream` from the "Mailbox" module:

```ts
import * as Mailbox from "effect/Mailbox"
// Can be accessed like this
Mailbox.fromStream
```

**Signature**

```ts
export declare const fromStream: {
  (options?: {
    readonly capacity?: number | undefined
    readonly strategy?: "suspend" | "dropping" | "sliding" | undefined
  }): <A, E, R>(self: Stream<A, E, R>) => Effect<ReadonlyMailbox<A, E>, never, R | Scope>
  <A, E, R>(
    self: Stream<A, E, R>,
    options?: {
      readonly capacity?: number | undefined
      readonly strategy?: "suspend" | "dropping" | "sliding" | undefined
    }
  ): Effect<ReadonlyMailbox<A, E>, never, R | Scope>
}
```


# into

Run an `Effect` into a `Mailbox`, where success ends the mailbox and failure
fails the mailbox.

To import and use `into` from the "Mailbox" module:

```ts
import * as Mailbox from "effect/Mailbox"
// Can be accessed like this
Mailbox.into
```

**Signature**

```ts
export declare const into: {
  <A, E>(self: Mailbox<A, E>): <AX, EX extends E, RX>(effect: Effect<AX, EX, RX>) => Effect<boolean, never, RX>
  <AX, E, EX extends E, RX, A>(effect: Effect<AX, EX, RX>, self: Mailbox<A, E>): Effect<boolean, never, RX>
}
```


# Mailbox

A `Mailbox` is a queue that can be signaled to be done or failed.

To import and use `Mailbox` from the "Mailbox" module:

```ts
import * as Mailbox from "effect/Mailbox"
// Can be accessed like this
Mailbox.Mailbox
```


# make

A `Mailbox` is a queue that can be signaled to be done or failed.

To import and use `make` from the "Mailbox" module:

```ts
import * as Mailbox from "effect/Mailbox"
// Can be accessed like this
Mailbox.make
```

**Example**

```ts
import { Effect, Mailbox } from "effect"

Effect.gen(function* () {
  const mailbox = yield* Mailbox.make<number, string>()

  // add messages to the mailbox
  yield* mailbox.offer(1)
  yield* mailbox.offer(2)
  yield* mailbox.offerAll([3, 4, 5])

  // take messages from the mailbox
  const [messages, done] = yield* mailbox.takeAll
  assert.deepStrictEqual(messages, [1, 2, 3, 4, 5])
  assert.strictEqual(done, false)

  // signal that the mailbox is done
  yield* mailbox.end
  const [messages2, done2] = yield* mailbox.takeAll
  assert.deepStrictEqual(messages2, [])
  assert.strictEqual(done2, true)

  // signal that the mailbox has failed
  yield* mailbox.fail("boom")
})
```

**Signature**

```ts
export declare const make: <A, E = never>(
  capacity?: number | { readonly capacity?: number; readonly strategy?: "suspend" | "dropping" | "sliding" } | undefined
) => Effect<Mailbox<A, E>>
```


# ReadonlyMailbox

A `ReadonlyMailbox` represents a mailbox that can only be read from.

To import and use `ReadonlyMailbox` from the "Mailbox" module:

```ts
import * as Mailbox from "effect/Mailbox"
// Can be accessed like this
Mailbox.ReadonlyMailbox
```


# toChannel

Create a `Channel` from a `Mailbox`.

To import and use `toChannel` from the "Mailbox" module:

```ts
import * as Mailbox from "effect/Mailbox"
// Can be accessed like this
Mailbox.toChannel
```

**Signature**

```ts
export declare const toChannel: <A, E>(self: ReadonlyMailbox<A, E>) => Channel<Chunk<A>, unknown, E>
```


# toStream

Create a `Stream` from a `Mailbox`.

To import and use `toStream` from the "Mailbox" module:

```ts
import * as Mailbox from "effect/Mailbox"
// Can be accessed like this
Mailbox.toStream
```

**Signature**

```ts
export declare const toStream: <A, E>(self: ReadonlyMailbox<A, E>) => Stream<A, E>
```


# isManagedRuntime

Checks if the provided argument is a `ManagedRuntime`.

To import and use `isManagedRuntime` from the "ManagedRuntime" module:

```ts
import * as ManagedRuntime from "effect/ManagedRuntime"
// Can be accessed like this
ManagedRuntime.isManagedRuntime
```

**Signature**

```ts
export declare const isManagedRuntime: (input: unknown) => input is ManagedRuntime<unknown, unknown>
```


# make

Convert a Layer into an ManagedRuntime, that can be used to run Effect's using
your services.

To import and use `make` from the "ManagedRuntime" module:

```ts
import * as ManagedRuntime from "effect/ManagedRuntime"
// Can be accessed like this
ManagedRuntime.make
```

**Example**

```ts
import { Console, Effect, Layer, ManagedRuntime } from "effect"

class Notifications extends Effect.Tag("Notifications")<
  Notifications,
  { readonly notify: (message: string) => Effect.Effect<void> }
>() {
  static Live = Layer.succeed(this, { notify: (message) => Console.log(message) })
}

async function main() {
  const runtime = ManagedRuntime.make(Notifications.Live)
  await runtime.runPromise(Notifications.notify("Hello, world!"))
  await runtime.dispose()
}

main()
```

**Signature**

```ts
export declare const make: <R, E>(
  layer: Layer.Layer<R, E, never>,
  memoMap?: Layer.MemoMap | undefined
) => ManagedRuntime<R, E>
```


# defaults

Uses the default as ManagerConfig.

To import and use `defaults` from the "ManagerConfig" module:

```ts
import * as ManagerConfig from "@effect/cluster/ManagerConfig"
// Can be accessed like this
ManagerConfig.defaults
```

**Signature**

```ts
export declare const defaults: Layer.Layer<ManagerConfig, never, never>
```


# fromConfig

Reads the ManagerConfig from the provided Config.

To import and use `fromConfig` from the "ManagerConfig" module:

```ts
import * as ManagerConfig from "@effect/cluster/ManagerConfig"
// Can be accessed like this
ManagerConfig.fromConfig
```

**Signature**

```ts
export declare const fromConfig: Layer.Layer<ManagerConfig, ConfigError.ConfigError, never>
```


# ManagerConfig

This is the Shard Manager configuration.

To import and use `ManagerConfig` from the "ManagerConfig" module:

```ts
import * as ManagerConfig from "@effect/cluster/ManagerConfig"
// Can be accessed like this
ManagerConfig.ManagerConfig
```


# any

Matches any value without restrictions.

To import and use `any` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.any
```

**Signature**

```ts
export declare const any: SafeRefinement<unknown, any>
```


# bigint

Matches values of type `bigint`.

To import and use `bigint` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.bigint
```

**Signature**

```ts
export declare const bigint: Predicate.Refinement<unknown, bigint>
```


# boolean

Matches values of type `boolean`.

To import and use `boolean` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.boolean
```

**Signature**

```ts
export declare const boolean: Predicate.Refinement<unknown, boolean>
```


# date

Matches values that are instances of `Date`.

To import and use `date` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.date
```

**Signature**

```ts
export declare const date: Predicate.Refinement<unknown, Date>
```


# defined

Matches any defined (non-null and non-undefined) value.

To import and use `defined` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.defined
```

**Signature**

```ts
export declare const defined: <A>(u: A) => u is A & {}
```


# discriminator

Matches values based on a specified discriminant field.

**Details**

This function is used to define pattern matching on objects that follow a
**discriminated union** structure, where a specific field (e.g., `type`,
`kind`, `_tag`) determines the variant of the object. It allows matching
multiple values of the discriminant and provides a function to handle the
matched cases.

To import and use `discriminator` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.discriminator
```

**Example**

```ts
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ type: "A"; a: string } | { type: "B"; b: number } | { type: "C"; c: boolean }>(),
  Match.discriminator("type")("A", "B", (_) => `A or B: ${_.type}`),
  Match.discriminator("type")("C", (_) => `C(${_.c})`),
  Match.exhaustive
)
```

**Signature**

```ts
export declare const discriminator: <D extends string>(
  field: D
) => <R, P extends Types.Tags<D, R> & string, Ret, B extends Ret>(
  ...pattern: [first: P, ...values: Array<P>, f: (_: Extract<R, Record<D, P>>) => B]
) => <I, F, A, Pr>(
  self: Matcher<I, F, R, A, Pr, Ret>
) => Matcher<
  I,
  Types.AddWithout<F, Extract<R, Record<D, P>>>,
  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, P>>>>,
  B | A,
  Pr,
  Ret
>
```


# discriminators

Matches values based on a field that serves as a discriminator, mapping each
possible value to a corresponding handler.

**Details**

This function simplifies working with discriminated unions by letting you
define a set of handlers for each possible value of a given field. Instead of
chaining multiple calls to {@link discriminator}, this function allows
defining all possible cases at once using an object where the keys are the
possible values of the field, and the values are the corresponding handler
functions.

To import and use `discriminators` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.discriminators
```

**Example**

```ts
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ type: "A"; a: string } | { type: "B"; b: number } | { type: "C"; c: boolean }>(),
  Match.discriminators("type")({
    A: (a) => a.a,
    B: (b) => b.b,
    C: (c) => c.c
  }),
  Match.exhaustive
)
```

**Signature**

```ts
export declare const discriminators: <D extends string>(
  field: D
) => <
  R,
  Ret,
  P extends { readonly [Tag in Types.Tags<D, R> & string]?: ((_: Extract<R, Record<D, Tag>>) => Ret) | undefined } & {
    readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never
  }
>(
  fields: P
) => <I, F, A, Pr>(
  self: Matcher<I, F, R, A, Pr, Ret>
) => Matcher<
  I,
  Types.AddWithout<F, Extract<R, Record<D, keyof P>>>,
  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, keyof P>>>>,
  A | ReturnType<P[keyof P] & {}>,
  Pr,
  Ret
>
```


# discriminatorsExhaustive

Matches values based on a discriminator field and **ensures all cases are
handled**.

\*_Details_+

This function is similar to {@link discriminators}, but **requires that all
possible cases** are explicitly handled. It is useful when working with
discriminated unions, where a specific field (e.g., `"type"`) determines the
shape of an object. Each possible value of the field must have a
corresponding handler, ensuring **exhaustiveness checking** at compile time.

This function **does not require** `Match.exhaustive` at the end of the
pipeline because it enforces exhaustiveness by design.

To import and use `discriminatorsExhaustive` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.discriminatorsExhaustive
```

**Example**

```ts
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ type: "A"; a: string } | { type: "B"; b: number } | { type: "C"; c: boolean }>(),
  Match.discriminatorsExhaustive("type")({
    A: (a) => a.a,
    B: (b) => b.b,
    C: (c) => c.c
  })
)
```

**Signature**

```ts
export declare const discriminatorsExhaustive: <D extends string>(
  field: D
) => <
  R,
  Ret,
  P extends { readonly [Tag in Types.Tags<D, R> & string]: (_: Extract<R, Record<D, Tag>>) => Ret } & {
    readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never
  }
>(
  fields: P
) => <I, F, A, Pr>(
  self: Matcher<I, F, R, A, Pr, Ret>
) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>>
```


# discriminatorStartsWith

Matches values where a specified field starts with a given prefix.

**Details**

This function is useful for working with discriminated unions where the
discriminant field follows a hierarchical or namespaced structure. It allows
you to match values based on whether the specified field starts with a given
prefix, making it easier to handle grouped cases.

Instead of checking for exact matches, this function lets you match values
that share a common prefix. For example, if your discriminant field contains
hierarchical names like `"A"`, `"A.A"`, and `"B"`, you can match all values
starting with `"A"` using a single rule.

To import and use `discriminatorStartsWith` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.discriminatorStartsWith
```

**Example**

```ts
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ type: "A" } | { type: "B" } | { type: "A.A" } | {}>(),
  Match.discriminatorStartsWith("type")("A", (_) => 1 as const),
  Match.discriminatorStartsWith("type")("B", (_) => 2 as const),
  Match.orElse((_) => 3 as const)
)

console.log(match({ type: "A" })) // 1
console.log(match({ type: "B" })) // 2
console.log(match({ type: "A.A" })) // 1
```

**Signature**

```ts
export declare const discriminatorStartsWith: <D extends string>(
  field: D
) => <R, P extends string, Ret, B extends Ret>(
  pattern: P,
  f: (_: Extract<R, Record<D, `${P}${string}`>>) => B
) => <I, F, A, Pr>(
  self: Matcher<I, F, R, A, Pr, Ret>
) => Matcher<
  I,
  Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>,
  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>>,
  B | A,
  Pr,
  Ret
>
```


# either

Wraps the match result in an `Either`, distinguishing matched and unmatched
cases.

**Details**

This function ensures that the result of a matcher is always wrapped in an
`Either`, allowing clear differentiation between successful matches
(`Right(value)`) and cases where no pattern matched (`Left(unmatched
value)`).

This approach is particularly useful when handling optional values or when an
unmatched case should be explicitly handled rather than returning a default
value or throwing an error.

To import and use `either` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.either
```

**Example**

```ts
// Title: Extracting a User Role with Either
import { Match } from "effect"

type User = { readonly role: "admin" | "editor" | "viewer" }

// Create a matcher to extract user roles
const getRole = Match.type<User>().pipe(
  Match.when({ role: "admin" }, () => "Has full access"),
  Match.when({ role: "editor" }, () => "Can edit content"),
  Match.either // Wrap the result in an Either
)

console.log(getRole({ role: "admin" }))
// Output: { _id: 'Either', _tag: 'Right', right: 'Has full access' }

console.log(getRole({ role: "viewer" }))
// Output: { _id: 'Either', _tag: 'Left', left: { role: 'viewer' } }
```

**Signature**

```ts
export declare const either: <I, F, R, A, Pr, Ret>(
  self: Matcher<I, F, R, A, Pr, Ret>
) => [Pr] extends [never] ? (input: I) => Either.Either<Unify<A>, R> : Either.Either<Unify<A>, R>
```


# exhaustive

The `Match.exhaustive` method finalizes the pattern matching process by
ensuring that all possible cases are accounted for. If any case is missing,
TypeScript will produce a type error. This is particularly useful when
working with unions, as it helps prevent unintended gaps in pattern matching.

To import and use `exhaustive` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.exhaustive
```

**Example**

```ts
// Title: Ensuring All Cases Are Covered
import { Match } from "effect"

// Create a matcher for string or number values
const match = Match.type<string | number>().pipe(
  // Match when the value is a number
  Match.when(Match.number, (n) => `number: ${n}`),
  // Mark the match as exhaustive, ensuring all cases are handled
  // TypeScript will throw an error if any case is missing
  // @ts-expect-error Type 'string' is not assignable to type 'never'
  Match.exhaustive
)
```

**Signature**

```ts
export declare const exhaustive: <I, F, A, Pr, Ret>(
  self: Matcher<I, F, never, A, Pr, Ret>
) => [Pr] extends [never] ? (u: I) => Unify<A> : Unify<A>
```


# instanceOf

Matches instances of a given class.

To import and use `instanceOf` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.instanceOf
```

**Signature**

```ts
export declare const instanceOf: <A extends abstract new (...args: any) => any>(
  constructor: A
) => SafeRefinement<InstanceType<A>, never>
```


# is

Matches a specific set of literal values (e.g., `Match.is("a", 42, true)`).

To import and use `is` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.is
```

**Signature**

```ts
export declare const is: <Literals extends ReadonlyArray<string | number | bigint | boolean | null>>(
  ...literals: Literals
) => Predicate.Refinement<unknown, Literals[number]>
```


# Matcher

Pattern matching follows a structured process:

- **Creating a matcher**: Define a `Matcher` that operates on either a
  specific `Match.type` or `Match.value`.

- **Defining patterns**: Use combinators such as `Match.when`, `Match.not`,
  and `Match.tag` to specify matching conditions.

- **Completing the match**: Apply a finalizer such as `Match.exhaustive`,
  `Match.orElse`, or `Match.option` to determine how unmatched cases should
  be handled.

To import and use `Matcher` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.Matcher
```

**Example**

```ts
import { Match } from "effect"

// Simulated dynamic input that can be a string or a number
const input: string | number = "some input"

//       string
//      
const result = Match.value(input).pipe(
  // Match if the value is a number
  Match.when(Match.number, (n) => `number: ${n}`),
  // Match if the value is a string
  Match.when(Match.string, (s) => `string: ${s}`),
  // Ensure all possible cases are covered
  Match.exhaustive
)

console.log(result)
// Output: "string: some input"
```


# nonEmptyString

Matches non-empty strings.

To import and use `nonEmptyString` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.nonEmptyString
```

**Signature**

```ts
export declare const nonEmptyString: SafeRefinement<string, never>
```


# not

Excludes a specific value from matching while allowing all others.

**Details**

This function is useful when you need to **handle all values except one or
more specific cases**. Instead of listing all possible matches manually, this
function simplifies the logic by allowing you to specify values to exclude.
Any excluded value will bypass the provided function and continue matching
through other cases.

To import and use `not` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.not
```

**Example**

```ts
// Title: Ignoring a Specific Value
import { Match } from "effect"

// Create a matcher for string or number values
const match = Match.type<string | number>().pipe(
  // Match any value except "hi", returning "ok"
  Match.not("hi", () => "ok"),
  // Fallback case for when the value is "hi"
  Match.orElse(() => "fallback")
)

console.log(match("hello"))
// Output: "ok"

console.log(match("hi"))
// Output: "fallback"
```

**Signature**

```ts
export declare const not: <
  R,
  const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>,
  Ret,
  Fn extends (_: Exclude<R, Types.ExtractMatch<R, Types.PForExclude<P>>>) => Ret
>(
  pattern: P,
  f: Fn
) => <I, F, A, Pr>(
  self: Matcher<I, F, R, A, Pr, Ret>
) => Matcher<
  I,
  Types.AddOnly<F, Types.WhenMatch<R, P>>,
  Types.ApplyFilters<I, Types.AddOnly<F, Types.WhenMatch<R, P>>>,
  A | ReturnType<Fn>,
  Pr,
  Ret
>
```


# null

Matches the value `null`.

To import and use `null` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.null
```


# number

Matches values of type `number`.

To import and use `number` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.number
```

**Signature**

```ts
export declare const number: Predicate.Refinement<unknown, number>
```


# option

Wraps the match result in an `Option`, representing an optional match.

**Details**

This function ensures that the result of a matcher is wrapped in an `Option`,
making it easy to handle cases where no pattern matches. If a match is found,
it returns `Some(value)`, otherwise, it returns `None`.

This is useful in cases where a missing match is expected and should be
handled explicitly rather than throwing an error or returning a default
value.

To import and use `option` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.option
```

**Example**

```ts
// Title: Extracting a User Role with Option
import { Match } from "effect"

type User = { readonly role: "admin" | "editor" | "viewer" }

// Create a matcher to extract user roles
const getRole = Match.type<User>().pipe(
  Match.when({ role: "admin" }, () => "Has full access"),
  Match.when({ role: "editor" }, () => "Can edit content"),
  Match.option // Wrap the result in an Option
)

console.log(getRole({ role: "admin" }))
// Output: { _id: 'Option', _tag: 'Some', value: 'Has full access' }

console.log(getRole({ role: "viewer" }))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
export declare const option: <I, F, R, A, Pr, Ret>(
  self: Matcher<I, F, R, A, Pr, Ret>
) => [Pr] extends [never] ? (input: I) => Option.Option<Unify<A>> : Option.Option<Unify<A>>
```


# orElse

Provides a fallback value when no patterns match.

**Details**

This function ensures that a matcher always returns a valid result, even if
no defined patterns match. It acts as a default case, similar to the
`default` clause in a `switch` statement or the final `else` in an `if-else`
chain.

To import and use `orElse` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.orElse
```

**Example**

```ts
// Title: Providing a Default Value When No Patterns Match
import { Match } from "effect"

// Create a matcher for string or number values
const match = Match.type<string | number>().pipe(
  // Match when the value is "a"
  Match.when("a", () => "ok"),
  // Fallback when no patterns match
  Match.orElse(() => "fallback")
)

console.log(match("a"))
// Output: "ok"

console.log(match("b"))
// Output: "fallback"
```

**Signature**

```ts
export declare const orElse: <RA, Ret, F extends (_: RA) => Ret>(
  f: F
) => <I, R, A, Pr>(
  self: Matcher<I, R, RA, A, Pr, Ret>
) => [Pr] extends [never] ? (input: I) => Unify<ReturnType<F> | A> : Unify<ReturnType<F> | A>
```


# orElseAbsurd

Throws an error if no pattern matches.

**Details**

This function finalizes a matcher by ensuring that if no patterns match, an
error is thrown. It is useful when all cases should be covered, and any
unexpected input should trigger an error instead of returning a default
value.

When used, this function removes the need for an explicit fallback case and
ensures that an unmatched value is never silently ignored.

To import and use `orElseAbsurd` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.orElseAbsurd
```

**Signature**

```ts
export declare const orElseAbsurd: <I, R, RA, A, Pr, Ret>(
  self: Matcher<I, R, RA, A, Pr, Ret>
) => [Pr] extends [never] ? (input: I) => Unify<A> : Unify<A>
```


# record

Matches objects where keys are `string` or `symbol` and values are `unknown`.

To import and use `record` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.record
```

**Signature**

```ts
export declare const record: Predicate.Refinement<unknown, { [x: string]: unknown; [x: symbol]: unknown }>
```


# string

Matches values of type `string`.

To import and use `string` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.string
```

**Signature**

```ts
export declare const string: Predicate.Refinement<unknown, string>
```


# symbol

Matches values of type `symbol`.

To import and use `symbol` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.symbol
```

**Signature**

```ts
export declare const symbol: Predicate.Refinement<unknown, symbol>
```


# tag

The `Match.tag` function allows pattern matching based on the `_tag` field in
a [Discriminated Union](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions).
You can specify multiple tags to match within a single pattern.

**Note**

The `Match.tag` function relies on the convention within the Effect ecosystem
of naming the tag field as `"_tag"`. Ensure that your discriminated unions
follow this naming convention for proper functionality.

To import and use `tag` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.tag
```

**Example**

```ts
// Title: Matching a Discriminated Union by Tag
import { Match } from "effect"

type Event =
  | { readonly _tag: "fetch" }
  | { readonly _tag: "success"; readonly data: string }
  | { readonly _tag: "error"; readonly error: Error }
  | { readonly _tag: "cancel" }

// Create a Matcher for Either<number, string>
const match = Match.type<Event>().pipe(
  // Match either "fetch" or "success"
  Match.tag("fetch", "success", () => `Ok!`),
  // Match "error" and extract the error message
  Match.tag("error", (event) => `Error: ${event.error.message}`),
  // Match "cancel"
  Match.tag("cancel", () => "Cancelled"),
  Match.exhaustive
)

console.log(match({ _tag: "success", data: "Hello" }))
// Output: "Ok!"

console.log(match({ _tag: "error", error: new Error("Oops!") }))
// Output: "Error: Oops!"
```

**Signature**

```ts
export declare const tag: <R, P extends Types.Tags<"_tag", R> & string, Ret, B extends Ret>(
  ...pattern: [first: P, ...values: Array<P>, f: (_: Extract<T.NoInfer<R>, Record<"_tag", P>>) => B]
) => <I, F, A, Pr>(
  self: Matcher<I, F, R, A, Pr, Ret>
) => Matcher<
  I,
  Types.AddWithout<F, Extract<R, Record<"_tag", P>>>,
  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<"_tag", P>>>>,
  B | A,
  Pr,
  Ret
>
```


# tags

Matches values based on their `_tag` field, mapping each tag to a
corresponding handler.

**Details**

This function provides a way to handle discriminated unions by mapping `_tag`
values to specific functions. Each handler receives the matched value and
returns a transformed result. If all possible tags are handled, you can
enforce exhaustiveness using `Match.exhaustive` to ensure no case is missed.

To import and use `tags` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.tags
```

**Example**

```ts
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ _tag: "A"; a: string } | { _tag: "B"; b: number } | { _tag: "C"; c: boolean }>(),
  Match.tags({
    A: (a) => a.a,
    B: (b) => b.b,
    C: (c) => c.c
  }),
  Match.exhaustive
)
```

**Signature**

```ts
export declare const tags: <
  R,
  Ret,
  P extends {
    readonly [Tag in Types.Tags<"_tag", R> & string]?: ((_: Extract<R, Record<"_tag", Tag>>) => Ret) | undefined
  } & { readonly [Tag in Exclude<keyof P, Types.Tags<"_tag", R>>]: never }
>(
  fields: P
) => <I, F, A, Pr>(
  self: Matcher<I, F, R, A, Pr, Ret>
) => Matcher<
  I,
  Types.AddWithout<F, Extract<R, Record<"_tag", keyof P>>>,
  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<"_tag", keyof P>>>>,
  A | ReturnType<P[keyof P] & {}>,
  Pr,
  Ret
>
```


# tagsExhaustive

Matches values based on their `_tag` field and requires handling of all
possible cases.

**Details**

This function is designed for **discriminated unions** where every possible
`_tag` value must have a corresponding handler. Unlike {@link tags}, this
function ensures **exhaustiveness**, meaning all cases must be explicitly
handled. If a `_tag` value is missing from the mapping, TypeScript will
report an error.

To import and use `tagsExhaustive` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.tagsExhaustive
```

**Example**

```ts
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ _tag: "A"; a: string } | { _tag: "B"; b: number } | { _tag: "C"; c: boolean }>(),
  Match.tagsExhaustive({
    A: (a) => a.a,
    B: (b) => b.b,
    C: (c) => c.c
  })
)
```

**Signature**

```ts
export declare const tagsExhaustive: <
  R,
  Ret,
  P extends { readonly [Tag in Types.Tags<"_tag", R> & string]: (_: Extract<R, Record<"_tag", Tag>>) => Ret } & {
    readonly [Tag in Exclude<keyof P, Types.Tags<"_tag", R>>]: never
  }
>(
  fields: P
) => <I, F, A, Pr>(
  self: Matcher<I, F, R, A, Pr, Ret>
) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>>
```


# tagStartsWith

Matches values where the `_tag` field starts with a given prefix.

**Details**

This function allows you to match on values in a **discriminated union**
based on whether the `_tag` field starts with a specified prefix. It is
useful for handling hierarchical or namespaced tags, where multiple related
cases share a common prefix.

To import and use `tagStartsWith` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.tagStartsWith
```

**Example**

```ts
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ _tag: "A" } | { _tag: "B" } | { _tag: "A.A" } | {}>(),
  Match.tagStartsWith("A", (_) => 1 as const),
  Match.tagStartsWith("B", (_) => 2 as const),
  Match.orElse((_) => 3 as const)
)

console.log(match({ _tag: "A" })) // 1
console.log(match({ _tag: "B" })) // 2
console.log(match({ _tag: "A.A" })) // 1
```

**Signature**

```ts
export declare const tagStartsWith: <R, P extends string, Ret, B extends Ret>(
  pattern: P,
  f: (_: Extract<T.NoInfer<R>, Record<"_tag", `${P}${string}`>>) => B
) => <I, F, A, Pr>(
  self: Matcher<I, F, R, A, Pr, Ret>
) => Matcher<
  I,
  Types.AddWithout<F, Extract<R, Record<"_tag", `${P}${string}`>>>,
  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<"_tag", `${P}${string}`>>>>,
  B | A,
  Pr,
  Ret
>
```


# type

Creates a matcher for a specific type.

**Details**

This function defines a `Matcher` that operates on a given type, allowing you
to specify conditions for handling different cases. Once the matcher is
created, you can use pattern-matching functions like {@link when} to define
how different values should be processed.

To import and use `type` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.type
```

**Example**

```ts
// Title: Matching Numbers and Strings
import { Match } from "effect"

// Create a matcher for values that are either strings or numbers
//
//       (u: string | number) => string
//      
const match = Match.type<string | number>().pipe(
  // Match when the value is a number
  Match.when(Match.number, (n) => `number: ${n}`),
  // Match when the value is a string
  Match.when(Match.string, (s) => `string: ${s}`),
  // Ensure all possible cases are handled
  Match.exhaustive
)

console.log(match(0))
// Output: "number: 0"

console.log(match("hello"))
// Output: "string: hello"
```

**Signature**

```ts
export declare const type: <I>() => Matcher<I, Types.Without<never>, I, never, never>
```


# undefined

Matches the value `undefined`.

To import and use `undefined` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.undefined
```


# value

Creates a matcher from a specific value.

**Details**

This function allows you to define a `Matcher` directly from a given value,
rather than from a type. This is useful when working with known values,
enabling structured pattern matching on objects, primitives, or any data
structure.

Once the matcher is created, you can use pattern-matching functions like
{@link when} to define how different cases should be handled.

To import and use `value` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.value
```

**Example**

```ts
// Title: Matching an Object by Property
import { Match } from "effect"

const input = { name: "John", age: 30 }

// Create a matcher for the specific object
const result = Match.value(input).pipe(
  // Match when the 'name' property is "John"
  Match.when({ name: "John" }, (user) => `${user.name} is ${user.age} years old`),
  // Provide a fallback if no match is found
  Match.orElse(() => "Oh, not John")
)

console.log(result)
// Output: "John is 30 years old"
```

**Signature**

```ts
export declare const value: <const I>(i: I) => Matcher<I, Types.Without<never>, I, never, I>
```


# when

Defines a condition for matching values.

**Details**

This function enables pattern matching by checking whether a given value
satisfies a condition. It supports both direct value comparisons and
predicate functions. If the condition is met, the associated function is
executed.

This function is useful when defining matchers that need to check for
specific values or apply logical conditions to determine a match. It works
well with structured objects and primitive types.

To import and use `when` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.when
```

**Example**

```ts
// Title: Matching with Values and Predicates
import { Match } from "effect"

// Create a matcher for objects with an "age" property
const match = Match.type<{ age: number }>().pipe(
  // Match when age is greater than 18
  Match.when({ age: (age) => age > 18 }, (user) => `Age: ${user.age}`),
  // Match when age is exactly 18
  Match.when({ age: 18 }, () => "You can vote"),
  // Fallback case for all other ages
  Match.orElse((user) => `${user.age} is too young`)
)

console.log(match({ age: 20 }))
// Output: "Age: 20"

console.log(match({ age: 18 }))
// Output: "You can vote"

console.log(match({ age: 4 }))
// Output: "4 is too young"
```

**Signature**

```ts
export declare const when: <
  R,
  const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>,
  Ret,
  Fn extends (_: Types.WhenMatch<R, P>) => Ret
>(
  pattern: P,
  f: Fn
) => <I, F, A, Pr>(
  self: Matcher<I, F, R, A, Pr, Ret>
) => Matcher<
  I,
  Types.AddWithout<F, Types.PForExclude<P>>,
  Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P>>>,
  A | ReturnType<Fn>,
  Pr,
  Ret
>
```


# whenAnd

Matches a value that satisfies all provided patterns.

**Details**

This function allows defining a condition where a value must match all the
given patterns simultaneously. If the value satisfies every pattern, the
associated function is executed.

Unlike {@link when}, which matches a single pattern at a time, this function
ensures that multiple conditions are met before executing the callback. It is
useful when checking for values that need to fulfill multiple criteria at
once.

To import and use `whenAnd` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.whenAnd
```

**Example**

```ts
import { Match } from "effect"

type User = { readonly age: number; readonly role: "admin" | "user" }

const checkUser = Match.type<User>().pipe(
  Match.whenAnd({ age: (n) => n >= 18 }, { role: "admin" }, () => "Admin access granted"),
  Match.orElse(() => "Access denied")
)

console.log(checkUser({ age: 20, role: "admin" }))
// Output: "Admin access granted"

console.log(checkUser({ age: 20, role: "user" }))
// Output: "Access denied"
```

**Signature**

```ts
export declare const whenAnd: <
  R,
  const P extends ReadonlyArray<Types.PatternPrimitive<R> | Types.PatternBase<R>>,
  Ret,
  Fn extends (_: Types.WhenMatch<R, T.UnionToIntersection<P[number]>>) => Ret
>(
  ...args: [...patterns: P, f: Fn]
) => <I, F, A, Pr>(
  self: Matcher<I, F, R, A, Pr, Ret>
) => Matcher<
  I,
  Types.AddWithout<F, Types.PForExclude<T.UnionToIntersection<P[number]>>>,
  Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<T.UnionToIntersection<P[number]>>>>,
  A | ReturnType<Fn>,
  Pr
>
```


# whenOr

Matches one of multiple patterns in a single condition.

**Details**

This function allows defining a condition where a value matches any of the
provided patterns. If a match is found, the associated function is executed.
It simplifies cases where multiple patterns share the same handling logic.

Unlike {@link when}, which requires separate conditions for each pattern,
this function enables combining them into a single statement, making the
matcher more concise.

To import and use `whenOr` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.whenOr
```

**Example**

```ts
import { Match } from "effect"

type ErrorType =
  | { readonly _tag: "NetworkError"; readonly message: string }
  | { readonly _tag: "TimeoutError"; readonly duration: number }
  | { readonly _tag: "ValidationError"; readonly field: string }

const handleError = Match.type<ErrorType>().pipe(
  Match.whenOr({ _tag: "NetworkError" }, { _tag: "TimeoutError" }, () => "Retry the request"),
  Match.when({ _tag: "ValidationError" }, (_) => `Invalid field: ${_.field}`),
  Match.exhaustive
)

console.log(handleError({ _tag: "NetworkError", message: "No connection" }))
// Output: "Retry the request"

console.log(handleError({ _tag: "ValidationError", field: "email" }))
// Output: "Invalid field: email"
```

**Signature**

```ts
export declare const whenOr: <
  R,
  const P extends ReadonlyArray<Types.PatternPrimitive<R> | Types.PatternBase<R>>,
  Ret,
  Fn extends (_: Types.WhenMatch<R, P[number]>) => Ret
>(
  ...args: [...patterns: P, f: Fn]
) => <I, F, A, Pr>(
  self: Matcher<I, F, R, A, Pr, Ret>
) => Matcher<
  I,
  Types.AddWithout<F, Types.PForExclude<P[number]>>,
  Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P[number]>>>,
  A | ReturnType<Fn>,
  Pr,
  Ret
>
```


# withReturnType

Ensures that all branches of a matcher return a specific type.

**Details**

This function enforces a consistent return type across all pattern-matching
branches. By specifying a return type, TypeScript will check that every
matching condition produces a value of the expected type.

**Important:** This function must be the first step in the matcher pipeline.
If used later, TypeScript will not enforce type consistency correctly.

To import and use `withReturnType` from the "Match" module:

```ts
import * as Match from "effect/Match"
// Can be accessed like this
Match.withReturnType
```

**Example**

```ts
// Title: Validating Return Type Consistency
import { Match } from "effect"

const match = Match.type<{ a: number } | { b: string }>().pipe(
  // Ensure all branches return a string
  Match.withReturnType<string>(),
  //  Type error: 'number' is not assignable to type 'string'
  // @ts-expect-error
  Match.when({ a: Match.number }, (_) => _.a),
  //  Correct: returns a string
  Match.when({ b: Match.string }, (_) => _.b),
  Match.exhaustive
)
```

**Signature**

```ts
export declare const withReturnType: <Ret>() => <I, F, R, A, Pr, _>(
  self: Matcher<I, F, R, A, Pr, _>
) => [Ret] extends [[A] extends [never] ? any : A]
  ? Matcher<I, F, R, A, Pr, Ret>
  : "withReturnType constraint does not extend Result type"
```


# isMergeDecision

Returns `true` if the specified value is a `MergeDecision`, `false`
otherwise.

To import and use `isMergeDecision` from the "MergeDecision" module:

```ts
import * as MergeDecision from "effect/MergeDecision"
// Can be accessed like this
MergeDecision.isMergeDecision
```

**Signature**

```ts
export declare const isMergeDecision: (u: unknown) => u is MergeDecision<unknown, unknown, unknown, unknown, unknown>
```


# isBothRunning

Returns `true` if the specified `MergeState` is a `BothRunning`, `false`
otherwise.

To import and use `isBothRunning` from the "MergeState" module:

```ts
import * as MergeState from "effect/MergeState"
// Can be accessed like this
MergeState.isBothRunning
```

**Signature**

```ts
export declare const isBothRunning: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(
  self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>
) => self is BothRunning<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>
```


# isLeftDone

Returns `true` if the specified `MergeState` is a `LeftDone`, `false`
otherwise.

To import and use `isLeftDone` from the "MergeState" module:

```ts
import * as MergeState from "effect/MergeState"
// Can be accessed like this
MergeState.isLeftDone
```

**Signature**

```ts
export declare const isLeftDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(
  self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>
) => self is LeftDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>
```


# isMergeState

Returns `true` if the specified value is a `MergeState`, `false` otherwise.

To import and use `isMergeState` from the "MergeState" module:

```ts
import * as MergeState from "effect/MergeState"
// Can be accessed like this
MergeState.isMergeState
```

**Signature**

```ts
export declare const isMergeState: (
  u: unknown
) => u is MergeState<unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown>
```


# isRightDone

Returns `true` if the specified `MergeState` is a `RightDone`, `false`
otherwise.

To import and use `isRightDone` from the "MergeState" module:

```ts
import * as MergeState from "effect/MergeState"
// Can be accessed like this
MergeState.isRightDone
```

**Signature**

```ts
export declare const isRightDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(
  self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>
) => self is RightDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>
```


# isBackPressure

Returns `true` if the specified `MergeStrategy` is a `BackPressure`, `false`
otherwise.

To import and use `isBackPressure` from the "MergeStrategy" module:

```ts
import * as MergeStrategy from "effect/MergeStrategy"
// Can be accessed like this
MergeStrategy.isBackPressure
```

**Signature**

```ts
export declare const isBackPressure: (self: MergeStrategy) => self is BackPressure
```


# isBufferSliding

Returns `true` if the specified `MergeStrategy` is a `BufferSliding`, `false`
otherwise.

To import and use `isBufferSliding` from the "MergeStrategy" module:

```ts
import * as MergeStrategy from "effect/MergeStrategy"
// Can be accessed like this
MergeStrategy.isBufferSliding
```

**Signature**

```ts
export declare const isBufferSliding: (self: MergeStrategy) => self is BufferSliding
```


# isMergeStrategy

Returns `true` if the specified value is a `MergeStrategy`, `false`
otherwise.

To import and use `isMergeStrategy` from the "MergeStrategy" module:

```ts
import * as MergeStrategy from "effect/MergeStrategy"
// Can be accessed like this
MergeStrategy.isMergeStrategy
```

**Signature**

```ts
export declare const isMergeStrategy: (u: unknown) => u is MergeStrategy
```


# match

Folds an `MergeStrategy` into a value of type `A`.

To import and use `match` from the "MergeStrategy" module:

```ts
import * as MergeStrategy from "effect/MergeStrategy"
// Can be accessed like this
MergeStrategy.match
```

**Signature**

```ts
export declare const match: {
  <A>(options: { readonly onBackPressure: () => A; readonly onBufferSliding: () => A }): (self: MergeStrategy) => A
  <A>(self: MergeStrategy, options: { readonly onBackPressure: () => A; readonly onBufferSliding: () => A }): A
}
```


# exitSchema

Extracts the exit schema from a Message. This schema will be used to encode the remote exit of the Message processor.

To import and use `exitSchema` from the "Message" module:

```ts
import * as Message from "@effect/cluster/Message"
// Can be accessed like this
Message.exitSchema
```

**Signature**

```ts
export declare const exitSchema: <A extends Message.Any>(message: A) => Schema.Schema<Message.Exit<A>, unknown>
```


# failureSchema

Extracts the failure schema from a Message. This schema will be used to encode remote failures of the Message processor.

To import and use `failureSchema` from the "Message" module:

```ts
import * as Message from "@effect/cluster/Message"
// Can be accessed like this
Message.failureSchema
```

**Signature**

```ts
export declare const failureSchema: <A extends Message.Any>(message: A) => Schema.Schema<Message.Error<A>, unknown>
```


# Message

A Message is a request for an entity that will process it.
A Message also has a PrimaryKey so that the receiver is eventually able to detect duplicated messages.

To import and use `Message` from the "Message" module:

```ts
import * as Message from "@effect/cluster/Message"
// Can be accessed like this
Message.Message
```


# successSchema

Extracts the success schema from a Message. This schema will be used to encode the remote success of the Message processor.

To import and use `successSchema` from the "Message" module:

```ts
import * as Message from "@effect/cluster/Message"
// Can be accessed like this
Message.successSchema
```

**Signature**

```ts
export declare const successSchema: <A extends Message.Any>(message: A) => Schema.Schema<Message.Success<A>, unknown>
```


# Acknowledged

Constructs an AcknowledgedMessageState.

To import and use `Acknowledged` from the "MessageState" module:

```ts
import * as MessageState from "@effect/cluster/MessageState"
// Can be accessed like this
MessageState.Acknowledged
```

**Signature**

```ts
export declare const Acknowledged: MessageStateAcknowledged
```


# isMessageState

Ensures that the given value is a MessageState

To import and use `isMessageState` from the "MessageState" module:

```ts
import * as MessageState from "@effect/cluster/MessageState"
// Can be accessed like this
MessageState.isMessageState
```

**Signature**

```ts
export declare const isMessageState: typeof internal.isMessageState
```


# mapEffect

Effectfully transform the <A> type of the MessageState<A>.

To import and use `mapEffect` from the "MessageState" module:

```ts
import * as MessageState from "@effect/cluster/MessageState"
// Can be accessed like this
MessageState.mapEffect
```

**Signature**

```ts
export declare const mapEffect: <A, B, R, E>(
  value: MessageState<A>,
  fn: (value: A) => Effect.Effect<B, E, R>
) => Effect.Effect<MessageState<B>, E, R>
```


# match

Match over the possible states of a MessageState

To import and use `match` from the "MessageState" module:

```ts
import * as MessageState from "@effect/cluster/MessageState"
// Can be accessed like this
MessageState.match
```

**Signature**

```ts
export declare const match: typeof internal.match
```


# MessageState

Once a Message is sent to an entity to be processed,
the state of that message over that entity is either Acknoledged (not yet processed) or Processed.

To import and use `MessageState` from the "MessageState" module:

```ts
import * as MessageState from "@effect/cluster/MessageState"
// Can be accessed like this
MessageState.MessageState
```


# MessageStateAcknowledged

A message state given to just acknowledged messages.
This state tells the sender that the receiver has received the message and will eventually process it later.

To import and use `MessageStateAcknowledged` from the "MessageState" module:

```ts
import * as MessageState from "@effect/cluster/MessageState"
// Can be accessed like this
MessageState.MessageStateAcknowledged
```


# MessageStateProcessed

A message state given to processed messages.
This state tells the sender that the receiver has already received and processed the message.
This will also tell the sender the result for this message.

To import and use `MessageStateProcessed` from the "MessageState" module:

```ts
import * as MessageState from "@effect/cluster/MessageState"
// Can be accessed like this
MessageState.MessageStateProcessed
```


# Processed

Constructs a ProcessedMessageState from the result of the message being processed.

To import and use `Processed` from the "MessageState" module:

```ts
import * as MessageState from "@effect/cluster/MessageState"
// Can be accessed like this
MessageState.Processed
```

**Signature**

```ts
export declare const Processed: <A>(result: A) => MessageStateProcessed<A>
```


# Messenger

An interface to communicate with a remote entity.

To import and use `Messenger` from the "Messenger" module:

```ts
import * as Messenger from "@effect/cluster/Messenger"
// Can be accessed like this
Messenger.Messenger
```


# counter

Represents a Counter metric that tracks cumulative numerical values over time.
Counters can be incremented and decremented and provide a running total of changes.

To import and use `counter` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.counter
```

**Example**

```ts
import { Metric } from "effect"

const numberCounter = Metric.counter("count", {
  description: "A number counter"
})

const bigintCounter = Metric.counter("count", {
  description: "A bigint counter",
  bigint: true
})
```

**Signature**

```ts
export declare const counter: {
  (
    name: string,
    options?: {
      readonly description?: string | undefined
      readonly bigint?: false | undefined
      readonly incremental?: boolean | undefined
    }
  ): Metric.Counter<number>
  (
    name: string,
    options: {
      readonly description?: string | undefined
      readonly bigint: true
      readonly incremental?: boolean | undefined
    }
  ): Metric.Counter<bigint>
}
```


# frequency

Creates a Frequency metric to count occurrences of events.
Frequency metrics are used to count the number of times specific events or incidents occur.

To import and use `frequency` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.frequency
```

**Example**

```ts
import { Metric } from "effect"

const errorFrequency = Metric.frequency("error_frequency", {
  description: "Counts the occurrences of errors."
})
```

**Signature**

```ts
export declare const frequency: (
  name: string,
  options?:
    | { readonly description?: string | undefined; readonly preregisteredWords?: ReadonlyArray<string> | undefined }
    | undefined
) => Metric.Frequency<string>
```


# gauge

Represents a Gauge metric that tracks and reports a single numerical value at a specific moment.
Gauges are suitable for metrics that represent instantaneous values, such as memory usage or CPU load.

To import and use `gauge` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.gauge
```

**Example**

```ts
import { Metric } from "effect"

const numberGauge = Metric.gauge("memory_usage", {
  description: "A gauge for memory usage"
})

const bigintGauge = Metric.gauge("cpu_load", {
  description: "A gauge for CPU load",
  bigint: true
})
```

**Signature**

```ts
export declare const gauge: {
  (
    name: string,
    options?: { readonly description?: string | undefined; readonly bigint?: false | undefined }
  ): Metric.Gauge<number>
  (name: string, options: { readonly description?: string | undefined; readonly bigint: true }): Metric.Gauge<bigint>
}
```


# histogram

Represents a Histogram metric that records observations in specified value boundaries.
Histogram metrics are useful for measuring the distribution of values within a range.

To import and use `histogram` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.histogram
```

**Example**

```ts
import { Metric, MetricBoundaries } from "effect"

const latencyHistogram = Metric.histogram(
  "latency_histogram",
  MetricBoundaries.linear({ start: 0, width: 10, count: 11 }),
  "Measures the distribution of request latency."
)
```

**Signature**

```ts
export declare const histogram: (
  name: string,
  boundaries: MetricBoundaries.MetricBoundaries,
  description?: string
) => Metric<MetricKeyType.MetricKeyType.Histogram, number, MetricState.MetricState.Histogram>
```


# map

Returns a new metric that is powered by this one, but which outputs a new
state type, determined by transforming the state type of this metric by the
specified function.

To import and use `map` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.map
```

**Signature**

```ts
export declare const map: {
  <Out, Out2>(f: (out: Out) => Out2): <Type, In>(self: Metric<Type, In, Out>) => Metric<Type, In, Out2>
  <Type, In, Out, Out2>(self: Metric<Type, In, Out>, f: (out: Out) => Out2): Metric<Type, In, Out2>
}
```


# mapInput

Returns a new metric that is powered by this one, but which accepts updates
of the specified new type, which must be transformable to the input type of
this metric.

To import and use `mapInput` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.mapInput
```

**Signature**

```ts
export declare const mapInput: {
  <In, In2>(f: (input: In2) => In): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In2, Out>
  <Type, In, Out, In2>(self: Metric<Type, In, Out>, f: (input: In2) => In): Metric<Type, In2, Out>
}
```


# Metric

A `Metric<Type, In, Out>` represents a concurrent metric which accepts
updates of type `In` and are aggregated to a stateful value of type `Out`.

For example, a counter metric would have type `Metric<number, number>`,
representing the fact that the metric can be updated with numbers (the amount
to increment or decrement the counter by), and the state of the counter is a
number.

There are five primitive metric types supported by Effect:

- Counters
- Frequencies
- Gauges
- Histograms
- Summaries

To import and use `Metric` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.Metric
```


# modify

Modifies the metric with the specified update message. For example, if the
metric were a gauge, the update would increment the method by the provided
amount.

To import and use `modify` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.modify
```

**Signature**

```ts
export declare const modify: {
  <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect.Effect<void>
  <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect.Effect<void>
}
```


# snapshot

Captures a snapshot of all metrics recorded by the application.

To import and use `snapshot` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.snapshot
```

**Signature**

```ts
export declare const snapshot: Effect.Effect<MetricPair.MetricPair.Untyped[], never, never>
```


# succeed

Creates a metric that ignores input and produces constant output.

To import and use `succeed` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.succeed
```

**Signature**

```ts
export declare const succeed: <Out>(out: Out) => Metric<void, unknown, Out>
```


# summary

Creates a Summary metric that records observations and calculates quantiles.
Summary metrics provide statistical information about a set of values, including quantiles.

To import and use `summary` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.summary
```

**Example**

```ts
import { Metric, Chunk } from "effect"

const responseTimesSummary = Metric.summary({
  name: "response_times_summary",
  maxAge: "60 seconds", // Retain observations for 60 seconds.
  maxSize: 1000, // Keep a maximum of 1000 observations.
  error: 0.01, // Allow a 1% error when calculating quantiles.
  quantiles: [0.5, 0.9, 0.99], // Calculate 50th, 90th, and 99th percentiles.
  description: "Measures the distribution of response times."
})
```

**Signature**

```ts
export declare const summary: (options: {
  readonly name: string
  readonly maxAge: Duration.DurationInput
  readonly maxSize: number
  readonly error: number
  readonly quantiles: ReadonlyArray<number>
  readonly description?: string | undefined
}) => Metric.Summary<number>
```


# sync

Creates a metric that ignores input and produces constant output.

To import and use `sync` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.sync
```

**Signature**

```ts
export declare const sync: <Out>(evaluate: LazyArg<Out>) => Metric<void, unknown, Out>
```


# tagged

Returns a new metric, which is identical in every way to this one, except
the specified tags have been added to the tags of this metric.

To import and use `tagged` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.tagged
```

**Signature**

```ts
export declare const tagged: {
  <Type, In, Out>(key: string, value: string): (self: Metric<Type, In, Out>) => Metric<Type, In, Out>
  <Type, In, Out>(self: Metric<Type, In, Out>, key: string, value: string): Metric<Type, In, Out>
}
```


# taggedWithLabels

Returns a new metric, which is identical in every way to this one, except
the specified tags have been added to the tags of this metric.

To import and use `taggedWithLabels` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.taggedWithLabels
```

**Signature**

```ts
export declare const taggedWithLabels: {
  <Type, In, Out>(extraTags: Iterable<MetricLabel.MetricLabel>): (self: Metric<Type, In, Out>) => Metric<Type, In, Out>
  <Type, In, Out>(self: Metric<Type, In, Out>, extraTags: Iterable<MetricLabel.MetricLabel>): Metric<Type, In, Out>
}
```


# taggedWithLabelsInput

Returns a new metric, which is identical in every way to this one, except
dynamic tags are added based on the update values. Note that the metric
returned by this method does not return any useful information, due to the
dynamic nature of the added tags.

To import and use `taggedWithLabelsInput` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.taggedWithLabelsInput
```

**Signature**

```ts
export declare const taggedWithLabelsInput: {
  <In>(
    f: (input: In) => Iterable<MetricLabel.MetricLabel>
  ): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In, void>
  <Type, In, Out>(
    self: Metric<Type, In, Out>,
    f: (input: In) => Iterable<MetricLabel.MetricLabel>
  ): Metric<Type, In, void>
}
```


# timer

Creates a timer metric, based on a histogram, which keeps track of
durations in milliseconds. The unit of time will automatically be added to
the metric as a tag (i.e. `"time_unit: milliseconds"`).

To import and use `timer` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.timer
```

**Signature**

```ts
export declare const timer: (
  name: string,
  description?: string
) => Metric<MetricKeyType.MetricKeyType.Histogram, Duration.Duration, MetricState.MetricState.Histogram>
```


# timerWithBoundaries

Creates a timer metric, based on a histogram created from the provided
boundaries, which keeps track of durations in milliseconds. The unit of time
will automatically be added to the metric as a tag (i.e.
`"time_unit: milliseconds"`).

To import and use `timerWithBoundaries` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.timerWithBoundaries
```

**Signature**

```ts
export declare const timerWithBoundaries: (
  name: string,
  boundaries: ReadonlyArray<number>,
  description?: string
) => Metric<MetricKeyType.MetricKeyType.Histogram, Duration.Duration, MetricState.MetricState.Histogram>
```


# trackAll

Returns an aspect that will update this metric with the specified constant
value every time the aspect is applied to an effect, regardless of whether
that effect fails or succeeds.

To import and use `trackAll` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.trackAll
```

**Signature**

```ts
export declare const trackAll: {
  <In>(
    input: In
  ): <Type, Out>(self: Metric<Type, In, Out>) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
  <Type, In, Out>(
    self: Metric<Type, In, Out>,
    input: In
  ): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
}
```


# trackDefect

Returns an aspect that will update this metric with the defects of the
effects that it is applied to.

To import and use `trackDefect` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.trackDefect
```

**Signature**

```ts
export declare const trackDefect: {
  <Type, Out>(metric: Metric<Type, unknown, Out>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
  <A, E, R, Type, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, unknown, Out>): Effect.Effect<A, E, R>
}
```


# trackDefectWith

Returns an aspect that will update this metric with the result of applying
the specified function to the defect throwables of the effects that the
aspect is applied to.

To import and use `trackDefectWith` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.trackDefectWith
```

**Signature**

```ts
export declare const trackDefectWith: {
  <Type, In, Out>(
    metric: Metric<Type, In, Out>,
    f: (defect: unknown) => In
  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
  <A, E, R, Type, In, Out>(
    self: Effect.Effect<A, E, R>,
    metric: Metric<Type, In, Out>,
    f: (defect: unknown) => In
  ): Effect.Effect<A, E, R>
}
```


# trackDuration

Returns an aspect that will update this metric with the duration that the
effect takes to execute. To call this method, the input type of the metric
must be `Duration`.

To import and use `trackDuration` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.trackDuration
```

**Signature**

```ts
export declare const trackDuration: {
  <Type, Out>(
    metric: Metric<Type, Duration.Duration, Out>
  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
  <A, E, R, Type, Out>(
    self: Effect.Effect<A, E, R>,
    metric: Metric<Type, Duration.Duration, Out>
  ): Effect.Effect<A, E, R>
}
```


# trackDurationWith

Returns an aspect that will update this metric with the duration that the
effect takes to execute. To call this method, you must supply a function
that can convert the `Duration` to the input type of this metric.

To import and use `trackDurationWith` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.trackDurationWith
```

**Signature**

```ts
export declare const trackDurationWith: {
  <Type, In, Out>(
    metric: Metric<Type, In, Out>,
    f: (duration: Duration.Duration) => In
  ): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
  <A, E, R, Type, In, Out>(
    self: Effect.Effect<A, E, R>,
    metric: Metric<Type, In, Out>,
    f: (duration: Duration.Duration) => In
  ): Effect.Effect<A, E, R>
}
```


# trackError

Returns an aspect that will update this metric with the failure value of
the effects that it is applied to.

To import and use `trackError` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.trackError
```

**Signature**

```ts
export declare const trackError: {
  <Type, In, Out>(
    metric: Metric<Type, In, Out>
  ): <A, E extends In, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
  <A, E extends In, R, Type, In, Out>(
    self: Effect.Effect<A, E, R>,
    metric: Metric<Type, In, Out>
  ): Effect.Effect<A, E, R>
}
```


# trackErrorWith

Returns an aspect that will update this metric with the result of applying
the specified function to the error value of the effects that the aspect is
applied to.

To import and use `trackErrorWith` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.trackErrorWith
```

**Signature**

```ts
export declare const trackErrorWith: {
  <Type, In, Out, In2>(
    metric: Metric<Type, In, Out>,
    f: (error: In2) => In
  ): <A, E extends In2, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
  <A, E extends In2, R, Type, In, Out, In2>(
    self: Effect.Effect<A, E, R>,
    metric: Metric<Type, In, Out>,
    f: (error: In2) => In
  ): Effect.Effect<A, E, R>
}
```


# trackSuccess

Returns an aspect that will update this metric with the success value of
the effects that it is applied to.

To import and use `trackSuccess` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.trackSuccess
```

**Signature**

```ts
export declare const trackSuccess: {
  <Type, In, Out>(
    metric: Metric<Type, In, Out>
  ): <A extends In, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
  <A extends In, E, R, Type, In, Out>(
    self: Effect.Effect<A, E, R>,
    metric: Metric<Type, In, Out>
  ): Effect.Effect<A, E, R>
}
```


# trackSuccessWith

Returns an aspect that will update this metric with the result of applying
the specified function to the success value of the effects that the aspect is
applied to.

To import and use `trackSuccessWith` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.trackSuccessWith
```

**Signature**

```ts
export declare const trackSuccessWith: {
  <Type, In, Out, In2>(
    metric: Metric<Type, In, Out>,
    f: (value: In2) => In
  ): <A extends In2, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
  <A extends In2, E, R, Type, In, Out, In2>(
    self: Effect.Effect<A, E, R>,
    metric: Metric<Type, In, Out>,
    f: (value: In2) => In
  ): Effect.Effect<A, E, R>
}
```


# unsafeSnapshot

Unsafely captures a snapshot of all metrics recorded by the application.

To import and use `unsafeSnapshot` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.unsafeSnapshot
```

**Signature**

```ts
export declare const unsafeSnapshot: (_: void) => ReadonlyArray<MetricPair.MetricPair.Untyped>
```


# update

Updates the metric with the specified update message. For example, if the
metric were a counter, the update would increment the method by the
provided amount.

To import and use `update` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.update
```

**Signature**

```ts
export declare const update: {
  <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect.Effect<void>
  <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect.Effect<void>
}
```


# value

Retrieves a snapshot of the value of the metric at this moment in time.

To import and use `value` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.value
```

**Signature**

```ts
export declare const value: <Type, In, Out>(self: Metric<Type, In, Out>) => Effect.Effect<Out>
```


# withConstantInput

Returns a new metric that is powered by this one, but which accepts updates
of any type, and translates them to updates with the specified constant
update value.

To import and use `withConstantInput` from the "Metric" module:

```ts
import * as Metric from "effect/Metric"
// Can be accessed like this
Metric.withConstantInput
```

**Signature**

```ts
export declare const withConstantInput: {
  <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, unknown, Out>
  <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Metric<Type, unknown, Out>
}
```


# exponential

A helper method to create histogram bucket boundaries for a histogram
with exponentially increasing values.

To import and use `exponential` from the "MetricBoundaries" module:

```ts
import * as MetricBoundaries from "effect/MetricBoundaries"
// Can be accessed like this
MetricBoundaries.exponential
```

**Signature**

```ts
export declare const exponential: (options: {
  readonly start: number
  readonly factor: number
  readonly count: number
}) => MetricBoundaries
```


# linear

A helper method to create histogram bucket boundaries for a histogram
with linear increasing values.

To import and use `linear` from the "MetricBoundaries" module:

```ts
import * as MetricBoundaries from "effect/MetricBoundaries"
// Can be accessed like this
MetricBoundaries.linear
```

**Signature**

```ts
export declare const linear: (options: {
  readonly start: number
  readonly width: number
  readonly count: number
}) => MetricBoundaries
```


# counter

Creates a metric key for a counter, with the specified name.

To import and use `counter` from the "MetricKey" module:

```ts
import * as MetricKey from "effect/MetricKey"
// Can be accessed like this
MetricKey.counter
```

**Signature**

```ts
export declare const counter: {
  (
    name: string,
    options?: {
      readonly description?: string | undefined
      readonly bigint?: false | undefined
      readonly incremental?: boolean | undefined
    }
  ): MetricKey.Counter<number>
  (
    name: string,
    options: {
      readonly description?: string | undefined
      readonly bigint: true
      readonly incremental?: boolean | undefined
    }
  ): MetricKey.Counter<bigint>
}
```


# frequency

Creates a metric key for a categorical frequency table, with the specified
name.

To import and use `frequency` from the "MetricKey" module:

```ts
import * as MetricKey from "effect/MetricKey"
// Can be accessed like this
MetricKey.frequency
```

**Signature**

```ts
export declare const frequency: (
  name: string,
  options?:
    | { readonly description?: string | undefined; readonly preregisteredWords?: ReadonlyArray<string> | undefined }
    | undefined
) => MetricKey.Frequency
```


# gauge

Creates a metric key for a gauge, with the specified name.

To import and use `gauge` from the "MetricKey" module:

```ts
import * as MetricKey from "effect/MetricKey"
// Can be accessed like this
MetricKey.gauge
```

**Signature**

```ts
export declare const gauge: {
  (
    name: string,
    options?: { readonly description?: string | undefined; readonly bigint?: false | undefined }
  ): MetricKey.Gauge<number>
  (name: string, options: { readonly description?: string | undefined; readonly bigint: true }): MetricKey.Gauge<bigint>
}
```


# histogram

Creates a metric key for a histogram, with the specified name and boundaries.

To import and use `histogram` from the "MetricKey" module:

```ts
import * as MetricKey from "effect/MetricKey"
// Can be accessed like this
MetricKey.histogram
```

**Signature**

```ts
export declare const histogram: (
  name: string,
  boundaries: MetricBoundaries.MetricBoundaries,
  description?: string
) => MetricKey.Histogram
```


# MetricKey

A `MetricKey` is a unique key associated with each metric. The key is based
on a combination of the metric type, the name and tags associated with the
metric, an optional description of the key, and any other information to
describe a metric, such as the boundaries of a histogram. In this way, it is
impossible to ever create different metrics with conflicting keys.

To import and use `MetricKey` from the "MetricKey" module:

```ts
import * as MetricKey from "effect/MetricKey"
// Can be accessed like this
MetricKey.MetricKey
```


# summary

Creates a metric key for a summary, with the specified name, maxAge,
maxSize, error, and quantiles.

To import and use `summary` from the "MetricKey" module:

```ts
import * as MetricKey from "effect/MetricKey"
// Can be accessed like this
MetricKey.summary
```

**Signature**

```ts
export declare const summary: (options: {
  readonly name: string
  readonly maxAge: Duration.DurationInput
  readonly maxSize: number
  readonly error: number
  readonly quantiles: ReadonlyArray<number>
  readonly description?: string | undefined
}) => MetricKey.Summary
```


# tagged

Returns a new `MetricKey` with the specified tag appended.

To import and use `tagged` from the "MetricKey" module:

```ts
import * as MetricKey from "effect/MetricKey"
// Can be accessed like this
MetricKey.tagged
```

**Signature**

```ts
export declare const tagged: {
  (
    key: string,
    value: string
  ): <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>) => MetricKey<Type>
  <Type extends MetricKeyType.MetricKeyType<any, any>>(
    self: MetricKey<Type>,
    key: string,
    value: string
  ): MetricKey<Type>
}
```


# taggedWithLabels

Returns a new `MetricKey` with the specified tags appended.

To import and use `taggedWithLabels` from the "MetricKey" module:

```ts
import * as MetricKey from "effect/MetricKey"
// Can be accessed like this
MetricKey.taggedWithLabels
```

**Signature**

```ts
export declare const taggedWithLabels: {
  (
    extraTags: ReadonlyArray<MetricLabel.MetricLabel>
  ): <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>) => MetricKey<Type>
  <Type extends MetricKeyType.MetricKeyType<any, any>>(
    self: MetricKey<Type>,
    extraTags: ReadonlyArray<MetricLabel.MetricLabel>
  ): MetricKey<Type>
}
```


# MetricLabel

A `MetricLabel` represents a key value pair that allows analyzing metrics at
an additional level of granularity.

For example if a metric tracks the response time of a service labels could
be used to create separate versions that track response times for different
clients.

To import and use `MetricLabel` from the "MetricLabel" module:

```ts
import * as MetricLabel from "effect/MetricLabel"
// Can be accessed like this
MetricLabel.MetricLabel
```


# collectAll

Collects all of the polling metrics into a single polling metric, which
polls for, updates, and produces the outputs of all individual metrics.

To import and use `collectAll` from the "MetricPolling" module:

```ts
import * as MetricPolling from "effect/MetricPolling"
// Can be accessed like this
MetricPolling.collectAll
```

**Signature**

```ts
export declare const collectAll: <R, E, Out>(
  iterable: Iterable<MetricPolling<any, any, R, E, Out>>
) => MetricPolling<Array<any>, Array<any>, R, E, Array<Out>>
```


# launch

Returns an effect that will launch the polling metric in a background
fiber, using the specified schedule.

To import and use `launch` from the "MetricPolling" module:

```ts
import * as MetricPolling from "effect/MetricPolling"
// Can be accessed like this
MetricPolling.launch
```

**Signature**

```ts
export declare const launch: {
  <A2, R2>(
    schedule: Schedule.Schedule<A2, unknown, R2>
  ): <Type, In, R, E, Out>(
    self: MetricPolling<Type, In, R, E, Out>
  ) => Effect.Effect<Fiber.Fiber<A2, E>, never, R2 | R | Scope.Scope>
  <Type, In, R, E, Out, A2, R2>(
    self: MetricPolling<Type, In, R, E, Out>,
    schedule: Schedule.Schedule<A2, unknown, R2>
  ): Effect.Effect<Fiber.Fiber<A2, E>, never, Scope.Scope | R | R2>
}
```


# make

Constructs a new polling metric from a metric and poll effect.

To import and use `make` from the "MetricPolling" module:

```ts
import * as MetricPolling from "effect/MetricPolling"
// Can be accessed like this
MetricPolling.make
```

**Signature**

```ts
export declare const make: <Type, In, Out, R, E>(
  metric: Metric.Metric<Type, In, Out>,
  poll: Effect.Effect<In, E, R>
) => MetricPolling<Type, In, R, E, Out>
```


# MetricPolling

A `MetricPolling` is a combination of a metric and an effect that polls for
updates to the metric.

To import and use `MetricPolling` from the "MetricPolling" module:

```ts
import * as MetricPolling from "effect/MetricPolling"
// Can be accessed like this
MetricPolling.MetricPolling
```


# poll

An effect that polls a value that may be fed to the metric.

To import and use `poll` from the "MetricPolling" module:

```ts
import * as MetricPolling from "effect/MetricPolling"
// Can be accessed like this
MetricPolling.poll
```

**Signature**

```ts
export declare const poll: <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => Effect.Effect<In, E, R>
```


# pollAndUpdate

An effect that polls for a value and uses the value to update the metric.

To import and use `pollAndUpdate` from the "MetricPolling" module:

```ts
import * as MetricPolling from "effect/MetricPolling"
// Can be accessed like this
MetricPolling.pollAndUpdate
```

**Signature**

```ts
export declare const pollAndUpdate: <Type, In, R, E, Out>(
  self: MetricPolling<Type, In, R, E, Out>
) => Effect.Effect<void, E, R>
```


# retry

Returns a new polling metric whose poll function will be retried with the
specified retry policy.

To import and use `retry` from the "MetricPolling" module:

```ts
import * as MetricPolling from "effect/MetricPolling"
// Can be accessed like this
MetricPolling.retry
```

**Signature**

```ts
export declare const retry: {
  <X, E, R2>(
    policy: Schedule.Schedule<X, NoInfer<E>, R2>
  ): <Type, In, R, Out>(self: MetricPolling<Type, In, R, E, Out>) => MetricPolling<Type, In, R2 | R, E, Out>
  <Type, In, R, E, Out, X, R2>(
    self: MetricPolling<Type, In, R, E, Out>,
    policy: Schedule.Schedule<X, E, R2>
  ): MetricPolling<Type, In, R | R2, E, Out>
}
```


# zip

Zips this polling metric with the specified polling metric.

To import and use `zip` from the "MetricPolling" module:

```ts
import * as MetricPolling from "effect/MetricPolling"
// Can be accessed like this
MetricPolling.zip
```

**Signature**

```ts
export declare const zip: {
  <Type2, In2, R2, E2, Out2>(
    that: MetricPolling<Type2, In2, R2, E2, Out2>
  ): <Type, In, R, E, Out>(
    self: MetricPolling<Type, In, R, E, Out>
  ) => MetricPolling<readonly [Type, Type2], readonly [In, In2], R2 | R, E2 | E, [Out, Out2]>
  <Type, In, R, E, Out, Type2, In2, R2, E2, Out2>(
    self: MetricPolling<Type, In, R, E, Out>,
    that: MetricPolling<Type2, In2, R2, E2, Out2>
  ): MetricPolling<readonly [Type, Type2], readonly [In, In2], R | R2, E | E2, [Out, Out2]>
}
```


# MetricState

A `MetricState` describes the state of a metric. The type parameter of a
metric state corresponds to the type of the metric key (`MetricStateType`).
This phantom type parameter is used to tie keys to their expected states.

To import and use `MetricState` from the "MetricState" module:

```ts
import * as MetricState from "effect/MetricState"
// Can be accessed like this
MetricState.MetricState
```


# acquireRelease

Create a resource with a cleanup `Micro` effect, ensuring the cleanup is
executed when the `MicroScope` is closed.

To import and use `acquireRelease` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.acquireRelease
```

**Signature**

```ts
export declare const acquireRelease: <A, E, R>(
  acquire: Micro<A, E, R>,
  release: (a: A, exit: MicroExit<unknown, unknown>) => Micro<void>
) => Micro<A, E, R | MicroScope>
```


# acquireUseRelease

Acquire a resource, use it, and then release the resource when the `use`
effect has completed.

To import and use `acquireUseRelease` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.acquireUseRelease
```

**Signature**

```ts
export declare const acquireUseRelease: <Resource, E, R, A, E2, R2, E3, R3>(
  acquire: Micro<Resource, E, R>,
  use: (a: Resource) => Micro<A, E2, R2>,
  release: (a: Resource, exit: MicroExit<A, E2>) => Micro<void, E3, R3>
) => Micro<A, E | E2 | E3, R | R2 | R3>
```


# addFinalizer

Add a finalizer to the current `MicroScope`.

To import and use `addFinalizer` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.addFinalizer
```

**Signature**

```ts
export declare const addFinalizer: (
  finalizer: (exit: MicroExit<unknown, unknown>) => Micro<void>
) => Micro<void, never, MicroScope>
```


# all

Runs all the provided effects in sequence respecting the structure provided in input.

Supports multiple arguments, a single argument tuple / array or record / struct.

To import and use `all` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.all
```

**Signature**

```ts
export declare const all: <
  const Arg extends Iterable<Micro<any, any, any>> | Record<string, Micro<any, any, any>>,
  O extends { readonly concurrency?: Concurrency | undefined; readonly discard?: boolean | undefined }
>(
  arg: Arg,
  options?: O
) => All.Return<Arg, O>
```


# andThen

A more flexible version of `flatMap` that combines `map` and `flatMap` into a
single API.

It also lets you directly pass a `Micro` effect, which will be executed after
the current effect.

To import and use `andThen` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.andThen
```

**Signature**

```ts
export declare const andThen: {
  <A, X>(
    f: (a: A) => X
  ): <E, R>(
    self: Micro<A, E, R>
  ) => [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>
  <X>(
    f: NotFunction<X>
  ): <A, E, R>(
    self: Micro<A, E, R>
  ) => [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>
  <A, E, R, X>(
    self: Micro<A, E, R>,
    f: (a: A) => X
  ): [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>
  <A, E, R, X>(
    self: Micro<A, E, R>,
    f: NotFunction<X>
  ): [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>
}
```


# as

Create a `Micro` effect that will replace the success value of the given
effect.

To import and use `as` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.as
```

**Signature**

```ts
export declare const as: {
  <A, B>(value: B): <E, R>(self: Micro<A, E, R>) => Micro<B, E, R>
  <A, E, R, B>(self: Micro<A, E, R>, value: B): Micro<B, E, R>
}
```


# asSome

Wrap the success value of this `Micro` effect in a `Some`.

To import and use `asSome` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.asSome
```

**Signature**

```ts
export declare const asSome: <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E, R>
```


# asVoid

Replace the success value of the `Micro` effect with `void`.

To import and use `asVoid` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.asVoid
```

**Signature**

```ts
export declare const asVoid: <A, E, R>(self: Micro<A, E, R>) => Micro<void, E, R>
```


# async

Create a `Micro` effect from an asynchronous computation.

You can return a cleanup effect that will be run when the effect is aborted.
It is also passed an `AbortSignal` that is triggered when the effect is
aborted.

To import and use `async` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.async
```

**Signature**

```ts
export declare const async: <A, E = never, R = never>(
  register: (resume: (effect: Micro<A, E, R>) => void, signal: AbortSignal) => void | Micro<void, never, R>
) => Micro<A, E, R>
```


# bind

Bind the success value of this `Micro` effect to the provided name.

To import and use `bind` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.bind
```

**Signature**

```ts
export declare const bind: {
  <N extends string, A extends Record<string, any>, B, E2, R2>(
    name: N,
    f: (a: NoInfer<A>) => Micro<B, E2, R2>
  ): <E, R>(self: Micro<A, E, R>) => Micro<Simplify<Omit<A, N> & { [K in N]: B }>, E | E2, R | R2>
  <A extends Record<string, any>, E, R, B, E2, R2, N extends string>(
    self: Micro<A, E, R>,
    name: N,
    f: (a: NoInfer<A>) => Micro<B, E2, R2>
  ): Micro<Simplify<Omit<A, N> & { [K in N]: B }>, E | E2, R | R2>
}
```


# bindTo

Bind the success value of this `Micro` effect to the provided name.

To import and use `bindTo` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.bindTo
```

**Signature**

```ts
export declare const bindTo: {
  <N extends string>(name: N): <A, E, R>(self: Micro<A, E, R>) => Micro<{ [K in N]: A }, E, R>
  <A, E, R, N extends string>(self: Micro<A, E, R>, name: N): Micro<{ [K in N]: A }, E, R>
}
```


# catchAll

Catch the error of the given `Micro` effect, allowing you to recover from it.

It only catches expected errors.

To import and use `catchAll` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.catchAll
```

**Signature**

```ts
export declare const catchAll: {
  <E, B, E2, R2>(f: (e: NoInfer<E>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E2, R | R2>
  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (e: NoInfer<E>) => Micro<B, E2, R2>): Micro<A | B, E2, R | R2>
}
```


# catchAllCause

Catch the full `MicroCause` object of the given `Micro` effect, allowing you to
recover from any kind of cause.

To import and use `catchAllCause` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.catchAllCause
```

**Signature**

```ts
export declare const catchAllCause: {
  <E, B, E2, R2>(
    f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>
  ): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E2, R | R2>
  <A, E, R, B, E2, R2>(
    self: Micro<A, E, R>,
    f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>
  ): Micro<A | B, E2, R | R2>
}
```


# catchAllDefect

Catch any unexpected errors of the given `Micro` effect, allowing you to recover from them.

To import and use `catchAllDefect` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.catchAllDefect
```

**Signature**

```ts
export declare const catchAllDefect: {
  <E, B, E2, R2>(f: (defect: unknown) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E | E2, R | R2>
  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (defect: unknown) => Micro<B, E2, R2>): Micro<A | B, E | E2, R | R2>
}
```


# catchCauseIf

Selectively catch a `MicroCause` object of the given `Micro` effect,
using the provided predicate to determine if the failure should be caught.

To import and use `catchCauseIf` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.catchCauseIf
```

**Signature**

```ts
export declare const catchCauseIf: {
  <E, B, E2, R2, EB extends MicroCause<E>>(
    refinement: Refinement<MicroCause<E>, EB>,
    f: (cause: EB) => Micro<B, E2, R2>
  ): <A, R>(self: Micro<A, E, R>) => Micro<A | B, Exclude<E, MicroCause.Error<EB>> | E2, R | R2>
  <E, B, E2, R2>(
    predicate: Predicate<MicroCause<NoInfer<E>>>,
    f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>
  ): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E | E2, R | R2>
  <A, E, R, B, E2, R2, EB extends MicroCause<E>>(
    self: Micro<A, E, R>,
    refinement: Refinement<MicroCause<E>, EB>,
    f: (cause: EB) => Micro<B, E2, R2>
  ): Micro<A | B, Exclude<E, MicroCause.Error<EB>> | E2, R | R2>
  <A, E, R, B, E2, R2>(
    self: Micro<A, E, R>,
    predicate: Predicate<MicroCause<NoInfer<E>>>,
    f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>
  ): Micro<A | B, E | E2, R | R2>
}
```


# catchIf

Catch any expected errors that match the specified predicate.

To import and use `catchIf` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.catchIf
```

**Signature**

```ts
export declare const catchIf: {
  <E, EB extends E, A2, E2, R2>(
    refinement: Refinement<NoInfer<E>, EB>,
    f: (e: EB) => Micro<A2, E2, R2>
  ): <A, R>(self: Micro<A, E, R>) => Micro<A2 | A, E2 | Exclude<E, EB>, R2 | R>
  <E, A2, E2, R2>(
    predicate: Predicate<NoInfer<E>>,
    f: (e: NoInfer<E>) => Micro<A2, E2, R2>
  ): <A, R>(self: Micro<A, E, R>) => Micro<A2 | A, E | E2, R2 | R>
  <A, E, R, EB extends E, A2, E2, R2>(
    self: Micro<A, E, R>,
    refinement: Refinement<E, EB>,
    f: (e: EB) => Micro<A2, E2, R2>
  ): Micro<A | A2, E2 | Exclude<E, EB>, R | R2>
  <A, E, R, A2, E2, R2>(
    self: Micro<A, E, R>,
    predicate: Predicate<E>,
    f: (e: E) => Micro<A2, E2, R2>
  ): Micro<A | A2, E | E2, R | R2>
}
```


# catchTag

Recovers from the specified tagged error.

To import and use `catchTag` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.catchTag
```

**Signature**

```ts
export declare const catchTag: {
  <K extends E extends { _tag: string } ? E["_tag"] : never, E, A1, E1, R1>(
    k: K,
    f: (e: Extract<E, { _tag: K }>) => Micro<A1, E1, R1>
  ): <A, R>(self: Micro<A, E, R>) => Micro<A1 | A, E1 | Exclude<E, { _tag: K }>, R1 | R>
  <A, E, R, K extends E extends { _tag: string } ? E["_tag"] : never, R1, E1, A1>(
    self: Micro<A, E, R>,
    k: K,
    f: (e: Extract<E, { _tag: K }>) => Micro<A1, E1, R1>
  ): Micro<A | A1, E1 | Exclude<E, { _tag: K }>, R | R1>
}
```


# context

Access the current `Context` from the environment.

To import and use `context` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.context
```

**Signature**

```ts
export declare const context: <R>() => Micro<Context.Context<R>>
```


# delay

Returns an effect that will delay the execution of this effect by the
specified duration.

To import and use `delay` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.delay
```

**Signature**

```ts
export declare const delay: {
  (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>
  <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<A, E, R>
}
```


# die

Creates a `Micro` effect that will die with the specified error.

This results in a `Die` variant of the `MicroCause` type, where the error is
not tracked at the type level.

To import and use `die` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.die
```

**Signature**

```ts
export declare const die: (defect: unknown) => Micro<never>
```


# Do

Start a do notation block.

To import and use `Do` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.Do
```

**Signature**

```ts
export declare const Do: Micro<{}, never, never>
```


# either

Replace the success value of the given `Micro` effect with an `Either`,
wrapping the success value in `Right` and wrapping any expected errors with
a `Left`.

To import and use `either` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.either
```

**Signature**

```ts
export declare const either: <A, E, R>(self: Micro<A, E, R>) => Micro<Either.Either<A, E>, never, R>
```


# ensuring

Regardless of the result of the this `Micro` effect, run the finalizer effect.

To import and use `ensuring` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.ensuring
```

**Signature**

```ts
export declare const ensuring: {
  <XE, XR>(finalizer: Micro<void, XE, XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>
  <A, E, R, XE, XR>(self: Micro<A, E, R>, finalizer: Micro<void, XE, XR>): Micro<A, E | XE, R | XR>
}
```


# exit

Access the `MicroExit` of the given `Micro` effect.

To import and use `exit` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.exit
```

**Signature**

```ts
export declare const exit: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroExit<A, E>, never, R>
```


# fail

Creates a `Micro` effect that fails with the given error.

This results in a `Fail` variant of the `MicroCause` type, where the error is
tracked at the type level.

To import and use `fail` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.fail
```

**Signature**

```ts
export declare const fail: <E>(error: E) => Micro<never, E>
```


# failCause

Creates a `Micro` effect that will fail with the specified `MicroCause`.

To import and use `failCause` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.failCause
```

**Signature**

```ts
export declare const failCause: <E>(cause: MicroCause<E>) => Micro<never, E>
```


# failCauseSync

Creates a `Micro` effect that will fail with the lazily evaluated `MicroCause`.

To import and use `failCauseSync` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.failCauseSync
```

**Signature**

```ts
export declare const failCauseSync: <E>(evaluate: LazyArg<MicroCause<E>>) => Micro<never, E>
```


# failSync

Creates a `Micro` effect that will fail with the lazily evaluated error.

This results in a `Fail` variant of the `MicroCause` type, where the error is
tracked at the type level.

To import and use `failSync` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.failSync
```

**Signature**

```ts
export declare const failSync: <E>(error: LazyArg<E>) => Micro<never, E>
```


# filter

Effectfully filter the elements of the provided iterable.

Use the `concurrency` option to control how many elements are processed
concurrently.

To import and use `filter` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.filter
```

**Signature**

```ts
export declare const filter: <A, E, R>(
  iterable: Iterable<A>,
  f: (a: NoInfer<A>) => Micro<boolean, E, R>,
  options?: { readonly concurrency?: Concurrency | undefined; readonly negate?: boolean | undefined }
) => Micro<Array<A>, E, R>
```


# filterMap

Effectfully filter the elements of the provided iterable.

Use the `concurrency` option to control how many elements are processed
concurrently.

To import and use `filterMap` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.filterMap
```

**Signature**

```ts
export declare const filterMap: <A, B, E, R>(
  iterable: Iterable<A>,
  f: (a: NoInfer<A>) => Micro<Option.Option<B>, E, R>,
  options?: { readonly concurrency?: Concurrency | undefined }
) => Micro<Array<B>, E, R>
```


# filterOrFail

Filter the specified effect with the provided function, failing with specified
error if the predicate fails.

In addition to the filtering capabilities discussed earlier, you have the option to further
refine and narrow down the type of the success channel by providing a

To import and use `filterOrFail` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.filterOrFail
```

**Signature**

```ts
export declare const filterOrFail: {
  <A, B extends A, E2>(
    refinement: Refinement<A, B>,
    orFailWith: (a: NoInfer<A>) => E2
  ): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R>
  <A, E2>(
    predicate: Predicate<NoInfer<A>>,
    orFailWith: (a: NoInfer<A>) => E2
  ): <E, R>(self: Micro<A, E, R>) => Micro<A, E2 | E, R>
  <A, E, R, B extends A, E2>(
    self: Micro<A, E, R>,
    refinement: Refinement<A, B>,
    orFailWith: (a: A) => E2
  ): Micro<B, E | E2, R>
  <A, E, R, E2>(self: Micro<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): Micro<A, E | E2, R>
}
```


# filterOrFailCause

Filter the specified effect with the provided function, failing with specified
`MicroCause` if the predicate fails.

In addition to the filtering capabilities discussed earlier, you have the option to further
refine and narrow down the type of the success channel by providing a

To import and use `filterOrFailCause` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.filterOrFailCause
```

**Signature**

```ts
export declare const filterOrFailCause: {
  <A, B extends A, E2>(
    refinement: Refinement<A, B>,
    orFailWith: (a: NoInfer<A>) => MicroCause<E2>
  ): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R>
  <A, E2>(
    predicate: Predicate<NoInfer<A>>,
    orFailWith: (a: NoInfer<A>) => MicroCause<E2>
  ): <E, R>(self: Micro<A, E, R>) => Micro<A, E2 | E, R>
  <A, E, R, B extends A, E2>(
    self: Micro<A, E, R>,
    refinement: Refinement<A, B>,
    orFailWith: (a: A) => MicroCause<E2>
  ): Micro<B, E | E2, R>
  <A, E, R, E2>(
    self: Micro<A, E, R>,
    predicate: Predicate<A>,
    orFailWith: (a: A) => MicroCause<E2>
  ): Micro<A, E | E2, R>
}
```


# flatMap

Map the success value of this `Micro` effect to another `Micro` effect, then
flatten the result.

To import and use `flatMap` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.flatMap
```

**Signature**

```ts
export declare const flatMap: {
  <A, B, E2, R2>(f: (a: A) => Micro<B, E2, R2>): <E, R>(self: Micro<A, E, R>) => Micro<B, E | E2, R | R2>
  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (a: A) => Micro<B, E2, R2>): Micro<B, E | E2, R | R2>
}
```


# flatten

Flattens any nested `Micro` effects, merging the error and requirement types.

To import and use `flatten` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.flatten
```

**Signature**

```ts
export declare const flatten: <A, E, R, E2, R2>(self: Micro<Micro<A, E, R>, E2, R2>) => Micro<A, E | E2, R | R2>
```


# flip

Swap the error and success types of the `Micro` effect.

To import and use `flip` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.flip
```

**Signature**

```ts
export declare const flip: <A, E, R>(self: Micro<A, E, R>) => Micro<E, A, R>
```


# forEach

For each element of the provided iterable, run the effect and collect the
results.

If the `discard` option is set to `true`, the results will be discarded and
the effect will return `void`.

The `concurrency` option can be set to control how many effects are run
concurrently. By default, the effects are run sequentially.

To import and use `forEach` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.forEach
```

**Signature**

```ts
export declare const forEach: {
  <A, B, E, R>(
    iterable: Iterable<A>,
    f: (a: A, index: number) => Micro<B, E, R>,
    options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: false | undefined }
  ): Micro<Array<B>, E, R>
  <A, B, E, R>(
    iterable: Iterable<A>,
    f: (a: A, index: number) => Micro<B, E, R>,
    options: { readonly concurrency?: Concurrency | undefined; readonly discard: true }
  ): Micro<void, E, R>
}
```


# forever

Repeat the given `Micro` effect forever, only stopping if the effect fails.

To import and use `forever` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.forever
```

**Signature**

```ts
export declare const forever: <A, E, R>(self: Micro<A, E, R>) => Micro<never, E, R>
```


# fork

Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or
aborted.

When the parent `Micro` finishes, this `Micro` will be aborted.

To import and use `fork` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.fork
```

**Signature**

```ts
export declare const fork: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R>
```


# forkDaemon

Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or
aborted.

It will not be aborted when the parent `Micro` finishes.

To import and use `forkDaemon` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.forkDaemon
```

**Signature**

```ts
export declare const forkDaemon: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R>
```


# forkIn

Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or
aborted.

The lifetime of the handle will be attached to the provided `MicroScope`.

To import and use `forkIn` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.forkIn
```

**Signature**

```ts
export declare const forkIn: {
  (scope: MicroScope): <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R>
  <A, E, R>(self: Micro<A, E, R>, scope: MicroScope): Micro<MicroFiber<A, E>, never, R>
}
```


# forkScoped

Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or
aborted.

The lifetime of the handle will be attached to the current `MicroScope`.

To import and use `forkScoped` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.forkScoped
```

**Signature**

```ts
export declare const forkScoped: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R | MicroScope>
```


# fromEither

Converts an `Either` into a `Micro` effect, that will fail with the left side
of the either if it is a `Left`. Otherwise, it will succeed with the right
side of the either.

To import and use `fromEither` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.fromEither
```

**Signature**

```ts
export declare const fromEither: <R, L>(either: Either.Either<R, L>) => Micro<R, L>
```


# fromOption

Converts an `Option` into a `Micro` effect, that will fail with
`NoSuchElementException` if the option is `None`. Otherwise, it will succeed with the
value of the option.

To import and use `fromOption` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.fromOption
```

**Signature**

```ts
export declare const fromOption: <A>(option: Option.Option<A>) => Micro<A, NoSuchElementException>
```


# ignore

Ignore any expected errors of the given `Micro` effect, returning `void`.

To import and use `ignore` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.ignore
```

**Signature**

```ts
export declare const ignore: <A, E, R>(self: Micro<A, E, R>) => Micro<void, never, R>
```


# ignoreLogged

Ignore any expected errors of the given `Micro` effect, returning `void`.

To import and use `ignoreLogged` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.ignoreLogged
```

**Signature**

```ts
export declare const ignoreLogged: <A, E, R>(self: Micro<A, E, R>) => Micro<void, never, R>
```


# interrupt

Abort the current `Micro` effect.

To import and use `interrupt` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.interrupt
```

**Signature**

```ts
export declare const interrupt: Micro<never, never, never>
```


# interruptible

Flag the effect as interruptible, which means that when the effect is
interrupted, it will be interrupted immediately.

To import and use `interruptible` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.interruptible
```

**Signature**

```ts
export declare const interruptible: <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>
```


# let

Bind the result of a synchronous computation to the given name.

To import and use `let` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.let
```


# map

Transforms the success value of the `Micro` effect with the specified
function.

To import and use `map` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.map
```

**Signature**

```ts
export declare const map: {
  <A, B>(f: (a: A) => B): <E, R>(self: Micro<A, E, R>) => Micro<B, E, R>
  <A, E, R, B>(self: Micro<A, E, R>, f: (a: A) => B): Micro<B, E, R>
}
```


# mapError

Transform any expected errors of the given `Micro` effect.

To import and use `mapError` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.mapError
```

**Signature**

```ts
export declare const mapError: {
  <E, E2>(f: (e: E) => E2): <A, R>(self: Micro<A, E, R>) => Micro<A, E2, R>
  <A, E, R, E2>(self: Micro<A, E, R>, f: (e: E) => E2): Micro<A, E2, R>
}
```


# mapErrorCause

Transform the full `MicroCause` object of the given `Micro` effect.

To import and use `mapErrorCause` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.mapErrorCause
```

**Signature**

```ts
export declare const mapErrorCause: {
  <E, E2>(f: (e: MicroCause<E>) => MicroCause<E2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E2, R>
  <A, E, R, E2>(self: Micro<A, E, R>, f: (e: MicroCause<E>) => MicroCause<E2>): Micro<A, E2, R>
}
```


# Micro

A lightweight alternative to the `Effect` data type, with a subset of the functionality.

To import and use `Micro` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.Micro
```


# MicroCause

A `MicroCause` is a data type that represents the different ways a `Micro` can fail.

**Details**

`MicroCause` comes in three forms:

- `Die`: Indicates an unforeseen defect that wasn't planned for in the system's logic.
- `Fail`: Covers anticipated errors that are recognized and typically handled within the application.
- `Interrupt`: Signifies an operation that has been purposefully stopped.

To import and use `MicroCause` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.MicroCause
```


# MicroExit

The `MicroExit` type is used to represent the result of a `Micro` computation. It
can either be successful, containing a value of type `A`, or it can fail,
containing an error of type `E` wrapped in a `MicroCause`.

To import and use `MicroExit` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.MicroExit
```


# MicroSchedule

The `MicroSchedule` type represents a function that can be used to calculate
the delay between repeats.

The function takes the current attempt number and the elapsed time since the
first attempt, and returns the delay for the next attempt. If the function
returns `None`, the repetition will stop.

To import and use `MicroSchedule` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.MicroSchedule
```


# never

A `Micro` that will never succeed or fail. It wraps `setInterval` to prevent
the Javascript runtime from exiting.

To import and use `never` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.never
```

**Signature**

```ts
export declare const never: Micro<never, never, never>
```


# NoSuchElementException

Represents a checked exception which occurs when an expected element was
unable to be found.

To import and use `NoSuchElementException` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.NoSuchElementException
```


# onError

When the `Micro` effect fails, run the given finalizer effect with the
`MicroCause` of the executed effect.

To import and use `onError` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.onError
```

**Signature**

```ts
export declare const onError: {
  <A, E, XE, XR>(
    f: (cause: MicroCause<NoInfer<E>>) => Micro<void, XE, XR>
  ): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>
  <A, E, R, XE, XR>(
    self: Micro<A, E, R>,
    f: (cause: MicroCause<NoInfer<E>>) => Micro<void, XE, XR>
  ): Micro<A, E | XE, R | XR>
}
```


# onExit

When the `Micro` effect is completed, run the given finalizer effect with the
`MicroExit` of the executed effect.

To import and use `onExit` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.onExit
```

**Signature**

```ts
export declare const onExit: {
  <A, E, XE, XR>(
    f: (exit: MicroExit<A, E>) => Micro<void, XE, XR>
  ): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>
  <A, E, R, XE, XR>(self: Micro<A, E, R>, f: (exit: MicroExit<A, E>) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>
}
```


# onExitIf

When the `Micro` effect is completed, run the given finalizer effect if it
matches the specified predicate.

To import and use `onExitIf` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.onExitIf
```

**Signature**

```ts
export declare const onExitIf: {
  <A, E, XE, XR, B extends MicroExit<A, E>>(
    refinement: Refinement<MicroExit<A, E>, B>,
    f: (exit: B) => Micro<void, XE, XR>
  ): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>
  <A, E, XE, XR>(
    predicate: Predicate<MicroExit<NoInfer<A>, NoInfer<E>>>,
    f: (exit: MicroExit<NoInfer<A>, NoInfer<E>>) => Micro<void, XE, XR>
  ): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>
  <A, E, R, XE, XR, B extends MicroExit<A, E>>(
    self: Micro<A, E, R>,
    refinement: Refinement<MicroExit<A, E>, B>,
    f: (exit: B) => Micro<void, XE, XR>
  ): Micro<A, E | XE, R | XR>
  <A, E, R, XE, XR>(
    self: Micro<A, E, R>,
    predicate: Predicate<MicroExit<NoInfer<A>, NoInfer<E>>>,
    f: (exit: MicroExit<NoInfer<A>, NoInfer<E>>) => Micro<void, XE, XR>
  ): Micro<A, E | XE, R | XR>
}
```


# onInterrupt

If this `Micro` effect is aborted, run the finalizer effect.

To import and use `onInterrupt` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.onInterrupt
```

**Signature**

```ts
export declare const onInterrupt: {
  <XE, XR>(finalizer: Micro<void, XE, XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>
  <A, E, R, XE, XR>(self: Micro<A, E, R>, finalizer: Micro<void, XE, XR>): Micro<A, E | XE, R | XR>
}
```


# option

Replace the success value of the given `Micro` effect with an `Option`,
wrapping the success value in `Some` and returning `None` if the effect fails
with an expected error.

To import and use `option` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.option
```

**Signature**

```ts
export declare const option: <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, never, R>
```


# orDie

Elevate any expected errors of the given `Micro` effect to unexpected errors,
resulting in an error type of `never`.

To import and use `orDie` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.orDie
```

**Signature**

```ts
export declare const orDie: <A, E, R>(self: Micro<A, E, R>) => Micro<A, never, R>
```


# orElseSucceed

Recover from all errors by succeeding with the given value.

To import and use `orElseSucceed` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.orElseSucceed
```

**Signature**

```ts
export declare const orElseSucceed: {
  <B>(f: LazyArg<B>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | B, never, R>
  <A, E, R, B>(self: Micro<A, E, R>, f: LazyArg<B>): Micro<A | B, never, R>
}
```


# promise

Wrap a `Promise` into a `Micro` effect.

Any errors will result in a `Die` variant of the `MicroCause` type, where the
error is not tracked at the type level.

To import and use `promise` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.promise
```

**Signature**

```ts
export declare const promise: <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>) => Micro<A>
```


# provideContext

Merge the given `Context` with the current context.

To import and use `provideContext` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.provideContext
```

**Signature**

```ts
export declare const provideContext: {
  <XR>(context: Context.Context<XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, XR>>
  <A, E, R, XR>(self: Micro<A, E, R>, context: Context.Context<XR>): Micro<A, E, Exclude<R, XR>>
}
```


# provideScope

Provide a `MicroScope` to an effect.

To import and use `provideScope` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.provideScope
```

**Signature**

```ts
export declare const provideScope: {
  (scope: MicroScope): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, MicroScope>>
  <A, E, R>(self: Micro<A, E, R>, scope: MicroScope): Micro<A, E, Exclude<R, MicroScope>>
}
```


# provideService

Add the provided service to the current context.

To import and use `provideService` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.provideService
```

**Signature**

```ts
export declare const provideService: {
  <I, S>(tag: Context.Tag<I, S>, service: S): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, I>>
  <A, E, R, I, S>(self: Micro<A, E, R>, tag: Context.Tag<I, S>, service: S): Micro<A, E, Exclude<R, I>>
}
```


# provideServiceEffect

Create a service using the provided `Micro` effect, and add it to the
current context.

To import and use `provideServiceEffect` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.provideServiceEffect
```

**Signature**

```ts
export declare const provideServiceEffect: {
  <I, S, E2, R2>(
    tag: Context.Tag<I, S>,
    acquire: Micro<S, E2, R2>
  ): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | E2, Exclude<R, I> | R2>
  <A, E, R, I, S, E2, R2>(
    self: Micro<A, E, R>,
    tag: Context.Tag<I, S>,
    acquire: Micro<S, E2, R2>
  ): Micro<A, E | E2, Exclude<R, I> | R2>
}
```


# race

Returns an effect that races two effects, yielding the value of the first
effect to succeed. Losers of the race will be interrupted immediately.

To import and use `race` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.race
```

**Signature**

```ts
export declare const race: {
  <A2, E2, R2>(that: Micro<A2, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>
  <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>
}
```


# raceAll

Returns an effect that races all the specified effects,
yielding the value of the first effect to succeed with a value. Losers of
the race will be interrupted immediately

To import and use `raceAll` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.raceAll
```

**Signature**

```ts
export declare const raceAll: <Eff extends Micro<any, any, any>>(
  all: Iterable<Eff>
) => Micro<Micro.Success<Eff>, Micro.Error<Eff>, Micro.Context<Eff>>
```


# raceAllFirst

Returns an effect that races all the specified effects,
yielding the value of the first effect to succeed or fail. Losers of
the race will be interrupted immediately.

To import and use `raceAllFirst` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.raceAllFirst
```

**Signature**

```ts
export declare const raceAllFirst: <Eff extends Micro<any, any, any>>(
  all: Iterable<Eff>
) => Micro<Micro.Success<Eff>, Micro.Error<Eff>, Micro.Context<Eff>>
```


# raceFirst

Returns an effect that races two effects, yielding the value of the first
effect to succeed _or_ fail. Losers of the race will be interrupted immediately.

To import and use `raceFirst` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.raceFirst
```

**Signature**

```ts
export declare const raceFirst: {
  <A2, E2, R2>(that: Micro<A2, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>
  <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>
}
```


# repeat

Repeat the given `Micro` effect using the provided options. Only successful
results will be repeated.

To import and use `repeat` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.repeat
```

**Signature**

```ts
export declare const repeat: {
  <A, E>(
    options?:
      | { while?: Predicate<A> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined }
      | undefined
  ): <R>(self: Micro<A, E, R>) => Micro<A, E, R>
  <A, E, R>(
    self: Micro<A, E, R>,
    options?:
      | { while?: Predicate<A> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined }
      | undefined
  ): Micro<A, E, R>
}
```


# repeatExit

Repeat the given `Micro` using the provided options.

The `while` predicate will be checked after each iteration, and can use the
fall `MicroExit` of the effect to determine if the repetition should continue.

To import and use `repeatExit` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.repeatExit
```

**Signature**

```ts
export declare const repeatExit: {
  <A, E>(options: {
    while: Predicate<MicroExit<A, E>>
    times?: number | undefined
    schedule?: MicroSchedule | undefined
  }): <R>(self: Micro<A, E, R>) => Micro<A, E, R>
  <A, E, R>(
    self: Micro<A, E, R>,
    options: { while: Predicate<MicroExit<A, E>>; times?: number | undefined; schedule?: MicroSchedule | undefined }
  ): Micro<A, E, R>
}
```


# replicate

Replicates the given effect `n` times.

To import and use `replicate` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.replicate
```

**Signature**

```ts
export declare const replicate: {
  (n: number): <A, E, R>(self: Micro<A, E, R>) => Array<Micro<A, E, R>>
  <A, E, R>(self: Micro<A, E, R>, n: number): Array<Micro<A, E, R>>
}
```


# replicateEffect

Performs this effect the specified number of times and collects the
results.

To import and use `replicateEffect` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.replicateEffect
```

**Signature**

```ts
export declare const replicateEffect: {
  (
    n: number,
    options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: false | undefined }
  ): <A, E, R>(self: Micro<A, E, R>) => Micro<Array<A>, E, R>
  (
    n: number,
    options: { readonly concurrency?: Concurrency | undefined; readonly discard: true }
  ): <A, E, R>(self: Micro<A, E, R>) => Micro<void, E, R>
  <A, E, R>(
    self: Micro<A, E, R>,
    n: number,
    options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: false | undefined }
  ): Micro<Array<A>, E, R>
  <A, E, R>(
    self: Micro<A, E, R>,
    n: number,
    options: { readonly concurrency?: Concurrency | undefined; readonly discard: true }
  ): Micro<void, E, R>
}
```


# retry

Retry the given `Micro` effect using the provided options.

To import and use `retry` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.retry
```

**Signature**

```ts
export declare const retry: {
  <A, E>(
    options?:
      | { while?: Predicate<E> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined }
      | undefined
  ): <R>(self: Micro<A, E, R>) => Micro<A, E, R>
  <A, E, R>(
    self: Micro<A, E, R>,
    options?:
      | { while?: Predicate<E> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined }
      | undefined
  ): Micro<A, E, R>
}
```


# runFork

Execute the `Micro` effect and return a `MicroFiber` that can be awaited, joined,
or aborted.

You can listen for the result by adding an observer using the handle's
`addObserver` method.

To import and use `runFork` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.runFork
```

**Example**

```ts
import * as Micro from "effect/Micro"

const handle = Micro.succeed(42).pipe(Micro.delay(1000), Micro.runFork)

handle.addObserver((exit) => {
  console.log(exit)
})
```

**Signature**

```ts
export declare const runFork: <A, E>(
  effect: Micro<A, E>,
  options?: { readonly signal?: AbortSignal | undefined; readonly scheduler?: MicroScheduler | undefined } | undefined
) => MicroFiberImpl<A, E>
```


# runPromise

Execute the `Micro` effect and return a `Promise` that resolves with the
successful value of the computation.

To import and use `runPromise` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.runPromise
```

**Signature**

```ts
export declare const runPromise: <A, E>(
  effect: Micro<A, E>,
  options?: { readonly signal?: AbortSignal | undefined; readonly scheduler?: MicroScheduler | undefined } | undefined
) => Promise<A>
```


# runPromiseExit

Execute the `Micro` effect and return a `Promise` that resolves with the
`MicroExit` of the computation.

To import and use `runPromiseExit` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.runPromiseExit
```

**Signature**

```ts
export declare const runPromiseExit: <A, E>(
  effect: Micro<A, E>,
  options?: { readonly signal?: AbortSignal | undefined; readonly scheduler?: MicroScheduler | undefined } | undefined
) => Promise<MicroExit<A, E>>
```


# runSync

Attempt to execute the `Micro` effect synchronously and return the success
value.

To import and use `runSync` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.runSync
```

**Signature**

```ts
export declare const runSync: <A, E>(effect: Micro<A, E>) => A
```


# runSyncExit

Attempt to execute the `Micro` effect synchronously and return the `MicroExit`.

If any asynchronous effects are encountered, the function will return a
`CauseDie` containing the `MicroFiber`.

To import and use `runSyncExit` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.runSyncExit
```

**Signature**

```ts
export declare const runSyncExit: <A, E>(effect: Micro<A, E>) => MicroExit<A, E>
```


# sandbox

Replace the error type of the given `Micro` with the full `MicroCause` object.

To import and use `sandbox` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.sandbox
```

**Signature**

```ts
export declare const sandbox: <A, E, R>(self: Micro<A, E, R>) => Micro<A, MicroCause<E>, R>
```


# scheduleAddDelay

Returns a new `MicroSchedule` with an added calculated delay to each delay
returned by this schedule.

To import and use `scheduleAddDelay` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.scheduleAddDelay
```

**Signature**

```ts
export declare const scheduleAddDelay: {
  (f: () => number): (self: MicroSchedule) => MicroSchedule
  (self: MicroSchedule, f: () => number): MicroSchedule
}
```


# scheduleExponential

Create a `MicroSchedule` that will generate a delay with an exponential backoff.

To import and use `scheduleExponential` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.scheduleExponential
```

**Signature**

```ts
export declare const scheduleExponential: (baseMillis: number, factor?: number) => MicroSchedule
```


# scheduleIntersect

Combines two `MicroSchedule`s, by recurring only if both schedules want to
recur, using the maximum of the two durations between recurrences.

To import and use `scheduleIntersect` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.scheduleIntersect
```

**Signature**

```ts
export declare const scheduleIntersect: {
  (that: MicroSchedule): (self: MicroSchedule) => MicroSchedule
  (self: MicroSchedule, that: MicroSchedule): MicroSchedule
}
```


# scheduleRecurs

Create a `MicroSchedule` that will stop repeating after the specified number
of attempts.

To import and use `scheduleRecurs` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.scheduleRecurs
```

**Signature**

```ts
export declare const scheduleRecurs: (n: number) => MicroSchedule
```


# scheduleSpaced

Create a `MicroSchedule` that will generate a constant delay.

To import and use `scheduleSpaced` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.scheduleSpaced
```

**Signature**

```ts
export declare const scheduleSpaced: (millis: number) => MicroSchedule
```


# scheduleUnion

Combines two `MicroSchedule`s, by recurring if either schedule wants to
recur, using the minimum of the two durations between recurrences.

To import and use `scheduleUnion` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.scheduleUnion
```

**Signature**

```ts
export declare const scheduleUnion: {
  (that: MicroSchedule): (self: MicroSchedule) => MicroSchedule
  (self: MicroSchedule, that: MicroSchedule): MicroSchedule
}
```


# scheduleWithMaxDelay

Transform a `MicroSchedule` to one that will have a delay that will never exceed
the specified maximum.

To import and use `scheduleWithMaxDelay` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.scheduleWithMaxDelay
```

**Signature**

```ts
export declare const scheduleWithMaxDelay: {
  (max: number): (self: MicroSchedule) => MicroSchedule
  (self: MicroSchedule, max: number): MicroSchedule
}
```


# scheduleWithMaxElapsed

Transform a `MicroSchedule` to one that will stop repeating after the specified
amount of time.

To import and use `scheduleWithMaxElapsed` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.scheduleWithMaxElapsed
```

**Signature**

```ts
export declare const scheduleWithMaxElapsed: {
  (max: number): (self: MicroSchedule) => MicroSchedule
  (self: MicroSchedule, max: number): MicroSchedule
}
```


# scope

Access the current `MicroScope`.

To import and use `scope` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.scope
```

**Signature**

```ts
export declare const scope: Micro<MicroScope, never, MicroScope>
```


# scoped

Provide a `MicroScope` to the given effect, closing it after the effect has
finished executing.

To import and use `scoped` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.scoped
```

**Signature**

```ts
export declare const scoped: <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, MicroScope>>
```


# service

Access the given `Context.Tag` from the environment.

To import and use `service` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.service
```

**Signature**

```ts
export declare const service: {
  <I, S>(tag: Context.Reference<I, S>): Micro<S>
  <I, S>(tag: Context.Tag<I, S>): Micro<S, never, I>
}
```


# serviceOption

Access the given `Context.Tag` from the environment, without tracking the
dependency at the type level.

It will return an `Option` of the service, depending on whether it is
available in the environment or not.

To import and use `serviceOption` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.serviceOption
```

**Signature**

```ts
export declare const serviceOption: <I, S>(tag: Context.Tag<I, S>) => Micro<Option.Option<S>>
```


# sleep

Create a `Micro` effect that will sleep for the specified duration.

To import and use `sleep` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.sleep
```

**Signature**

```ts
export declare const sleep: (millis: number) => Micro<void>
```


# succeed

Creates a `Micro` effect that will succeed with the specified constant value.

To import and use `succeed` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.succeed
```

**Signature**

```ts
export declare const succeed: <A>(value: A) => Micro<A>
```


# succeedNone

Creates a `Micro` effect that succeeds with `None`.

To import and use `succeedNone` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.succeedNone
```

**Signature**

```ts
export declare const succeedNone: Micro<Option.Option<never>, never, never>
```


# succeedSome

Creates a `Micro` effect that will succeed with the value wrapped in `Some`.

To import and use `succeedSome` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.succeedSome
```

**Signature**

```ts
export declare const succeedSome: <A>(a: A) => Micro<Option.Option<A>>
```


# suspend

Lazily creates a `Micro` effect from the given side-effect.

To import and use `suspend` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.suspend
```

**Signature**

```ts
export declare const suspend: <A, E, R>(evaluate: LazyArg<Micro<A, E, R>>) => Micro<A, E, R>
```


# sync

Creates a `Micro` effect that succeeds with a lazily evaluated value.

If the evaluation of the value throws an error, the effect will fail with a
`Die` variant of the `MicroCause` type.

To import and use `sync` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.sync
```

**Signature**

```ts
export declare const sync: <A>(evaluate: LazyArg<A>) => Micro<A>
```


# tap

Execute a side effect from the success value of the `Micro` effect.

It is similar to the `andThen` api, but the success value is ignored.

To import and use `tap` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.tap
```

**Signature**

```ts
export declare const tap: {
  <A, X>(
    f: (a: NoInfer<A>) => X
  ): <E, R>(
    self: Micro<A, E, R>
  ) => [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>
  <X>(
    f: NotFunction<X>
  ): <A, E, R>(
    self: Micro<A, E, R>
  ) => [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>
  <A, E, R, X>(
    self: Micro<A, E, R>,
    f: (a: NoInfer<A>) => X
  ): [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>
  <A, E, R, X>(
    self: Micro<A, E, R>,
    f: NotFunction<X>
  ): [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>
}
```


# tapDefect

Perform a side effect from unexpected errors of the given `Micro`.

To import and use `tapDefect` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.tapDefect
```

**Signature**

```ts
export declare const tapDefect: {
  <E, B, E2, R2>(f: (defect: unknown) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>
  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (defect: unknown) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>
}
```


# tapError

Perform a side effect from expected errors of the given `Micro`.

To import and use `tapError` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.tapError
```

**Signature**

```ts
export declare const tapError: {
  <E, B, E2, R2>(f: (e: NoInfer<E>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>
  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (e: NoInfer<E>) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>
}
```


# tapErrorCause

Perform a side effect using the full `MicroCause` object of the given `Micro`.

To import and use `tapErrorCause` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.tapErrorCause
```

**Signature**

```ts
export declare const tapErrorCause: {
  <E, B, E2, R2>(
    f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>
  ): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>
  <A, E, R, B, E2, R2>(
    self: Micro<A, E, R>,
    f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>
  ): Micro<A, E | E2, R | R2>
}
```


# tapErrorCauseIf

Perform a side effect using if a `MicroCause` object matches the specified
predicate.

To import and use `tapErrorCauseIf` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.tapErrorCauseIf
```

**Signature**

```ts
export declare const tapErrorCauseIf: {
  <E, B, E2, R2, EB extends MicroCause<E>>(
    refinement: Refinement<MicroCause<E>, EB>,
    f: (a: EB) => Micro<B, E2, R2>
  ): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>
  <E, B, E2, R2>(
    predicate: (cause: NoInfer<MicroCause<E>>) => boolean,
    f: (a: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>
  ): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>
  <A, E, R, B, E2, R2, EB extends MicroCause<E>>(
    self: Micro<A, E, R>,
    refinement: Refinement<MicroCause<E>, EB>,
    f: (a: EB) => Micro<B, E2, R2>
  ): Micro<A, E | E2, R | R2>
  <A, E, R, B, E2, R2>(
    self: Micro<A, E, R>,
    predicate: (cause: NoInfer<MicroCause<E>>) => boolean,
    f: (a: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>
  ): Micro<A, E | E2, R | R2>
}
```


# timeout

Returns an effect that will timeout this effect, that will fail with a
`TimeoutException` if the timeout elapses before the effect has produced a
value.

If the timeout elapses, the running effect will be safely interrupted.

To import and use `timeout` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.timeout
```

**Signature**

```ts
export declare const timeout: {
  (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | TimeoutException, R>
  <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<A, E | TimeoutException, R>
}
```


# TimeoutException

Represents a checked exception which occurs when a timeout occurs.

To import and use `TimeoutException` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.TimeoutException
```


# timeoutOption

Returns an effect that will timeout this effect, succeeding with a `None`
if the timeout elapses before the effect has produced a value; and `Some` of
the produced value otherwise.

If the timeout elapses, the running effect will be safely interrupted.

To import and use `timeoutOption` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.timeoutOption
```

**Signature**

```ts
export declare const timeoutOption: {
  (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E, R>
  <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<Option.Option<A>, E, R>
}
```


# timeoutOrElse

Returns an effect that will timeout this effect, that will execute the
fallback effect if the timeout elapses before the effect has produced a value.

If the timeout elapses, the running effect will be safely interrupted.

To import and use `timeoutOrElse` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.timeoutOrElse
```

**Signature**

```ts
export declare const timeoutOrElse: {
  <A2, E2, R2>(options: {
    readonly duration: number
    readonly onTimeout: LazyArg<Micro<A2, E2, R2>>
  }): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>
  <A, E, R, A2, E2, R2>(
    self: Micro<A, E, R>,
    options: { readonly duration: number; readonly onTimeout: LazyArg<Micro<A2, E2, R2>> }
  ): Micro<A | A2, E | E2, R | R2>
}
```


# try

The `Micro` equivalent of a try / catch block, which allows you to map
thrown errors to a specific error type.

To import and use `try` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.try
```

**Example**

```ts
import { Micro } from "effect"

Micro.try({
  try: () => throw new Error("boom"),
  catch: (cause) => new Error("caught", { cause })
})
```


# tryPromise

Wrap a `Promise` into a `Micro` effect. Any errors will be caught and
converted into a specific error type.

To import and use `tryPromise` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.tryPromise
```

**Example**

```ts
import { Micro } from "effect"

Micro.tryPromise({
  try: () => Promise.resolve("success"),
  catch: (cause) => new Error("caught", { cause })
})
```

**Signature**

```ts
export declare const tryPromise: <A, E>(options: {
  readonly try: (signal: AbortSignal) => PromiseLike<A>
  readonly catch: (error: unknown) => E
}) => Micro<A, E>
```


# uninterruptible

Flag the effect as uninterruptible, which means that when the effect is
interrupted, it will be allowed to continue running until completion.

To import and use `uninterruptible` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.uninterruptible
```

**Signature**

```ts
export declare const uninterruptible: <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>
```


# uninterruptibleMask

Wrap the given `Micro` effect in an uninterruptible region, preventing the
effect from being aborted.

You can use the `restore` function to restore a `Micro` effect to the
interruptibility state before the `uninterruptibleMask` was applied.

To import and use `uninterruptibleMask` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.uninterruptibleMask
```

**Example**

```ts
import * as Micro from "effect/Micro"

Micro.uninterruptibleMask((restore) =>
  Micro.sleep(1000).pipe(
    // uninterruptible
    Micro.andThen(restore(Micro.sleep(1000))) // interruptible
  )
)
```

**Signature**

```ts
export declare const uninterruptibleMask: <A, E, R>(
  f: (restore: <A, E, R>(effect: Micro<A, E, R>) => Micro<A, E, R>) => Micro<A, E, R>
) => Micro<A, E, R>
```


# updateContext

Update the Context with the given mapping function.

To import and use `updateContext` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.updateContext
```

**Signature**

```ts
export declare const updateContext: {
  <R2, R>(
    f: (context: Context.Context<R2>) => Context.Context<NoInfer<R>>
  ): <A, E>(self: Micro<A, E, R>) => Micro<A, E, R2>
  <A, E, R, R2>(self: Micro<A, E, R>, f: (context: Context.Context<R2>) => Context.Context<NoInfer<R>>): Micro<A, E, R2>
}
```


# updateService

Update the service for the given `Context.Tag` in the environment.

To import and use `updateService` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.updateService
```

**Signature**

```ts
export declare const updateService: {
  <I, A>(tag: Context.Reference<I, A>, f: (value: A) => A): <XA, E, R>(self: Micro<XA, E, R>) => Micro<XA, E, R>
  <I, A>(tag: Context.Tag<I, A>, f: (value: A) => A): <XA, E, R>(self: Micro<XA, E, R>) => Micro<XA, E, R | I>
  <XA, E, R, I, A>(self: Micro<XA, E, R>, tag: Context.Reference<I, A>, f: (value: A) => A): Micro<XA, E, R>
  <XA, E, R, I, A>(self: Micro<XA, E, R>, tag: Context.Tag<I, A>, f: (value: A) => A): Micro<XA, E, R | I>
}
```


# void

A `Micro` effect that will succeed with `void` (`undefined`).

To import and use `void` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.void
```


# when

The moral equivalent of `if (p) exp`.

To import and use `when` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.when
```

**Signature**

```ts
export declare const when: {
  <E2 = never, R2 = never>(
    condition: LazyArg<boolean> | Micro<boolean, E2, R2>
  ): <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E | E2, R | R2>
  <A, E, R, E2 = never, R2 = never>(
    self: Micro<A, E, R>,
    condition: LazyArg<boolean> | Micro<boolean, E2, R2>
  ): Micro<Option.Option<A>, E | E2, R | R2>
}
```


# withConcurrency

If you have a `Micro` that uses `concurrency: "inherit"`, you can use this
api to control the concurrency of that `Micro` when it is run.

To import and use `withConcurrency` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.withConcurrency
```

**Example**

```ts
import * as Micro from "effect/Micro"

Micro.forEach([1, 2, 3], (n) => Micro.succeed(n), {
  concurrency: "inherit"
}).pipe(
  Micro.withConcurrency(2) // use a concurrency of 2
)
```

**Signature**

```ts
export declare const withConcurrency: {
  (concurrency: "unbounded" | number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>
  <A, E, R>(self: Micro<A, E, R>, concurrency: "unbounded" | number): Micro<A, E, R>
}
```


# withMicroFiber

Create a `Micro` effect using the current `MicroFiber`.

To import and use `withMicroFiber` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.withMicroFiber
```

**Signature**

```ts
export declare const withMicroFiber: <A, E = never, R = never>(
  evaluate: (fiber: MicroFiberImpl<A, E>) => Micro<A, E, R>
) => Micro<A, E, R>
```


# withTrace

Add a stack trace to any failures that occur in the effect. The trace will be
added to the `traces` field of the `MicroCause` object.

To import and use `withTrace` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.withTrace
```

**Signature**

```ts
export declare const withTrace: {
  (name: string): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>
  <A, E, R>(self: Micro<A, E, R>, name: string): Micro<A, E, R>
}
```


# yieldFlush

Flush any yielded effects that are waiting to be executed.

To import and use `yieldFlush` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.yieldFlush
```

**Signature**

```ts
export declare const yieldFlush: Micro<void, never, never>
```


# yieldNow

Pause the execution of the current `Micro` effect, and resume it on the next
scheduler tick.

To import and use `yieldNow` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.yieldNow
```

**Signature**

```ts
export declare const yieldNow: Micro<void, never, never>
```


# yieldNowWith

Pause the execution of the current `Micro` effect, and resume it on the next
scheduler tick.

To import and use `yieldNowWith` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.yieldNowWith
```

**Signature**

```ts
export declare const yieldNowWith: (priority?: number) => Micro<void>
```


# zip

Combine two `Micro` effects into a single effect that produces a tuple of
their results.

To import and use `zip` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.zip
```

**Signature**

```ts
export declare const zip: {
  <A2, E2, R2>(
    that: Micro<A2, E2, R2>,
    options?: { readonly concurrent?: boolean | undefined } | undefined
  ): <A, E, R>(self: Micro<A, E, R>) => Micro<[A, A2], E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Micro<A, E, R>,
    that: Micro<A2, E2, R2>,
    options?: { readonly concurrent?: boolean | undefined }
  ): Micro<[A, A2], E | E2, R | R2>
}
```


# zipWith

The `Micro.zipWith` function combines two `Micro` effects and allows you to
apply a function to the results of the combined effects, transforming them
into a single value.

To import and use `zipWith` from the "Micro" module:

```ts
import * as Micro from "effect/Micro"
// Can be accessed like this
Micro.zipWith
```

**Signature**

```ts
export declare const zipWith: {
  <A2, E2, R2, A, B>(
    that: Micro<A2, E2, R2>,
    f: (a: A, b: A2) => B,
    options?: { readonly concurrent?: boolean | undefined }
  ): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2, B>(
    self: Micro<A, E, R>,
    that: Micro<A2, E2, R2>,
    f: (a: A, b: A2) => B,
    options?: { readonly concurrent?: boolean | undefined }
  ): Micro<B, E2 | E, R2 | R>
}
```


# BooleanFromNumber

A boolean parsed from 0 or 1

To import and use `BooleanFromNumber` from the "Model" module:

```ts
import * as Model from "@effect/sql/Model"
// Can be accessed like this
Model.BooleanFromNumber
```


# Class

A base class used for creating domain model schemas.

It supports common variants for database and JSON apis.

To import and use `Class` from the "Model" module:

```ts
import * as Model from "@effect/sql/Model"
// Can be accessed like this
Model.Class
```

**Example**

```ts
import { Schema } from "effect"
import { Model } from "@effect/sql"

export const GroupId = Schema.Number.pipe(Schema.brand("GroupId"))

export class Group extends Model.Class<Group>("Group")({
  id: Model.Generated(GroupId),
  name: Schema.NonEmptyTrimmedString,
  createdAt: Model.DateTimeInsertFromDate,
  updatedAt: Model.DateTimeUpdateFromDate
}) {}

// schema used for selects
Group

// schema used for inserts
Group.insert

// schema used for updates
Group.update

// schema used for json api
Group.json
Group.jsonCreate
Group.jsonUpdate

// you can also turn them into classes
class GroupJson extends Schema.Class<GroupJson>("GroupJson")(Group.json) {
  get upperName() {
    return this.name.toUpperCase()
  }
}
```


# Date

A schema for a `DateTime.Utc` that is serialized as a date string in the
format `YYYY-MM-DD`.

To import and use `Date` from the "Model" module:

```ts
import * as Model from "@effect/sql/Model"
// Can be accessed like this
Model.Date
```

**Signature**

```ts
export declare const Date: Date
```


# DateTimeInsert

A field that represents a date-time value that is inserted as the current
`DateTime.Utc`. It is serialized as a string for the database.

It is omitted from updates and is available for selection.

To import and use `DateTimeInsert` from the "Model" module:

```ts
import * as Model from "@effect/sql/Model"
// Can be accessed like this
Model.DateTimeInsert
```

**Signature**

```ts
export declare const DateTimeInsert: DateTimeInsert
```


# DateTimeInsertFromDate

A field that represents a date-time value that is inserted as the current
`DateTime.Utc`. It is serialized as a `Date` for the database.

It is omitted from updates and is available for selection.

To import and use `DateTimeInsertFromDate` from the "Model" module:

```ts
import * as Model from "@effect/sql/Model"
// Can be accessed like this
Model.DateTimeInsertFromDate
```

**Signature**

```ts
export declare const DateTimeInsertFromDate: DateTimeInsertFromDate
```


# DateTimeInsertFromNumber

A field that represents a date-time value that is inserted as the current
`DateTime.Utc`. It is serialized as a `number`.

It is omitted from updates and is available for selection.

To import and use `DateTimeInsertFromNumber` from the "Model" module:

```ts
import * as Model from "@effect/sql/Model"
// Can be accessed like this
Model.DateTimeInsertFromNumber
```

**Signature**

```ts
export declare const DateTimeInsertFromNumber: DateTimeInsertFromNumber
```


# DateTimeUpdate

A field that represents a date-time value that is updated as the current
`DateTime.Utc`. It is serialized as a string for the database.

It is set to the current `DateTime.Utc` on updates and inserts and is
available for selection.

To import and use `DateTimeUpdate` from the "Model" module:

```ts
import * as Model from "@effect/sql/Model"
// Can be accessed like this
Model.DateTimeUpdate
```

**Signature**

```ts
export declare const DateTimeUpdate: DateTimeUpdate
```


# DateTimeUpdateFromDate

A field that represents a date-time value that is updated as the current
`DateTime.Utc`. It is serialized as a `Date` for the database.

It is set to the current `DateTime.Utc` on updates and inserts and is
available for selection.

To import and use `DateTimeUpdateFromDate` from the "Model" module:

```ts
import * as Model from "@effect/sql/Model"
// Can be accessed like this
Model.DateTimeUpdateFromDate
```

**Signature**

```ts
export declare const DateTimeUpdateFromDate: DateTimeUpdateFromDate
```


# DateTimeUpdateFromNumber

A field that represents a date-time value that is updated as the current
`DateTime.Utc`. It is serialized as a `number`.

It is set to the current `DateTime.Utc` on updates and inserts and is
available for selection.

To import and use `DateTimeUpdateFromNumber` from the "Model" module:

```ts
import * as Model from "@effect/sql/Model"
// Can be accessed like this
Model.DateTimeUpdateFromNumber
```

**Signature**

```ts
export declare const DateTimeUpdateFromNumber: DateTimeUpdateFromNumber
```


# FieldOption

Convert a field to one that is optional for all variants.

For the database variants, it will accept `null`able values.
For the JSON variants, it will also accept missing keys.

To import and use `FieldOption` from the "Model" module:

```ts
import * as Model from "@effect/sql/Model"
// Can be accessed like this
Model.FieldOption
```


# Generated

A field that represents a column that is generated by the database.

It is available for selection and update, but not for insertion.

To import and use `Generated` from the "Model" module:

```ts
import * as Model from "@effect/sql/Model"
// Can be accessed like this
Model.Generated
```

**Signature**

```ts
export declare const Generated: <S extends Schema.Schema.All | Schema.PropertySignature.All>(schema: S) => Generated<S>
```


# GeneratedByApp

A field that represents a column that is generated by the application.

It is required by the database, but not by the JSON variants.

To import and use `GeneratedByApp` from the "Model" module:

```ts
import * as Model from "@effect/sql/Model"
// Can be accessed like this
Model.GeneratedByApp
```

**Signature**

```ts
export declare const GeneratedByApp: <S extends Schema.Schema.All | Schema.PropertySignature.All>(
  schema: S
) => GeneratedByApp<S>
```


# JsonFromString

A field that represents a JSON value stored as text in the database.

The "json" variants will use the object schema directly.

To import and use `JsonFromString` from the "Model" module:

```ts
import * as Model from "@effect/sql/Model"
// Can be accessed like this
Model.JsonFromString
```

**Signature**

```ts
export declare const JsonFromString: <S extends Schema.Schema.All | Schema.PropertySignature.All>(
  schema: S
) => JsonFromString<S>
```


# makeDataLoaders

Create some simple data loaders from a model.

To import and use `makeDataLoaders` from the "Model" module:

```ts
import * as Model from "@effect/sql/Model"
// Can be accessed like this
Model.makeDataLoaders
```

**Signature**

```ts
export declare const makeDataLoaders: <
  S extends AnyNoContext,
  Id extends keyof S["Type"] & keyof S["update"]["Type"] & keyof S["fields"]
>(
  Model: S,
  options: {
    readonly tableName: string
    readonly spanPrefix: string
    readonly idColumn: Id
    readonly window: DurationInput
    readonly maxBatchSize?: number | undefined
  }
) => Effect.Effect<
  {
    readonly insert: (insert: S["insert"]["Type"]) => Effect.Effect<S["Type"]>
    readonly insertVoid: (insert: S["insert"]["Type"]) => Effect.Effect<void>
    readonly findById: (id: Schema.Schema.Type<S["fields"][Id]>) => Effect.Effect<Option.Option<S["Type"]>>
    readonly delete: (id: Schema.Schema.Type<S["fields"][Id]>) => Effect.Effect<void>
  },
  never,
  SqlClient | Scope
>
```


# makeRepository

Create a simple CRUD repository from a model.

To import and use `makeRepository` from the "Model" module:

```ts
import * as Model from "@effect/sql/Model"
// Can be accessed like this
Model.makeRepository
```

**Signature**

```ts
export declare const makeRepository: <
  S extends Any,
  Id extends keyof S["Type"] & keyof S["update"]["Type"] & keyof S["fields"]
>(
  Model: S,
  options: { readonly tableName: string; readonly spanPrefix: string; readonly idColumn: Id }
) => Effect.Effect<
  {
    readonly insert: (
      insert: S["insert"]["Type"]
    ) => Effect.Effect<S["Type"], never, S["Context"] | S["insert"]["Context"]>
    readonly insertVoid: (
      insert: S["insert"]["Type"]
    ) => Effect.Effect<void, never, S["Context"] | S["insert"]["Context"]>
    readonly update: (
      update: S["update"]["Type"]
    ) => Effect.Effect<S["Type"], never, S["Context"] | S["update"]["Context"]>
    readonly updateVoid: (
      update: S["update"]["Type"]
    ) => Effect.Effect<void, never, S["Context"] | S["update"]["Context"]>
    readonly findById: (
      id: Schema.Schema.Type<S["fields"][Id]>
    ) => Effect.Effect<Option.Option<S["Type"]>, never, S["Context"] | Schema.Schema.Context<S["fields"][Id]>>
    readonly delete: (
      id: Schema.Schema.Type<S["fields"][Id]>
    ) => Effect.Effect<void, never, Schema.Schema.Context<S["fields"][Id]>>
  },
  never,
  SqlClient
>
```


# Sensitive

A field that represents a sensitive value that should not be exposed in the
JSON variants.

To import and use `Sensitive` from the "Model" module:

```ts
import * as Model from "@effect/sql/Model"
// Can be accessed like this
Model.Sensitive
```

**Signature**

```ts
export declare const Sensitive: <S extends Schema.Schema.All | Schema.PropertySignature.All>(schema: S) => Sensitive<S>
```


# UuidV4Insert

A field that represents a binary UUID v4 that is generated on inserts.

To import and use `UuidV4Insert` from the "Model" module:

```ts
import * as Model from "@effect/sql/Model"
// Can be accessed like this
Model.UuidV4Insert
```

**Signature**

```ts
export declare const UuidV4Insert: <const B extends string | symbol>(
  schema: Schema.brand<typeof Schema.Uint8ArrayFromSelf, B>
) => UuidV4Insert<B>
```


# array

Given a type `A`, this function creates and returns a `Semigroup` for `ReadonlyArray<A>`.

The `empty` value is the empty array.

To import and use `array` from the "Monoid" module:

```ts
import * as Monoid from "@effect/typeclass/Monoid"
// Can be accessed like this
Monoid.array
```

**Signature**

```ts
export declare const array: <A>() => Monoid<ReadonlyArray<A>>
```


# max

Get a monoid where `combine` will return the maximum, based on the provided bounded order.

The `empty` value is the `minimum` value.

To import and use `max` from the "Monoid" module:

```ts
import * as Monoid from "@effect/typeclass/Monoid"
// Can be accessed like this
Monoid.max
```

**Signature**

```ts
export declare const max: <A>(B: Bounded<A>) => Monoid<A>
```


# min

Get a monoid where `combine` will return the minimum, based on the provided bounded order.

The `empty` value is the `maxBound` value.

To import and use `min` from the "Monoid" module:

```ts
import * as Monoid from "@effect/typeclass/Monoid"
// Can be accessed like this
Monoid.min
```

**Signature**

```ts
export declare const min: <A>(B: Bounded<A>) => Monoid<A>
```


# reverse

The dual of a `Monoid`, obtained by swapping the arguments of `combine`.

To import and use `reverse` from the "Monoid" module:

```ts
import * as Monoid from "@effect/typeclass/Monoid"
// Can be accessed like this
Monoid.reverse
```

**Signature**

```ts
export declare const reverse: <A>(M: Monoid<A>) => Monoid<A>
```


# struct

This function creates and returns a new `Monoid` for a struct of values based on the given `Monoid`s for each property in the struct.
The returned `Monoid` combines two structs of the same type by applying the corresponding `Monoid` passed as arguments to each property in the struct.

The `empty` value of the returned `Monoid` is a struct where each property is the `empty` value of the corresponding `Monoid` in the input `monoids` object.

It is useful when you need to combine two structs of the same type and you have a specific way of combining each property of the struct.

To import and use `struct` from the "Monoid" module:

```ts
import * as Monoid from "@effect/typeclass/Monoid"
// Can be accessed like this
Monoid.struct
```

**Signature**

```ts
export declare const struct: <R extends { readonly [x: string]: Monoid<any> }>(
  fields: R
) => Monoid<{ readonly [K in keyof R]: [R[K]] extends [Monoid<infer A>] ? A : never }>
```


# tuple

Similar to `Promise.all` but operates on `Monoid`s.

```
[Monoid<A>, Monoid<B>, ...] -> Monoid<[A, B, ...]>
```

This function creates and returns a new `Monoid` for a tuple of values based on the given `Monoid`s for each element in the tuple.
The returned `Monoid` combines two tuples of the same type by applying the corresponding `Monoid` passed as arguments to each element in the tuple.

The `empty` value of the returned `Monoid` is the tuple of `empty` values of the input `Monoid`s.

It is useful when you need to combine two tuples of the same type and you have a specific way of combining each element of the tuple.

To import and use `tuple` from the "Monoid" module:

```ts
import * as Monoid from "@effect/typeclass/Monoid"
// Can be accessed like this
Monoid.tuple
```

**Signature**

```ts
export declare const tuple: <T extends ReadonlyArray<Monoid<any>>>(
  ...elements: T
) => Monoid<{ readonly [I in keyof T]: [T[I]] extends [Monoid<infer A>] ? A : never }>
```


# fromIterable

Creates a new `MutableHashMap` from an iterable collection of key/value pairs.

To import and use `fromIterable` from the "MutableHashMap" module:

```ts
import * as MutableHashMap from "effect/MutableHashMap"
// Can be accessed like this
MutableHashMap.fromIterable
```

**Signature**

```ts
export declare const fromIterable: <K, V>(entries: Iterable<readonly [K, V]>) => MutableHashMap<K, V>
```


# modify

Updates the value of the specified key within the `MutableHashMap` if it exists.

To import and use `modify` from the "MutableHashMap" module:

```ts
import * as MutableHashMap from "effect/MutableHashMap"
// Can be accessed like this
MutableHashMap.modify
```

**Signature**

```ts
export declare const modify: {
  <K, V>(key: K, f: (v: V) => V): (self: MutableHashMap<K, V>) => MutableHashMap<K, V>
  <K, V>(self: MutableHashMap<K, V>, key: K, f: (v: V) => V): MutableHashMap<K, V>
}
```


# modifyAt

Set or remove the specified key in the `MutableHashMap` using the specified
update function.

To import and use `modifyAt` from the "MutableHashMap" module:

```ts
import * as MutableHashMap from "effect/MutableHashMap"
// Can be accessed like this
MutableHashMap.modifyAt
```

**Signature**

```ts
export declare const modifyAt: {
  <K, V>(key: K, f: (value: Option.Option<V>) => Option.Option<V>): (self: MutableHashMap<K, V>) => MutableHashMap<K, V>
  <K, V>(self: MutableHashMap<K, V>, key: K, f: (value: Option.Option<V>) => Option.Option<V>): MutableHashMap<K, V>
}
```


# fromIterable

Creates a new `MutableHashSet` from an iterable collection of values.

To import and use `fromIterable` from the "MutableHashSet" module:

```ts
import * as MutableHashSet from "effect/MutableHashSet"
// Can be accessed like this
MutableHashSet.fromIterable
```

**Signature**

```ts
export declare const fromIterable: <K = never>(keys: Iterable<K>) => MutableHashSet<K>
```


# append

Appends the specified element to the end of the `MutableList`.

To import and use `append` from the "MutableList" module:

```ts
import * as MutableList from "effect/MutableList"
// Can be accessed like this
MutableList.append
```

**Signature**

```ts
export declare const append: {
  <A>(value: A): (self: MutableList<A>) => MutableList<A>
  <A>(self: MutableList<A>, value: A): MutableList<A>
}
```


# empty

Creates an empty `MutableList`.

To import and use `empty` from the "MutableList" module:

```ts
import * as MutableList from "effect/MutableList"
// Can be accessed like this
MutableList.empty
```

**Signature**

```ts
export declare const empty: <A>() => MutableList<A>
```


# forEach

Executes the specified function `f` for each element in the list.

To import and use `forEach` from the "MutableList" module:

```ts
import * as MutableList from "effect/MutableList"
// Can be accessed like this
MutableList.forEach
```

**Signature**

```ts
export declare const forEach: {
  <A>(f: (element: A) => void): (self: MutableList<A>) => void
  <A>(self: MutableList<A>, f: (element: A) => void): void
}
```


# fromIterable

Creates a new `MutableList` from an iterable collection of values.

To import and use `fromIterable` from the "MutableList" module:

```ts
import * as MutableList from "effect/MutableList"
// Can be accessed like this
MutableList.fromIterable
```

**Signature**

```ts
export declare const fromIterable: <A>(iterable: Iterable<A>) => MutableList<A>
```


# head

Returns the first element of the list, if it exists.

To import and use `head` from the "MutableList" module:

```ts
import * as MutableList from "effect/MutableList"
// Can be accessed like this
MutableList.head
```

**Signature**

```ts
export declare const head: <A>(self: MutableList<A>) => A | undefined
```


# isEmpty

Returns `true` if the list contains zero elements, `false`, otherwise.

To import and use `isEmpty` from the "MutableList" module:

```ts
import * as MutableList from "effect/MutableList"
// Can be accessed like this
MutableList.isEmpty
```

**Signature**

```ts
export declare const isEmpty: <A>(self: MutableList<A>) => boolean
```


# length

Returns the length of the list.

To import and use `length` from the "MutableList" module:

```ts
import * as MutableList from "effect/MutableList"
// Can be accessed like this
MutableList.length
```

**Signature**

```ts
export declare const length: <A>(self: MutableList<A>) => number
```


# make

Creates a new `MutableList` from the specified elements.

To import and use `make` from the "MutableList" module:

```ts
import * as MutableList from "effect/MutableList"
// Can be accessed like this
MutableList.make
```

**Signature**

```ts
export declare const make: <A>(...elements: ReadonlyArray<A>) => MutableList<A>
```


# pop

Removes the last value from the list and returns it, if it exists.

To import and use `pop` from the "MutableList" module:

```ts
import * as MutableList from "effect/MutableList"
// Can be accessed like this
MutableList.pop
```

**Signature**

```ts
export declare const pop: <A>(self: MutableList<A>) => A | undefined
```


# prepend

Prepends the specified value to the beginning of the list.

To import and use `prepend` from the "MutableList" module:

```ts
import * as MutableList from "effect/MutableList"
// Can be accessed like this
MutableList.prepend
```

**Signature**

```ts
export declare const prepend: {
  <A>(value: A): (self: MutableList<A>) => MutableList<A>
  <A>(self: MutableList<A>, value: A): MutableList<A>
}
```


# reset

Removes all elements from the doubly-linked list.

To import and use `reset` from the "MutableList" module:

```ts
import * as MutableList from "effect/MutableList"
// Can be accessed like this
MutableList.reset
```

**Signature**

```ts
export declare const reset: <A>(self: MutableList<A>) => MutableList<A>
```


# shift

Removes the first value from the list and returns it, if it exists.

To import and use `shift` from the "MutableList" module:

```ts
import * as MutableList from "effect/MutableList"
// Can be accessed like this
MutableList.shift
```

**Signature**

```ts
export declare const shift: <A>(self: MutableList<A>) => A | undefined
```


# tail

Returns the last element of the list, if it exists.

To import and use `tail` from the "MutableList" module:

```ts
import * as MutableList from "effect/MutableList"
// Can be accessed like this
MutableList.tail
```

**Signature**

```ts
export declare const tail: <A>(self: MutableList<A>) => A | undefined
```


# bounded

Creates a new bounded `MutableQueue`.

To import and use `bounded` from the "MutableQueue" module:

```ts
import * as MutableQueue from "effect/MutableQueue"
// Can be accessed like this
MutableQueue.bounded
```

**Signature**

```ts
export declare const bounded: <A>(capacity: number) => MutableQueue<A>
```


# capacity

The **maximum** number of elements that a queue can hold.

**Note**: unbounded queues can still implement this interface with
`capacity = Infinity`.

To import and use `capacity` from the "MutableQueue" module:

```ts
import * as MutableQueue from "effect/MutableQueue"
// Can be accessed like this
MutableQueue.capacity
```

**Signature**

```ts
export declare const capacity: <A>(self: MutableQueue<A>) => number
```


# isEmpty

Returns `true` if the queue is empty, `false` otherwise.

To import and use `isEmpty` from the "MutableQueue" module:

```ts
import * as MutableQueue from "effect/MutableQueue"
// Can be accessed like this
MutableQueue.isEmpty
```

**Signature**

```ts
export declare const isEmpty: <A>(self: MutableQueue<A>) => boolean
```


# isFull

Returns `true` if the queue is full, `false` otherwise.

To import and use `isFull` from the "MutableQueue" module:

```ts
import * as MutableQueue from "effect/MutableQueue"
// Can be accessed like this
MutableQueue.isFull
```

**Signature**

```ts
export declare const isFull: <A>(self: MutableQueue<A>) => boolean
```


# length

Returns the current number of elements in the queue.

To import and use `length` from the "MutableQueue" module:

```ts
import * as MutableQueue from "effect/MutableQueue"
// Can be accessed like this
MutableQueue.length
```

**Signature**

```ts
export declare const length: <A>(self: MutableQueue<A>) => number
```


# offer

Offers an element to the queue.

Returns whether the enqueue was successful or not.

To import and use `offer` from the "MutableQueue" module:

```ts
import * as MutableQueue from "effect/MutableQueue"
// Can be accessed like this
MutableQueue.offer
```

**Signature**

```ts
export declare const offer: {
  <A>(self: MutableQueue<A>, value: A): boolean
  <A>(value: A): (self: MutableQueue<A>) => boolean
}
```


# offerAll

Enqueues a collection of values into the queue.

Returns a `Chunk` of the values that were **not** able to be enqueued.

To import and use `offerAll` from the "MutableQueue" module:

```ts
import * as MutableQueue from "effect/MutableQueue"
// Can be accessed like this
MutableQueue.offerAll
```

**Signature**

```ts
export declare const offerAll: {
  <A>(values: Iterable<A>): (self: MutableQueue<A>) => Chunk.Chunk<A>
  <A>(self: MutableQueue<A>, values: Iterable<A>): Chunk.Chunk<A>
}
```


# poll

Dequeues an element from the queue.

Returns either an element from the queue, or the `def` param.

**Note**: if there is no meaningful default for your type, you can always
use `poll(MutableQueue.EmptyMutableQueue)`.

To import and use `poll` from the "MutableQueue" module:

```ts
import * as MutableQueue from "effect/MutableQueue"
// Can be accessed like this
MutableQueue.poll
```

**Signature**

```ts
export declare const poll: {
  <D>(def: D): <A>(self: MutableQueue<A>) => D | A
  <A, D>(self: MutableQueue<A>, def: D): A | D
}
```


# pollUpTo

Dequeues up to `n` elements from the queue.

Returns a `List` of up to `n` elements.

To import and use `pollUpTo` from the "MutableQueue" module:

```ts
import * as MutableQueue from "effect/MutableQueue"
// Can be accessed like this
MutableQueue.pollUpTo
```

**Signature**

```ts
export declare const pollUpTo: {
  (n: number): <A>(self: MutableQueue<A>) => Chunk.Chunk<A>
  <A>(self: MutableQueue<A>, n: number): Chunk.Chunk<A>
}
```


# unbounded

Creates a new unbounded `MutableQueue`.

To import and use `unbounded` from the "MutableQueue" module:

```ts
import * as MutableQueue from "effect/MutableQueue"
// Can be accessed like this
MutableQueue.unbounded
```

**Signature**

```ts
export declare const unbounded: <A>() => MutableQueue<A>
```


# NdjsonOptions

Represents a set of options which can be used to control how the newline
delimited JSON is handled.

To import and use `NdjsonOptions` from the "Ndjson" module:

```ts
import * as Ndjson from "@effect/experimental/Ndjson"
// Can be accessed like this
Ndjson.NdjsonOptions
```


# layer

You can provide this Layer to use `@parcel/watcher` as the backend for watching files.

To import and use `layer` from the "ParcelWatcher" module:

```ts
import * as ParcelWatcher from "@effect/platform-node-shared/NodeFileSystem/ParcelWatcher"
// Can be accessed like this
ParcelWatcher.layer
```

**Signature**

```ts
export declare const layer: Layer<WatchBackend, never, never>
```


# layerContext

A Layer providing the `HttpPlatform`, `FileSystem`, `Etag.Generator`, and `Path`
services.

The `FileSystem` service is a no-op implementation, so this layer is only
useful for platforms that have no file system.

To import and use `layerContext` from the "NodeHttpServer" module:

```ts
import * as NodeHttpServer from "@effect/platform-node/NodeHttpServer"
// Can be accessed like this
NodeHttpServer.layerContext
```

**Signature**

```ts
export declare const layerContext: Layer.Layer<
  Platform.HttpPlatform | Etag.Generator | NodeContext.NodeContext,
  never,
  never
>
```


# layerTest

Layer starting a server on a random port and producing an `HttpClient`
with prepended url of the running http server.

To import and use `layerTest` from the "NodeHttpServer" module:

```ts
import * as NodeHttpServer from "@effect/platform-node/NodeHttpServer"
// Can be accessed like this
NodeHttpServer.layerTest
```

**Example**

```ts
import { HttpClient, HttpRouter, HttpServer } from "@effect/platform"
import { NodeHttpServer } from "@effect/platform-node"
import { Effect } from "effect"

Effect.gen(function* () {
  yield* HttpServer.serveEffect(HttpRouter.empty)
  const response = yield* HttpClient.get("/")
  assert.strictEqual(response.status, 404)
}).pipe(Effect.provide(NodeHttpServer.layerTest))
```

**Signature**

```ts
export declare const layerTest: Layer.Layer<
  Server.HttpServer | Platform.HttpPlatform | Etag.Generator | NodeContext.NodeContext | HttpClient.HttpClient,
  ServeError,
  never
>
```


# between

Checks if a `number` is between a `minimum` and `maximum` value (inclusive).

To import and use `between` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.between
```

**Example**

```ts
import { Number } from "effect"

const between = Number.between({ minimum: 0, maximum: 5 })

assert.deepStrictEqual(between(3), true)
assert.deepStrictEqual(between(-1), false)
assert.deepStrictEqual(between(6), false)
```

**Signature**

```ts
export declare const between: {
  (options: { minimum: number; maximum: number }): (self: number) => boolean
  (self: number, options: { minimum: number; maximum: number }): boolean
}
```


# clamp

Restricts the given `number` to be within the range specified by the `minimum` and `maximum` values.

- If the `number` is less than the `minimum` value, the function returns the `minimum` value.
- If the `number` is greater than the `maximum` value, the function returns the `maximum` value.
- Otherwise, it returns the original `number`.

To import and use `clamp` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.clamp
```

**Example**

```ts
import { Number } from "effect"

const clamp = Number.clamp({ minimum: 1, maximum: 5 })

assert.equal(clamp(3), 3)
assert.equal(clamp(0), 1)
assert.equal(clamp(6), 5)
```

**Signature**

```ts
export declare const clamp: {
  (options: { minimum: number; maximum: number }): (self: number) => number
  (self: number, options: { minimum: number; maximum: number }): number
}
```


# decrement

Decrements a number by `1`.

To import and use `decrement` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.decrement
```

**Example**

```ts
import { decrement } from "effect/Number"

assert.deepStrictEqual(decrement(3), 2)
```

**Signature**

```ts
export declare const decrement: (n: number) => number
```


# divide

Provides a division operation on `number`s.

To import and use `divide` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.divide
```

**Example**

```ts
import { Number, Option } from "effect"

assert.deepStrictEqual(Number.divide(6, 3), Option.some(2))
assert.deepStrictEqual(Number.divide(6, 0), Option.none())
```

**Signature**

```ts
export declare const divide: {
  (that: number): (self: number) => Option<number>
  (self: number, that: number): Option<number>
}
```


# greaterThan

Returns `true` if the first argument is greater than the second, otherwise `false`.

To import and use `greaterThan` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.greaterThan
```

**Example**

```ts
import { greaterThan } from "effect/Number"

assert.deepStrictEqual(greaterThan(2, 3), false)
assert.deepStrictEqual(greaterThan(3, 3), false)
assert.deepStrictEqual(greaterThan(4, 3), true)
```

**Signature**

```ts
export declare const greaterThan: { (that: number): (self: number) => boolean; (self: number, that: number): boolean }
```


# greaterThanOrEqualTo

Returns a function that checks if a given `number` is greater than or equal to the provided one.

To import and use `greaterThanOrEqualTo` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.greaterThanOrEqualTo
```

**Example**

```ts
import { greaterThanOrEqualTo } from "effect/Number"

assert.deepStrictEqual(greaterThanOrEqualTo(2, 3), false)
assert.deepStrictEqual(greaterThanOrEqualTo(3, 3), true)
assert.deepStrictEqual(greaterThanOrEqualTo(4, 3), true)
```

**Signature**

```ts
export declare const greaterThanOrEqualTo: {
  (that: number): (self: number) => boolean
  (self: number, that: number): boolean
}
```


# increment

Returns the result of adding `1` to a given number.

To import and use `increment` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.increment
```

**Example**

```ts
import { increment } from "effect/Number"

assert.deepStrictEqual(increment(2), 3)
```

**Signature**

```ts
export declare const increment: (n: number) => number
```


# isNumber

Tests if a value is a `number`.

To import and use `isNumber` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.isNumber
```

**Example**

```ts
import { isNumber } from "effect/Number"

assert.deepStrictEqual(isNumber(2), true)
assert.deepStrictEqual(isNumber("2"), false)
```

**Signature**

```ts
export declare const isNumber: (input: unknown) => input is number
```


# lessThan

Returns `true` if the first argument is less than the second, otherwise `false`.

To import and use `lessThan` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.lessThan
```

**Example**

```ts
import { lessThan } from "effect/Number"

assert.deepStrictEqual(lessThan(2, 3), true)
assert.deepStrictEqual(lessThan(3, 3), false)
assert.deepStrictEqual(lessThan(4, 3), false)
```

**Signature**

```ts
export declare const lessThan: { (that: number): (self: number) => boolean; (self: number, that: number): boolean }
```


# lessThanOrEqualTo

Returns a function that checks if a given `number` is less than or equal to the provided one.

To import and use `lessThanOrEqualTo` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.lessThanOrEqualTo
```

**Example**

```ts
import { lessThanOrEqualTo } from "effect/Number"

assert.deepStrictEqual(lessThanOrEqualTo(2, 3), true)
assert.deepStrictEqual(lessThanOrEqualTo(3, 3), true)
assert.deepStrictEqual(lessThanOrEqualTo(4, 3), false)
```

**Signature**

```ts
export declare const lessThanOrEqualTo: {
  (that: number): (self: number) => boolean
  (self: number, that: number): boolean
}
```


# max

Returns the maximum between two `number`s.

To import and use `max` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.max
```

**Example**

```ts
import { max } from "effect/Number"

assert.deepStrictEqual(max(2, 3), 3)
```

**Signature**

```ts
export declare const max: { (that: number): (self: number) => number; (self: number, that: number): number }
```


# min

Returns the minimum between two `number`s.

To import and use `min` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.min
```

**Example**

```ts
import { min } from "effect/Number"

assert.deepStrictEqual(min(2, 3), 2)
```

**Signature**

```ts
export declare const min: { (that: number): (self: number) => number; (self: number, that: number): number }
```


# multiply

Provides a multiplication operation on `number`s.

To import and use `multiply` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.multiply
```

**Example**

```ts
import { multiply } from "effect/Number"

assert.deepStrictEqual(multiply(2, 3), 6)
```

**Signature**

```ts
export declare const multiply: { (that: number): (self: number) => number; (self: number, that: number): number }
```


# multiplyAll

Takes an `Iterable` of `number`s and returns their multiplication as a single `number`.

To import and use `multiplyAll` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.multiplyAll
```

**Example**

```ts
import { multiplyAll } from "effect/Number"

assert.deepStrictEqual(multiplyAll([2, 3, 4]), 24)
```

**Signature**

```ts
export declare const multiplyAll: (collection: Iterable<number>) => number
```


# nextPow2

Returns the next power of 2 from the given number.

To import and use `nextPow2` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.nextPow2
```

**Example**

```ts
import { nextPow2 } from "effect/Number"

assert.deepStrictEqual(nextPow2(5), 8)
assert.deepStrictEqual(nextPow2(17), 32)
```

**Signature**

```ts
export declare const nextPow2: (n: number) => number
```


# parse

Tries to parse a `number` from a `string` using the `Number()` function.
The following special string values are supported: "NaN", "Infinity", "-Infinity".

To import and use `parse` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.parse
```

**Signature**

```ts
export declare const parse: (s: string) => Option<number>
```


# remainder

Returns the remainder left over when one operand is divided by a second operand.

It always takes the sign of the dividend.

To import and use `remainder` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.remainder
```

**Example**

```ts
import { remainder } from "effect/Number"

assert.deepStrictEqual(remainder(2, 2), 0)
assert.deepStrictEqual(remainder(3, 2), 1)
assert.deepStrictEqual(remainder(-4, 2), -0)
```

**Signature**

```ts
export declare const remainder: { (divisor: number): (self: number) => number; (self: number, divisor: number): number }
```


# round

Returns the number rounded with the given precision.

To import and use `round` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.round
```

**Example**

```ts
import { round } from "effect/Number"

assert.deepStrictEqual(round(1.1234, 2), 1.12)
assert.deepStrictEqual(round(1.567, 2), 1.57)
```

**Signature**

```ts
export declare const round: { (precision: number): (self: number) => number; (self: number, precision: number): number }
```


# sign

Determines the sign of a given `number`.

To import and use `sign` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.sign
```

**Example**

```ts
import { sign } from "effect/Number"

assert.deepStrictEqual(sign(-5), -1)
assert.deepStrictEqual(sign(0), 0)
assert.deepStrictEqual(sign(5), 1)
```

**Signature**

```ts
export declare const sign: (n: number) => Ordering
```


# subtract

Provides a subtraction operation on `number`s.

To import and use `subtract` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.subtract
```

**Example**

```ts
import { subtract } from "effect/Number"

assert.deepStrictEqual(subtract(2, 3), -1)
```

**Signature**

```ts
export declare const subtract: { (that: number): (self: number) => number; (self: number, that: number): number }
```


# sum

Provides an addition operation on `number`s.

To import and use `sum` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.sum
```

**Example**

```ts
import { sum } from "effect/Number"

assert.deepStrictEqual(sum(2, 3), 5)
```

**Signature**

```ts
export declare const sum: { (that: number): (self: number) => number; (self: number, that: number): number }
```


# sumAll

Takes an `Iterable` of `number`s and returns their sum as a single `number`.

To import and use `sumAll` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.sumAll
```

**Example**

```ts
import { sumAll } from "effect/Number"

assert.deepStrictEqual(sumAll([2, 3, 4]), 9)
```

**Signature**

```ts
export declare const sumAll: (collection: Iterable<number>) => number
```


# unsafeDivide

Provides a division operation on `number`s.

Throws a `RangeError` if the divisor is `0`.

To import and use `unsafeDivide` from the "Number" module:

```ts
import * as Number from "effect/Number"
// Can be accessed like this
Number.unsafeDivide
```

**Example**

```ts
import { unsafeDivide } from "effect/Number"

assert.deepStrictEqual(unsafeDivide(6, 3), 2)
```

**Signature**

```ts
export declare const unsafeDivide: { (that: number): (self: number) => number; (self: number, that: number): number }
```


# ofComposition

Returns a default `of` composition.

To import and use `ofComposition` from the "Of" module:

```ts
import * as Of from "@effect/typeclass/Of"
// Can be accessed like this
Of.ofComposition
```

**Signature**

```ts
export declare const ofComposition: <F extends TypeLambda, G extends TypeLambda>(
  F: Of<F>,
  G: Of<G>
) => <A>(a: A) => Kind<F, unknown, never, never, Kind<G, unknown, never, never, A>>
```


# fromApi

Converts an `HttpApi` instance into an OpenAPI Specification object.

**Details**

This function takes an `HttpApi` instance, which defines a structured API,
and generates an OpenAPI Specification (`OpenAPISpec`). The resulting spec
adheres to the OpenAPI 3.1.0 standard and includes detailed metadata such as
paths, operations, security schemes, and components. The function processes
the API's annotations, middleware, groups, and endpoints to build a complete
and accurate representation of the API in OpenAPI format.

The function also deduplicates schemas, applies transformations, and
integrates annotations like descriptions, summaries, external documentation,
and overrides. Cached results are used for better performance when the same
`HttpApi` instance is processed multiple times.

To import and use `fromApi` from the "OpenApi" module:

```ts
import * as OpenApi from "@effect/platform/OpenApi"
// Can be accessed like this
OpenApi.fromApi
```

**Example**

```ts
import { HttpApi, HttpApiEndpoint, HttpApiGroup, OpenApi } from "@effect/platform"
import { Schema } from "effect"

const api = HttpApi.make("api").add(
  HttpApiGroup.make("group").add(HttpApiEndpoint.get("get", "/items").addSuccess(Schema.Array(Schema.String)))
)

const spec = OpenApi.fromApi(api)

// console.log(JSON.stringify(spec, null, 2))
// Output: OpenAPI specification in JSON format
```

**Signature**

```ts
export declare const fromApi: <Id extends string, Groups extends HttpApiGroup.Any, E, R>(
  api: HttpApi.HttpApi<Id, Groups, E, R>
) => OpenAPISpec
```


# OpenAPISpec

This model describes the OpenAPI specification (version 3.1.0) returned by
{@link fromApi}. It is not intended to describe the entire OpenAPI
specification, only the output of `fromApi`.

To import and use `OpenAPISpec` from the "OpenApi" module:

```ts
import * as OpenApi from "@effect/platform/OpenApi"
// Can be accessed like this
OpenApi.OpenAPISpec
```


# Transform

Transforms the generated OpenAPI specification

To import and use `Transform` from the "OpenApi" module:

```ts
import * as OpenApi from "@effect/platform/OpenApi"
// Can be accessed like this
OpenApi.Transform
```


# makeWithDefs

Creates a schema with additional options and definitions.

- `defs`: A record of definitions that are included in the schema.
- `defsPath`: The path to the definitions within the schema (defaults to "#/$defs/").
- `topLevelReferenceStrategy`: Controls the handling of the top-level reference. Possible values are:
  - `"keep"`: Keep the top-level reference (default behavior).
  - `"skip"`: Skip the top-level reference.

To import and use `makeWithDefs` from the "OpenApiJsonSchema" module:

```ts
import * as OpenApiJsonSchema from "@effect/platform/OpenApiJsonSchema"
// Can be accessed like this
OpenApiJsonSchema.makeWithDefs
```

**Signature**

```ts
export declare const makeWithDefs: <A, I, R>(
  schema: Schema.Schema<A, I, R>,
  options: {
    readonly defs: Record<string, any>
    readonly defsPath?: string
    readonly topLevelReferenceStrategy?: "skip" | "keep"
  }
) => JsonSchema
```


# Deep

Instructs the document fusion optimizer to recurse into all leaves of the
document tree, including different layout alternatives and all
location-sensitive values (i.e. those created by `nesting`), which cannot be
fused before, but only during, the layout process. As a result, the
performance cost of using deep document fusion optimization is often hard to
predict and depends on the interplay between page layout and the document
that is to be pretty printed.

This value should only be utilized if profiling demonstrates that it is
**significantly** faster than using `Shallow`.

To import and use `Deep` from the "Optimize" module:

```ts
import * as Optimize from "@effect/printer/Optimize"
// Can be accessed like this
Optimize.Deep
```


# FusionDepth

Represents an instruction that determines how deeply the document fusion
optimizer should traverse the document tree.

To import and use `FusionDepth` from the "Optimize" module:

```ts
import * as Optimize from "@effect/printer/Optimize"
// Can be accessed like this
Optimize.FusionDepth
```


# optimize

The `optimize` function will combine text nodes so that they can be rendered
more efficiently. An optimized document is always laid out in an identical
manner to its un-optimized counterpart.

When laying a `Doc` out to a `SimpleDocStream`, every component of the input
document is translated directly to the simpler output format. This sometimes
yields undesirable chunking when many pieces have been concatenated together.

It is therefore a good idea to run `fuse` on concatenations of lots of small
strings that are used many times.

To import and use `optimize` from the "Optimize" module:

```ts
import * as Optimize from "@effect/printer/Optimize"
// Can be accessed like this
Optimize.optimize
```

**Example**

```ts
import * as Doc from "@effect/printer/Doc"
import * as Optimize from "@effect/printer/Optimize"

// The document below contains a chain of four entries in the output `DocStream`
const inefficient = Doc.hsep([Doc.char("a"), Doc.char("b"), Doc.char("c"), Doc.char("d")])

// However, the above document is fully equivalent to the tightly packed
// document below which is only a single entry in the output `DocStream` and
// can be processed much more efficiently.
const efficient = Doc.text("abcd")

// We can optimize the `inefficient` document using `Optimize`
Optimize.optimize(Optimize.Deep)(inefficient)
```

**Signature**

```ts
export declare const optimize: {
  (depth: FusionDepth): <A>(self: Doc<A>) => Doc<A>
  <A>(self: Doc<A>, depth: FusionDepth): Doc<A>
}
```


# Optimize

Represents optimization of a given document tree through fusion of redundant
document nodes.

To import and use `Optimize` from the "Optimize" module:

```ts
import * as Optimize from "@effect/printer/Optimize"
// Can be accessed like this
Optimize.Optimize
```


# Shallow

Instructs the document fusion optimizer to avoid diving deeply into nested
documents, fusing mostly concatenations of text nodes together.

To import and use `Shallow` from the "Optimize" module:

```ts
import * as Optimize from "@effect/printer/Optimize"
// Can be accessed like this
Optimize.Shallow
```


# all

Combines a structure of `Option`s into a single `Option` containing the
values with the same structure.

**Details**

This function takes a structure of `Option`s (a tuple, struct, or iterable)
and produces a single `Option` that contains the values from the input
structure if all `Option`s are `Some`. If any `Option` in the input is
`None`, the result is `None`. The structure of the input is preserved in the
output.

- If the input is a tuple (e.g., an array), the result will be an `Option`
  containing a tuple with the same length.
- If the input is a struct (e.g., an object), the result will be an `Option`
  containing a struct with the same keys.
- If the input is an iterable, the result will be an `Option` containing an
  array.

To import and use `all` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.all
```

**Example**

```ts
import { Option } from "effect"

const maybeName: Option.Option<string> = Option.some("John")
const maybeAge: Option.Option<number> = Option.some(25)

//       Option<[string, number]>
//      
const tuple = Option.all([maybeName, maybeAge])
console.log(tuple)
// Output:
// { _id: 'Option', _tag: 'Some', value: [ 'John', 25 ] }

//       Option<{ name: string; age: number; }>
//      
const struct = Option.all({ name: maybeName, age: maybeAge })
console.log(struct)
// Output:
// { _id: 'Option', _tag: 'Some', value: { name: 'John', age: 25 } }
```

**Signature**

```ts
export declare const all: <const I extends Iterable<Option<any>> | Record<string, Option<any>>>(
  input: I
) => [I] extends [ReadonlyArray<Option<any>>]
  ? Option<{ -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never }>
  : [I] extends [Iterable<Option<infer A>>]
    ? Option<Array<A>>
    : Option<{ -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never }>
```


# andThen

Chains two `Option`s together. The second `Option` can either be a static
value or depend on the result of the first `Option`.

**Details**

This function enables sequencing of two `Option` computations. If the first
`Option` is `Some`, the second `Option` is evaluated. The second `Option` can
either:

- Be a static `Option` value.
- Be a function that produces an `Option`, optionally based on the value of
  the first `Option`.

If the first `Option` is `None`, the function skips the evaluation of the
second `Option` and directly returns `None`.

To import and use `andThen` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.andThen
```

**Signature**

```ts
export declare const andThen: {
  <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>
  <B>(f: Option<B>): <A>(self: Option<A>) => Option<B>
  <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>
  <B>(f: NotFunction<B>): <A>(self: Option<A>) => Option<B>
  <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>
  <A, B>(self: Option<A>, f: Option<B>): Option<B>
  <A, B>(self: Option<A>, f: (a: A) => B): Option<B>
  <A, B>(self: Option<A>, f: NotFunction<B>): Option<B>
}
```


# ap

Applies a function inside a `Some` to a value inside another `Some`,
combining them into a new `Option`.

**Details**

This function allows you to apply a function wrapped in an `Option` (`self`)
to a value wrapped in another `Option` (`that`). If both `Option`s are
`Some`, the function is applied to the value, and the result is wrapped in a
new `Some`. If either `Option` is `None`, the result is `None`.

To import and use `ap` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.ap
```

**Signature**

```ts
export declare const ap: {
  <A>(that: Option<A>): <B>(self: Option<(a: A) => B>) => Option<B>
  <A, B>(self: Option<(a: A) => B>, that: Option<A>): Option<B>
}
```


# as

Replaces the value inside a `Some` with the specified constant value, leaving
`None` unchanged.

**Details**

This function transforms an `Option` by replacing the value inside a `Some`
with the given constant value `b`. If the `Option` is `None`, it remains
unchanged.

This is useful when you want to preserve the presence of a value (`Some`) but
replace its content with a fixed value.

To import and use `as` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.as
```

**Example**

```ts
import { Option } from "effect"

// Replacing the value of a `Some`
const someValue = Option.some(42)

console.log(Option.as(someValue, "new value"))
// Output: { _id: 'Option', _tag: 'Some', value: 'new value' }

// Replacing a `None` (no effect)
const noneValue = Option.none<number>()

console.log(Option.as(noneValue, "new value"))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
export declare const as: { <B>(b: B): <X>(self: Option<X>) => Option<B>; <X, B>(self: Option<X>, b: B): Option<B> }
```


# asVoid

Replaces the value inside a `Some` with the constant value `void`, leaving
`None` unchanged.

**Details**

This function transforms an `Option` by replacing the value inside a `Some`
with `void`. If the `Option` is `None`, it remains unchanged.

This is particularly useful in scenarios where the presence or absence of a
value is significant, but the actual content of the value is irrelevant.

To import and use `asVoid` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.asVoid
```

**Signature**

```ts
export declare const asVoid: <_>(self: Option<_>) => Option<void>
```


# bind

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

To import and use `bind` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.bind
```

**Example**

```ts
import { Option, pipe } from "effect"

const result = pipe(
  Option.Do,
  Option.bind("x", () => Option.some(2)),
  Option.bind("y", () => Option.some(3)),
  Option.let("sum", ({ x, y }) => x + y),
  Option.filter(({ x, y }) => x * y > 5)
)
assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))
```

**Signature**

```ts
export declare const bind: {
  <N extends string, A extends object, B>(
    name: Exclude<N, keyof A>,
    f: (a: NoInfer<A>) => Option<B>
  ): (self: Option<A>) => Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>
  <A extends object, N extends string, B>(
    self: Option<A>,
    name: Exclude<N, keyof A>,
    f: (a: NoInfer<A>) => Option<B>
  ): Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>
}
```


# bindTo

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

To import and use `bindTo` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.bindTo
```

**Example**

```ts
import { Option, pipe } from "effect"

const result = pipe(
  Option.Do,
  Option.bind("x", () => Option.some(2)),
  Option.bind("y", () => Option.some(3)),
  Option.let("sum", ({ x, y }) => x + y),
  Option.filter(({ x, y }) => x * y > 5)
)
assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))
```

**Signature**

```ts
export declare const bindTo: {
  <N extends string>(name: N): <A>(self: Option<A>) => Option<{ [K in N]: A }>
  <A, N extends string>(self: Option<A>, name: N): Option<{ [K in N]: A }>
}
```


# composeK

Composes two functions that return `Option` values, creating a new function
that chains them together.

**Details**

This function allows you to compose two computations, each represented by a
function that returns an `Option`. The result of the first function is passed
to the second function if it is `Some`. If the first function returns `None`,
the composed function short-circuits and returns `None` without invoking the
second function.

To import and use `composeK` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.composeK
```

**Example**

```ts
import { Option } from "effect"

const parse = (s: string): Option.Option<number> => (isNaN(Number(s)) ? Option.none() : Option.some(Number(s)))

const double = (n: number): Option.Option<number> => (n > 0 ? Option.some(n * 2) : Option.none())

const parseAndDouble = Option.composeK(parse, double)

console.log(parseAndDouble("42"))
// Output: { _id: 'Option', _tag: 'Some', value: 84 }

console.log(parseAndDouble("not a number"))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
export declare const composeK: {
  <B, C>(bfc: (b: B) => Option<C>): <A>(afb: (a: A) => Option<B>) => (a: A) => Option<C>
  <A, B, C>(afb: (a: A) => Option<B>, bfc: (b: B) => Option<C>): (a: A) => Option<C>
}
```


# contains

Returns a function that checks if an `Option` contains a specified value
using the default `Equivalence`.

**Details**

This function allows you to check whether an `Option` contains a specific
value. It uses the default `Equivalence` for equality comparison. If the
`Option` is `Some` and its value is equivalent to the provided value, the
result is `true`. If the `Option` is `None` or the values are not equivalent,
the result is `false`.

To import and use `contains` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.contains
```

**Example**

```ts
import { Option } from "effect"

console.log(Option.some(2).pipe(Option.contains(2)))
// Output: true

console.log(Option.some(1).pipe(Option.contains(2)))
// Output: false

console.log(Option.none().pipe(Option.contains(2)))
// Output: false
```

**Signature**

```ts
export declare const contains: { <A>(a: A): (self: Option<A>) => boolean; <A>(self: Option<A>, a: A): boolean }
```


# containsWith

Returns a function that checks if an `Option` contains a specified value,
using a provided equivalence function.

**Details**

This function allows you to check whether an `Option` contains a specific
value. It uses an equivalence function `isEquivalent` to compare the value
inside the `Option` to the provided value. If the `Option` is `Some` and the
equivalence function returns `true`, the result is `true`. If the `Option` is
`None` or the values are not equivalent, the result is `false`.

To import and use `containsWith` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.containsWith
```

**Example**

```ts
import { Number, Option } from "effect"

const contains = Option.containsWith(Number.Equivalence)

console.log(Option.some(2).pipe(contains(2)))
// Output: true

console.log(Option.some(1).pipe(contains(2)))
// Output: false

console.log(Option.none().pipe(contains(2)))
// Output: false
```

**Signature**

```ts
export declare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => {
  (a: A): (self: Option<A>) => boolean
  (self: Option<A>, a: A): boolean
}
```


# Do

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

To import and use `Do` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.Do
```

**Example**

```ts
import { Option, pipe } from "effect"

const result = pipe(
  Option.Do,
  Option.bind("x", () => Option.some(2)),
  Option.bind("y", () => Option.some(3)),
  Option.let("sum", ({ x, y }) => x + y),
  Option.filter(({ x, y }) => x * y > 5)
)
assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))
```

**Signature**

```ts
export declare const Do: Option<{}>
```


# exists

Checks if a value in an `Option` satisfies a given predicate or refinement.

**Details**

This function allows you to check if a value inside a `Some` meets a
specified condition. If the `Option` is `None`, the result is `false`. If the
`Option` is `Some`, the provided predicate or refinement is applied to the
value:

- If the condition is met, the result is `true`.
- If the condition is not met, the result is `false`.

To import and use `exists` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.exists
```

**Example**

```ts
import { Option } from "effect"

const isEven = (n: number) => n % 2 === 0

console.log(Option.some(2).pipe(Option.exists(isEven)))
// Output: true

console.log(Option.some(1).pipe(Option.exists(isEven)))
// Output: false

console.log(Option.none().pipe(Option.exists(isEven)))
// Output: false
```

**Signature**

```ts
export declare const exists: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => self is Option<B>
  <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => boolean
  <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): self is Option<B>
  <A>(self: Option<A>, predicate: Predicate<A>): boolean
}
```


# filter

Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.

If you need to change the type of the `Option` in addition to filtering, see `filterMap`.

To import and use `filter` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.filter
```

**Example**

```ts
import { Option } from "effect"

const removeEmptyString = (input: Option.Option<string>) => Option.filter(input, (value) => value !== "")

console.log(removeEmptyString(Option.none()))
// Output: { _id: 'Option', _tag: 'None' }

console.log(removeEmptyString(Option.some("")))
// Output: { _id: 'Option', _tag: 'None' }

console.log(removeEmptyString(Option.some("a")))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }
```

**Signature**

```ts
export declare const filter: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => Option<B>
  <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => Option<A>
  <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): Option<B>
  <A>(self: Option<A>, predicate: Predicate<A>): Option<A>
}
```


# filterMap

Maps over the value of an `Option` with a function that may return `None`,
effectively filtering and transforming the value.

**Details**

This function allows you to both transform the value of a `Some` and filter
it at the same time. The mapping function `f` can either return a new
`Option` (to transform the value) or return `None` to filter it out. If the
input `Option` is `None`, the function is not applied, and the result remains
`None`.

This utility is particularly useful when you want to apply a transformation
to the value of an `Option` while conditionally removing invalid or unwanted
results.

To import and use `filterMap` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.filterMap
```

**Example**

```ts
import { Option } from "effect"

// Transform and filter numbers
const transformEven = (n: Option.Option<number>): Option.Option<string> =>
  Option.filterMap(n, (n) => (n % 2 === 0 ? Option.some(`Even: ${n}`) : Option.none()))

console.log(transformEven(Option.none()))
// Output: { _id: 'Option', _tag: 'None' }

console.log(transformEven(Option.some(1)))
// Output: { _id: 'Option', _tag: 'None' }

console.log(transformEven(Option.some(2)))
// Output: { _id: 'Option', _tag: 'Some', value: 'Even: 2' }
```

**Signature**

```ts
export declare const filterMap: {
  <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>
  <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>
}
```


# firstSomeOf

Returns the first `Some` value found in an `Iterable` collection of
`Option`s, or `None` if no `Some` is found.

**Details**

This function iterates over a collection of `Option` values and returns the
first `Some` it encounters. If the collection contains only `None` values,
the result will also be `None`. This utility is useful for efficiently
finding the first valid value in a sequence of potentially empty or invalid
options.

The iteration stops as soon as a `Some` is found, making this function
efficient for large collections.

To import and use `firstSomeOf` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.firstSomeOf
```

**Example**

```ts
import { Option } from "effect"

console.log(Option.firstSomeOf([Option.none(), Option.some(1), Option.some(2)]))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }
```

**Signature**

```ts
export declare const firstSomeOf: <T, C extends Iterable<Option<T>> = Iterable<Option<T>>>(
  collection: C
) => [C] extends [Iterable<Option<infer A>>] ? Option<A> : never
```


# flatMap

Applies a function to the value of a `Some` and flattens the resulting
`Option`. If the input is `None`, it remains `None`.

**Details**

This function allows you to chain computations that return `Option` values.
If the input `Option` is `Some`, the provided function `f` is applied to the
contained value, and the resulting `Option` is returned. If the input is
`None`, the function is not applied, and the result remains `None`.

This utility is particularly useful for sequencing operations that may fail
or produce optional results, enabling clean and concise workflows for
handling such cases.

To import and use `flatMap` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.flatMap
```

**Example**

```ts
import { Option } from "effect"

interface Address {
  readonly city: string
  readonly street: Option.Option<string>
}

interface User {
  readonly id: number
  readonly username: string
  readonly email: Option.Option<string>
  readonly address: Option.Option<Address>
}

const user: User = {
  id: 1,
  username: "john_doe",
  email: Option.some("john.doe@example.com"),
  address: Option.some({
    city: "New York",
    street: Option.some("123 Main St")
  })
}

// Use flatMap to extract the street value
const street = user.address.pipe(Option.flatMap((address) => address.street))

console.log(street)
// Output: { _id: 'Option', _tag: 'Some', value: '123 Main St' }
```

**Signature**

```ts
export declare const flatMap: {
  <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>
  <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>
}
```


# flatMapNullable

Combines `flatMap` and `fromNullable`, transforming the value inside a `Some`
using a function that may return `null` or `undefined`.

**Details**

This function applies a transformation function `f` to the value inside a
`Some`. The function `f` may return a value, `null`, or `undefined`. If `f`
returns a value, it is wrapped in a `Some`. If `f` returns `null` or
`undefined`, the result is `None`. If the input `Option` is `None`, the
function is not applied, and `None` is returned.

This utility is particularly useful when working with deeply nested optional
values or chaining computations that may result in `null` or `undefined` at
some point.

To import and use `flatMapNullable` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.flatMapNullable
```

**Example**

```ts
import { Option } from "effect"

interface Employee {
  company?: {
    address?: {
      street?: {
        name?: string
      }
    }
  }
}

const employee1: Employee = { company: { address: { street: { name: "high street" } } } }

// Extracting a deeply nested property
console.log(Option.some(employee1).pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name)))
// Output: { _id: 'Option', _tag: 'Some', value: 'high street' }

const employee2: Employee = { company: { address: { street: {} } } }

// Property does not exist
console.log(Option.some(employee2).pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name)))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
export declare const flatMapNullable: {
  <A, B>(f: (a: A) => B | null | undefined): (self: Option<A>) => Option<NonNullable<B>>
  <A, B>(self: Option<A>, f: (a: A) => B | null | undefined): Option<NonNullable<B>>
}
```


# flatten

Flattens an `Option` of `Option` into a single `Option`.

**Details**

This function takes an `Option` that wraps another `Option` and flattens it
into a single `Option`. If the outer `Option` is `Some`, the function
extracts the inner `Option`. If the outer `Option` is `None`, the result
remains `None`.

This is useful for simplifying nested `Option` structures that may arise
during functional operations.

To import and use `flatten` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.flatten
```

**Signature**

```ts
export declare const flatten: <A>(self: Option<Option<A>>) => Option<A>
```


# fromIterable

Converts an `Iterable` into an `Option`, wrapping the first element if it
exists.

**Details**

This function takes an `Iterable` (e.g., an array, a generator, or any object
implementing the `Iterable` interface) and returns an `Option` based on its
content:

- If the `Iterable` contains at least one element, the first element is
  wrapped in a `Some` and returned.
- If the `Iterable` is empty, `None` is returned, representing the absence of
  a value.

This utility is useful for safely handling collections that might be empty,
ensuring you explicitly handle both cases where a value exists or doesn't.

To import and use `fromIterable` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.fromIterable
```

**Example**

```ts
import { Option } from "effect"

console.log(Option.fromIterable([1, 2, 3]))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(Option.fromIterable([]))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
export declare const fromIterable: <A>(collection: Iterable<A>) => Option<A>
```


# fromNullable

Converts a nullable value into an `Option`. Returns `None` if the value is
`null` or `undefined`, otherwise wraps the value in a `Some`.

To import and use `fromNullable` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.fromNullable
```

**Example**

```ts
import { Option } from "effect"

console.log(Option.fromNullable(undefined))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.fromNullable(null))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.fromNullable(1))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }
```

**Signature**

```ts
export declare const fromNullable: <A>(nullableValue: A) => Option<NonNullable<A>>
```


# gen

Similar to `Effect.gen`, `Option.gen` provides a more readable,
generator-based syntax for working with `Option` values, making code that
involves `Option` easier to write and understand. This approach is similar to
using `async/await` but tailored for `Option`.

To import and use `gen` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.gen
```

**Example**

```ts
// Title: Using Option.gen to Create a Combined Value
import { Option } from "effect"

const maybeName: Option.Option<string> = Option.some("John")
const maybeAge: Option.Option<number> = Option.some(25)

const person = Option.gen(function* () {
  const name = (yield* maybeName).toUpperCase()
  const age = yield* maybeAge
  return { name, age }
})

console.log(person)
// Output:
// { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }
```

**Signature**

```ts
export declare const gen: Gen.Gen<OptionTypeLambda, Gen.Adapter<OptionTypeLambda>>
```


# getEquivalence

Creates an `Equivalence` instance for comparing `Option` values, using a
provided `Equivalence` for the inner type.

**Details**

This function takes an `Equivalence` instance for a specific type `A` and
produces an `Equivalence` instance for `Option<A>`. The resulting
`Equivalence` determines whether two `Option` values are equivalent:

- Two `None`s are considered equivalent.
- A `Some` and a `None` are not equivalent.
- Two `Some` values are equivalent if their inner values are equivalent
  according to the provided `Equivalence`.

To import and use `getEquivalence` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.getEquivalence
```

**Example**

```ts
// Title: Comparing Optional Numbers for Equivalence
import { Number, Option } from "effect"

const isEquivalent = Option.getEquivalence(Number.Equivalence)

console.log(isEquivalent(Option.none(), Option.none()))
// Output: true

console.log(isEquivalent(Option.none(), Option.some(1)))
// Output: false

console.log(isEquivalent(Option.some(1), Option.none()))
// Output: false

console.log(isEquivalent(Option.some(1), Option.some(2)))
// Output: false

console.log(isEquivalent(Option.some(1), Option.some(1)))
// Output: true
```

**Signature**

```ts
export declare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<Option<A>>
```


# getLeft

Converts an `Either` into an `Option` by discarding the right value and
extracting the left value.

**Details**

This function transforms an `Either` into an `Option` as follows:

- If the `Either` is a `Left`, its value is wrapped in a `Some` and returned.
- If the `Either` is a `Right`, the value is discarded, and `None` is
  returned.

This utility is useful when you only care about the error case (`Left`) of an
`Either` and want to handle it as an `Option`. By discarding the right value,
it simplifies error-focused workflows.

To import and use `getLeft` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.getLeft
```

**Example**

```ts
import { Either, Option } from "effect"

console.log(Option.getLeft(Either.right("ok")))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.getLeft(Either.left("err")))
// Output: { _id: 'Option', _tag: 'Some', value: 'err' }
```

**Signature**

```ts
export declare const getLeft: <R, L>(self: Either<R, L>) => Option<L>
```


# getOrder

Creates an `Order` instance for comparing `Option` values, using a provided
`Order` for the inner type.

**Details**

This function produces an `Order` instance for `Option<A>`, allowing `Option`
values to be compared:

- `None` is always considered less than any `Some` value.
- If both are `Some`, their inner values are compared using the provided
  `Order` instance.

To import and use `getOrder` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.getOrder
```

**Example**

```ts
import { Number, Option } from "effect"

const order = Option.getOrder(Number.Order)

console.log(order(Option.none(), Option.none()))
// Output: 0

console.log(order(Option.none(), Option.some(1)))
// Output: -1

console.log(order(Option.some(1), Option.none()))
// Output: 1

console.log(order(Option.some(1), Option.some(2)))
// Output: -1

console.log(order(Option.some(1), Option.some(1)))
// Output: 0
```

**Signature**

```ts
export declare const getOrder: <A>(O: Order<A>) => Order<Option<A>>
```


# getOrElse

Returns the value contained in the `Option` if it is `Some`, otherwise
evaluates and returns the result of `onNone`.

**Details**

This function allows you to provide a fallback value or computation for when
an `Option` is `None`. If the `Option` contains a value (`Some`), that value
is returned. If it is empty (`None`), the `onNone` function is executed, and
its result is returned instead.

This utility is helpful for safely handling `Option` values by ensuring you
always receive a meaningful result, whether or not the `Option` contains a
value. It is particularly useful for providing default values or alternative
logic when working with optional values.

To import and use `getOrElse` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.getOrElse
```

**Example**

```ts
import { Option } from "effect"

console.log(Option.some(1).pipe(Option.getOrElse(() => 0)))
// Output: 1

console.log(Option.none().pipe(Option.getOrElse(() => 0)))
// Output: 0
```

**Signature**

```ts
export declare const getOrElse: {
  <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => B | A
  <A, B>(self: Option<A>, onNone: LazyArg<B>): A | B
}
```


# getOrNull

Returns the value contained in the `Option` if it is `Some`; otherwise,
returns `null`.

**Details**

This function provides a way to extract the value of an `Option` while
falling back to `null` if the `Option` is `None`.

It is particularly useful in scenarios where `null` is an acceptable
placeholder for the absence of a value, such as when interacting with APIs or
systems that use `null` as a default for missing values.

To import and use `getOrNull` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.getOrNull
```

**Example**

```ts
import { Option } from "effect"

console.log(Option.getOrNull(Option.some(1)))
// Output: 1

console.log(Option.getOrNull(Option.none()))
// Output: null
```

**Signature**

```ts
export declare const getOrNull: <A>(self: Option<A>) => A | null
```


# getOrThrow

Extracts the value of an `Option` or throws a default error if the `Option`
is `None`.

**Details**

This function extracts the value from an `Option` if it is `Some`. If the
`Option` is `None`, it throws a default error. It is useful for fail-fast
scenarios where the absence of a value is treated as an exceptional case and
a default error is sufficient.

To import and use `getOrThrow` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.getOrThrow
```

**Example**

```ts
import { Option } from "effect"

assert.deepStrictEqual(Option.getOrThrow(Option.some(1)), 1)
assert.throws(() => Option.getOrThrow(Option.none()))
```

**Signature**

```ts
export declare const getOrThrow: <A>(self: Option<A>) => A
```


# getOrThrowWith

Extracts the value of an `Option` or throws an error if the `Option` is
`None`, using a custom error factory.

**Details**

This function allows you to extract the value of an `Option` when it is
`Some`. If the `Option` is `None`, it throws an error generated by the
provided `onNone` function. This utility is particularly useful when you need
a fail-fast behavior for empty `Option` values and want to provide a custom
error message or object.

To import and use `getOrThrowWith` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.getOrThrowWith
```

**Example**

```ts
import { Option } from "effect"

assert.deepStrictEqual(
  Option.getOrThrowWith(Option.some(1), () => new Error("Unexpected None")),
  1
)
assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error("Unexpected None")))
```

**Signature**

```ts
export declare const getOrThrowWith: {
  (onNone: () => unknown): <A>(self: Option<A>) => A
  <A>(self: Option<A>, onNone: () => unknown): A
}
```


# getOrUndefined

Returns the value contained in the `Option` if it is `Some`; otherwise,
returns `undefined`.

**Details**

This function provides a way to extract the value of an `Option` while
falling back to `undefined` if the `Option` is `None`.

It is particularly useful in scenarios where `undefined` is an acceptable
placeholder for the absence of a value, such as when interacting with APIs or
systems that use `undefined` as a default for missing values.

To import and use `getOrUndefined` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.getOrUndefined
```

**Example**

```ts
import { Option } from "effect"

console.log(Option.getOrUndefined(Option.some(1)))
// Output: 1

console.log(Option.getOrUndefined(Option.none()))
// Output: undefined
```

**Signature**

```ts
export declare const getOrUndefined: <A>(self: Option<A>) => A | undefined
```


# getRight

Converts an `Either` into an `Option` by discarding the error and extracting
the right value.

**Details**

This function takes an `Either` and returns an `Option` based on its value:

- If the `Either` is a `Right`, its value is wrapped in a `Some` and
  returned.
- If the `Either` is a `Left`, the error is discarded, and `None` is
  returned.

This is particularly useful when you only care about the success case
(`Right`) of an `Either` and want to handle the result using `Option`. By
using this function, you can convert `Either` into a simpler structure for
cases where error handling is not required.

To import and use `getRight` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.getRight
```

**Example**

```ts
import { Either, Option } from "effect"

console.log(Option.getRight(Either.right("ok")))
// Output: { _id: 'Option', _tag: 'Some', value: 'ok' }

console.log(Option.getRight(Either.left("err")))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
export declare const getRight: <R, L>(self: Either<R, L>) => Option<R>
```


# isNone

Checks whether an `Option` represents the absence of a value (`None`).

To import and use `isNone` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.isNone
```

**Example**

```ts
import { Option } from "effect"

console.log(Option.isNone(Option.some(1)))
// Output: false

console.log(Option.isNone(Option.none()))
// Output: true
```

**Signature**

```ts
export declare const isNone: <A>(self: Option<A>) => self is None<A>
```


# isOption

Determines whether the given value is an `Option`.

**Details**

This function checks if a value is an instance of `Option`. It returns `true`
if the value is either `Option.some` or `Option.none`, and `false` otherwise.
This is particularly useful when working with unknown values or when you need
to ensure type safety in your code.

To import and use `isOption` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.isOption
```

**Example**

```ts
import { Option } from "effect"

console.log(Option.isOption(Option.some(1)))
// Output: true

console.log(Option.isOption(Option.none()))
// Output: true

console.log(Option.isOption({}))
// Output: false
```

**Signature**

```ts
export declare const isOption: (input: unknown) => input is Option<unknown>
```


# isSome

Checks whether an `Option` contains a value (`Some`).

To import and use `isSome` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.isSome
```

**Example**

```ts
import { Option } from "effect"

console.log(Option.isSome(Option.some(1)))
// Output: true

console.log(Option.isSome(Option.none()))
// Output: false
```

**Signature**

```ts
export declare const isSome: <A>(self: Option<A>) => self is Some<A>
```


# let

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

To import and use `let` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.let
```

**Example**

```ts
import { Option, pipe } from "effect"

const result = pipe(
  Option.Do,
  Option.bind("x", () => Option.some(2)),
  Option.bind("y", () => Option.some(3)),
  Option.let("sum", ({ x, y }) => x + y),
  Option.filter(({ x, y }) => x * y > 5)
)
assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))
```


# lift2

Lifts a binary function to work with `Option` values, allowing the function
to operate on two `Option`s.

**Details**

This function takes a binary function `f` and returns a new function that
applies `f` to the values of two `Option`s (`self` and `that`). If both
`Option`s are `Some`, the binary function `f` is applied to their values, and
the result is wrapped in a new `Some`. If either `Option` is `None`, the
result is `None`.

To import and use `lift2` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.lift2
```

**Example**

```ts
import { Option } from "effect"

// A binary function to add two numbers
const add = (a: number, b: number): number => a + b

// Lift the `add` function to work with `Option` values
const addOptions = Option.lift2(add)

// Both `Option`s are `Some`
console.log(addOptions(Option.some(2), Option.some(3)))
// Output: { _id: 'Option', _tag: 'Some', value: 5 }

// One `Option` is `None`
console.log(addOptions(Option.some(2), Option.none()))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
export declare const lift2: <A, B, C>(
  f: (a: A, b: B) => C
) => { (that: Option<B>): (self: Option<A>) => Option<C>; (self: Option<A>, that: Option<B>): Option<C> }
```


# liftNullable

Lifts a function that returns `null` or `undefined` into the `Option`
context.

**Details**

This function takes a function `f` that might return `null` or `undefined`
and transforms it into a function that returns an `Option`. The resulting
function will return:

- `Some` if the original function produces a non-null, non-undefined value.
- `None` if the original function produces `null` or `undefined`.

To import and use `liftNullable` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.liftNullable
```

**Example**

```ts
import { Option } from "effect"

const parse = (s: string): number | undefined => {
  const n = parseFloat(s)
  return isNaN(n) ? undefined : n
}

const parseOption = Option.liftNullable(parse)

console.log(parseOption("1"))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(parseOption("not a number"))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
export declare const liftNullable: <A extends ReadonlyArray<unknown>, B>(
  f: (...a: A) => B | null | undefined
) => (...a: A) => Option<NonNullable<B>>
```


# liftPredicate

Lifts a `Predicate` or `Refinement` into the `Option` context, returning a
`Some` of the input value if the predicate is satisfied, or `None` otherwise.

**Details**

This function transforms a `Predicate` (or a more specific `Refinement`) into
a function that produces an `Option`. If the predicate evaluates to `true`,
the input value is wrapped in a `Some`. If the predicate evaluates to
`false`, the result is `None`.

To import and use `liftPredicate` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.liftPredicate
```

**Example**

```ts
import { Option } from "effect"

// Check if a number is positive
const isPositive = (n: number) => n > 0

//       (b: number) => Option<number>
//      
const parsePositive = Option.liftPredicate(isPositive)

console.log(parsePositive(1))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(parsePositive(-1))
// OUtput: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
export declare const liftPredicate: {
  <A, B extends A>(refinement: Refinement<A, B>): (a: A) => Option<B>
  <B extends A, A = B>(predicate: Predicate<A>): (b: B) => Option<B>
  <A, B extends A>(self: A, refinement: Refinement<A, B>): Option<B>
  <B extends A, A = B>(self: B, predicate: Predicate<A>): Option<B>
}
```


# liftThrowable

Lifts a function that throws exceptions into a function that returns an
`Option`.

**Details**

This utility function takes a function `f` that might throw an exception and
transforms it into a safer function that returns an `Option`. If the original
function executes successfully, the result is wrapped in a `Some`. If an
exception is thrown, the result is `None`, allowing the developer to handle
errors in a functional, type-safe way.

To import and use `liftThrowable` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.liftThrowable
```

**Example**

```ts
import { Option } from "effect"

const parse = Option.liftThrowable(JSON.parse)

console.log(parse("1"))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(parse(""))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
export declare const liftThrowable: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B) => (...a: A) => Option<B>
```


# map

Transforms the value inside a `Some` to a new value using the provided
function, while leaving `None` unchanged.

**Details**

This function applies a mapping function `f` to the value inside an `Option`
if it is a `Some`. If the `Option` is `None`, it remains unchanged. The
result is a new `Option` with the transformed value (if it was a `Some`) or
still `None`.

This utility is particularly useful for chaining transformations in a
functional way without needing to manually handle `None` cases.

To import and use `map` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.map
```

**Example**

```ts
import { Option } from "effect"

// Mapping over a `Some`
const someValue = Option.some(2)

console.log(Option.map(someValue, (n) => n * 2))
// Output: { _id: 'Option', _tag: 'Some', value: 4 }

// Mapping over a `None`
const noneValue = Option.none<number>()

console.log(Option.map(noneValue, (n) => n * 2))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
export declare const map: {
  <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>
  <A, B>(self: Option<A>, f: (a: A) => B): Option<B>
}
```


# match

Performs pattern matching on an `Option` to handle both `Some` and `None`
cases.

**Details**

This function allows you to match against an `Option` and handle both
scenarios: when the `Option` is `None` (i.e., contains no value), and when
the `Option` is `Some` (i.e., contains a value). It executes one of the
provided functions based on the case:

- If the `Option` is `None`, the `onNone` function is executed and its result
  is returned.
- If the `Option` is `Some`, the `onSome` function is executed with the
  contained value, and its result is returned.

This function provides a concise and functional way to handle optional values
without resorting to `if` or manual checks, making your code more declarative
and readable.

To import and use `match` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.match
```

**Example**

```ts
// Title: Pattern Matching with Option
import { Option } from "effect"

const foo = Option.some(1)

const message = Option.match(foo, {
  onNone: () => "Option is empty",
  onSome: (value) => `Option has a value: ${value}`
})

console.log(message)
// Output: "Option has a value: 1"
```

**Signature**

```ts
export declare const match: {
  <B, A, C = B>(options: { readonly onNone: LazyArg<B>; readonly onSome: (a: A) => C }): (self: Option<A>) => B | C
  <A, B, C = B>(self: Option<A>, options: { readonly onNone: LazyArg<B>; readonly onSome: (a: A) => C }): B | C
}
```


# none

Represents the absence of a value by creating an empty `Option`.

`Option.none` returns an `Option<never>`, which is a subtype of `Option<A>`.
This means you can use it in place of any `Option<A>` regardless of the type
`A`.

To import and use `none` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.none
```

**Example**

```ts
// Title: Creating an Option with No Value
import { Option } from "effect"

// An Option holding no value
//
//       Option<never>
//      
const noValue = Option.none()

console.log(noValue)
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
export declare const none: <A = never>() => Option<A>
```


# Option

The `Option` data type represents optional values. An `Option<A>` can either
be `Some<A>`, containing a value of type `A`, or `None`, representing the
absence of a value.

**When to Use**

You can use `Option` in scenarios like:

- Using it for initial values
- Returning values from functions that are not defined for all possible
  inputs (referred to as partial functions)
- Managing optional fields in data structures
- Handling optional function arguments

To import and use `Option` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.Option
```


# orElse

Returns the provided `Option` `that` if the current `Option` (`self`) is
`None`; otherwise, it returns `self`.

**Details**

This function provides a fallback mechanism for `Option` values. If the
current `Option` is `None` (i.e., it contains no value), the `that` function
is evaluated, and its resulting `Option` is returned. If the current `Option`
is `Some` (i.e., it contains a value), the original `Option` is returned
unchanged.

This is particularly useful for chaining fallback values or computations,
allowing you to provide alternative `Option` values when the first one is
empty.

To import and use `orElse` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.orElse
```

**Example**

```ts
import { Option } from "effect"

console.log(Option.none().pipe(Option.orElse(() => Option.none())))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.some("a").pipe(Option.orElse(() => Option.none())))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }

console.log(Option.none().pipe(Option.orElse(() => Option.some("b"))))
// Output: { _id: 'Option', _tag: 'Some', value: 'b' }

console.log(Option.some("a").pipe(Option.orElse(() => Option.some("b"))))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }
```

**Signature**

```ts
export declare const orElse: {
  <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<B | A>
  <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<A | B>
}
```


# orElseEither

Similar to {@link orElse}, but returns an `Either` wrapped in an `Option` to
indicate the source of the value.

**Details**

This function allows you to provide a fallback `Option` in case the current
`Option` (`self`) is `None`. However, unlike `orElse`, it returns the value
wrapped in an `Either` object, providing additional information about where
the value came from:

- If the value is from the fallback `Option` (`that`), it is wrapped in an
  `Either.right`.
- If the value is from the original `Option` (`self`), it is wrapped in an
  `Either.left`.

This is especially useful when you need to differentiate between values
originating from the primary `Option` and those coming from the fallback,
while still maintaining the `Option`-style handling.

To import and use `orElseEither` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.orElseEither
```

**Signature**

```ts
export declare const orElseEither: {
  <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<Either<B, A>>
  <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<Either<B, A>>
}
```


# orElseSome

Returns the provided default value wrapped in `Some` if the current `Option`
(`self`) is `None`; otherwise, returns `self`.

**Details**

This function provides a way to supply a default value for cases where an
`Option` is `None`. If the current `Option` is empty (`None`), the `onNone`
function is executed to compute the default value, which is then wrapped in a
`Some`. If the current `Option` contains a value (`Some`), it is returned as
is.

This is particularly useful for handling optional values where a fallback
default needs to be provided explicitly in case of absence.

To import and use `orElseSome` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.orElseSome
```

**Example**

```ts
import { Option } from "effect"

console.log(Option.none().pipe(Option.orElseSome(() => "b")))
// Output: { _id: 'Option', _tag: 'Some', value: 'b' }

console.log(Option.some("a").pipe(Option.orElseSome(() => "b")))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }
```

**Signature**

```ts
export declare const orElseSome: {
  <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => Option<B | A>
  <A, B>(self: Option<A>, onNone: LazyArg<B>): Option<A | B>
}
```


# partitionMap

Splits an `Option` into two `Option`s based on the result of a mapping
function that produces an `Either`.

**Details**

This function takes an `Option` and a mapping function `f` that converts its
value into an `Either`. It returns a tuple of two `Option`s:

- The first `Option` (`left`) contains the value from the `Left` side of the
  `Either` if it exists, otherwise `None`.
- The second `Option` (`right`) contains the value from the `Right` side of
  the `Either` if it exists, otherwise `None`.

If the input `Option` is `None`, both returned `Option`s are `None`.

This utility is useful for filtering and categorizing the contents of an
`Option` based on a bifurcating computation.

To import and use `partitionMap` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.partitionMap
```

**Signature**

```ts
export declare const partitionMap: {
  <A, B, C>(f: (a: A) => Either<C, B>): (self: Option<A>) => [left: Option<B>, right: Option<C>]
  <A, B, C>(self: Option<A>, f: (a: A) => Either<C, B>): [left: Option<B>, right: Option<C>]
}
```


# product

Combines two `Option` values into a single `Option` containing a tuple of
their values if both are `Some`.

**Details**

This function takes two `Option`s and combines their values into a tuple `[A,
B]` if both are `Some`. If either of the `Option`s is `None`, the result is
`None`. This is particularly useful for combining multiple `Option` values
into a single one, ensuring both contain valid values.

To import and use `product` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.product
```

**Signature**

```ts
export declare const product: <A, B>(self: Option<A>, that: Option<B>) => Option<[A, B]>
```


# productMany

Combines an `Option` with a collection of `Option`s into a single `Option`
containing a tuple of their values if all are `Some`.

**Details**

This function takes a primary `Option` and a collection of `Option`s and
combines their values into a tuple `[A, ...Array<A>]` if all are `Some`. If
the primary `Option` or any `Option` in the collection is `None`, the result
is `None`.

To import and use `productMany` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.productMany
```

**Signature**

```ts
export declare const productMany: <A>(self: Option<A>, collection: Iterable<Option<A>>) => Option<[A, ...Array<A>]>
```


# reduceCompact

Reduces an `Iterable` of `Option<A>` to a single value of type `B`, ignoring
elements that are `None`.

**Details**

This function takes an initial value of type `B` and a reducing function `f`
that combines the accumulator with values of type `A`. It processes an
iterable of `Option<A>`, applying `f` only to the `Some` values while
ignoring the `None` values. The result is a single value of type `B`.

This utility is particularly useful for aggregating values from an iterable
of `Option`s while skipping the absent (`None`) values.

To import and use `reduceCompact` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.reduceCompact
```

**Example**

```ts
import { Option, pipe } from "effect"

const iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]

console.log(
  pipe(
    iterable,
    Option.reduceCompact(0, (b, a) => b + a)
  )
)
// Output: 3
```

**Signature**

```ts
export declare const reduceCompact: {
  <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<Option<A>>) => B
  <A, B>(self: Iterable<Option<A>>, b: B, f: (b: B, a: A) => B): B
}
```


# some

Wraps the given value into an `Option` to represent its presence.

To import and use `some` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.some
```

**Example**

```ts
// Title: Creating an Option with a Value
import { Option } from "effect"

// An Option holding the number 1
//
//       Option<number>
//      
const value = Option.some(1)

console.log(value)
// Output: { _id: 'Option', _tag: 'Some', value: 1 }
```

**Signature**

```ts
export declare const some: <A>(value: A) => Option<A>
```


# tap

Applies the provided function `f` to the value of the `Option` if it is
`Some` and returns the original `Option`, unless `f` returns `None`, in which
case it returns `None`.

**Details**

This function allows you to perform additional computations on the value of
an `Option` without modifying its original value. If the `Option` is `Some`,
the provided function `f` is executed with the value, and its result
determines whether the original `Option` is returned (`Some`) or the result
is `None` if `f` returns `None`. If the input `Option` is `None`, the
function is not executed, and `None` is returned.

This is particularly useful for applying side conditions or performing
validation checks while retaining the original `Option`'s value.

To import and use `tap` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.tap
```

**Example**

```ts
import { Option } from "effect"

const getInteger = (n: number) => (Number.isInteger(n) ? Option.some(n) : Option.none())

console.log(Option.tap(Option.none(), getInteger))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.tap(Option.some(1), getInteger))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(Option.tap(Option.some(1.14), getInteger))
// Output: { _id: 'Option', _tag: 'None' }
```

**Signature**

```ts
export declare const tap: {
  <A, X>(f: (a: A) => Option<X>): (self: Option<A>) => Option<A>
  <A, X>(self: Option<A>, f: (a: A) => Option<X>): Option<A>
}
```


# toArray

Converts an `Option` into an `Array`.
If the input is `None`, an empty array is returned.
If the input is `Some`, its value is wrapped in a single-element array.

To import and use `toArray` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.toArray
```

**Example**

```ts
import { Option } from "effect"

console.log(Option.toArray(Option.some(1)))
// Output: [1]

console.log(Option.toArray(Option.none()))
// Output: []
```

**Signature**

```ts
export declare const toArray: <A>(self: Option<A>) => Array<A>
```


# toRefinement

Converts an `Option`-returning function into a type guard.

**Details**

This function transforms a function that returns an `Option` into a type
guard, ensuring type safety when validating or narrowing types. The returned
type guard function checks whether the input satisfies the condition defined
in the original `Option`-returning function.

If the original function returns `Option.some`, the type guard evaluates to
`true`, confirming the input is of the desired type. If the function returns
`Option.none`, the type guard evaluates to `false`.

This utility is especially useful for validating types in union types,
filtering arrays, or ensuring safe handling of specific subtypes.

To import and use `toRefinement` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.toRefinement
```

**Example**

```ts
import { Option } from "effect"

type MyData = string | number

const parseString = (data: MyData): Option.Option<string> =>
  typeof data === "string" ? Option.some(data) : Option.none()

//       (a: MyData) => a is string
//      
const isString = Option.toRefinement(parseString)

console.log(isString("a"))
// Output: true

console.log(isString(1))
// Output: false
```

**Signature**

```ts
export declare const toRefinement: <A, B extends A>(f: (a: A) => Option<B>) => (a: A) => a is B
```


# zipLeft

Combines two `Option`s, keeping the value from the first `Option` if both are
`Some`.

**Details**

This function takes two `Option`s and returns the first one if it is `Some`.
If either the first `Option` or the second `Option` is `None`, the result
will be `None`. This operation "zips" the two `Option`s while discarding the
value from the second `Option`.

This is useful when sequencing computations where the second `Option`
represents a dependency or condition that must hold, but its value is
irrelevant.

To import and use `zipLeft` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.zipLeft
```

**Signature**

```ts
export declare const zipLeft: {
  <_>(that: Option<_>): <A>(self: Option<A>) => Option<A>
  <A, X>(self: Option<A>, that: Option<X>): Option<A>
}
```


# zipRight

Combines two `Option`s, keeping the value from the second `Option` if both
are `Some`.

**Details**

This function takes two `Option`s and returns the second one if the first is
`Some`. If the first `Option` is `None`, the result will also be `None`,
regardless of the second `Option`. It effectively "zips" the two `Option`s
while discarding the value from the first `Option`.

This is particularly useful when sequencing computations where the result of
the first computation is not needed, and you only care about the result of
the second computation.

To import and use `zipRight` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.zipRight
```

**Signature**

```ts
export declare const zipRight: {
  <B>(that: Option<B>): <_>(self: Option<_>) => Option<B>
  <X, B>(self: Option<X>, that: Option<B>): Option<B>
}
```


# zipWith

Combines two `Option` values into a new `Option` by applying a provided
function to their values.

**Details**

This function takes two `Option` values (`self` and `that`) and a combining
function `f`. If both `Option` values are `Some`, the function `f` is applied
to their values, and the result is wrapped in a new `Some`. If either
`Option` is `None`, the result is `None`.

This utility is useful for combining two optional computations into a single
result while maintaining type safety and avoiding explicit checks for `None`.

To import and use `zipWith` from the "Option" module:

```ts
import * as Option from "effect/Option"
// Can be accessed like this
Option.zipWith
```

**Example**

```ts
import { Option } from "effect"

const maybeName: Option.Option<string> = Option.some("John")
const maybeAge: Option.Option<number> = Option.some(25)

// Combine the name and age into a person object
const person = Option.zipWith(maybeName, maybeAge, (name, age) => ({
  name: name.toUpperCase(),
  age
}))

console.log(person)
// Output:
// { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }
```

**Signature**

```ts
export declare const zipWith: {
  <B, A, C>(that: Option<B>, f: (a: A, b: B) => C): (self: Option<A>) => Option<C>
  <A, B, C>(self: Option<A>, that: Option<B>, f: (a: A, b: B) => C): Option<C>
}
```


# choice

Constructs command-line `Options` that represent a choice between several
inputs. The input will be mapped to it's associated value during parsing.

To import and use `choice` from the "Options" module:

```ts
import * as Options from "@effect/cli/Options"
// Can be accessed like this
Options.choice
```

**Example**

```ts
import * as Options from "@effect/cli/Options"

export const animal: Options.Options<"dog" | "cat"> = Options.choice("animal", ["dog", "cat"])
```

**Signature**

```ts
export declare const choice: <A extends string, C extends ReadonlyArray<A>>(
  name: string,
  choices: C
) => Options<C[number]>
```


# choiceWithValue

Constructs command-line `Options` that represent a choice between several
inputs. The input will be mapped to it's associated value during parsing.

To import and use `choiceWithValue` from the "Options" module:

```ts
import * as Options from "@effect/cli/Options"
// Can be accessed like this
Options.choiceWithValue
```

**Example**

```ts
import * as Options from "@effect/cli/Options"
import * as Data from "effect/Data"

export type Animal = Dog | Cat

export interface Dog {
  readonly _tag: "Dog"
}

export const Dog = Data.tagged<Dog>("Dog")

export interface Cat {
  readonly _tag: "Cat"
}

export const Cat = Data.tagged<Cat>("Cat")

export const animal: Options.Options<Animal> = Options.choiceWithValue("animal", [
  ["dog", Dog()],
  ["cat", Cat()]
])
```

**Signature**

```ts
export declare const choiceWithValue: <C extends ReadonlyArray<[string, any]>>(
  name: string,
  choices: C
) => Options<C[number][1]>
```


# directory

Creates a parameter expecting path to a directory.

To import and use `directory` from the "Options" module:

```ts
import * as Options from "@effect/cli/Options"
// Can be accessed like this
Options.directory
```

**Signature**

```ts
export declare const directory: (name: string, config?: Options.PathOptionsConfig) => Options<string>
```


# file

Creates a parameter expecting path to a file.

To import and use `file` from the "Options" module:

```ts
import * as Options from "@effect/cli/Options"
// Can be accessed like this
Options.file
```

**Signature**

```ts
export declare const file: (name: string, config?: Options.PathOptionsConfig) => Options<string>
```


# fileContent

Creates a parameter expecting path to a file and reads its contents.

To import and use `fileContent` from the "Options" module:

```ts
import * as Options from "@effect/cli/Options"
// Can be accessed like this
Options.fileContent
```

**Signature**

```ts
export declare const fileContent: (name: string) => Options<readonly [path: string, content: Uint8Array]>
```


# fileParse

Creates a parameter expecting path to a file and parse its contents.

To import and use `fileParse` from the "Options" module:

```ts
import * as Options from "@effect/cli/Options"
// Can be accessed like this
Options.fileParse
```

**Signature**

```ts
export declare const fileParse: (
  name: string,
  format?: "json" | "yaml" | "ini" | "toml" | undefined
) => Options<unknown>
```


# fileSchema

Creates a parameter expecting path to a file, parse its contents and validate
it with a Schema.

To import and use `fileSchema` from the "Options" module:

```ts
import * as Options from "@effect/cli/Options"
// Can be accessed like this
Options.fileSchema
```

**Signature**

```ts
export declare const fileSchema: <I, A>(
  name: string,
  schema: Schema<A, I, FileSystem | Path | Terminal>,
  format?: "json" | "yaml" | "ini" | "toml" | undefined
) => Options<A>
```


# fileText

Creates a parameter expecting path to a file and reads its contents.

To import and use `fileText` from the "Options" module:

```ts
import * as Options from "@effect/cli/Options"
// Can be accessed like this
Options.fileText
```

**Signature**

```ts
export declare const fileText: (name: string) => Options<readonly [path: string, content: string]>
```


# isBool

Returns `true` if the specified `Options` is a boolean flag, `false`
otherwise.

To import and use `isBool` from the "Options" module:

```ts
import * as Options from "@effect/cli/Options"
// Can be accessed like this
Options.isBool
```

**Signature**

```ts
export declare const isBool: <A>(self: Options<A>) => boolean
```


# processCommandLine

Processes the provided command-line arguments, searching for the specified
`Options`.

Returns an `Option<ValidationError>`, any leftover arguments, and the
constructed value of type `A`. The possible error inside
`Option<ValidationError>` would only be triggered if there is an error when
parsing the command-line arguments. This is because `ValidationError`s are
also used internally to control the end of the command-line arguments (i.e.
the command-line symbol `--`) corresponding to options.

To import and use `processCommandLine` from the "Options" module:

```ts
import * as Options from "@effect/cli/Options"
// Can be accessed like this
Options.processCommandLine
```

**Signature**

```ts
export declare const processCommandLine: {
  (
    args: ReadonlyArray<string>,
    config: CliConfig
  ): <A>(
    self: Options<A>
  ) => Effect<[Option<ValidationError>, Array<string>, A], ValidationError, FileSystem | Path | Terminal>
  <A>(
    self: Options<A>,
    args: ReadonlyArray<string>,
    config: CliConfig
  ): Effect<[Option<ValidationError>, Array<string>, A], ValidationError, FileSystem | Path | Terminal>
}
```


# repeated

Indicates that the specified command-line option can be repeated `0` or more
times.

**NOTE**: if the command-line option is not provided, and empty array will be
returned as the value for said option.

To import and use `repeated` from the "Options" module:

```ts
import * as Options from "@effect/cli/Options"
// Can be accessed like this
Options.repeated
```

**Signature**

```ts
export declare const repeated: <A>(self: Options<A>) => Options<Array<A>>
```


# array

This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.
The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.
If all elements are equal, the arrays are then compared based on their length.
It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.

To import and use `array` from the "Order" module:

```ts
import * as Order from "effect/Order"
// Can be accessed like this
Order.array
```

**Signature**

```ts
export declare const array: <A>(O: Order<A>) => Order<ReadonlyArray<A>>
```


# between

Test whether a value is between a minimum and a maximum (inclusive).

To import and use `between` from the "Order" module:

```ts
import * as Order from "effect/Order"
// Can be accessed like this
Order.between
```

**Signature**

```ts
export declare const between: <A>(O: Order<A>) => {
  (options: { minimum: A; maximum: A }): (self: A) => boolean
  (self: A, options: { minimum: A; maximum: A }): boolean
}
```


# clamp

Clamp a value between a minimum and a maximum.

To import and use `clamp` from the "Order" module:

```ts
import * as Order from "effect/Order"
// Can be accessed like this
Order.clamp
```

**Example**

```ts
import { Order, Number } from "effect"

const clamp = Order.clamp(Number.Order)({ minimum: 1, maximum: 5 })

assert.equal(clamp(3), 3)
assert.equal(clamp(0), 1)
assert.equal(clamp(6), 5)
```

**Signature**

```ts
export declare const clamp: <A>(O: Order<A>) => {
  (options: { minimum: A; maximum: A }): (self: A) => A
  (self: A, options: { minimum: A; maximum: A }): A
}
```


# greaterThan

Test whether one value is _strictly greater than_ another.

To import and use `greaterThan` from the "Order" module:

```ts
import * as Order from "effect/Order"
// Can be accessed like this
Order.greaterThan
```

**Signature**

```ts
export declare const greaterThan: <A>(O: Order<A>) => { (that: A): (self: A) => boolean; (self: A, that: A): boolean }
```


# greaterThanOrEqualTo

Test whether one value is _non-strictly greater than_ another.

To import and use `greaterThanOrEqualTo` from the "Order" module:

```ts
import * as Order from "effect/Order"
// Can be accessed like this
Order.greaterThanOrEqualTo
```

**Signature**

```ts
export declare const greaterThanOrEqualTo: <A>(O: Order<A>) => {
  (that: A): (self: A) => boolean
  (self: A, that: A): boolean
}
```


# lessThan

Test whether one value is _strictly less than_ another.

To import and use `lessThan` from the "Order" module:

```ts
import * as Order from "effect/Order"
// Can be accessed like this
Order.lessThan
```

**Signature**

```ts
export declare const lessThan: <A>(O: Order<A>) => { (that: A): (self: A) => boolean; (self: A, that: A): boolean }
```


# lessThanOrEqualTo

Test whether one value is _non-strictly less than_ another.

To import and use `lessThanOrEqualTo` from the "Order" module:

```ts
import * as Order from "effect/Order"
// Can be accessed like this
Order.lessThanOrEqualTo
```

**Signature**

```ts
export declare const lessThanOrEqualTo: <A>(O: Order<A>) => {
  (that: A): (self: A) => boolean
  (self: A, that: A): boolean
}
```


# max

Take the maximum of two values. If they are considered equal, the first argument is chosen.

To import and use `max` from the "Order" module:

```ts
import * as Order from "effect/Order"
// Can be accessed like this
Order.max
```

**Signature**

```ts
export declare const max: <A>(O: Order<A>) => { (that: A): (self: A) => A; (self: A, that: A): A }
```


# min

Take the minimum of two values. If they are considered equal, the first argument is chosen.

To import and use `min` from the "Order" module:

```ts
import * as Order from "effect/Order"
// Can be accessed like this
Order.min
```

**Signature**

```ts
export declare const min: <A>(O: Order<A>) => { (that: A): (self: A) => A; (self: A, that: A): A }
```


# struct

This function creates and returns a new `Order` for a struct of values based on the given `Order`s
for each property in the struct.

To import and use `struct` from the "Order" module:

```ts
import * as Order from "effect/Order"
// Can be accessed like this
Order.struct
```

**Signature**

```ts
export declare const struct: <R extends { readonly [x: string]: Order<any> }>(
  fields: R
) => Order<{ [K in keyof R]: [R[K]] extends [Order<infer A>] ? A : never }>
```


# tuple

Similar to `Promise.all` but operates on `Order`s.

```
[Order<A>, Order<B>, ...] -> Order<[A, B, ...]>
```

This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.
The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.
It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element
of the tuple.

To import and use `tuple` from the "Order" module:

```ts
import * as Order from "effect/Order"
// Can be accessed like this
Order.tuple
```

**Signature**

```ts
export declare const tuple: <T extends ReadonlyArray<Order<any>>>(
  ...elements: T
) => Order<Readonly<{ [I in keyof T]: [T[I]] extends [Order<infer A>] ? A : never }>>
```


# match

Depending on the `Ordering` parameter given to it, returns a value produced by one of the 3 functions provided as parameters.

To import and use `match` from the "Ordering" module:

```ts
import * as Ordering from "effect/Ordering"
// Can be accessed like this
Ordering.match
```

**Example**

```ts
import { Ordering } from "effect"
import { constant } from "effect/Function"

const toMessage = Ordering.match({
  onLessThan: constant("less than"),
  onEqual: constant("equal"),
  onGreaterThan: constant("greater than")
})

assert.deepStrictEqual(toMessage(-1), "less than")
assert.deepStrictEqual(toMessage(0), "equal")
assert.deepStrictEqual(toMessage(1), "greater than")
```

**Signature**

```ts
export declare const match: {
  <A, B, C = B>(options: {
    readonly onLessThan: LazyArg<A>
    readonly onEqual: LazyArg<B>
    readonly onGreaterThan: LazyArg<C>
  }): (self: Ordering) => A | B | C
  <A, B, C = B>(
    o: Ordering,
    options: { readonly onLessThan: LazyArg<A>; readonly onEqual: LazyArg<B>; readonly onGreaterThan: LazyArg<C> }
  ): A | B | C
}
```


# reverse

Inverts the ordering of the input `Ordering`.

To import and use `reverse` from the "Ordering" module:

```ts
import * as Ordering from "effect/Ordering"
// Can be accessed like this
Ordering.reverse
```

**Example**

```ts
import { reverse } from "effect/Ordering"

assert.deepStrictEqual(reverse(1), -1)
assert.deepStrictEqual(reverse(-1), 1)
assert.deepStrictEqual(reverse(0), 0)
```

**Signature**

```ts
export declare const reverse: (o: Ordering) => Ordering
```


# AvailablePerLine

Represents a `PageWidth` setting that informs the layout algorithms to avoid
exceeding the specified space per line.

To import and use `AvailablePerLine` from the "PageWidth" module:

```ts
import * as PageWidth from "@effect/printer/PageWidth"
// Can be accessed like this
PageWidth.AvailablePerLine
```


# isAvailablePerLine

Returns `true` if the specified `PageWidth` is an `AvailablePerLine`, `false`
otherwise.

To import and use `isAvailablePerLine` from the "PageWidth" module:

```ts
import * as PageWidth from "@effect/printer/PageWidth"
// Can be accessed like this
PageWidth.isAvailablePerLine
```

**Signature**

```ts
export declare const isAvailablePerLine: (self: PageWidth) => self is AvailablePerLine
```


# isPageWidth

Returns `true` if the specified value is a `PageWidth`, `false` otherwise.

To import and use `isPageWidth` from the "PageWidth" module:

```ts
import * as PageWidth from "@effect/printer/PageWidth"
// Can be accessed like this
PageWidth.isPageWidth
```

**Signature**

```ts
export declare const isPageWidth: (u: unknown) => u is PageWidth
```


# isUnbounded

Returns `true` if the specified `PageWidth` is an `Unbounded`, `false`
otherwise.

To import and use `isUnbounded` from the "PageWidth" module:

```ts
import * as PageWidth from "@effect/printer/PageWidth"
// Can be accessed like this
PageWidth.isUnbounded
```

**Signature**

```ts
export declare const isUnbounded: (self: PageWidth) => self is Unbounded
```


# PageWidth

Represents the maximum number of characters that fit onto a single line in a
document. The layout algorithms will try to avoid exceeding the set character
limit by inserting line breaks where appropriate (e.g., via `softLine`).

To import and use `PageWidth` from the "PageWidth" module:

```ts
import * as PageWidth from "@effect/printer/PageWidth"
// Can be accessed like this
PageWidth.PageWidth
```


# remainingWidth

Calculates the remaining width on the current line.

To import and use `remainingWidth` from the "PageWidth" module:

```ts
import * as PageWidth from "@effect/printer/PageWidth"
// Can be accessed like this
PageWidth.remainingWidth
```

**Signature**

```ts
export declare const remainingWidth: (
  lineLength: number,
  ribbonFraction: number,
  lineIndent: number,
  currentColumn: number
) => number
```


# Unbounded

Represents a `PageWidth` setting that informs the layout algorithms to avoid
introducing line breaks into a document.

To import and use `Unbounded` from the "PageWidth" module:

```ts
import * as PageWidth from "@effect/printer/PageWidth"
// Can be accessed like this
PageWidth.Unbounded
```


# ArrayFormatterIssue

Represents an issue returned by the {@link ArrayFormatter} formatter.

To import and use `ArrayFormatterIssue` from the "ParseResult" module:

```ts
import * as ParseResult from "effect/ParseResult"
// Can be accessed like this
ParseResult.ArrayFormatterIssue
```


# asserts

By default the option `exact` is set to `true`.

To import and use `asserts` from the "ParseResult" module:

```ts
import * as ParseResult from "effect/ParseResult"
// Can be accessed like this
ParseResult.asserts
```

**Signature**

```ts
export declare const asserts: <A, I, R>(
  schema: Schema.Schema<A, I, R>,
  options?: AST.ParseOptions
) => (u: unknown, overrideOptions?: AST.ParseOptions) => asserts u is A
```


# Composite

Error that contains multiple issues.

To import and use `Composite` from the "ParseResult" module:

```ts
import * as ParseResult from "effect/ParseResult"
// Can be accessed like this
ParseResult.Composite
```


# Forbidden

The `Forbidden` variant of the `ParseIssue` type represents a forbidden operation, such as when encountering an Effect that is not allowed to execute (e.g., using `runSync`).

To import and use `Forbidden` from the "ParseResult" module:

```ts
import * as ParseResult from "effect/ParseResult"
// Can be accessed like this
ParseResult.Forbidden
```


# is

By default the option `exact` is set to `true`.

To import and use `is` from the "ParseResult" module:

```ts
import * as ParseResult from "effect/ParseResult"
// Can be accessed like this
ParseResult.is
```

**Signature**

```ts
export declare const is: <A, I, R>(
  schema: Schema.Schema<A, I, R>,
  options?: AST.ParseOptions
) => (u: unknown, overrideOptions?: AST.ParseOptions | number) => u is A
```


# isComposite

Returns `true` if the value is a `Composite`.

To import and use `isComposite` from the "ParseResult" module:

```ts
import * as ParseResult from "effect/ParseResult"
// Can be accessed like this
ParseResult.isComposite
```

**Signature**

```ts
export declare const isComposite: (issue: ParseIssue) => issue is Extract<ParseIssue, { _tag: "Composite" }>
```


# Missing

Error that occurs when a required key or index is missing.

To import and use `Missing` from the "ParseResult" module:

```ts
import * as ParseResult from "effect/ParseResult"
// Can be accessed like this
ParseResult.Missing
```


# ParseIssue

`ParseIssue` is a type that represents the different types of errors that can occur when decoding/encoding a value.

To import and use `ParseIssue` from the "ParseResult" module:

```ts
import * as ParseResult from "effect/ParseResult"
// Can be accessed like this
ParseResult.ParseIssue
```


# Refinement

Error that occurs when a refinement has an error.

To import and use `Refinement` from the "ParseResult" module:

```ts
import * as ParseResult from "effect/ParseResult"
// Can be accessed like this
ParseResult.Refinement
```


# Transformation

Error that occurs when a transformation has an error.

To import and use `Transformation` from the "ParseResult" module:

```ts
import * as ParseResult from "effect/ParseResult"
// Can be accessed like this
ParseResult.Transformation
```


# Type

The `Type` variant of the `ParseIssue` type represents an error that occurs when the `actual` value is not of the expected type.
The `ast` field specifies the expected type, and the `actual` field contains the value that caused the error.

To import and use `Type` from the "ParseResult" module:

```ts
import * as ParseResult from "effect/ParseResult"
// Can be accessed like this
ParseResult.Type
```


# Unexpected

Error that occurs when an unexpected key or index is present.

To import and use `Unexpected` from the "ParseResult" module:

```ts
import * as ParseResult from "effect/ParseResult"
// Can be accessed like this
ParseResult.Unexpected
```


# layer

An implementation of the Path interface that can be used in all environments
(including browsers).

It uses the POSIX standard for paths.

To import and use `layer` from the "Path" module:

```ts
import * as Path from "@effect/platform/Path"
// Can be accessed like this
Path.layer
```

**Signature**

```ts
export declare const layer: Layer<Path, never, never>
```


# layer

A layer that directly interfaces with the `navigator.permissions` api

To import and use `layer` from the "Permissions" module:

```ts
import * as Permissions from "@effect/platform-browser/Permissions"
// Can be accessed like this
Permissions.layer
```

**Signature**

```ts
export declare const layer: Layer.Layer<Permissions, never, never>
```


# Permissions

Wrapper on the Permission API (`navigator.permissions`)
with methods for querying status of permissions.

To import and use `Permissions` from the "Permissions" module:

```ts
import * as Permissions from "@effect/platform-browser/Permissions"
// Can be accessed like this
Permissions.Permissions
```


# fromDotEnv

Create a dotenv ConfigProvider.

To import and use `fromDotEnv` from the "PlatformConfigProvider" module:

```ts
import * as PlatformConfigProvider from "@effect/platform/PlatformConfigProvider"
// Can be accessed like this
PlatformConfigProvider.fromDotEnv
```

**Signature**

```ts
export declare const fromDotEnv: (
  paths: string
) => Effect.Effect<ConfigProvider.ConfigProvider, PlatformError, FileSystem.FileSystem>
```


# layerDotEnv

Add the dotenv ConfigProvider to the environment, replacing the current ConfigProvider.

To import and use `layerDotEnv` from the "PlatformConfigProvider" module:

```ts
import * as PlatformConfigProvider from "@effect/platform/PlatformConfigProvider"
// Can be accessed like this
PlatformConfigProvider.layerDotEnv
```

**Signature**

```ts
export declare const layerDotEnv: (path: string) => Layer.Layer<never, PlatformError, FileSystem.FileSystem>
```


# layerDotEnvAdd

Add the dotenv ConfigProvider to the environment, as a fallback to the current ConfigProvider.
If the file is not found, a debug log is produced and empty layer is returned.

To import and use `layerDotEnvAdd` from the "PlatformConfigProvider" module:

```ts
import * as PlatformConfigProvider from "@effect/platform/PlatformConfigProvider"
// Can be accessed like this
PlatformConfigProvider.layerDotEnvAdd
```

**Signature**

```ts
export declare const layerDotEnvAdd: (path: string) => Layer.Layer<never, never, FileSystem.FileSystem>
```


# layerFileTree

Add the file tree ConfigProvider to the environment, replacing the current ConfigProvider.

To import and use `layerFileTree` from the "PlatformConfigProvider" module:

```ts
import * as PlatformConfigProvider from "@effect/platform/PlatformConfigProvider"
// Can be accessed like this
PlatformConfigProvider.layerFileTree
```

**Signature**

```ts
export declare const layerFileTree: (options?: {
  readonly rootDirectory?: string
}) => Layer.Layer<never, never, Path.Path | FileSystem.FileSystem>
```


# layerFileTreeAdd

Add the file tree ConfigProvider to the environment, as a fallback to the current ConfigProvider.

To import and use `layerFileTreeAdd` from the "PlatformConfigProvider" module:

```ts
import * as PlatformConfigProvider from "@effect/platform/PlatformConfigProvider"
// Can be accessed like this
PlatformConfigProvider.layerFileTreeAdd
```

**Signature**

```ts
export declare const layerFileTreeAdd: (options?: {
  readonly rootDirectory?: string
}) => Layer.Layer<never, never, Path.Path | FileSystem.FileSystem>
```


# toFile

Create a Logger from another string Logger that writes to the specified file.

To import and use `toFile` from the "PlatformLogger" module:

```ts
import * as PlatformLogger from "@effect/platform/PlatformLogger"
// Can be accessed like this
PlatformLogger.toFile
```

**Example**

```ts
import { PlatformLogger } from "@effect/platform"
import { NodeFileSystem, NodeRuntime } from "@effect/platform-node"
import { Effect, Layer, Logger } from "effect"

const fileLogger = Logger.logfmtLogger.pipe(PlatformLogger.toFile("/tmp/log.txt"))
const LoggerLive = Logger.replaceScoped(Logger.defaultLogger, fileLogger).pipe(Layer.provide(NodeFileSystem.layer))

Effect.log("a").pipe(
  Effect.zipRight(Effect.log("b")),
  Effect.zipRight(Effect.log("c")),
  Effect.provide(LoggerLive),
  NodeRuntime.runMain
)
```

**Signature**

```ts
export declare const toFile: {
  (
    path: string,
    options?: (OpenFileOptions & { readonly batchWindow?: DurationInput | undefined }) | undefined
  ): <Message>(
    self: Logger.Logger<Message, string>
  ) => Effect<Logger.Logger<Message, void>, PlatformError, Scope | FileSystem>
  <Message>(
    self: Logger.Logger<Message, string>,
    path: string,
    options?: (OpenFileOptions & { readonly batchWindow?: DurationInput | undefined }) | undefined
  ): Effect<Logger.Logger<Message, void>, PlatformError, Scope | FileSystem>
}
```


# isPod

Given a value, ensures that it's a valid Pod.

To import and use `isPod` from the "Pod" module:

```ts
import * as Pod from "@effect/cluster/Pod"
// Can be accessed like this
Pod.isPod
```

**Signature**

```ts
export declare function isPod(value: unknown): value is Pod
```


# make

Constructs a Pod from it's identifing PodAddress and application server version.

To import and use `make` from the "Pod" module:

```ts
import * as Pod from "@effect/cluster/Pod"
// Can be accessed like this
Pod.make
```

**Signature**

```ts
export declare function make(address: PodAddress.PodAddress, version: string): Pod
```


# Pod

A pod is an application server that is able to run entities. A pod can run multiple entities,
but a single entity will live on a given pod at a time.
Since this is an application server, it needs to have an unique identifier where it's addressed (PodAddress),
and has a version of the application that's running on it.
Version is used during the rebalance phase to give priority to newer application servers and slowly kill older ones.

To import and use `Pod` from the "Pod" module:

```ts
import * as Pod from "@effect/cluster/Pod"
// Can be accessed like this
Pod.Pod
```


# isPodAddress

Ensures that the given value is a valid PodAddress.

To import and use `isPodAddress` from the "PodAddress" module:

```ts
import * as PodAddress from "@effect/cluster/PodAddress"
// Can be accessed like this
PodAddress.isPodAddress
```

**Signature**

```ts
export declare function isPodAddress(value: unknown): value is PodAddress
```


# make

Constructs a PodAddress from an host and a port.

To import and use `make` from the "PodAddress" module:

```ts
import * as PodAddress from "@effect/cluster/PodAddress"
// Can be accessed like this
PodAddress.make
```

**Signature**

```ts
export declare function make(host: string, port: number): PodAddress
```


# PodAddress

A PodAddress is a unique identifier of a Pod (application server).
It is conventially built by using an address and a port, so that messaging implementations may use directly the
PodAddress to know how to connect to the specific Pod.

To import and use `PodAddress` from the "PodAddress" module:

```ts
import * as PodAddress from "@effect/cluster/PodAddress"
// Can be accessed like this
PodAddress.PodAddress
```


# schema

This is the schema for a PodAddress.

To import and use `schema` from the "PodAddress" module:

```ts
import * as PodAddress from "@effect/cluster/PodAddress"
// Can be accessed like this
PodAddress.schema
```

**Signature**

```ts
export declare const schema: Schema.Schema<PodAddress, PodAddress.Encoded, never>
```


# make

Constructs a Pods service from its implementation

To import and use `make` from the "Pods" module:

```ts
import * as Pods from "@effect/cluster/Pods"
// Can be accessed like this
Pods.make
```

**Signature**

```ts
export declare const make: (args: Omit<Pods, typeof PodsTypeId>) => Pods
```


# noop

A layer that creates a service that does nothing when called.
Useful for testing ShardManager or when using Sharding.local.

To import and use `noop` from the "Pods" module:

```ts
import * as Pods from "@effect/cluster/Pods"
// Can be accessed like this
Pods.noop
```

**Signature**

```ts
export declare const noop: Layer.Layer<Pods, never, never>
```


# Pods

An interface to communicate with remote pods.
This is used by the Shard Manager for assigning and unassigning shards.
This is also used by pods for internal communication (forward messages to each other).

To import and use `Pods` from the "Pods" module:

```ts
import * as Pods from "@effect/cluster/Pods"
// Can be accessed like this
Pods.Pods
```


# local

A layer that pings the pod directly to check if it's alive.
This is useful for developing and testing but not reliable in production.

To import and use `local` from the "PodsHealth" module:

```ts
import * as PodsHealth from "@effect/cluster/PodsHealth"
// Can be accessed like this
PodsHealth.local
```

**Signature**

```ts
export declare const local: Layer.Layer<PodsHealth, never, Pods.Pods>
```


# make

Constructs a PodsHealth from its implementation

To import and use `make` from the "PodsHealth" module:

```ts
import * as PodsHealth from "@effect/cluster/PodsHealth"
// Can be accessed like this
PodsHealth.make
```

**Signature**

```ts
export declare const make: (args: Omit<PodsHealth, typeof PodsHealthTypeId>) => PodsHealth
```


# noop

A layer that considers pods as always alive.
This is useful for testing only.

To import and use `noop` from the "PodsHealth" module:

```ts
import * as PodsHealth from "@effect/cluster/PodsHealth"
// Can be accessed like this
PodsHealth.noop
```

**Signature**

```ts
export declare const noop: Layer.Layer<PodsHealth, never, never>
```


# PodsHealth

An interface to check a pod's health.
This is used when a pod is unresponsive, to check if it should be unassigned all its shards or not.
If the pod is alive, shards will not be unassigned because the pods might still be processing messages and might be responsive again.
If the pod is not alive, shards can be safely reassigned somewhere else.
A typical implementation for this is using k8s to check if the pod still exists.

To import and use `PodsHealth` from the "PodsHealth" module:

```ts
import * as PodsHealth from "@effect/cluster/PodsHealth"
// Can be accessed like this
PodsHealth.PodsHealth
```


# podsRpc

Given a function that resolves an RPC client, constructs a Pods service that uses RPC to communicate

To import and use `podsRpc` from the "PodsRpc" module:

```ts
import * as PodsRpc from "@effect/cluster-node/PodsRpc"
// Can be accessed like this
PodsRpc.podsRpc
```

**Signature**

```ts
export declare function podsRpc<R>(
  buildClient: (
    podAddress: PodAddress.PodAddress
  ) => RpcResolver.Client<
    RequestResolver.RequestResolver<Rpc.Request<ShardingServiceRpc.ShardingServiceRpcRequest>, never>
  >
): Layer.Layer<Pods.Pods, never, R>
```


# isPoisonPill

Checks if the given value is a PoisonPill.

To import and use `isPoisonPill` from the "PoisonPill" module:

```ts
import * as PoisonPill from "@effect/cluster/PoisonPill"
// Can be accessed like this
PoisonPill.isPoisonPill
```

**Signature**

```ts
export declare function isPoisonPill(value: unknown): value is PoisonPill
```


# make

Constructs a new PosionPill

To import and use `make` from the "PoisonPill" module:

```ts
import * as PoisonPill from "@effect/cluster/PoisonPill"
// Can be accessed like this
PoisonPill.make
```

**Signature**

```ts
export declare const make: Effect.Effect<PoisonPill, never, never>
```


# PoisonPill

A PoisonPill is a special value that tells a behaviour entity to shut itself down.
PoisonPill is handled only when you are using a Queue-based RecipientBehaviour.
Other RecipientBehaviour such as fromFunctionEffect would not care about PoisonPill.

To import and use `PoisonPill` from the "PoisonPill" module:

```ts
import * as PoisonPill from "@effect/cluster/PoisonPill"
// Can be accessed like this
PoisonPill.PoisonPill
```


# schema

This is the schema for a PoisonPill that is used to encode the value over the wire.
This is useful if you want a behavior that can be shut down from an external message.

To import and use `schema` from the "PoisonPill" module:

```ts
import * as PoisonPill from "@effect/cluster/PoisonPill"
// Can be accessed like this
PoisonPill.schema
```

**Signature**

```ts
export declare const schema: Schema.Schema<PoisonPill, PoisonPill.Encoded, never>
```


# takeOrInterrupt

Attempts to take a message from the queue in the same way Queue.take does.
If the result is a PoisonPill, it will interrupt the effect.

To import and use `takeOrInterrupt` from the "PoisonPill" module:

```ts
import * as PoisonPill from "@effect/cluster/PoisonPill"
// Can be accessed like this
PoisonPill.takeOrInterrupt
```

**Signature**

```ts
export declare function takeOrInterrupt<Req>(dequeue: Queue.Dequeue<Req | PoisonPill>): Effect.Effect<Req>
```


# get

Retrieves an item from the pool in a scoped effect. Note that if
acquisition fails, then the returned effect will fail for that same reason.
Retrying a failed acquisition attempt will repeat the acquisition attempt.

To import and use `get` from the "Pool" module:

```ts
import * as Pool from "effect/Pool"
// Can be accessed like this
Pool.get
```

**Signature**

```ts
export declare const get: <A, E>(self: Pool<A, E>) => Effect.Effect<A, E, Scope.Scope>
```


# invalidate

Invalidates the specified item. This will cause the pool to eventually
reallocate the item, although this reallocation may occur lazily rather
than eagerly.

To import and use `invalidate` from the "Pool" module:

```ts
import * as Pool from "effect/Pool"
// Can be accessed like this
Pool.invalidate
```

**Signature**

```ts
export declare const invalidate: {
  <A>(value: A): <E>(self: Pool<A, E>) => Effect.Effect<void, never, Scope.Scope>
  <A, E>(self: Pool<A, E>, value: A): Effect.Effect<void, never, Scope.Scope>
}
```


# isPool

Returns `true` if the specified value is a `Pool`, `false` otherwise.

To import and use `isPool` from the "Pool" module:

```ts
import * as Pool from "effect/Pool"
// Can be accessed like this
Pool.isPool
```

**Signature**

```ts
export declare const isPool: (u: unknown) => u is Pool<unknown, unknown>
```


# make

Makes a new pool of the specified fixed size. The pool is returned in a
`Scope`, which governs the lifetime of the pool. When the pool is shutdown
because the `Scope` is closed, the individual items allocated by the pool
will be released in some unspecified order.

By setting the `concurrency` parameter, you can control the level of concurrent
access per pool item. By default, the number of permits is set to `1`.

`targetUtilization` determines when to create new pool items. It is a value
between 0 and 1, where 1 means only create new pool items when all the existing
items are fully utilized.

A `targetUtilization` of 0.5 will create new pool items when the existing items are
50% utilized.

To import and use `make` from the "Pool" module:

```ts
import * as Pool from "effect/Pool"
// Can be accessed like this
Pool.make
```

**Signature**

```ts
export declare const make: <A, E, R>(options: {
  readonly acquire: Effect.Effect<A, E, R>
  readonly size: number
  readonly concurrency?: number | undefined
  readonly targetUtilization?: number | undefined
}) => Effect.Effect<Pool<A, E>, never, Scope.Scope | R>
```


# makeWithTTL

Makes a new pool with the specified minimum and maximum sizes and time to
live before a pool whose excess items are not being used will be shrunk
down to the minimum size. The pool is returned in a `Scope`, which governs
the lifetime of the pool. When the pool is shutdown because the `Scope` is
used, the individual items allocated by the pool will be released in some
unspecified order.

By setting the `concurrency` parameter, you can control the level of concurrent
access per pool item. By default, the number of permits is set to `1`.

`targetUtilization` determines when to create new pool items. It is a value
between 0 and 1, where 1 means only create new pool items when all the existing
items are fully utilized.

A `targetUtilization` of 0.5 will create new pool items when the existing items are
50% utilized.

The `timeToLiveStrategy` determines how items are invalidated. If set to
"creation", then items are invalidated based on their creation time. If set
to "usage", then items are invalidated based on pool usage.

By default, the `timeToLiveStrategy` is set to "usage".

```ts
import { createConnection } from "mysql2"
import { Duration, Effect, Pool } from "effect"

const acquireDBConnection = Effect.acquireRelease(
  Effect.sync(() => createConnection("mysql://...")),
  (connection) => Effect.sync(() => connection.end(() => {}))
)

const connectionPool = Effect.flatMap(
  Pool.makeWithTTL({
    acquire: acquireDBConnection,
    min: 10,
    max: 20,
    timeToLive: Duration.seconds(60)
  }),
  (pool) => pool.get
)
```

To import and use `makeWithTTL` from the "Pool" module:

```ts
import * as Pool from "effect/Pool"
// Can be accessed like this
Pool.makeWithTTL
```

**Signature**

```ts
export declare const makeWithTTL: <A, E, R>(options: {
  readonly acquire: Effect.Effect<A, E, R>
  readonly min: number
  readonly max: number
  readonly concurrency?: number | undefined
  readonly targetUtilization?: number | undefined
  readonly timeToLive: Duration.DurationInput
  readonly timeToLiveStrategy?: "creation" | "usage" | undefined
}) => Effect.Effect<Pool<A, E>, never, Scope.Scope | R>
```


# Pool

A `Pool<A, E>` is a pool of items of type `A`, each of which may be
associated with the acquisition and release of resources. An attempt to get
an item `A` from a pool may fail with an error of type `E`.

To import and use `Pool` from the "Pool" module:

```ts
import * as Pool from "effect/Pool"
// Can be accessed like this
Pool.Pool
```


# and

Combines two predicates into a new predicate that returns `true` if both of the predicates returns `true`.

To import and use `and` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.and
```

**Example**

```ts
import { Predicate } from "effect"

const minLength = (n: number) => (s: string) => s.length >= n
const maxLength = (n: number) => (s: string) => s.length <= n

const length = (n: number) => Predicate.and(minLength(n), maxLength(n))

assert.deepStrictEqual(length(2)("aa"), true)
assert.deepStrictEqual(length(2)("a"), false)
assert.deepStrictEqual(length(2)("aaa"), false)
```

**Signature**

```ts
export declare const and: {
  <A, C extends A>(that: Refinement<A, C>): <B extends A>(self: Refinement<A, B>) => Refinement<A, B & C>
  <A, B extends A, C extends A>(self: Refinement<A, B>, that: Refinement<A, C>): Refinement<A, B & C>
  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>
  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>
}
```


# hasProperty

Checks whether a value is an `object` containing a specified property key.

To import and use `hasProperty` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.hasProperty
```

**Signature**

```ts
export declare const hasProperty: {
  <P extends PropertyKey>(property: P): (self: unknown) => self is { [K in P]: unknown }
  <P extends PropertyKey>(self: unknown, property: P): self is { [K in P]: unknown }
}
```


# implies

Represents the logical implication combinator for predicates. In formal
logic, the implication operator `->` denotes that if the first proposition
(antecedent) is true, then the second proposition (consequent) must also be
true. In simpler terms, `p implies q` can be interpreted as "if p then q". If
the first predicate holds, then the second predicate must hold
for the given context.

In practical terms within TypeScript, `p implies q` is equivalent to `!p || (p && q)`.

Note that if the antecedent is `false`, the result is `true` by default
because the outcome of the consequent cannot be determined.

This function is useful in situations where you need to enforce rules or
constraints that are contingent on certain conditions.
It proves especially helpful in defining property tests.

The example below illustrates the transitive property of order using the
`implies` function. In simple terms, if `a <= b` and `b <= c`, then `a <= c`
must be true.

To import and use `implies` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.implies
```

**Example**

```ts
import { Predicate } from "effect"

type Triple = {
  readonly a: number
  readonly b: number
  readonly c: number
}

const transitivity = Predicate.implies(
  // antecedent
  (input: Triple) => input.a <= input.b && input.b <= input.c,
  // consequent
  (input: Triple) => input.a <= input.c
)

assert.equal(transitivity({ a: 1, b: 2, c: 3 }), true)
// antecedent is `false`, so the result is `true`
assert.equal(transitivity({ a: 1, b: 0, c: 0 }), true)
```

**Signature**

```ts
export declare const implies: {
  <A>(consequent: Predicate<A>): (antecedent: Predicate<A>) => Predicate<A>
  <A>(antecedent: Predicate<A>, consequent: Predicate<A>): Predicate<A>
}
```


# isBigInt

Tests if a value is a `bigint`.

To import and use `isBigInt` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isBigInt
```

**Example**

```ts
import { isBigInt } from "effect/Predicate"

assert.deepStrictEqual(isBigInt(1n), true)

assert.deepStrictEqual(isBigInt(1), false)
```

**Signature**

```ts
export declare const isBigInt: (input: unknown) => input is bigint
```


# isBoolean

Tests if a value is a `boolean`.

To import and use `isBoolean` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isBoolean
```

**Example**

```ts
import { isBoolean } from "effect/Predicate"

assert.deepStrictEqual(isBoolean(true), true)

assert.deepStrictEqual(isBoolean("true"), false)
```

**Signature**

```ts
export declare const isBoolean: (input: unknown) => input is boolean
```


# isDate

A guard that succeeds when the input is a `Date`.

To import and use `isDate` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isDate
```

**Example**

```ts
import { isDate } from "effect/Predicate"

assert.deepStrictEqual(isDate(new Date()), true)

assert.deepStrictEqual(isDate(null), false)
assert.deepStrictEqual(isDate({}), false)
```

**Signature**

```ts
export declare const isDate: (input: unknown) => input is Date
```


# isError

A guard that succeeds when the input is an `Error`.

To import and use `isError` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isError
```

**Example**

```ts
import { isError } from "effect/Predicate"

assert.deepStrictEqual(isError(new Error()), true)

assert.deepStrictEqual(isError(null), false)
assert.deepStrictEqual(isError({}), false)
```

**Signature**

```ts
export declare const isError: (input: unknown) => input is Error
```


# isFunction

Tests if a value is a `function`.

To import and use `isFunction` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isFunction
```

**Example**

```ts
import { isFunction } from "effect/Predicate"

assert.deepStrictEqual(isFunction(isFunction), true)

assert.deepStrictEqual(isFunction("function"), false)
```

**Signature**

```ts
export declare const isFunction: (input: unknown) => input is Function
```


# isIterable

A guard that succeeds when the input is an `Iterable`.

To import and use `isIterable` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isIterable
```

**Example**

```ts
import { isIterable } from "effect/Predicate"

assert.deepStrictEqual(isIterable([]), true)
assert.deepStrictEqual(isIterable(new Set()), true)

assert.deepStrictEqual(isIterable(null), false)
assert.deepStrictEqual(isIterable({}), false)
```

**Signature**

```ts
export declare const isIterable: (input: unknown) => input is Iterable<unknown>
```


# isMap

Tests if a value is a `Map`.

To import and use `isMap` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isMap
```

**Example**

```ts
import { isMap } from "effect/Predicate"

assert.deepStrictEqual(isMap(new Map()), true)
assert.deepStrictEqual(isMap({}), false)
assert.deepStrictEqual(isMap(null), false)
assert.deepStrictEqual(isMap(undefined), false)
```

**Signature**

```ts
export declare const isMap: (input: unknown) => input is Map<unknown, unknown>
```


# isNever

A guard that always fails.

To import and use `isNever` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isNever
```

**Example**

```ts
import { isNever } from "effect/Predicate"

assert.deepStrictEqual(isNever(null), false)
assert.deepStrictEqual(isNever(undefined), false)
assert.deepStrictEqual(isNever({}), false)
assert.deepStrictEqual(isNever([]), false)
```

**Signature**

```ts
export declare const isNever: (input: unknown) => input is never
```


# isNotNull

Tests if a value is not `null`.

To import and use `isNotNull` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isNotNull
```

**Example**

```ts
import { isNotNull } from "effect/Predicate"

assert.deepStrictEqual(isNotNull(undefined), true)
assert.deepStrictEqual(isNotNull("null"), true)

assert.deepStrictEqual(isNotNull(null), false)
```

**Signature**

```ts
export declare const isNotNull: <A>(input: A) => input is Exclude<A, null>
```


# isNotNullable

A guard that succeeds when the input is not `null` or `undefined`.

To import and use `isNotNullable` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isNotNullable
```

**Example**

```ts
import { isNotNullable } from "effect/Predicate"

assert.deepStrictEqual(isNotNullable({}), true)
assert.deepStrictEqual(isNotNullable([]), true)

assert.deepStrictEqual(isNotNullable(null), false)
assert.deepStrictEqual(isNotNullable(undefined), false)
```

**Signature**

```ts
export declare const isNotNullable: <A>(input: A) => input is NonNullable<A>
```


# isNotUndefined

Tests if a value is not `undefined`.

To import and use `isNotUndefined` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isNotUndefined
```

**Example**

```ts
import { isNotUndefined } from "effect/Predicate"

assert.deepStrictEqual(isNotUndefined(null), true)
assert.deepStrictEqual(isNotUndefined("undefined"), true)

assert.deepStrictEqual(isNotUndefined(undefined), false)
```

**Signature**

```ts
export declare const isNotUndefined: <A>(input: A) => input is Exclude<A, undefined>
```


# isNull

Tests if a value is `null`.

To import and use `isNull` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isNull
```

**Example**

```ts
import { isNull } from "effect/Predicate"

assert.deepStrictEqual(isNull(null), true)

assert.deepStrictEqual(isNull(undefined), false)
assert.deepStrictEqual(isNull("null"), false)
```

**Signature**

```ts
export declare const isNull: (input: unknown) => input is null
```


# isNullable

A guard that succeeds when the input is `null` or `undefined`.

To import and use `isNullable` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isNullable
```

**Example**

```ts
import { isNullable } from "effect/Predicate"

assert.deepStrictEqual(isNullable(null), true)
assert.deepStrictEqual(isNullable(undefined), true)

assert.deepStrictEqual(isNullable({}), false)
assert.deepStrictEqual(isNullable([]), false)
```

**Signature**

```ts
export declare const isNullable: <A>(input: A) => input is Extract<A, null | undefined>
```


# isNumber

Tests if a value is a `number`.

To import and use `isNumber` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isNumber
```

**Example**

```ts
import { isNumber } from "effect/Predicate"

assert.deepStrictEqual(isNumber(2), true)

assert.deepStrictEqual(isNumber("2"), false)
```

**Signature**

```ts
export declare const isNumber: (input: unknown) => input is number
```


# isObject

Tests if a value is an `object`.

To import and use `isObject` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isObject
```

**Example**

```ts
import { isObject } from "effect/Predicate"

assert.deepStrictEqual(isObject({}), true)
assert.deepStrictEqual(isObject([]), true)

assert.deepStrictEqual(isObject(null), false)
assert.deepStrictEqual(isObject(undefined), false)
```

**Signature**

```ts
export declare const isObject: (input: unknown) => input is object
```


# isPromise

A guard that succeeds when the input is a Promise.

To import and use `isPromise` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isPromise
```

**Example**

```ts
import { isPromise } from "effect/Predicate"

assert.deepStrictEqual(isPromise({}), false)
assert.deepStrictEqual(isPromise(Promise.resolve("hello")), true)
```

**Signature**

```ts
export declare const isPromise: (input: unknown) => input is Promise<unknown>
```


# isReadonlyRecord

A guard that succeeds when the input is a readonly record.

To import and use `isReadonlyRecord` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isReadonlyRecord
```

**Example**

```ts
import { isReadonlyRecord } from "effect/Predicate"

assert.deepStrictEqual(isReadonlyRecord({}), true)
assert.deepStrictEqual(isReadonlyRecord({ a: 1 }), true)

assert.deepStrictEqual(isReadonlyRecord([]), false)
assert.deepStrictEqual(isReadonlyRecord([1, 2, 3]), false)
assert.deepStrictEqual(isReadonlyRecord(null), false)
assert.deepStrictEqual(isReadonlyRecord(undefined), false)
```

**Signature**

```ts
export declare const isReadonlyRecord: (input: unknown) => input is { readonly [x: string | symbol]: unknown }
```


# isRecord

A guard that succeeds when the input is a record.

To import and use `isRecord` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isRecord
```

**Example**

```ts
import { isRecord } from "effect/Predicate"

assert.deepStrictEqual(isRecord({}), true)
assert.deepStrictEqual(isRecord({ a: 1 }), true)

assert.deepStrictEqual(isRecord([]), false)
assert.deepStrictEqual(isRecord([1, 2, 3]), false)
assert.deepStrictEqual(isRecord(null), false)
assert.deepStrictEqual(isRecord(undefined), false)
assert.deepStrictEqual(
  isRecord(() => null),
  false
)
```

**Signature**

```ts
export declare const isRecord: (input: unknown) => input is { [x: string | symbol]: unknown }
```


# isRegExp

Tests if a value is a `RegExp`.

To import and use `isRegExp` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isRegExp
```

**Example**

```ts
import { Predicate } from "effect"

assert.deepStrictEqual(Predicate.isRegExp(/a/), true)
assert.deepStrictEqual(Predicate.isRegExp("a"), false)
```

**Signature**

```ts
export declare const isRegExp: (input: unknown) => input is RegExp
```


# isSet

Tests if a value is a `Set`.

To import and use `isSet` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isSet
```

**Example**

```ts
import { isSet } from "effect/Predicate"

assert.deepStrictEqual(isSet(new Set([1, 2])), true)
assert.deepStrictEqual(isSet(new Set()), true)
assert.deepStrictEqual(isSet({}), false)
assert.deepStrictEqual(isSet(null), false)
assert.deepStrictEqual(isSet(undefined), false)
```

**Signature**

```ts
export declare const isSet: (input: unknown) => input is Set<unknown>
```


# isString

Tests if a value is a `string`.

To import and use `isString` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isString
```

**Example**

```ts
import { isString } from "effect/Predicate"

assert.deepStrictEqual(isString("a"), true)

assert.deepStrictEqual(isString(1), false)
```

**Signature**

```ts
export declare const isString: (input: unknown) => input is string
```


# isSymbol

Tests if a value is a `symbol`.

To import and use `isSymbol` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isSymbol
```

**Example**

```ts
import { isSymbol } from "effect/Predicate"

assert.deepStrictEqual(isSymbol(Symbol.for("a")), true)

assert.deepStrictEqual(isSymbol("a"), false)
```

**Signature**

```ts
export declare const isSymbol: (input: unknown) => input is symbol
```


# isTagged

Tests if a value is an `object` with a property `_tag` that matches the given tag.

To import and use `isTagged` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isTagged
```

**Example**

```ts
import { isTagged } from "effect/Predicate"

assert.deepStrictEqual(isTagged(1, "a"), false)
assert.deepStrictEqual(isTagged(null, "a"), false)
assert.deepStrictEqual(isTagged({}, "a"), false)
assert.deepStrictEqual(isTagged({ a: "a" }, "a"), false)
assert.deepStrictEqual(isTagged({ _tag: "a" }, "a"), true)
assert.deepStrictEqual(isTagged("a")({ _tag: "a" }), true)
```

**Signature**

```ts
export declare const isTagged: {
  <K extends string>(tag: K): (self: unknown) => self is { _tag: K }
  <K extends string>(self: unknown, tag: K): self is { _tag: K }
}
```


# isTruthy

Tests if a value is `truthy`.

To import and use `isTruthy` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isTruthy
```

**Example**

```ts
import { isTruthy } from "effect/Predicate"

assert.deepStrictEqual(isTruthy(1), true)
assert.deepStrictEqual(isTruthy(0), false)
assert.deepStrictEqual(isTruthy(""), false)
```

**Signature**

```ts
export declare const isTruthy: (input: unknown) => boolean
```


# isTupleOf

Determine if an `Array` is a tuple with exactly `N` elements, narrowing down the type to `TupleOf`.

An `Array` is considered to be a `TupleOf` if its length is exactly `N`.

To import and use `isTupleOf` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isTupleOf
```

**Example**

```ts
import { isTupleOf } from "effect/Predicate"

assert.deepStrictEqual(isTupleOf([1, 2, 3], 3), true)
assert.deepStrictEqual(isTupleOf([1, 2, 3], 2), false)
assert.deepStrictEqual(isTupleOf([1, 2, 3], 4), false)

const arr: number[] = [1, 2, 3]
if (isTupleOf(arr, 3)) {
  console.log(arr)
  // ^? [number, number, number]
}
```

**Signature**

```ts
export declare const isTupleOf: {
  <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOf<N, T>
  <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOf<N, T>
}
```


# isTupleOfAtLeast

Determine if an `Array` is a tuple with at least `N` elements, narrowing down the type to `TupleOfAtLeast`.

An `Array` is considered to be a `TupleOfAtLeast` if its length is at least `N`.

To import and use `isTupleOfAtLeast` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isTupleOfAtLeast
```

**Example**

```ts
import { isTupleOfAtLeast } from "effect/Predicate"

assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 3), true)
assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 2), true)
assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 4), false)

const arr: number[] = [1, 2, 3, 4]
if (isTupleOfAtLeast(arr, 3)) {
  console.log(arr)
  // ^? [number, number, number, ...number[]]
}
```

**Signature**

```ts
export declare const isTupleOfAtLeast: {
  <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOfAtLeast<N, T>
  <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOfAtLeast<N, T>
}
```


# isUint8Array

A guard that succeeds when the input is a `Uint8Array`.

To import and use `isUint8Array` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isUint8Array
```

**Example**

```ts
import { isUint8Array } from "effect/Predicate"

assert.deepStrictEqual(isUint8Array(new Uint8Array()), true)

assert.deepStrictEqual(isUint8Array(null), false)
assert.deepStrictEqual(isUint8Array({}), false)
```

**Signature**

```ts
export declare const isUint8Array: (input: unknown) => input is Uint8Array
```


# isUndefined

Tests if a value is `undefined`.

To import and use `isUndefined` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isUndefined
```

**Example**

```ts
import { isUndefined } from "effect/Predicate"

assert.deepStrictEqual(isUndefined(undefined), true)

assert.deepStrictEqual(isUndefined(null), false)
assert.deepStrictEqual(isUndefined("undefined"), false)
```

**Signature**

```ts
export declare const isUndefined: (input: unknown) => input is undefined
```


# isUnknown

A guard that always succeeds.

To import and use `isUnknown` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.isUnknown
```

**Example**

```ts
import { isUnknown } from "effect/Predicate"

assert.deepStrictEqual(isUnknown(null), true)
assert.deepStrictEqual(isUnknown(undefined), true)

assert.deepStrictEqual(isUnknown({}), true)
assert.deepStrictEqual(isUnknown([]), true)
```

**Signature**

```ts
export declare const isUnknown: (input: unknown) => input is unknown
```


# mapInput

Given a `Predicate<A>` returns a `Predicate<B>`

To import and use `mapInput` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.mapInput
```

**Example**

```ts
import { Predicate, Number } from "effect"

const minLength3 = Predicate.mapInput(Number.greaterThan(2), (s: string) => s.length)

assert.deepStrictEqual(minLength3("a"), false)
assert.deepStrictEqual(minLength3("aa"), false)
assert.deepStrictEqual(minLength3("aaa"), true)
assert.deepStrictEqual(minLength3("aaaa"), true)
```

**Signature**

```ts
export declare const mapInput: {
  <B, A>(f: (b: B) => A): (self: Predicate<A>) => Predicate<B>
  <A, B>(self: Predicate<A>, f: (b: B) => A): Predicate<B>
}
```


# not

Negates the result of a given predicate.

To import and use `not` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.not
```

**Example**

```ts
import { Predicate, Number } from "effect"

const isPositive = Predicate.not(Number.lessThan(0))

assert.deepStrictEqual(isPositive(-1), false)
assert.deepStrictEqual(isPositive(0), true)
assert.deepStrictEqual(isPositive(1), true)
```

**Signature**

```ts
export declare const not: <A>(self: Predicate<A>) => Predicate<A>
```


# or

Combines two predicates into a new predicate that returns `true` if at least one of the predicates returns `true`.

To import and use `or` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.or
```

**Example**

```ts
import { Predicate, Number } from "effect"

const nonZero = Predicate.or(Number.lessThan(0), Number.greaterThan(0))

assert.deepStrictEqual(nonZero(-1), true)
assert.deepStrictEqual(nonZero(0), false)
assert.deepStrictEqual(nonZero(1), true)
```

**Signature**

```ts
export declare const or: {
  <A, C extends A>(that: Refinement<A, C>): <B extends A>(self: Refinement<A, B>) => Refinement<A, B | C>
  <A, B extends A, C extends A>(self: Refinement<A, B>, that: Refinement<A, C>): Refinement<A, B | C>
  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>
  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>
}
```


# struct

```
{ ab: Refinement<A, B>; cd: Refinement<C, D>, ... } -> Refinement<{ ab: A; cd: C; ... }, { ab: B; cd: D; ... }>
{ a: Predicate<A, B>; b: Predicate<B>, ... } -> Predicate<{ a: A; b: B; ... }>
{ ab: Refinement<A, B>; c: Predicate<C>, ... } -> Refinement<{ ab: A; c: C; ... }, { ab: B; c: ; ... }>
```

To import and use `struct` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.struct
```

**Signature**

```ts
export declare const struct: <R extends Record<string, Predicate.Any>>(
  fields: R
) => [Extract<R[keyof R], Refinement.Any>] extends [never]
  ? Predicate<{ readonly [K in keyof R]: Predicate.In<R[K]> }>
  : Refinement<
      { readonly [K in keyof R]: R[K] extends Refinement.Any ? Refinement.In<R[K]> : Predicate.In<R[K]> },
      { readonly [K in keyof R]: R[K] extends Refinement.Any ? Refinement.Out<R[K]> : Predicate.In<R[K]> }
    >
```


# tuple

Similar to `Promise.all` but operates on `Predicate`s.

```
[Refinement<A, B>, Refinement<C, D>, ...] -> Refinement<[A, C, ...], [B, D, ...]>
[Predicate<A>, Predicate<B>, ...] -> Predicate<[A, B, ...]>
[Refinement<A, B>, Predicate<C>, ...] -> Refinement<[A, C, ...], [B, C, ...]>
```

To import and use `tuple` from the "Predicate" module:

```ts
import * as Predicate from "effect/Predicate"
// Can be accessed like this
Predicate.tuple
```

**Signature**

```ts
export declare const tuple: <T extends ReadonlyArray<Predicate.Any>>(
  ...elements: T
) => [Extract<T[number], Refinement.Any>] extends [never]
  ? Predicate<{ readonly [I in keyof T]: Predicate.In<T[I]> }>
  : Refinement<
      { readonly [I in keyof T]: T[I] extends Refinement.Any ? Refinement.In<T[I]> : Predicate.In<T[I]> },
      { readonly [I in keyof T]: T[I] extends Refinement.Any ? Refinement.Out<T[I]> : Predicate.In<T[I]> }
    >
```


# boolean

Represents a boolean value.

True values can be passed as one of: `["true", "1", "y", "yes" or "on"]`.
False value can be passed as one of: `["false", "o", "n", "no" or "off"]`.

To import and use `boolean` from the "Primitive" module:

```ts
import * as Primitive from "@effect/cli/Primitive"
// Can be accessed like this
Primitive.boolean
```

**Signature**

```ts
export declare const boolean: (defaultValue: Option<boolean>) => Primitive<boolean>
```


# date

Represents a date in ISO-8601 format, such as `2007-12-03T10:15:30`.

To import and use `date` from the "Primitive" module:

```ts
import * as Primitive from "@effect/cli/Primitive"
// Can be accessed like this
Primitive.date
```

**Signature**

```ts
export declare const date: Primitive<Date>
```


# float

Represents a floating point number.

To import and use `float` from the "Primitive" module:

```ts
import * as Primitive from "@effect/cli/Primitive"
// Can be accessed like this
Primitive.float
```

**Signature**

```ts
export declare const float: Primitive<number>
```


# getChoices

Returns a text representation of the valid choices for a primitive type, if
any.

To import and use `getChoices` from the "Primitive" module:

```ts
import * as Primitive from "@effect/cli/Primitive"
// Can be accessed like this
Primitive.getChoices
```

**Signature**

```ts
export declare const getChoices: <A>(self: Primitive<A>) => Option<string>
```


# getHelp

Returns help documentation for a primitive type.

To import and use `getHelp` from the "Primitive" module:

```ts
import * as Primitive from "@effect/cli/Primitive"
// Can be accessed like this
Primitive.getHelp
```

**Signature**

```ts
export declare const getHelp: <A>(self: Primitive<A>) => Span
```


# getTypeName

Returns a string representation of the primitive type.

To import and use `getTypeName` from the "Primitive" module:

```ts
import * as Primitive from "@effect/cli/Primitive"
// Can be accessed like this
Primitive.getTypeName
```

**Signature**

```ts
export declare const getTypeName: <A>(self: Primitive<A>) => string
```


# integer

Represents an integer.

To import and use `integer` from the "Primitive" module:

```ts
import * as Primitive from "@effect/cli/Primitive"
// Can be accessed like this
Primitive.integer
```

**Signature**

```ts
export declare const integer: Primitive<number>
```


# Primitive

A `Primitive` represents the primitive types supported by Effect CLI.

Each primitive type has a way to parse and validate from a string.

To import and use `Primitive` from the "Primitive" module:

```ts
import * as Primitive from "@effect/cli/Primitive"
// Can be accessed like this
Primitive.Primitive
```


# text

Represents a user-defined piece of text.

To import and use `text` from the "Primitive" module:

```ts
import * as Primitive from "@effect/cli/Primitive"
// Can be accessed like this
Primitive.text
```

**Signature**

```ts
export declare const text: Primitive<string>
```


# validate

Validates that the specified value, if any, matches the specified primitive
type.

To import and use `validate` from the "Primitive" module:

```ts
import * as Primitive from "@effect/cli/Primitive"
// Can be accessed like this
Primitive.validate
```

**Signature**

```ts
export declare const validate: {
  (value: Option<string>, config: CliConfig): <A>(self: Primitive<A>) => Effect<A, string, FileSystem>
  <A>(self: Primitive<A>, value: Option<string>, config: CliConfig): Effect<A, string, FileSystem>
}
```


# wizard

Runs a wizard that will prompt the user for input matching the specified
primitive type.

To import and use `wizard` from the "Primitive" module:

```ts
import * as Primitive from "@effect/cli/Primitive"
// Can be accessed like this
Primitive.wizard
```

**Signature**

```ts
export declare const wizard: {
  (help: HelpDoc): <A>(self: Primitive<A>) => Prompt<A>
  <A>(self: Primitive<A>, help: HelpDoc): Prompt<A>
}
```


# all

Runs all the provided prompts in sequence respecting the structure provided
in input.

Supports either a tuple / iterable of prompts or a record / struct of prompts
as an argument.

To import and use `all` from the "Prompt" module:

```ts
import * as Prompt from "@effect/cli/Prompt"
// Can be accessed like this
Prompt.all
```

**Example**

```ts
import * as Prompt from "@effect/cli/Prompt"
import * as NodeContext from "@effect/platform-node/NodeContext"
import * as Runtime from "@effect/platform-node/NodeRuntime"
import * as Effect from "effect/Effect"

const username = Prompt.text({
  message: "Enter your username: "
})

const password = Prompt.password({
  message: "Enter your password: ",
  validate: (value) => (value.length === 0 ? Effect.fail("Password cannot be empty") : Effect.succeed(value))
})

const allWithTuple = Prompt.all([username, password])

const allWithRecord = Prompt.all({ username, password })
```

**Signature**

```ts
export declare const all: <const Arg extends Iterable<Prompt<any>> | Record<string, Prompt<any>>>(
  arg: Arg
) => All.Return<Arg>
```


# custom

Creates a custom `Prompt` from the specified initial state and handlers.

The initial state can either be a pure value or an `Effect`. This is
particularly useful when the initial state of the `Prompt` must be computed
by performing some effectful computation, such as reading data from the file
system.

A `Prompt` is essentially a render loop where user input triggers a new frame
to be rendered to the `Terminal`. The `handlers` of a custom prompt are used
to control what is rendered to the `Terminal` each frame. During each frame,
the following occurs:

1. The `render` handler is called with this frame's prompt state and prompt
   action and returns an ANSI escape string to be rendered to the
   `Terminal`
2. The `Terminal` obtains input from the user
3. The `process` handler is called with the input obtained from the user
   and this frame's prompt state and returns the next prompt action that
   should be performed
4. The `clear` handler is called with this frame's prompt state and prompt
   action and returns an ANSI escape string used to clear the screen of
   the `Terminal`

To import and use `custom` from the "Prompt" module:

```ts
import * as Prompt from "@effect/cli/Prompt"
// Can be accessed like this
Prompt.custom
```

**Signature**

```ts
export declare const custom: <State, Output>(
  initialState: State | Effect<State, never, Prompt.Environment>,
  handlers: Prompt.Handlers<State, Output>
) => Prompt<Output>
```


# run

Executes the specified `Prompt`.

To import and use `run` from the "Prompt" module:

```ts
import * as Prompt from "@effect/cli/Prompt"
// Can be accessed like this
Prompt.run
```

**Signature**

```ts
export declare const run: <Output>(self: Prompt<Output>) => Effect<Output, QuitException, Prompt.Environment>
```


# succeed

Creates a `Prompt` which immediately succeeds with the specified value.

**NOTE**: This method will not attempt to obtain user input or render
anything to the screen.

To import and use `succeed` from the "Prompt" module:

```ts
import * as Prompt from "@effect/cli/Prompt"
// Can be accessed like this
Prompt.succeed
```

**Signature**

```ts
export declare const succeed: <A>(value: A) => Prompt<A>
```


# awaitShutdown

Waits until the queue is shutdown. The `Effect` returned by this method will
not resume until the queue has been shutdown. If the queue is already
shutdown, the `Effect` will resume right away.

To import and use `awaitShutdown` from the "PubSub" module:

```ts
import * as PubSub from "effect/PubSub"
// Can be accessed like this
PubSub.awaitShutdown
```

**Signature**

```ts
export declare const awaitShutdown: <A>(self: PubSub<A>) => Effect.Effect<void>
```


# bounded

Creates a bounded `PubSub` with the back pressure strategy. The `PubSub` will retain
messages until they have been taken by all subscribers, applying back
pressure to publishers if the `PubSub` is at capacity.

For best performance use capacities that are powers of two.

To import and use `bounded` from the "PubSub" module:

```ts
import * as PubSub from "effect/PubSub"
// Can be accessed like this
PubSub.bounded
```

**Signature**

```ts
export declare const bounded: <A>(
  capacity: number | { readonly capacity: number; readonly replay?: number | undefined }
) => Effect.Effect<PubSub<A>>
```


# capacity

Returns the number of elements the queue can hold.

To import and use `capacity` from the "PubSub" module:

```ts
import * as PubSub from "effect/PubSub"
// Can be accessed like this
PubSub.capacity
```

**Signature**

```ts
export declare const capacity: <A>(self: PubSub<A>) => number
```


# dropping

Creates a bounded `PubSub` with the dropping strategy. The `PubSub` will drop new
messages if the `PubSub` is at capacity.

For best performance use capacities that are powers of two.

To import and use `dropping` from the "PubSub" module:

```ts
import * as PubSub from "effect/PubSub"
// Can be accessed like this
PubSub.dropping
```

**Signature**

```ts
export declare const dropping: <A>(
  capacity: number | { readonly capacity: number; readonly replay?: number | undefined }
) => Effect.Effect<PubSub<A>>
```


# isEmpty

Returns `true` if the `Queue` contains zero elements, `false` otherwise.

To import and use `isEmpty` from the "PubSub" module:

```ts
import * as PubSub from "effect/PubSub"
// Can be accessed like this
PubSub.isEmpty
```

**Signature**

```ts
export declare const isEmpty: <A>(self: PubSub<A>) => Effect.Effect<boolean>
```


# isFull

Returns `true` if the `Queue` contains at least one element, `false`
otherwise.

To import and use `isFull` from the "PubSub" module:

```ts
import * as PubSub from "effect/PubSub"
// Can be accessed like this
PubSub.isFull
```

**Signature**

```ts
export declare const isFull: <A>(self: PubSub<A>) => Effect.Effect<boolean>
```


# isShutdown

Returns `true` if `shutdown` has been called, otherwise returns `false`.

To import and use `isShutdown` from the "PubSub" module:

```ts
import * as PubSub from "effect/PubSub"
// Can be accessed like this
PubSub.isShutdown
```

**Signature**

```ts
export declare const isShutdown: <A>(self: PubSub<A>) => Effect.Effect<boolean>
```


# publish

Publishes a message to the `PubSub`, returning whether the message was published
to the `PubSub`.

To import and use `publish` from the "PubSub" module:

```ts
import * as PubSub from "effect/PubSub"
// Can be accessed like this
PubSub.publish
```

**Signature**

```ts
export declare const publish: {
  <A>(value: A): (self: PubSub<A>) => Effect.Effect<boolean>
  <A>(self: PubSub<A>, value: A): Effect.Effect<boolean>
}
```


# publishAll

Publishes all of the specified messages to the `PubSub`, returning whether they
were published to the `PubSub`.

To import and use `publishAll` from the "PubSub" module:

```ts
import * as PubSub from "effect/PubSub"
// Can be accessed like this
PubSub.publishAll
```

**Signature**

```ts
export declare const publishAll: {
  <A>(elements: Iterable<A>): (self: PubSub<A>) => Effect.Effect<boolean>
  <A>(self: PubSub<A>, elements: Iterable<A>): Effect.Effect<boolean>
}
```


# PubSub

A `PubSub<A>` is an asynchronous message hub into which publishers can publish
messages of type `A` and subscribers can subscribe to take messages of type
`A`.

To import and use `PubSub` from the "PubSub" module:

```ts
import * as PubSub from "effect/PubSub"
// Can be accessed like this
PubSub.PubSub
```


# shutdown

Interrupts any fibers that are suspended on `offer` or `take`. Future calls
to `offer*` and `take*` will be interrupted immediately.

To import and use `shutdown` from the "PubSub" module:

```ts
import * as PubSub from "effect/PubSub"
// Can be accessed like this
PubSub.shutdown
```

**Signature**

```ts
export declare const shutdown: <A>(self: PubSub<A>) => Effect.Effect<void>
```


# size

Retrieves the size of the queue, which is equal to the number of elements
in the queue. This may be negative if fibers are suspended waiting for
elements to be added to the queue.

To import and use `size` from the "PubSub" module:

```ts
import * as PubSub from "effect/PubSub"
// Can be accessed like this
PubSub.size
```

**Signature**

```ts
export declare const size: <A>(self: PubSub<A>) => Effect.Effect<number>
```


# sliding

Creates a bounded `PubSub` with the sliding strategy. The `PubSub` will add new
messages and drop old messages if the `PubSub` is at capacity.

For best performance use capacities that are powers of two.

To import and use `sliding` from the "PubSub" module:

```ts
import * as PubSub from "effect/PubSub"
// Can be accessed like this
PubSub.sliding
```

**Signature**

```ts
export declare const sliding: <A>(
  capacity: number | { readonly capacity: number; readonly replay?: number | undefined }
) => Effect.Effect<PubSub<A>>
```


# subscribe

Subscribes to receive messages from the `PubSub`. The resulting subscription can
be evaluated multiple times within the scope to take a message from the `PubSub`
each time.

To import and use `subscribe` from the "PubSub" module:

```ts
import * as PubSub from "effect/PubSub"
// Can be accessed like this
PubSub.subscribe
```

**Signature**

```ts
export declare const subscribe: <A>(self: PubSub<A>) => Effect.Effect<Queue.Dequeue<A>, never, Scope.Scope>
```


# unbounded

Creates an unbounded `PubSub`.

To import and use `unbounded` from the "PubSub" module:

```ts
import * as PubSub from "effect/PubSub"
// Can be accessed like this
PubSub.unbounded
```

**Signature**

```ts
export declare const unbounded: <A>(options?: { readonly replay?: number | undefined }) => Effect.Effect<PubSub<A>>
```


# awaitShutdown

Waits until the queue is shutdown. The `Effect` returned by this method will
not resume until the queue has been shutdown. If the queue is already
shutdown, the `Effect` will resume right away.

To import and use `awaitShutdown` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.awaitShutdown
```

**Signature**

```ts
export declare const awaitShutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<void>
```


# BaseQueue

The base interface that all `Queue`s must implement.

To import and use `BaseQueue` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.BaseQueue
```


# bounded

Makes a new bounded `Queue`. When the capacity of the queue is reached, any
additional calls to `offer` will be suspended until there is more room in
the queue.

**Note**: When possible use only power of 2 capacities; this will provide
better performance by utilising an optimised version of the underlying
`RingBuffer`.

To import and use `bounded` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.bounded
```

**Signature**

```ts
export declare const bounded: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>
```


# capacity

Returns the number of elements the queue can hold.

To import and use `capacity` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.capacity
```

**Signature**

```ts
export declare const capacity: <A>(self: Dequeue<A> | Enqueue<A>) => number
```


# dropping

Makes a new bounded `Queue` with the dropping strategy.

When the capacity of the queue is reached, new elements will be dropped and the
old elements will remain.

**Note**: When possible use only power of 2 capacities; this will provide
better performance by utilising an optimised version of the underlying
`RingBuffer`.

To import and use `dropping` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.dropping
```

**Signature**

```ts
export declare const dropping: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>
```


# isDequeue

Returns `true` if the specified value is a `Dequeue`, `false` otherwise.

To import and use `isDequeue` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.isDequeue
```

**Signature**

```ts
export declare const isDequeue: (u: unknown) => u is Dequeue<unknown>
```


# isEmpty

Returns `true` if the `Queue` contains zero elements, `false` otherwise.

To import and use `isEmpty` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.isEmpty
```

**Signature**

```ts
export declare const isEmpty: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>
```


# isEnqueue

Returns `true` if the specified value is a `Enqueue`, `false` otherwise.

To import and use `isEnqueue` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.isEnqueue
```

**Signature**

```ts
export declare const isEnqueue: (u: unknown) => u is Enqueue<unknown>
```


# isFull

Returns `true` if the `Queue` contains at least one element, `false`
otherwise.

To import and use `isFull` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.isFull
```

**Signature**

```ts
export declare const isFull: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>
```


# isQueue

Returns `true` if the specified value is a `Queue`, `false` otherwise.

To import and use `isQueue` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.isQueue
```

**Signature**

```ts
export declare const isQueue: (u: unknown) => u is Queue<unknown>
```


# isShutdown

Returns `true` if `shutdown` has been called, otherwise returns `false`.

To import and use `isShutdown` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.isShutdown
```

**Signature**

```ts
export declare const isShutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>
```


# offer

Places one value in the queue.

To import and use `offer` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.offer
```

**Signature**

```ts
export declare const offer: {
  <A>(value: A): (self: Enqueue<A>) => Effect.Effect<boolean>
  <A>(self: Enqueue<A>, value: A): Effect.Effect<boolean>
}
```


# offerAll

For Bounded Queue: uses the `BackPressure` Strategy, places the values in
the queue and always returns true. If the queue has reached capacity, then
the fiber performing the `offerAll` will be suspended until there is room
in the queue.

For Unbounded Queue: Places all values in the queue and returns true.

For Sliding Queue: uses `Sliding` Strategy If there is room in the queue,
it places the values otherwise it removes the old elements and enqueues the
new ones. Always returns true.

For Dropping Queue: uses `Dropping` Strategy, It places the values in the
queue but if there is no room it will not enqueue them and return false.

To import and use `offerAll` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.offerAll
```

**Signature**

```ts
export declare const offerAll: {
  <A>(iterable: Iterable<A>): (self: Enqueue<A>) => Effect.Effect<boolean>
  <A>(self: Enqueue<A>, iterable: Iterable<A>): Effect.Effect<boolean>
}
```


# poll

Returns the first value in the `Queue` as a `Some<A>`, or `None` if the queue
is empty.

To import and use `poll` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.poll
```

**Signature**

```ts
export declare const poll: <A>(self: Dequeue<A>) => Effect.Effect<Option.Option<A>>
```


# shutdown

Interrupts any fibers that are suspended on `offer` or `take`. Future calls
to `offer*` and `take*` will be interrupted immediately.

To import and use `shutdown` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.shutdown
```

**Signature**

```ts
export declare const shutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<void>
```


# size

Retrieves the size of the queue, which is equal to the number of elements
in the queue. This may be negative if fibers are suspended waiting for
elements to be added to the queue.

To import and use `size` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.size
```

**Signature**

```ts
export declare const size: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<number>
```


# sliding

Makes a new bounded `Queue` with the sliding strategy.

When the capacity of the queue is reached, new elements will be added and the
old elements will be dropped.

**Note**: When possible use only power of 2 capacities; this will provide
better performance by utilising an optimised version of the underlying
`RingBuffer`.

To import and use `sliding` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.sliding
```

**Signature**

```ts
export declare const sliding: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>
```


# take

Takes the oldest value in the queue. If the queue is empty, this will return
a computation that resumes when an item has been added to the queue.

To import and use `take` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.take
```

**Signature**

```ts
export declare const take: <A>(self: Dequeue<A>) => Effect.Effect<A>
```


# takeAll

Takes all the values in the queue and returns the values. If the queue is
empty returns an empty collection.

To import and use `takeAll` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.takeAll
```

**Signature**

```ts
export declare const takeAll: <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>
```


# takeBetween

Takes a number of elements from the queue between the specified minimum and
maximum. If there are fewer than the minimum number of elements available,
suspends until at least the minimum number of elements have been collected.

To import and use `takeBetween` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.takeBetween
```

**Signature**

```ts
export declare const takeBetween: {
  (min: number, max: number): <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>
  <A>(self: Dequeue<A>, min: number, max: number): Effect.Effect<Chunk.Chunk<A>>
}
```


# takeN

Takes the specified number of elements from the queue. If there are fewer
than the specified number of elements available, it suspends until they
become available.

To import and use `takeN` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.takeN
```

**Signature**

```ts
export declare const takeN: {
  (n: number): <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>
  <A>(self: Dequeue<A>, n: number): Effect.Effect<Chunk.Chunk<A>>
}
```


# takeUpTo

Takes up to max number of values from the queue.

To import and use `takeUpTo` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.takeUpTo
```

**Signature**

```ts
export declare const takeUpTo: {
  (max: number): <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>
  <A>(self: Dequeue<A>, max: number): Effect.Effect<Chunk.Chunk<A>>
}
```


# unbounded

Creates a new unbounded `Queue`.

To import and use `unbounded` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.unbounded
```

**Signature**

```ts
export declare const unbounded: <A>() => Effect.Effect<Queue<A>>
```


# unsafeOffer

Places one value in the queue.

To import and use `unsafeOffer` from the "Queue" module:

```ts
import * as Queue from "effect/Queue"
// Can be accessed like this
Queue.unsafeOffer
```

**Signature**

```ts
export declare const unsafeOffer: {
  <A>(value: A): (self: Enqueue<A>) => boolean
  <A>(self: Enqueue<A>, value: A): boolean
}
```


# choice

Get a random element from an iterable.

To import and use `choice` from the "Random" module:

```ts
import * as Random from "effect/Random"
// Can be accessed like this
Random.choice
```

**Example**

```ts
import { Effect, Random } from "effect"

Effect.gen(function* () {
  const randomItem = yield* Random.choice([1, 2, 3])
  console.log(randomItem)
})
```

**Signature**

```ts
export declare const choice: <Self extends Iterable<unknown>>(
  elements: Self
) => Self extends NonEmptyIterable.NonEmptyIterable<infer A>
  ? Effect.Effect<A>
  : Self extends Array.NonEmptyReadonlyArray<infer A>
    ? Effect.Effect<A>
    : Self extends Iterable<infer A>
      ? Effect.Effect<A, Cause.NoSuchElementException>
      : never
```


# make

Constructs the `Random` service, seeding the pseudo-random number generator
with an hash of the specified seed.
This constructor is useful for generating predictable sequences of random values for specific use cases.

Example uses:

- Generating random UI data for visual tests.
- Creating data that needs to change daily but remain the same throughout a single day, such as using a date as the seed.

To import and use `make` from the "Random" module:

```ts
import * as Random from "effect/Random"
// Can be accessed like this
Random.make
```

**Example**

```ts
import { Effect, Random } from "effect"

const random1 = Random.make("myseed")
const random2 = Random.make("myseed")

assert.equal(Effect.runSync(random1.next), Effect.runSync(random2.next))
```

**Signature**

```ts
export declare const make: <A>(seed: A) => Random
```


# next

Returns the next numeric value from the pseudo-random number generator.

To import and use `next` from the "Random" module:

```ts
import * as Random from "effect/Random"
// Can be accessed like this
Random.next
```

**Signature**

```ts
export declare const next: Effect.Effect<number, never, never>
```


# nextBoolean

Returns the next boolean value from the pseudo-random number generator.

To import and use `nextBoolean` from the "Random" module:

```ts
import * as Random from "effect/Random"
// Can be accessed like this
Random.nextBoolean
```

**Signature**

```ts
export declare const nextBoolean: Effect.Effect<boolean, never, never>
```


# nextInt

Returns the next integer value from the pseudo-random number generator.

To import and use `nextInt` from the "Random" module:

```ts
import * as Random from "effect/Random"
// Can be accessed like this
Random.nextInt
```

**Signature**

```ts
export declare const nextInt: Effect.Effect<number, never, never>
```


# nextIntBetween

Returns the next integer value in the specified range from the
pseudo-random number generator.

To import and use `nextIntBetween` from the "Random" module:

```ts
import * as Random from "effect/Random"
// Can be accessed like this
Random.nextIntBetween
```

**Signature**

```ts
export declare const nextIntBetween: (min: number, max: number) => Effect.Effect<number>
```


# nextRange

Returns the next numeric value in the specified range from the
pseudo-random number generator.

To import and use `nextRange` from the "Random" module:

```ts
import * as Random from "effect/Random"
// Can be accessed like this
Random.nextRange
```

**Signature**

```ts
export declare const nextRange: (min: number, max: number) => Effect.Effect<number>
```


# randomWith

Retreives the `Random` service from the context and uses it to run the
specified workflow.

To import and use `randomWith` from the "Random" module:

```ts
import * as Random from "effect/Random"
// Can be accessed like this
Random.randomWith
```

**Signature**

```ts
export declare const randomWith: <A, E, R>(f: (random: Random) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
```


# shuffle

Uses the pseudo-random number generator to shuffle the specified iterable.

To import and use `shuffle` from the "Random" module:

```ts
import * as Random from "effect/Random"
// Can be accessed like this
Random.shuffle
```

**Signature**

```ts
export declare const shuffle: <A>(elements: Iterable<A>) => Effect.Effect<Chunk.Chunk<A>>
```


# make

Constructs a new `RateLimiter` which will utilize the specified algorithm
to limit requests (defaults to `token-bucket`).

Notes

- Only the moment of starting the effect is rate limited. The number of concurrent executions is not bounded.
- Instances of `RateLimiter` can be composed.
- The "cost" per effect can be changed. See {@link withCost}

To import and use `make` from the "RateLimiter" module:

```ts
import * as RateLimiter from "effect/RateLimiter"
// Can be accessed like this
RateLimiter.make
```

**Example**

```ts
import { Effect, RateLimiter } from "effect"
import { compose } from "effect/Function"

const program = Effect.scoped(
  Effect.gen(function* ($) {
    const perMinuteRL = yield* $(RateLimiter.make({ limit: 30, interval: "1 minutes" }))
    const perSecondRL = yield* $(RateLimiter.make({ limit: 2, interval: "1 seconds" }))

    // This rate limiter respects both the 30 calls per minute
    // and the 2 calls per second constraints.
    const rateLimit = compose(perMinuteRL, perSecondRL)

    // simulate repeated calls
    for (let n = 0; n < 100; n++) {
      // wrap the effect we want to limit with rateLimit
      yield* $(rateLimit(Effect.log("Calling RateLimited Effect")))
    }
  })
)
```

**Signature**

```ts
export declare const make: (options: RateLimiter.Options) => Effect<RateLimiter, never, Scope>
```


# RateLimiter

Limits the number of calls to a resource to a maximum amount in some interval.

Note that only the moment of starting the effect is rate limited: the number
of concurrent executions is not bounded.

To import and use `RateLimiter` from the "RateLimiter" module:

```ts
import * as RateLimiter from "effect/RateLimiter"
// Can be accessed like this
RateLimiter.RateLimiter
```


# withCost

Alters the per-effect cost of the rate-limiter.

This can be used for "credit" based rate-limiting where different API endpoints
cost a different number of credits within a time window.
Eg: 1000 credits / hour, where a query costs 1 credit and a mutation costs 5 credits.

To import and use `withCost` from the "RateLimiter" module:

```ts
import * as RateLimiter from "effect/RateLimiter"
// Can be accessed like this
RateLimiter.withCost
```

**Example**

```ts
import { Effect, RateLimiter } from "effect"
import { compose } from "effect/Function"

const program = Effect.scoped(
  Effect.gen(function* ($) {
    // Create a rate limiter that has an hourly limit of 1000 credits
    const rateLimiter = yield* $(RateLimiter.make({ limit: 1000, interval: "1 hours" }))
    // Query API costs 1 credit per call ( 1 is the default cost )
    const queryAPIRL = compose(rateLimiter, RateLimiter.withCost(1))
    // Mutation API costs 5 credits per call
    const mutationAPIRL = compose(rateLimiter, RateLimiter.withCost(5))

    // Use the pre-defined rate limiters
    yield* $(queryAPIRL(Effect.log("Sample Query")))
    yield* $(mutationAPIRL(Effect.log("Sample Mutation")))

    // Or set a cost on-the-fly
    yield* $(rateLimiter(Effect.log("Another query with a different cost")).pipe(RateLimiter.withCost(3)))
  })
)
```

**Signature**

```ts
export declare const withCost: (cost: number) => <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>
```


# make

An `RcMap` can contain multiple reference counted resources that can be indexed
by a key. The resources are lazily acquired on the first call to `get` and
released when the last reference is released.

Complex keys can extend `Equal` and `Hash` to allow lookups by value.

To import and use `make` from the "RcMap" module:

```ts
import * as RcMap from "effect/RcMap"
// Can be accessed like this
RcMap.make
```

**Example**

```ts
import { Effect, RcMap } from "effect"

Effect.gen(function* () {
  const map = yield* RcMap.make({
    lookup: (key: string) =>
      Effect.acquireRelease(Effect.succeed(`acquired ${key}`), () => Effect.log(`releasing ${key}`))
  })

  // Get "foo" from the map twice, which will only acquire it once.
  // It will then be released once the scope closes.
  yield* RcMap.get(map, "foo").pipe(Effect.andThen(RcMap.get(map, "foo")), Effect.scoped)
})
```

**Signature**

```ts
export declare const make: {
  <K, A, E, R>(options: {
    readonly lookup: (key: K) => Effect.Effect<A, E, R>
    readonly idleTimeToLive?: Duration.DurationInput | undefined
    readonly capacity?: undefined
  }): Effect.Effect<RcMap<K, A, E>, never, Scope.Scope | R>
  <K, A, E, R>(options: {
    readonly lookup: (key: K) => Effect.Effect<A, E, R>
    readonly idleTimeToLive?: Duration.DurationInput | undefined
    readonly capacity: number
  }): Effect.Effect<RcMap<K, A, E | Cause.ExceededCapacityException>, never, Scope.Scope | R>
}
```


# make

Create an `RcRef` from an acquire `Effect`.

An RcRef wraps a reference counted resource that can be acquired and released
multiple times.

The resource is lazily acquired on the first call to `get` and released when
the last reference is released.

To import and use `make` from the "RcRef" module:

```ts
import * as RcRef from "effect/RcRef"
// Can be accessed like this
RcRef.make
```

**Example**

```ts
import { Effect, RcRef } from "effect"

Effect.gen(function* () {
  const ref = yield* RcRef.make({
    acquire: Effect.acquireRelease(Effect.succeed("foo"), () => Effect.log("release foo"))
  })

  // will only acquire the resource once, and release it
  // when the scope is closed
  yield* RcRef.get(ref).pipe(Effect.andThen(RcRef.get(ref)), Effect.scoped)
})
```

**Signature**

```ts
export declare const make: <A, E, R>(options: {
  readonly acquire: Effect.Effect<A, E, R>
  readonly idleTimeToLive?: Duration.DurationInput | undefined
}) => Effect.Effect<RcRef<A, E>, never, R | Scope.Scope>
```


# isRecipientAddress

Ensure that given value is a RecipientAddress

To import and use `isRecipientAddress` from the "RecipientAddress" module:

```ts
import * as RecipientAddress from "@effect/cluster/RecipientAddress"
// Can be accessed like this
RecipientAddress.isRecipientAddress
```

**Signature**

```ts
export declare function isRecipientAddress(value: unknown): value is RecipientAddress
```


# makeRecipientAddress

Given a name and a schema for the protocol, constructs an EntityType.

To import and use `makeRecipientAddress` from the "RecipientAddress" module:

```ts
import * as RecipientAddress from "@effect/cluster/RecipientAddress"
// Can be accessed like this
RecipientAddress.makeRecipientAddress
```

**Signature**

```ts
export declare function makeRecipientAddress(recipientTypeName: string, entityId: string): RecipientAddress
```


# RecipientAddress

A RecipientAddress uniquely identifies a RecipientType + EntityId instance.

To import and use `RecipientAddress` from the "RecipientAddress" module:

```ts
import * as RecipientAddress from "@effect/cluster/RecipientAddress"
// Can be accessed like this
RecipientAddress.RecipientAddress
```


# EntityBehaviourOptions

This are the options for an EntityBehaviour. This controls the entityMaxIdleTime,
check out more on that over the ShardingConfig.
This allows to override the setting for a specific entity.

To import and use `EntityBehaviourOptions` from the "RecipientBehaviour" module:

```ts
import * as RecipientBehaviour from "@effect/cluster/RecipientBehaviour"
// Can be accessed like this
RecipientBehaviour.EntityBehaviourOptions
```


# fromFunctionEffect

This is the simplest behaviour you can have.
You provide a function that given the entityId and the message, it will immediatly process it.
You are then required to return a MessageState to tell the caller
if the message has just arrived and will be later processed or it has been processed.

To import and use `fromFunctionEffect` from the "RecipientBehaviour" module:

```ts
import * as RecipientBehaviour from "@effect/cluster/RecipientBehaviour"
// Can be accessed like this
RecipientBehaviour.fromFunctionEffect
```

**Signature**

```ts
export declare const fromFunctionEffect: <Msg extends Message.Message.Any, R>(
  handler: (
    entityId: string,
    message: Msg
  ) => Effect.Effect<MessageState.MessageState<Message.Message.Exit<Msg>>, never, R>
) => RecipientBehaviour<Msg, R>
```


# fromFunctionEffectStateful

This is a stateful version of fromFunctionEffect.
You can provide a function to get the initialState, and then it will be passed as Ref.
Everything here is just stored in memory, so eventual persistence of the state is up to you!

To import and use `fromFunctionEffectStateful` from the "RecipientBehaviour" module:

```ts
import * as RecipientBehaviour from "@effect/cluster/RecipientBehaviour"
// Can be accessed like this
RecipientBehaviour.fromFunctionEffectStateful
```

**Signature**

```ts
export declare const fromFunctionEffectStateful: <S, R, Msg extends Message.Message.Any, R2>(
  initialState: (entityId: string) => Effect.Effect<S, never, R>,
  handler: (
    entityId: string,
    message: Msg,
    stateRef: Ref.Ref<S>
  ) => Effect.Effect<MessageState.MessageState<Message.Message.Exit<Msg>>, never, R2>
) => RecipientBehaviour<Msg, R | R2>
```


# fromInMemoryQueue

This behaviour uses a Queue where the entity will accumulate messages to be processed,
and then you can use the Dequeue to take messages and process them.
A PoisonPill is provided to request interruption of the entity behaviour.

To import and use `fromInMemoryQueue` from the "RecipientBehaviour" module:

```ts
import * as RecipientBehaviour from "@effect/cluster/RecipientBehaviour"
// Can be accessed like this
RecipientBehaviour.fromInMemoryQueue
```

**Signature**

```ts
export declare const fromInMemoryQueue: <Msg extends Message.Message.Any, R>(
  handler: (
    entityId: string,
    dequeue: Queue.Dequeue<Msg | PoisonPill.PoisonPill>,
    processed: <A extends Msg>(
      message: A,
      value: Option.Option<Message.Message.Exit<A>>
    ) => Effect.Effect<void, never, never>
  ) => Effect.Effect<void, never, R>
) => RecipientBehaviour<Msg, R>
```


# RecipientBehaviour

A RecipientBehaviour describes how a specific RecipientType should behave.
This is the actual implementation of what an entity should do upon receiving a Msg,
this could require additional context.

The scope provided in the context is controlled by the cluster EntityManager,
and is used to request the shoutdown of the entity,
so you can safely scope whatever resource you want to use for your behaviour
and the EntityManager will close the scope for you when the entity is shoutdown.

The function returned by the RecipientBehaviour effect is what we call "offer" effect.
The offer effect is used by the EntityManager to give messages to the RecipientBehaviour.

To import and use `RecipientBehaviour` from the "RecipientBehaviour" module:

```ts
import * as RecipientBehaviour from "@effect/cluster/RecipientBehaviour"
// Can be accessed like this
RecipientBehaviour.RecipientBehaviour
```


# entityId

Gets the current entityId

To import and use `entityId` from the "RecipientBehaviourContext" module:

```ts
import * as RecipientBehaviourContext from "@effect/cluster/RecipientBehaviourContext"
// Can be accessed like this
RecipientBehaviourContext.entityId
```

**Signature**

```ts
export declare const entityId: Effect.Effect<string, never, RecipientBehaviourContext>
```


# forkShutdown

Forks the shutdown of the current recipient behaviour as soon as possible.

To import and use `forkShutdown` from the "RecipientBehaviourContext" module:

```ts
import * as RecipientBehaviourContext from "@effect/cluster/RecipientBehaviourContext"
// Can be accessed like this
RecipientBehaviourContext.forkShutdown
```

**Signature**

```ts
export declare const forkShutdown: Effect.Effect<void, never, RecipientBehaviourContext>
```


# make

Creates a new RecipientBehaviourContext

To import and use `make` from the "RecipientBehaviourContext" module:

```ts
import * as RecipientBehaviourContext from "@effect/cluster/RecipientBehaviourContext"
// Can be accessed like this
RecipientBehaviourContext.make
```

**Signature**

```ts
export declare const make: (
  args: Omit<RecipientBehaviourContext, typeof RecipientBehaviourContextTypeId>
) => RecipientBehaviourContext
```


# recipientAddress

Gets the current entityId

To import and use `recipientAddress` from the "RecipientBehaviourContext" module:

```ts
import * as RecipientBehaviourContext from "@effect/cluster/RecipientBehaviourContext"
// Can be accessed like this
RecipientBehaviourContext.recipientAddress
```

**Signature**

```ts
export declare const recipientAddress: Effect.Effect<
  RecipientAddress.RecipientAddress,
  never,
  RecipientBehaviourContext
>
```


# RecipientBehaviourContext

This is the context information that is available to the RecipientBehaviour and has general informations
about this specific entity, like the entityId or the recipientType.

To import and use `RecipientBehaviourContext` from the "RecipientBehaviourContext" module:

```ts
import * as RecipientBehaviourContext from "@effect/cluster/RecipientBehaviourContext"
// Can be accessed like this
RecipientBehaviourContext.RecipientBehaviourContext
```


# recipientType

Gets the current recipientType

To import and use `recipientType` from the "RecipientBehaviourContext" module:

```ts
import * as RecipientBehaviourContext from "@effect/cluster/RecipientBehaviourContext"
// Can be accessed like this
RecipientBehaviourContext.recipientType
```

**Signature**

```ts
export declare const recipientType: Effect.Effect<
  RecipientType.RecipientType<Message.Message.Any>,
  never,
  RecipientBehaviourContext
>
```


# shardId

Gets the current shardId

To import and use `shardId` from the "RecipientBehaviourContext" module:

```ts
import * as RecipientBehaviourContext from "@effect/cluster/RecipientBehaviourContext"
// Can be accessed like this
RecipientBehaviourContext.shardId
```

**Signature**

```ts
export declare const shardId: Effect.Effect<ShardId.ShardId, never, RecipientBehaviourContext>
```


# EntityType

An EntityType is a RecipientType that is ensured to be alive only on a single Pod at a time.

To import and use `EntityType` from the "RecipientType" module:

```ts
import * as RecipientType from "@effect/cluster/RecipientType"
// Can be accessed like this
RecipientType.EntityType
```


# isRecipientType

Ensure that given value is a RecipientType

To import and use `isRecipientType` from the "RecipientType" module:

```ts
import * as RecipientType from "@effect/cluster/RecipientType"
// Can be accessed like this
RecipientType.isRecipientType
```

**Signature**

```ts
export declare function isRecipientType<A extends Message.Message.Any>(value: unknown): value is RecipientType<A>
```


# makeEntityType

Given a name and a schema for the protocol, constructs an EntityType.

To import and use `makeEntityType` from the "RecipientType" module:

```ts
import * as RecipientType from "@effect/cluster/RecipientType"
// Can be accessed like this
RecipientType.makeEntityType
```

**Signature**

```ts
export declare function makeEntityType<Msg extends Message.Message.Any, I>(
  name: string,
  schema: Schema.Schema<Msg, I>
): EntityType<Msg>
```


# makeTopicType

Given a name and a schema for the protocol, constructs an TopicType.

To import and use `makeTopicType` from the "RecipientType" module:

```ts
import * as RecipientType from "@effect/cluster/RecipientType"
// Can be accessed like this
RecipientType.makeTopicType
```

**Signature**

```ts
export declare function makeTopicType<Msg extends Message.Message.Any, I>(
  name: string,
  schema: Schema.Schema<Msg, I>
): TopicType<Msg>
```


# RecipientType

A RecipientType is basically a pointer to a logical grouping of multiple enties having the same RecipientBehaviour.
This value is required to be able to message with an entity/topic since it holds the Schema for the messages over the wire.
Without the schema, you cannot ensure that the messages sent are what the receiver expects.
Ideally, you can share this definition between the caller and the receiver.

To import and use `RecipientType` from the "RecipientType" module:

```ts
import * as RecipientType from "@effect/cluster/RecipientType"
// Can be accessed like this
RecipientType.RecipientType
```


# TopicType

A TopicType can live on multiple Pods at the same time.

To import and use `TopicType` from the "RecipientType" module:

```ts
import * as RecipientType from "@effect/cluster/RecipientType"
// Can be accessed like this
RecipientType.TopicType
```


# collect

Transforms the values of a record into an `Array` with a custom mapping function.

To import and use `collect` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.collect
```

**Example**

```ts
import { collect } from "effect/Record"

const x = { a: 1, b: 2, c: 3 }
assert.deepStrictEqual(
  collect(x, (key, n) => [key, n]),
  [
    ["a", 1],
    ["b", 2],
    ["c", 3]
  ]
)
```

**Signature**

```ts
export declare const collect: {
  <K extends string, A, B>(f: (key: K, a: A) => B): (self: ReadonlyRecord<K, A>) => Array<B>
  <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => B): Array<B>
}
```


# difference

Merge two records, preserving only the entries that are unique to each record.

To import and use `difference` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.difference
```

**Signature**

```ts
export declare const difference: {
  <K1 extends string, B>(
    that: ReadonlyRecord<K1, B>
  ): <K0 extends string, A>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B>
  <K0 extends string, A, K1 extends string, B>(
    self: ReadonlyRecord<K0, A>,
    that: ReadonlyRecord<K1, B>
  ): Record<K0 | K1, A | B>
}
```


# empty

Creates a new, empty record.

To import and use `empty` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.empty
```

**Signature**

```ts
export declare const empty: <K extends string | symbol = never, V = never>() => Record<
  ReadonlyRecord.NonLiteralKey<K>,
  V
>
```


# every

Check if all entries in a record meet a specific condition.

To import and use `every` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.every
```

**Signature**

```ts
export declare const every: {
  <A, K extends string, B extends A>(
    refinement: (value: A, key: K) => value is B
  ): (self: ReadonlyRecord<K, A>) => self is ReadonlyRecord<K, B>
  <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean
  <A, K extends string, B extends A>(
    self: ReadonlyRecord<K, A>,
    refinement: (value: A, key: K) => value is B
  ): self is ReadonlyRecord<K, B>
  <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean
}
```


# filter

Selects properties from a record whose values match the given predicate.

To import and use `filter` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.filter
```

**Example**

```ts
import { filter } from "effect/Record"

const x = { a: 1, b: 2, c: 3, d: 4 }
assert.deepStrictEqual(
  filter(x, (n) => n > 2),
  { c: 3, d: 4 }
)
```

**Signature**

```ts
export declare const filter: {
  <K extends string, A, B extends A>(
    refinement: (a: NoInfer<A>, key: K) => a is B
  ): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>
  <K extends string, A>(
    predicate: (A: NoInfer<A>, key: K) => boolean
  ): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, A>
  <K extends string, A, B extends A>(
    self: ReadonlyRecord<K, A>,
    refinement: (a: A, key: K) => a is B
  ): Record<ReadonlyRecord.NonLiteralKey<K>, B>
  <K extends string, A>(
    self: ReadonlyRecord<K, A>,
    predicate: (a: A, key: K) => boolean
  ): Record<ReadonlyRecord.NonLiteralKey<K>, A>
}
```


# filterMap

Transforms a record into a record by applying the function `f` to each key and value in the original record.
If the function returns `Some`, the key-value pair is included in the output record.

To import and use `filterMap` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.filterMap
```

**Example**

```ts
import { Record, Option } from "effect"

const x = { a: 1, b: 2, c: 3 }
const f = (a: number, key: string) => (a > 2 ? Option.some(a * 2) : Option.none())
assert.deepStrictEqual(Record.filterMap(x, f), { c: 6 })
```

**Signature**

```ts
export declare const filterMap: {
  <K extends string, A, B>(
    f: (a: A, key: K) => Option.Option<B>
  ): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>
  <K extends string, A, B>(
    self: ReadonlyRecord<K, A>,
    f: (a: A, key: K) => Option.Option<B>
  ): Record<ReadonlyRecord.NonLiteralKey<K>, B>
}
```


# fromEntries

Builds a record from an iterable of key-value pairs.

If there are conflicting keys when using `fromEntries`, the last occurrence of the key/value pair will overwrite the
previous ones. So the resulting record will only have the value of the last occurrence of each key.

To import and use `fromEntries` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.fromEntries
```

**Example**

```ts
import { fromEntries } from "effect/Record"

const input: Array<[string, number]> = [
  ["a", 1],
  ["b", 2]
]

assert.deepStrictEqual(fromEntries(input), { a: 1, b: 2 })
```

**Signature**

```ts
export declare const fromEntries: <Entry extends readonly [string | symbol, any]>(
  entries: Iterable<Entry>
) => Record<ReadonlyRecord.NonLiteralKey<Entry[0]>, Entry[1]>
```


# fromIterableBy

Creates a new record from an iterable, utilizing the provided function to determine the key for each element.

To import and use `fromIterableBy` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.fromIterableBy
```

**Example**

```ts
import { fromIterableBy } from "effect/Record"

const users = [
  { id: "2", name: "name2" },
  { id: "1", name: "name1" }
]

assert.deepStrictEqual(
  fromIterableBy(users, (user) => user.id),
  {
    "2": { id: "2", name: "name2" },
    "1": { id: "1", name: "name1" }
  }
)
```

**Signature**

```ts
export declare const fromIterableBy: <A, K extends string | symbol>(
  items: Iterable<A>,
  f: (a: A) => K
) => Record<ReadonlyRecord.NonLiteralKey<K>, A>
```


# fromIterableWith

Takes an iterable and a projection function and returns a record.
The projection function maps each value of the iterable to a tuple of a key and a value, which is then added to the resulting record.

To import and use `fromIterableWith` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.fromIterableWith
```

**Example**

```ts
import { fromIterableWith } from "effect/Record"

const input = [1, 2, 3, 4]

assert.deepStrictEqual(
  fromIterableWith(input, (a) => [String(a), a * 2]),
  { "1": 2, "2": 4, "3": 6, "4": 8 }
)
```

**Signature**

```ts
export declare const fromIterableWith: {
  <A, K extends string | symbol, B>(
    f: (a: A) => readonly [K, B]
  ): (self: Iterable<A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>
  <A, K extends string | symbol, B>(
    self: Iterable<A>,
    f: (a: A) => readonly [K, B]
  ): Record<ReadonlyRecord.NonLiteralKey<K>, B>
}
```


# get

Retrieve a value at a particular key from a record, returning it wrapped in an `Option`.

To import and use `get` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.get
```

**Example**

```ts
import { Record as R, Option } from "effect"

const person: Record<string, unknown> = { name: "John Doe", age: 35 }

assert.deepStrictEqual(R.get(person, "name"), Option.some("John Doe"))
assert.deepStrictEqual(R.get(person, "email"), Option.none())
```

**Signature**

```ts
export declare const get: {
  <K extends string | symbol>(key: NoInfer<K>): <A>(self: ReadonlyRecord<K, A>) => Option.Option<A>
  <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): Option.Option<A>
}
```


# getEquivalence

Create an `Equivalence` for records using the provided `Equivalence` for values.

To import and use `getEquivalence` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.getEquivalence
```

**Signature**

```ts
export declare const getEquivalence: <K extends string, A>(
  equivalence: Equivalence<A>
) => Equivalence<ReadonlyRecord<K, A>>
```


# getLefts

Given a record with `Either` values, returns a new record containing only the `Left` values, preserving the original keys.

To import and use `getLefts` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.getLefts
```

**Example**

```ts
import { Record, Either } from "effect"

assert.deepStrictEqual(Record.getLefts({ a: Either.right(1), b: Either.left("err"), c: Either.right(2) }), { b: "err" })
```

**Signature**

```ts
export declare const getLefts: <K extends string, R, L>(
  self: ReadonlyRecord<K, Either<R, L>>
) => Record<ReadonlyRecord.NonLiteralKey<K>, L>
```


# getRights

Given a record with `Either` values, returns a new record containing only the `Right` values, preserving the original keys.

To import and use `getRights` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.getRights
```

**Example**

```ts
import { Record, Either } from "effect"

assert.deepStrictEqual(Record.getRights({ a: Either.right(1), b: Either.left("err"), c: Either.right(2) }), {
  a: 1,
  c: 2
})
```

**Signature**

```ts
export declare const getRights: <K extends string, R, L>(self: ReadonlyRecord<K, Either<R, L>>) => Record<string, R>
```


# getSomes

Given a record with `Option` values, returns a new record containing only the `Some` values, preserving the original keys.

To import and use `getSomes` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.getSomes
```

**Example**

```ts
import { Record, Option } from "effect"

assert.deepStrictEqual(Record.getSomes({ a: Option.some(1), b: Option.none(), c: Option.some(2) }), { a: 1, c: 2 })
```

**Signature**

```ts
export declare const getSomes: <K extends string, A>(
  self: ReadonlyRecord<K, Option.Option<A>>
) => Record<ReadonlyRecord.NonLiteralKey<K>, A>
```


# has

Check if a given `key` exists in a record.

To import and use `has` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.has
```

**Example**

```ts
import { empty, has } from "effect/Record"

assert.deepStrictEqual(has({ a: 1, b: 2 }, "a"), true)
assert.deepStrictEqual(has(empty<string>(), "c"), false)
```

**Signature**

```ts
export declare const has: {
  <K extends string | symbol>(key: NoInfer<K>): <A>(self: ReadonlyRecord<K, A>) => boolean
  <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): boolean
}
```


# intersection

Merge two records, retaining only the entries that exist in both records.

To import and use `intersection` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.intersection
```

**Signature**

```ts
export declare const intersection: {
  <K1 extends string, A, B, C>(
    that: ReadonlyRecord<K1, B>,
    combine: (selfValue: A, thatValue: B) => C
  ): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>
  <K0 extends string, A, K1 extends string, B, C>(
    self: ReadonlyRecord<K0, A>,
    that: ReadonlyRecord<K1, B>,
    combine: (selfValue: A, thatValue: B) => C
  ): Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>
}
```


# isEmptyReadonlyRecord

Determine if a record is empty.

To import and use `isEmptyReadonlyRecord` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.isEmptyReadonlyRecord
```

**Example**

```ts
import { isEmptyReadonlyRecord } from "effect/Record"

assert.deepStrictEqual(isEmptyReadonlyRecord({}), true)
assert.deepStrictEqual(isEmptyReadonlyRecord({ a: 3 }), false)
```

**Signature**

```ts
export declare const isEmptyReadonlyRecord: <K extends string, A>(
  self: ReadonlyRecord<K, A>
) => self is ReadonlyRecord<K, never>
```


# isEmptyRecord

Determine if a record is empty.

To import and use `isEmptyRecord` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.isEmptyRecord
```

**Example**

```ts
import { isEmptyRecord } from "effect/Record"

assert.deepStrictEqual(isEmptyRecord({}), true)
assert.deepStrictEqual(isEmptyRecord({ a: 3 }), false)
```

**Signature**

```ts
export declare const isEmptyRecord: <K extends string, A>(self: Record<K, A>) => self is Record<K, never>
```


# isSubrecord

Check if one record is a subrecord of another, meaning it contains all the keys and values found in the second record.
This comparison uses default equality checks (`Equal.equivalence()`).

To import and use `isSubrecord` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.isSubrecord
```

**Signature**

```ts
export declare const isSubrecord: {
  <K extends string, A>(that: ReadonlyRecord<K, A>): (self: ReadonlyRecord<K, A>) => boolean
  <K extends string, A>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean
}
```


# isSubrecordBy

Check if all the keys and values in one record are also found in another record.

To import and use `isSubrecordBy` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.isSubrecordBy
```

**Signature**

```ts
export declare const isSubrecordBy: <A>(equivalence: Equivalence<A>) => {
  <K extends string>(that: ReadonlyRecord<K, A>): (self: ReadonlyRecord<K, A>) => boolean
  <K extends string>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean
}
```


# keys

Retrieve the keys of a given record as an array.

To import and use `keys` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.keys
```

**Signature**

```ts
export declare const keys: <K extends string | symbol, A>(self: ReadonlyRecord<K, A>) => Array<K & string>
```


# map

Maps a record into another record by applying a transformation function to each of its values.

To import and use `map` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.map
```

**Example**

```ts
import { map } from "effect/Record"

const f = (n: number) => `-${n}`

assert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: "-3", b: "-5" })

const g = (n: number, key: string) => `${key.toUpperCase()}-${n}`

assert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: "A-3", b: "B-5" })
```

**Signature**

```ts
export declare const map: {
  <K extends string, A, B>(f: (a: A, key: NoInfer<K>) => B): (self: ReadonlyRecord<K, A>) => Record<K, B>
  <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: NoInfer<K>) => B): Record<K, B>
}
```


# mapEntries

Maps entries of a `ReadonlyRecord` using the provided function, allowing modification of both keys and corresponding values.

To import and use `mapEntries` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.mapEntries
```

**Example**

```ts
import { mapEntries } from "effect/Record"

assert.deepStrictEqual(
  mapEntries({ a: 3, b: 5 }, (a, key) => [key.toUpperCase(), a + 1]),
  { A: 4, B: 6 }
)
```

**Signature**

```ts
export declare const mapEntries: {
  <K extends string, A, K2 extends string, B>(
    f: (a: A, key: K) => readonly [K2, B]
  ): (self: ReadonlyRecord<K, A>) => Record<K2, B>
  <K extends string, A, K2 extends string, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => [K2, B]): Record<K2, B>
}
```


# mapKeys

Maps the keys of a `ReadonlyRecord` while preserving the corresponding values.

To import and use `mapKeys` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.mapKeys
```

**Example**

```ts
import { mapKeys } from "effect/Record"

assert.deepStrictEqual(
  mapKeys({ a: 3, b: 5 }, (key) => key.toUpperCase()),
  { A: 3, B: 5 }
)
```

**Signature**

```ts
export declare const mapKeys: {
  <K extends string, A, K2 extends string>(f: (key: K, a: A) => K2): (self: ReadonlyRecord<K, A>) => Record<K2, A>
  <K extends string, A, K2 extends string>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => K2): Record<K2, A>
}
```


# modify

Apply a function to the element at the specified key, creating a new record.
If the key does not exist, the record is returned unchanged.

To import and use `modify` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.modify
```

**Example**

```ts
import { Record as R } from "effect"

const f = (x: number) => x * 2

assert.deepStrictEqual(R.modify({ a: 3 }, "a", f), { a: 6 })
assert.deepStrictEqual(R.modify({ a: 3 } as Record<string, number>, "b", f), { a: 3 })
```

**Signature**

```ts
export declare const modify: {
  <K extends string | symbol, A, B>(key: NoInfer<K>, f: (a: A) => B): (self: ReadonlyRecord<K, A>) => Record<K, A | B>
  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Record<K, A | B>
}
```


# modifyOption

Apply a function to the element at the specified key, creating a new record,
or return `None` if the key doesn't exist.

To import and use `modifyOption` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.modifyOption
```

**Example**

```ts
import { Record as R, Option } from "effect"

const f = (x: number) => x * 2

assert.deepStrictEqual(R.modifyOption({ a: 3 }, "a", f), Option.some({ a: 6 }))
assert.deepStrictEqual(R.modifyOption({ a: 3 } as Record<string, number>, "b", f), Option.none())
```

**Signature**

```ts
export declare const modifyOption: {
  <K extends string | symbol, A, B>(
    key: NoInfer<K>,
    f: (a: A) => B
  ): (self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>
  <K extends string | symbol, A, B>(
    self: ReadonlyRecord<K, A>,
    key: NoInfer<K>,
    f: (a: A) => B
  ): Option.Option<Record<K, A | B>>
}
```


# partition

Partitions a record into two separate records based on the result of a predicate function.

To import and use `partition` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.partition
```

**Example**

```ts
import { partition } from "effect/Record"

assert.deepStrictEqual(
  partition({ a: 1, b: 3 }, (n) => n > 2),
  [{ a: 1 }, { b: 3 }]
)
```

**Signature**

```ts
export declare const partition: {
  <K extends string, A, B extends A>(
    refinement: (a: NoInfer<A>, key: K) => a is B
  ): (
    self: ReadonlyRecord<K, A>
  ) => [
    excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>,
    satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>
  ]
  <K extends string, A>(
    predicate: (a: NoInfer<A>, key: K) => boolean
  ): (
    self: ReadonlyRecord<K, A>
  ) => [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]
  <K extends string, A, B extends A>(
    self: ReadonlyRecord<K, A>,
    refinement: (a: A, key: K) => a is B
  ): [
    excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>,
    satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>
  ]
  <K extends string, A>(
    self: ReadonlyRecord<K, A>,
    predicate: (a: A, key: K) => boolean
  ): [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]
}
```


# partitionMap

Partitions the elements of a record into two groups: those that match a predicate, and those that don't.

To import and use `partitionMap` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.partitionMap
```

**Example**

```ts
import { Record, Either } from "effect"

const x = { a: 1, b: 2, c: 3 }
const f = (n: number) => (n % 2 === 0 ? Either.right(n) : Either.left(n))
assert.deepStrictEqual(Record.partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2 }])
```

**Signature**

```ts
export declare const partitionMap: {
  <K extends string, A, B, C>(
    f: (a: A, key: K) => Either<C, B>
  ): (
    self: ReadonlyRecord<K, A>
  ) => [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]
  <K extends string, A, B, C>(
    self: ReadonlyRecord<K, A>,
    f: (a: A, key: K) => Either<C, B>
  ): [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]
}
```


# pop

Retrieves the value of the property with the given `key` from a record and returns an `Option`
of a tuple with the value and the record with the removed property.
If the key is not present, returns `O.none`.

To import and use `pop` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.pop
```

**Example**

```ts
import { Record as R, Option } from "effect"

assert.deepStrictEqual(R.pop({ a: 1, b: 2 }, "a"), Option.some([1, { b: 2 }]))
assert.deepStrictEqual(R.pop({ a: 1, b: 2 } as Record<string, number>, "c"), Option.none())
```

**Signature**

```ts
export declare const pop: {
  <K extends string | symbol, X extends K>(
    key: X
  ): <A>(self: ReadonlyRecord<K, A>) => Option.Option<[A, Record<Exclude<K, X>, A>]>
  <K extends string | symbol, A, X extends K>(
    self: ReadonlyRecord<K, A>,
    key: X
  ): Option.Option<[A, Record<Exclude<K, X>, A>]>
}
```


# reduce

Reduce a record to a single value by combining its entries with a specified function.

To import and use `reduce` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.reduce
```

**Signature**

```ts
export declare const reduce: {
  <Z, V, K extends string>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: ReadonlyRecord<K, V>) => Z
  <K extends string, V, Z>(self: ReadonlyRecord<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z
}
```


# remove

If the given key exists in the record, returns a new record with the key removed,
otherwise returns a copy of the original record.

To import and use `remove` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.remove
```

**Example**

```ts
import { remove } from "effect/Record"

assert.deepStrictEqual(remove({ a: 1, b: 2 }, "a"), { b: 2 })
```

**Signature**

```ts
export declare const remove: {
  <K extends string | symbol, X extends K>(key: X): <A>(self: ReadonlyRecord<K, A>) => Record<Exclude<K, X>, A>
  <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Record<Exclude<K, X>, A>
}
```


# replace

Replace a key's value in a record and return the updated record.
If the key does not exist in the record, a copy of the original record is returned.

To import and use `replace` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.replace
```

**Example**

```ts
import { Record } from "effect"

assert.deepStrictEqual(Record.replace("a", 3)({ a: 1, b: 2 }), { a: 3, b: 2 })
assert.deepStrictEqual(Record.replace("c", 3)({ a: 1, b: 2 }), { a: 1, b: 2 })
```

**Signature**

```ts
export declare const replace: {
  <K extends string | symbol, B>(key: NoInfer<K>, value: B): <A>(self: ReadonlyRecord<K, A>) => Record<K, A | B>
  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, value: B): Record<K, A | B>
}
```


# replaceOption

Replaces a value in the record with the new value passed as parameter.

To import and use `replaceOption` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.replaceOption
```

**Example**

```ts
import { Record, Option } from "effect"

assert.deepStrictEqual(Record.replaceOption({ a: 1, b: 2, c: 3 }, "a", 10), Option.some({ a: 10, b: 2, c: 3 }))
assert.deepStrictEqual(Record.replaceOption(Record.empty<string>(), "a", 10), Option.none())
```

**Signature**

```ts
export declare const replaceOption: {
  <K extends string | symbol, B>(
    key: NoInfer<K>,
    b: B
  ): <A>(self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>
  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, b: B): Option.Option<Record<K, A | B>>
}
```


# separate

Partitions a record of `Either` values into two separate records,
one with the `Left` values and one with the `Right` values.

To import and use `separate` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.separate
```

**Example**

```ts
import { Record, Either } from "effect"

assert.deepStrictEqual(Record.separate({ a: Either.left("e"), b: Either.right(1) }), [{ a: "e" }, { b: 1 }])
```

**Signature**

```ts
export declare const separate: <K extends string, A, B>(
  self: ReadonlyRecord<K, Either<B, A>>
) => [Record<ReadonlyRecord.NonLiteralKey<K>, A>, Record<ReadonlyRecord.NonLiteralKey<K>, B>]
```


# set

Add a new key-value pair or update an existing key's value in a record.

To import and use `set` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.set
```

**Example**

```ts
import { set } from "effect/Record"

assert.deepStrictEqual(set("a", 5)({ a: 1, b: 2 }), { a: 5, b: 2 })
assert.deepStrictEqual(set("c", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 })
```

**Signature**

```ts
export declare const set: {
  <K extends string | symbol, K1 extends K | ((string | symbol) & {}), B>(
    key: K1,
    value: B
  ): <A>(self: ReadonlyRecord<K, A>) => Record<K | K1, A | B>
  <K extends string | symbol, A, K1 extends K | ((string | symbol) & {}), B>(
    self: ReadonlyRecord<K, A>,
    key: K1,
    value: B
  ): Record<K | K1, A | B>
}
```


# singleton

Create a non-empty record from a single element.

To import and use `singleton` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.singleton
```

**Signature**

```ts
export declare const singleton: <K extends string | symbol, A>(key: K, value: A) => Record<K, A>
```


# size

Returns the number of key/value pairs in a record.

To import and use `size` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.size
```

**Example**

```ts
import { size } from "effect/Record"

assert.deepStrictEqual(size({ a: "a", b: 1, c: true }), 3)
```

**Signature**

```ts
export declare const size: <K extends string, A>(self: ReadonlyRecord<K, A>) => number
```


# some

Check if any entry in a record meets a specific condition.

To import and use `some` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.some
```

**Signature**

```ts
export declare const some: {
  <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean
  <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean
}
```


# toEntries

Takes a record and returns an array of tuples containing its keys and values.

To import and use `toEntries` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.toEntries
```

**Example**

```ts
import { toEntries } from "effect/Record"

const x = { a: 1, b: 2, c: 3 }
assert.deepStrictEqual(toEntries(x), [
  ["a", 1],
  ["b", 2],
  ["c", 3]
])
```

**Signature**

```ts
export declare const toEntries: <K extends string, A>(self: ReadonlyRecord<K, A>) => Array<[K, A]>
```


# union

Merge two records, preserving entries that exist in either of the records.

To import and use `union` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.union
```

**Signature**

```ts
export declare const union: {
  <K1 extends string, A, B, C>(
    that: ReadonlyRecord<K1, B>,
    combine: (selfValue: A, thatValue: B) => C
  ): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B | C>
  <K0 extends string, A, K1 extends string, B, C>(
    self: ReadonlyRecord<K0, A>,
    that: ReadonlyRecord<K1, B>,
    combine: (selfValue: A, thatValue: B) => C
  ): Record<K0 | K1, A | B | C>
}
```


# values

Retrieve the values of a given record as an array.

To import and use `values` from the "Record" module:

```ts
import * as Record from "effect/Record"
// Can be accessed like this
Record.values
```

**Signature**

```ts
export declare const values: <K extends string, A>(self: ReadonlyRecord<K, A>) => Array<A>
```


# getEquivalence

Generates an equivalence relation for `Redacted<A>` values based on an
equivalence relation for the underlying values `A`. This function is useful
for comparing `Redacted` instances without exposing their contents.

To import and use `getEquivalence` from the "Redacted" module:

```ts
import * as Redacted from "effect/Redacted"
// Can be accessed like this
Redacted.getEquivalence
```

**Example**

```ts
import { Redacted, Equivalence } from "effect"

const API_KEY1 = Redacted.make("1234567890")
const API_KEY2 = Redacted.make("1-34567890")
const API_KEY3 = Redacted.make("1234567890")

const equivalence = Redacted.getEquivalence(Equivalence.string)

assert.equal(equivalence(API_KEY1, API_KEY2), false)
assert.equal(equivalence(API_KEY1, API_KEY3), true)
```

**Signature**

```ts
export declare const getEquivalence: <A>(
  isEquivalent: Equivalence.Equivalence<A>
) => Equivalence.Equivalence<Redacted<A>>
```


# make

This function creates a `Redacted<A>` instance from a given value `A`,
securely hiding its content.

To import and use `make` from the "Redacted" module:

```ts
import * as Redacted from "effect/Redacted"
// Can be accessed like this
Redacted.make
```

**Example**

```ts
import { Redacted } from "effect"

const API_KEY = Redacted.make("1234567890")
```

**Signature**

```ts
export declare const make: <A>(value: A) => Redacted<A>
```


# unsafeWipe

Erases the underlying value of a `Redacted` instance, rendering it unusable.
This function is intended to ensure that sensitive data does not remain in
memory longer than necessary.

To import and use `unsafeWipe` from the "Redacted" module:

```ts
import * as Redacted from "effect/Redacted"
// Can be accessed like this
Redacted.unsafeWipe
```

**Example**

```ts
import { Redacted } from "effect"

const API_KEY = Redacted.make("1234567890")

assert.equal(Redacted.value(API_KEY), "1234567890")

Redacted.unsafeWipe(API_KEY)

assert.throws(() => Redacted.value(API_KEY), new Error("Unable to get redacted value"))
```

**Signature**

```ts
export declare const unsafeWipe: <A>(self: Redacted<A>) => boolean
```


# value

Retrieves the original value from a `Redacted` instance. Use this function
with caution, as it exposes the sensitive data.

To import and use `value` from the "Redacted" module:

```ts
import * as Redacted from "effect/Redacted"
// Can be accessed like this
Redacted.value
```

**Example**

```ts
import { Redacted } from "effect"

const API_KEY = Redacted.make("1234567890")

assert.equal(Redacted.value(API_KEY), "1234567890")
```

**Signature**

```ts
export declare const value: <A>(self: Redacted<A>) => A
```


# at

Returns an iterator that points to the element at the specified index of the
tree.

**Note**: The iterator will run through elements in order.

To import and use `at` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.at
```

**Signature**

```ts
export declare const at: {
  (index: number): <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>
  <K, V>(self: RedBlackTree<K, V>, index: number): Iterable<[K, V]>
}
```


# atReversed

Returns an iterator that points to the element at the specified index of the
tree.

**Note**: The iterator will run through elements in reverse order.

To import and use `atReversed` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.atReversed
```

**Signature**

```ts
export declare const atReversed: {
  (index: number): <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>
  <K, V>(self: RedBlackTree<K, V>, index: number): Iterable<[K, V]>
}
```


# empty

Creates an empty `RedBlackTree`.

To import and use `empty` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.empty
```

**Signature**

```ts
export declare const empty: <K, V = never>(ord: Order<K>) => RedBlackTree<K, V>
```


# findAll

Finds all values in the tree associated with the specified key.

To import and use `findAll` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.findAll
```

**Signature**

```ts
export declare const findAll: {
  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Chunk<V>
  <K, V>(self: RedBlackTree<K, V>, key: K): Chunk<V>
}
```


# findFirst

Finds the first value in the tree associated with the specified key, if it exists.

To import and use `findFirst` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.findFirst
```

**Signature**

```ts
export declare const findFirst: {
  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Option<V>
  <K, V>(self: RedBlackTree<K, V>, key: K): Option<V>
}
```


# first

Returns the first entry in the tree, if it exists.

To import and use `first` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.first
```

**Signature**

```ts
export declare const first: <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>
```


# forEach

Execute the specified function for each node of the tree, in order.

To import and use `forEach` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.forEach
```

**Signature**

```ts
export declare const forEach: {
  <K, V>(f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void
  <K, V>(self: RedBlackTree<K, V>, f: (key: K, value: V) => void): void
}
```


# forEachBetween

Visit each node of the tree in order with key lower than max and greater
than or equal to min.

To import and use `forEachBetween` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.forEachBetween
```

**Signature**

```ts
export declare const forEachBetween: {
  <K, V>(options: {
    readonly min: K
    readonly max: K
    readonly body: (key: K, value: V) => void
  }): (self: RedBlackTree<K, V>) => void
  <K, V>(
    self: RedBlackTree<K, V>,
    options: { readonly min: K; readonly max: K; readonly body: (key: K, value: V) => void }
  ): void
}
```


# forEachGreaterThanEqual

Visit each node of the tree in order with key greater then or equal to max.

To import and use `forEachGreaterThanEqual` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.forEachGreaterThanEqual
```

**Signature**

```ts
export declare const forEachGreaterThanEqual: {
  <K, V>(min: K, f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void
  <K, V>(self: RedBlackTree<K, V>, min: K, f: (key: K, value: V) => void): void
}
```


# forEachLessThan

Visit each node of the tree in order with key lower then max.

To import and use `forEachLessThan` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.forEachLessThan
```

**Signature**

```ts
export declare const forEachLessThan: {
  <K, V>(max: K, f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void
  <K, V>(self: RedBlackTree<K, V>, max: K, f: (key: K, value: V) => void): void
}
```


# fromIterable

Creates a new `RedBlackTree` from an iterable collection of key/value pairs.

To import and use `fromIterable` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.fromIterable
```

**Signature**

```ts
export declare const fromIterable: {
  <B>(ord: Order<B>): <K extends B, V>(entries: Iterable<readonly [K, V]>) => RedBlackTree<K, V>
  <K extends B, V, B>(entries: Iterable<readonly [K, V]>, ord: Order<B>): RedBlackTree<K, V>
}
```


# getAt

Returns the element at the specified index within the tree or `None` if the
specified index does not exist.

To import and use `getAt` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.getAt
```

**Signature**

```ts
export declare const getAt: {
  (index: number): <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>
  <K, V>(self: RedBlackTree<K, V>, index: number): Option<[K, V]>
}
```


# getOrder

Gets the `Order<K>` that the `RedBlackTree<K, V>` is using.

To import and use `getOrder` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.getOrder
```

**Signature**

```ts
export declare const getOrder: <K, V>(self: RedBlackTree<K, V>) => Order<K>
```


# greaterThan

Returns an iterator that traverse entries in order with keys greater than the
specified key.

To import and use `greaterThan` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.greaterThan
```

**Signature**

```ts
export declare const greaterThan: {
  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>
  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>
}
```


# greaterThanEqual

Returns an iterator that traverse entries in order with keys greater than or
equal to the specified key.

To import and use `greaterThanEqual` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.greaterThanEqual
```

**Signature**

```ts
export declare const greaterThanEqual: {
  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>
  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>
}
```


# greaterThanEqualReversed

Returns an iterator that traverse entries in reverse order with keys greater
than or equal to the specified key.

To import and use `greaterThanEqualReversed` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.greaterThanEqualReversed
```

**Signature**

```ts
export declare const greaterThanEqualReversed: {
  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>
  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>
}
```


# greaterThanReversed

Returns an iterator that traverse entries in reverse order with keys greater
than the specified key.

To import and use `greaterThanReversed` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.greaterThanReversed
```

**Signature**

```ts
export declare const greaterThanReversed: {
  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>
  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>
}
```


# has

Finds the item with key, if it exists.

To import and use `has` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.has
```

**Signature**

```ts
export declare const has: {
  <K>(key: K): <V>(self: RedBlackTree<K, V>) => boolean
  <K, V>(self: RedBlackTree<K, V>, key: K): boolean
}
```


# insert

Insert a new item into the tree.

To import and use `insert` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.insert
```

**Signature**

```ts
export declare const insert: {
  <K, V>(key: K, value: V): (self: RedBlackTree<K, V>) => RedBlackTree<K, V>
  <K, V>(self: RedBlackTree<K, V>, key: K, value: V): RedBlackTree<K, V>
}
```


# keys

Get all the keys present in the tree in order.

To import and use `keys` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.keys
```

**Signature**

```ts
export declare const keys: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<K>
```


# keysReversed

Get all the keys present in the tree in reverse order.

To import and use `keysReversed` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.keysReversed
```

**Signature**

```ts
export declare const keysReversed: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<K>
```


# last

Returns the last entry in the tree, if it exists.

To import and use `last` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.last
```

**Signature**

```ts
export declare const last: <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>
```


# lessThan

Returns an iterator that traverse entries in order with keys less than the
specified key.

To import and use `lessThan` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.lessThan
```

**Signature**

```ts
export declare const lessThan: {
  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>
  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>
}
```


# lessThanEqual

Returns an iterator that traverse entries in order with keys less than or
equal to the specified key.

To import and use `lessThanEqual` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.lessThanEqual
```

**Signature**

```ts
export declare const lessThanEqual: {
  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>
  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>
}
```


# lessThanEqualReversed

Returns an iterator that traverse entries in reverse order with keys less
than or equal to the specified key.

To import and use `lessThanEqualReversed` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.lessThanEqualReversed
```

**Signature**

```ts
export declare const lessThanEqualReversed: {
  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>
  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>
}
```


# lessThanReversed

Returns an iterator that traverse entries in reverse order with keys less
than the specified key.

To import and use `lessThanReversed` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.lessThanReversed
```

**Signature**

```ts
export declare const lessThanReversed: {
  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>
  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>
}
```


# make

Constructs a new `RedBlackTree` from the specified entries.

To import and use `make` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.make
```

**Signature**

```ts
export declare const make: <K>(
  ord: Order<K>
) => <Entries extends Array<readonly [K, any]>>(
  ...entries: Entries
) => RedBlackTree<K, Entries[number] extends readonly [any, infer V] ? V : never>
```


# RedBlackTree

A Red-Black Tree.

To import and use `RedBlackTree` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.RedBlackTree
```


# reduce

Reduce a state over the entries of the tree.

To import and use `reduce` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.reduce
```

**Signature**

```ts
export declare const reduce: {
  <Z, V, K>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: RedBlackTree<K, V>) => Z
  <Z, V, K>(self: RedBlackTree<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z
}
```


# removeFirst

Removes the entry with the specified key, if it exists.

To import and use `removeFirst` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.removeFirst
```

**Signature**

```ts
export declare const removeFirst: {
  <K>(key: K): <V>(self: RedBlackTree<K, V>) => RedBlackTree<K, V>
  <K, V>(self: RedBlackTree<K, V>, key: K): RedBlackTree<K, V>
}
```


# reversed

Traverse the tree in reverse order.

To import and use `reversed` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.reversed
```

**Signature**

```ts
export declare const reversed: <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>
```


# size

Returns the size of the tree.

To import and use `size` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.size
```

**Signature**

```ts
export declare const size: <K, V>(self: RedBlackTree<K, V>) => number
```


# values

Get all values present in the tree in order.

To import and use `values` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.values
```

**Signature**

```ts
export declare const values: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<V>
```


# valuesReversed

Get all values present in the tree in reverse order.

To import and use `valuesReversed` from the "RedBlackTree" module:

```ts
import * as RedBlackTree from "effect/RedBlackTree"
// Can be accessed like this
RedBlackTree.valuesReversed
```

**Signature**

```ts
export declare const valuesReversed: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<V>
```


# escape

Escapes special characters in a regular expression pattern.

To import and use `escape` from the "RegExp" module:

```ts
import * as RegExp from "effect/RegExp"
// Can be accessed like this
RegExp.escape
```

**Example**

```ts
import { RegExp } from "effect"

assert.deepStrictEqual(RegExp.escape("a*b"), "a\\*b")
```

**Signature**

```ts
export declare const escape: (string: string) => string
```


# isRegExp

Tests if a value is a `RegExp`.

To import and use `isRegExp` from the "RegExp" module:

```ts
import * as RegExp from "effect/RegExp"
// Can be accessed like this
RegExp.isRegExp
```

**Example**

```ts
import { RegExp } from "effect"

assert.deepStrictEqual(RegExp.isRegExp(/a/), true)
assert.deepStrictEqual(RegExp.isRegExp("a"), false)
```

**Signature**

```ts
export declare const isRegExp: (input: unknown) => input is RegExp
```


# auto

Makes a new reloadable service from a layer that describes the construction
of a static service. The service is automatically reloaded according to the
provided schedule.

To import and use `auto` from the "Reloadable" module:

```ts
import * as Reloadable from "effect/Reloadable"
// Can be accessed like this
Reloadable.auto
```

**Signature**

```ts
export declare const auto: <I, S, E, In, R>(
  tag: Context.Tag<I, S>,
  options: { readonly layer: Layer.Layer<I, E, In>; readonly schedule: Schedule.Schedule<unknown, unknown, R> }
) => Layer.Layer<Reloadable<I>, E, R | In>
```


# autoFromConfig

Makes a new reloadable service from a layer that describes the construction
of a static service. The service is automatically reloaded according to a
schedule, which is extracted from the input to the layer.

To import and use `autoFromConfig` from the "Reloadable" module:

```ts
import * as Reloadable from "effect/Reloadable"
// Can be accessed like this
Reloadable.autoFromConfig
```

**Signature**

```ts
export declare const autoFromConfig: <I, S, E, In, R>(
  tag: Context.Tag<I, S>,
  options: {
    readonly layer: Layer.Layer<I, E, In>
    readonly scheduleFromConfig: (context: Context.Context<In>) => Schedule.Schedule<unknown, unknown, R>
  }
) => Layer.Layer<Reloadable<I>, E, R | In>
```


# get

Retrieves the current version of the reloadable service.

To import and use `get` from the "Reloadable" module:

```ts
import * as Reloadable from "effect/Reloadable"
// Can be accessed like this
Reloadable.get
```

**Signature**

```ts
export declare const get: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<S, never, Reloadable<I>>
```


# manual

Makes a new reloadable service from a layer that describes the construction
of a static service.

To import and use `manual` from the "Reloadable" module:

```ts
import * as Reloadable from "effect/Reloadable"
// Can be accessed like this
Reloadable.manual
```

**Signature**

```ts
export declare const manual: <I, S, In, E>(
  tag: Context.Tag<I, S>,
  options: { readonly layer: Layer.Layer<I, E, In> }
) => Layer.Layer<Reloadable<I>, E, In>
```


# reload

Reloads the specified service.

To import and use `reload` from the "Reloadable" module:

```ts
import * as Reloadable from "effect/Reloadable"
// Can be accessed like this
Reloadable.reload
```

**Signature**

```ts
export declare const reload: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<void, unknown, Reloadable<I>>
```


# Reloadable

A `Reloadable` is an implementation of some service that can be dynamically
reloaded, or swapped out for another implementation on-the-fly.

To import and use `Reloadable` from the "Reloadable" module:

```ts
import * as Reloadable from "effect/Reloadable"
// Can be accessed like this
Reloadable.Reloadable
```


# reloadFork

Forks the reload of the service in the background, ignoring any errors.

To import and use `reloadFork` from the "Reloadable" module:

```ts
import * as Reloadable from "effect/Reloadable"
// Can be accessed like this
Reloadable.reloadFork
```

**Signature**

```ts
export declare const reloadFork: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<void, unknown, Reloadable<I>>
```


# Class

Provides a constructor for a Request Class.

To import and use `Class` from the "Request" module:

```ts
import * as Request from "effect/Request"
// Can be accessed like this
Request.Class
```

**Example**

```ts
import { Request } from "effect"

type Success = string
type Error = never

class MyRequest extends Request.Class<
  Success,
  Error,
  {
    readonly id: string
  }
> {}
```

**Signature**

```ts
export declare const Class: new <Success, Error, A extends Record<string, any>>(
  args: Types.Equals<Omit<A, keyof Request<unknown, unknown>>, {}> extends true
    ? void
    : { readonly [P in keyof A as P extends keyof Request<unknown, unknown> ? never : P]: A[P] }
) => Request<Success, Error> & Readonly<A>
```


# complete

Complete a `Request` with the specified result.

To import and use `complete` from the "Request" module:

```ts
import * as Request from "effect/Request"
// Can be accessed like this
Request.complete
```

**Signature**

```ts
export declare const complete: {
  <A extends Request<any, any>>(result: Request.Result<A>): (self: A) => Effect.Effect<void>
  <A extends Request<any, any>>(self: A, result: Request.Result<A>): Effect.Effect<void>
}
```


# completeEffect

Complete a `Request` with the specified effectful computation, failing the
request with the error from the effect workflow if it fails, and completing
the request with the value of the effect workflow if it succeeds.

To import and use `completeEffect` from the "Request" module:

```ts
import * as Request from "effect/Request"
// Can be accessed like this
Request.completeEffect
```

**Signature**

```ts
export declare const completeEffect: {
  <A extends Request<any, any>, R>(
    effect: Effect.Effect<Request.Success<A>, Request.Error<A>, R>
  ): (self: A) => Effect.Effect<void, never, R>
  <A extends Request<any, any>, R>(
    self: A,
    effect: Effect.Effect<Request.Success<A>, Request.Error<A>, R>
  ): Effect.Effect<void, never, R>
}
```


# Entry

A `Entry<A>` keeps track of a request of type `A` along with a
`Ref` containing the result of the request, existentially hiding the result
type. This is used internally by the library to support data sources that
return different result types for different requests while guaranteeing that
results will be of the type requested.

To import and use `Entry` from the "Request" module:

```ts
import * as Request from "effect/Request"
// Can be accessed like this
Request.Entry
```


# fail

Complete a `Request` with the specified error.

To import and use `fail` from the "Request" module:

```ts
import * as Request from "effect/Request"
// Can be accessed like this
Request.fail
```

**Signature**

```ts
export declare const fail: {
  <A extends Request<any, any>>(error: Request.Error<A>): (self: A) => Effect.Effect<void>
  <A extends Request<any, any>>(self: A, error: Request.Error<A>): Effect.Effect<void>
}
```


# failCause

Complete a `Request` with the specified cause.

To import and use `failCause` from the "Request" module:

```ts
import * as Request from "effect/Request"
// Can be accessed like this
Request.failCause
```

**Signature**

```ts
export declare const failCause: {
  <A extends Request<any, any>>(cause: Cause<Request.Error<A>>): (self: A) => Effect.Effect<void>
  <A extends Request<any, any>>(self: A, cause: Cause<Request.Error<A>>): Effect.Effect<void>
}
```


# interruptWhenPossible

Interrupts the child effect when requests are no longer needed

To import and use `interruptWhenPossible` from the "Request" module:

```ts
import * as Request from "effect/Request"
// Can be accessed like this
Request.interruptWhenPossible
```

**Signature**

```ts
export declare const interruptWhenPossible: {
  (all: Iterable<Request<any, any>>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<void, E, R>
  <A, E, R>(self: Effect.Effect<A, E, R>, all: Iterable<Request<any, any>>): Effect.Effect<void, E, R>
}
```


# isRequest

Returns `true` if the specified value is a `Request`, `false` otherwise.

To import and use `isRequest` from the "Request" module:

```ts
import * as Request from "effect/Request"
// Can be accessed like this
Request.isRequest
```

**Signature**

```ts
export declare const isRequest: (u: unknown) => u is Request<unknown, unknown>
```


# of

Constructs a new `Request`.

To import and use `of` from the "Request" module:

```ts
import * as Request from "effect/Request"
// Can be accessed like this
Request.of
```

**Signature**

```ts
export declare const of: <R extends Request<any, any>>() => Request.Constructor<R>
```


# Request

A `Request<A, E>` is a request from a data source for a value of type `A`
that may fail with an `E`.

To import and use `Request` from the "Request" module:

```ts
import * as Request from "effect/Request"
// Can be accessed like this
Request.Request
```


# succeed

Complete a `Request` with the specified value.

To import and use `succeed` from the "Request" module:

```ts
import * as Request from "effect/Request"
// Can be accessed like this
Request.succeed
```

**Signature**

```ts
export declare const succeed: {
  <A extends Request<any, any>>(value: Request.Success<A>): (self: A) => Effect.Effect<void>
  <A extends Request<any, any>>(self: A, value: Request.Success<A>): Effect.Effect<void>
}
```


# tagged

Constructs a new `Request`.

To import and use `tagged` from the "Request" module:

```ts
import * as Request from "effect/Request"
// Can be accessed like this
Request.tagged
```

**Signature**

```ts
export declare const tagged: <R extends Request<any, any> & { _tag: string }>(
  tag: R["_tag"]
) => Request.Constructor<R, "_tag">
```


# TaggedClass

Provides a Tagged constructor for a Request Class.

To import and use `TaggedClass` from the "Request" module:

```ts
import * as Request from "effect/Request"
// Can be accessed like this
Request.TaggedClass
```

**Example**

```ts
import { Request } from "effect"

type Success = string
type Error = never

class MyRequest extends Request.TaggedClass("MyRequest")<
  Success,
  Error,
  {
    readonly name: string
  }
> {}
```

**Signature**

```ts
export declare const TaggedClass: <Tag extends string>(
  tag: Tag
) => new <Success, Error, A extends Record<string, any>>(
  args: Types.Equals<Omit<A, keyof Request<unknown, unknown>>, {}> extends true
    ? void
    : { readonly [P in keyof A as P extends "_tag" | keyof Request<unknown, unknown> ? never : P]: A[P] }
) => Request<Success, Error> & Readonly<A> & { readonly _tag: Tag }
```


# RequestBlock

`RequestBlock` captures a collection of blocked requests as a data
structure. By doing this the library is able to preserve information about
which requests must be performed sequentially and which can be performed in
parallel, allowing for maximum possible batching and pipelining while
preserving ordering guarantees.

To import and use `RequestBlock` from the "RequestBlock" module:

```ts
import * as RequestBlock from "effect/RequestBlock"
// Can be accessed like this
RequestBlock.RequestBlock
```


# around

A data source aspect that executes requests between two effects, `before`
and `after`, where the result of `before` can be used by `after`.

To import and use `around` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.around
```

**Signature**

```ts
export declare const around: {
  <A2, R2, X, R3>(
    before: Effect.Effect<A2, never, R2>,
    after: (a: A2) => Effect.Effect<X, never, R3>
  ): <A, R>(self: RequestResolver<A, R>) => RequestResolver<A, R2 | R3 | R>
  <A, R, A2, R2, X, R3>(
    self: RequestResolver<A, R>,
    before: Effect.Effect<A2, never, R2>,
    after: (a: A2) => Effect.Effect<X, never, R3>
  ): RequestResolver<A, R | R2 | R3>
}
```


# aroundRequests

A data source aspect that executes requests between two effects, `before`
and `after`, where the result of `before` can be used by `after`.

The `before` and `after` effects are provided with the requests being executed.

To import and use `aroundRequests` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.aroundRequests
```

**Example**

```ts
import { Effect, Request, RequestResolver } from "effect"

interface GetUserById extends Request.Request<unknown> {
  readonly id: number
}

const resolver = RequestResolver.fromFunction((request: GetUserById) => ({ id: request.id, name: "John" }))

RequestResolver.aroundRequests(
  resolver,
  (requests) => Effect.log(`got ${requests.length} requests`),
  (requests, _) => Effect.log(`finised running ${requests.length} requests`)
)
```

**Signature**

```ts
export declare const aroundRequests: {
  <A, A2, R2, X, R3>(
    before: (requests: ReadonlyArray<Types.NoInfer<A>>) => Effect.Effect<A2, never, R2>,
    after: (requests: ReadonlyArray<Types.NoInfer<A>>, _: A2) => Effect.Effect<X, never, R3>
  ): <R>(self: RequestResolver<A, R>) => RequestResolver<A, R2 | R3 | R>
  <A, R, A2, R2, X, R3>(
    self: RequestResolver<A, R>,
    before: (requests: ReadonlyArray<Types.NoInfer<A>>) => Effect.Effect<A2, never, R2>,
    after: (requests: ReadonlyArray<Types.NoInfer<A>>, _: A2) => Effect.Effect<X, never, R3>
  ): RequestResolver<A, R | R2 | R3>
}
```


# batchN

Returns a data source that executes at most `n` requests in parallel.

To import and use `batchN` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.batchN
```

**Signature**

```ts
export declare const batchN: {
  (n: number): <A, R>(self: RequestResolver<A, R>) => RequestResolver<A, R>
  <A, R>(self: RequestResolver<A, R>, n: number): RequestResolver<A, R>
}
```


# eitherWith

Returns a new data source that executes requests of type `C` using the
specified function to transform `C` requests into requests that either this
data source or that data source can execute.

To import and use `eitherWith` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.eitherWith
```

**Signature**

```ts
export declare const eitherWith: {
  <A extends Request.Request<any, any>, R2, B extends Request.Request<any, any>, C extends Request.Request<any, any>>(
    that: RequestResolver<B, R2>,
    f: (_: Request.Entry<C>) => Either.Either<Request.Entry<B>, Request.Entry<A>>
  ): <R>(self: RequestResolver<A, R>) => RequestResolver<C, R2 | R>
  <
    R,
    A extends Request.Request<any, any>,
    R2,
    B extends Request.Request<any, any>,
    C extends Request.Request<any, any>
  >(
    self: RequestResolver<A, R>,
    that: RequestResolver<B, R2>,
    f: (_: Request.Entry<C>) => Either.Either<Request.Entry<B>, Request.Entry<A>>
  ): RequestResolver<C, R | R2>
}
```


# fromEffect

Constructs a data source from an effectual function.

To import and use `fromEffect` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.fromEffect
```

**Signature**

```ts
export declare const fromEffect: <R, A extends Request.Request<any, any>>(
  f: (a: A) => Effect.Effect<Request.Request.Success<A>, Request.Request.Error<A>, R>
) => RequestResolver<A, R>
```


# fromEffectTagged

Constructs a data source from a list of tags paired to functions, that takes
a list of requests and returns a list of results of the same size. Each item
in the result list must correspond to the item at the same index in the
request list.

To import and use `fromEffectTagged` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.fromEffectTagged
```

**Signature**

```ts
export declare const fromEffectTagged: <A extends Request.Request<any, any> & { readonly _tag: string }>() => <
  Fns extends {
    readonly [Tag in A["_tag"]]: [Extract<A, { readonly _tag: Tag }>] extends [infer Req]
      ? Req extends Request.Request<infer ReqA, infer ReqE>
        ? (requests: Array<Req>) => Effect.Effect<Iterable<ReqA>, ReqE, any>
        : never
      : never
  }
>(
  fns: Fns
) => RequestResolver<A, ReturnType<Fns[keyof Fns]> extends Effect.Effect<infer _A, infer _E, infer R> ? R : never>
```


# fromFunction

Constructs a data source from a pure function.

To import and use `fromFunction` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.fromFunction
```

**Signature**

```ts
export declare const fromFunction: <A extends Request.Request<any>>(
  f: (request: A) => Request.Request.Success<A>
) => RequestResolver<A>
```


# fromFunctionBatched

Constructs a data source from a pure function that takes a list of requests
and returns a list of results of the same size. Each item in the result
list must correspond to the item at the same index in the request list.

To import and use `fromFunctionBatched` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.fromFunctionBatched
```

**Signature**

```ts
export declare const fromFunctionBatched: <A extends Request.Request<any>>(
  f: (chunk: NonEmptyArray<A>) => Iterable<Request.Request.Success<A>>
) => RequestResolver<A>
```


# isRequestResolver

Returns `true` if the specified value is a `RequestResolver`, `false` otherwise.

To import and use `isRequestResolver` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.isRequestResolver
```

**Signature**

```ts
export declare const isRequestResolver: (u: unknown) => u is RequestResolver<unknown, unknown>
```


# locally

Returns a new data source with a localized FiberRef

To import and use `locally` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.locally
```

**Signature**

```ts
export declare const locally: {
  <A>(
    self: FiberRef<A>,
    value: A
  ): <R, B extends Request.Request<any, any>>(use: RequestResolver<B, R>) => RequestResolver<B, R>
  <R, B extends Request.Request<any, any>, A>(
    use: RequestResolver<B, R>,
    self: FiberRef<A>,
    value: A
  ): RequestResolver<B, R>
}
```


# make

Constructs a data source with the specified identifier and method to run
requests.

To import and use `make` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.make
```

**Signature**

```ts
export declare const make: <A, R>(
  runAll: (requests: Array<Array<A>>) => Effect.Effect<void, never, R>
) => RequestResolver<A, R>
```


# makeBatched

Constructs a data source from a function taking a collection of requests.

To import and use `makeBatched` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.makeBatched
```

**Signature**

```ts
export declare const makeBatched: <A extends Request.Request<any, any>, R>(
  run: (requests: NonEmptyArray<A>) => Effect.Effect<void, never, R>
) => RequestResolver<A, R>
```


# makeWithEntry

Constructs a data source with the specified identifier and method to run
requests.

To import and use `makeWithEntry` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.makeWithEntry
```

**Signature**

```ts
export declare const makeWithEntry: <A, R>(
  runAll: (requests: Array<Array<Request.Entry<A>>>) => Effect.Effect<void, never, R>
) => RequestResolver<A, R>
```


# mapInputContext

Provides this data source with part of its required context.

To import and use `mapInputContext` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.mapInputContext
```

**Signature**

```ts
export declare const mapInputContext: {
  <R0, R>(
    f: (context: Context.Context<R0>) => Context.Context<R>
  ): <A extends Request.Request<any, any>>(self: RequestResolver<A, R>) => RequestResolver<A, R0>
  <R, A extends Request.Request<any, any>, R0>(
    self: RequestResolver<A, R>,
    f: (context: Context.Context<R0>) => Context.Context<R>
  ): RequestResolver<A, R0>
}
```


# never

A data source that never executes requests.

To import and use `never` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.never
```

**Signature**

```ts
export declare const never: RequestResolver<never, never>
```


# provideContext

Provides this data source with its required context.

To import and use `provideContext` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.provideContext
```

**Signature**

```ts
export declare const provideContext: {
  <R>(
    context: Context.Context<R>
  ): <A extends Request.Request<any, any>>(self: RequestResolver<A, R>) => RequestResolver<A>
  <R, A extends Request.Request<any, any>>(self: RequestResolver<A, R>, context: Context.Context<R>): RequestResolver<A>
}
```


# race

Returns a new data source that executes requests by sending them to this
data source and that data source, returning the results from the first data
source to complete and safely interrupting the loser.

To import and use `race` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.race
```

**Signature**

```ts
export declare const race: {
  <A2 extends Request.Request<any, any>, R2>(
    that: RequestResolver<A2, R2>
  ): <A extends Request.Request<any, any>, R>(self: RequestResolver<A, R>) => RequestResolver<A2 | A, R2 | R>
  <A extends Request.Request<any, any>, R, A2 extends Request.Request<any, any>, R2>(
    self: RequestResolver<A, R>,
    that: RequestResolver<A2, R2>
  ): RequestResolver<A | A2, R | R2>
}
```


# RequestResolver

The `RequestResolver<A, R>` interface requires an environment `R` and handles
the execution of requests of type `A`.

Implementations must provide a `runAll` method, which processes a collection
of requests and produces an effect that fulfills these requests. Requests are
organized into a `Array<Array<A>>`, where the outer `Array` groups requests
into batches that are executed sequentially, and each inner `Array` contains
requests that can be executed in parallel. This structure allows
implementations to analyze all incoming requests collectively and optimize
query execution accordingly.

Implementations are typically specialized for a subtype of `Request<A, E>`.
However, they are not strictly limited to these subtypes as long as they can
map any given request type to `Request<A, E>`. Implementations should inspect
the collection of requests to identify the needed information and execute the
corresponding queries. It is imperative that implementations resolve all the
requests they receive. Failing to do so will lead to a `QueryFailure` error
during query execution.

To import and use `RequestResolver` from the "RequestResolver" module:

```ts
import * as RequestResolver from "effect/RequestResolver"
// Can be accessed like this
RequestResolver.RequestResolver
```


# auto

Creates a new `Resource` value that is automatically refreshed according to
the specified policy. Note that error retrying is not performed
automatically, so if you want to retry on errors, you should first apply
retry policies to the acquisition effect before passing it to this
constructor.

To import and use `auto` from the "Resource" module:

```ts
import * as Resource from "effect/Resource"
// Can be accessed like this
Resource.auto
```

**Signature**

```ts
export declare const auto: <A, E, R, Out, R2>(
  acquire: Effect.Effect<A, E, R>,
  policy: Schedule.Schedule<Out, unknown, R2>
) => Effect.Effect<Resource<A, E>, never, R | R2 | Scope.Scope>
```


# get

Retrieves the current value stored in the cache.

To import and use `get` from the "Resource" module:

```ts
import * as Resource from "effect/Resource"
// Can be accessed like this
Resource.get
```

**Signature**

```ts
export declare const get: <A, E>(self: Resource<A, E>) => Effect.Effect<A, E>
```


# manual

Creates a new `Resource` value that must be manually refreshed by calling
the refresh method. Note that error retrying is not performed
automatically, so if you want to retry on errors, you should first apply
retry policies to the acquisition effect before passing it to this
constructor.

To import and use `manual` from the "Resource" module:

```ts
import * as Resource from "effect/Resource"
// Can be accessed like this
Resource.manual
```

**Signature**

```ts
export declare const manual: <A, E, R>(
  acquire: Effect.Effect<A, E, R>
) => Effect.Effect<Resource<A, E>, never, Scope.Scope | R>
```


# refresh

Refreshes the cache. This method will not return until either the refresh
is successful, or the refresh operation fails.

To import and use `refresh` from the "Resource" module:

```ts
import * as Resource from "effect/Resource"
// Can be accessed like this
Resource.refresh
```

**Signature**

```ts
export declare const refresh: <A, E>(self: Resource<A, E>) => Effect.Effect<void, E>
```


# Resource

A `Resource` is a possibly resourceful value that is loaded into memory, and
which can be refreshed either manually or automatically.

To import and use `Resource` from the "Resource" module:

```ts
import * as Resource from "effect/Resource"
// Can be accessed like this
Resource.Resource
```


# runCallback

Executes the effect asynchronously, eventually passing the exit value to
the specified callback.

This method is effectful and should only be invoked at the edges of your
program.

To import and use `runCallback` from the "Runtime" module:

```ts
import * as Runtime from "effect/Runtime"
// Can be accessed like this
Runtime.runCallback
```

**Signature**

```ts
export declare const runCallback: <R>(
  runtime: Runtime<R>
) => <A, E>(effect: Effect.Effect<A, E, R>, options?: RunCallbackOptions<A, E> | undefined) => Cancel<A, E>
```


# runFork

Executes the effect using the provided Scheduler or using the global
Scheduler if not provided

To import and use `runFork` from the "Runtime" module:

```ts
import * as Runtime from "effect/Runtime"
// Can be accessed like this
Runtime.runFork
```

**Signature**

```ts
export declare const runFork: <R>(
  runtime: Runtime<R>
) => <A, E>(self: Effect.Effect<A, E, R>, options?: RunForkOptions) => Fiber.RuntimeFiber<A, E>
```


# runPromise

Runs the `Effect`, returning a JavaScript `Promise` that will be resolved
with the value of the effect once the effect has been executed, or will be
rejected with the first error or exception throw by the effect.

This method is effectful and should only be used at the edges of your
program.

To import and use `runPromise` from the "Runtime" module:

```ts
import * as Runtime from "effect/Runtime"
// Can be accessed like this
Runtime.runPromise
```

**Signature**

```ts
export declare const runPromise: <R>(
  runtime: Runtime<R>
) => <A, E>(effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal } | undefined) => Promise<A>
```


# runPromiseExit

Runs the `Effect`, returning a JavaScript `Promise` that will be resolved
with the `Exit` state of the effect once the effect has been executed.

This method is effectful and should only be used at the edges of your
program.

To import and use `runPromiseExit` from the "Runtime" module:

```ts
import * as Runtime from "effect/Runtime"
// Can be accessed like this
Runtime.runPromiseExit
```

**Signature**

```ts
export declare const runPromiseExit: <R>(
  runtime: Runtime<R>
) => <A, E>(
  effect: Effect.Effect<A, E, R>,
  options?: { readonly signal?: AbortSignal } | undefined
) => Promise<Exit.Exit<A, E>>
```


# runSync

Executes the effect synchronously throwing in case of errors or async boundaries.

This method is effectful and should only be invoked at the edges of your
program.

To import and use `runSync` from the "Runtime" module:

```ts
import * as Runtime from "effect/Runtime"
// Can be accessed like this
Runtime.runSync
```

**Signature**

```ts
export declare const runSync: <R>(runtime: Runtime<R>) => <A, E>(effect: Effect.Effect<A, E, R>) => A
```


# runSyncExit

Executes the effect synchronously returning the exit.

This method is effectful and should only be invoked at the edges of your
program.

To import and use `runSyncExit` from the "Runtime" module:

```ts
import * as Runtime from "effect/Runtime"
// Can be accessed like this
Runtime.runSyncExit
```

**Signature**

```ts
export declare const runSyncExit: <R>(runtime: Runtime<R>) => <A, E>(effect: Effect.Effect<A, E, R>) => Exit.Exit<A, E>
```


# cooperativeYielding

Returns `true` if the `CooperativeYielding` `RuntimeFlag` is enabled, `false`
otherwise.

To import and use `cooperativeYielding` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.cooperativeYielding
```

**Signature**

```ts
export declare const cooperativeYielding: (self: RuntimeFlags) => boolean
```


# CooperativeYielding

The cooperative yielding flag determines whether the Effect runtime will
yield to another fiber.

To import and use `CooperativeYielding` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.CooperativeYielding
```

**Signature**

```ts
export declare const CooperativeYielding: RuntimeFlag
```


# diff

Creates a `RuntimeFlagsPatch` which describes the difference between `self`
and `that`.

To import and use `diff` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.diff
```

**Signature**

```ts
export declare const diff: {
  (that: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlagsPatch.RuntimeFlagsPatch
  (self: RuntimeFlags, that: RuntimeFlags): RuntimeFlagsPatch.RuntimeFlagsPatch
}
```


# differ

Constructs a differ that knows how to diff `RuntimeFlags` values.

To import and use `differ` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.differ
```

**Signature**

```ts
export declare const differ: Differ.Differ<RuntimeFlags, RuntimeFlagsPatch.RuntimeFlagsPatch>
```


# disable

Disables the specified `RuntimeFlag`.

To import and use `disable` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.disable
```

**Signature**

```ts
export declare const disable: {
  (flag: RuntimeFlag): (self: RuntimeFlags) => RuntimeFlags
  (self: RuntimeFlags, flag: RuntimeFlag): RuntimeFlags
}
```


# disableAll

Disables all of the `RuntimeFlag`s in the specified set of `RuntimeFlags`.

To import and use `disableAll` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.disableAll
```

**Signature**

```ts
export declare const disableAll: {
  (flags: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlags
  (self: RuntimeFlags, flags: RuntimeFlags): RuntimeFlags
}
```


# enable

Enables the specified `RuntimeFlag`.

To import and use `enable` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.enable
```

**Signature**

```ts
export declare const enable: {
  (flag: RuntimeFlag): (self: RuntimeFlags) => RuntimeFlags
  (self: RuntimeFlags, flag: RuntimeFlag): RuntimeFlags
}
```


# enableAll

Enables all of the `RuntimeFlag`s in the specified set of `RuntimeFlags`.

To import and use `enableAll` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.enableAll
```

**Signature**

```ts
export declare const enableAll: {
  (flags: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlags
  (self: RuntimeFlags, flags: RuntimeFlags): RuntimeFlags
}
```


# interruptible

Returns true only if the `Interruption` flag is **enabled** and the
`WindDown` flag is **disabled**.

A fiber is said to be interruptible if interruption is enabled and the fiber
is not in its wind-down phase, in which it takes care of cleanup activities
related to fiber shutdown.

To import and use `interruptible` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.interruptible
```

**Signature**

```ts
export declare const interruptible: (self: RuntimeFlags) => boolean
```


# interruption

Returns `true` if the `Interruption` `RuntimeFlag` is enabled, `false`
otherwise.

To import and use `interruption` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.interruption
```

**Signature**

```ts
export declare const interruption: (self: RuntimeFlags) => boolean
```


# Interruption

The interruption flag determines whether or not the Effect runtime system will
interrupt a fiber.

To import and use `Interruption` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.Interruption
```

**Signature**

```ts
export declare const Interruption: RuntimeFlag
```


# isDisabled

Returns `true` if the specified `RuntimeFlag` is disabled, `false` otherwise.

To import and use `isDisabled` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.isDisabled
```

**Signature**

```ts
export declare const isDisabled: {
  (flag: RuntimeFlag): (self: RuntimeFlags) => boolean
  (self: RuntimeFlags, flag: RuntimeFlag): boolean
}
```


# isEnabled

Returns `true` if the specified `RuntimeFlag` is enabled, `false` otherwise.

To import and use `isEnabled` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.isEnabled
```

**Signature**

```ts
export declare const isEnabled: {
  (flag: RuntimeFlag): (self: RuntimeFlags) => boolean
  (self: RuntimeFlags, flag: RuntimeFlag): boolean
}
```


# None

No runtime flags.

To import and use `None` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.None
```

**Signature**

```ts
export declare const None: RuntimeFlag
```


# opSupervision

Returns `true` if the `OpSupervision` `RuntimeFlag` is enabled, `false`
otherwise.

To import and use `opSupervision` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.opSupervision
```

**Signature**

```ts
export declare const opSupervision: (self: RuntimeFlags) => boolean
```


# OpSupervision

The op supervision flag determines whether or not the Effect runtime system
will supervise all operations of the Effect runtime. Use of this flag will
negatively impact performance, but is required for some operations, such as
profiling.

To import and use `OpSupervision` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.OpSupervision
```

**Signature**

```ts
export declare const OpSupervision: RuntimeFlag
```


# patch

Patches a set of `RuntimeFlag`s with a `RuntimeFlagsPatch`, returning the
patched set of `RuntimeFlag`s.

To import and use `patch` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.patch
```

**Signature**

```ts
export declare const patch: {
  (patch: RuntimeFlagsPatch.RuntimeFlagsPatch): (self: RuntimeFlags) => RuntimeFlags
  (self: RuntimeFlags, patch: RuntimeFlagsPatch.RuntimeFlagsPatch): RuntimeFlags
}
```


# render

Converts the provided `RuntimeFlags` into a `string`.

To import and use `render` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.render
```

**Signature**

```ts
export declare const render: (self: RuntimeFlags) => string
```


# RuntimeFlag

Represents a flag that can be set to enable or disable a particular feature
of the Effect runtime.

To import and use `RuntimeFlag` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.RuntimeFlag
```


# RuntimeFlags

Represents a set of `RuntimeFlag`s. `RuntimeFlag`s affect the operation of
the Effect runtime system. They are exposed to application-level code because
they affect the behavior and performance of application code.

To import and use `RuntimeFlags` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.RuntimeFlags
```


# runtimeMetrics

Returns `true` if the `RuntimeMetrics` `RuntimeFlag` is enabled, `false`
otherwise.

To import and use `runtimeMetrics` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.runtimeMetrics
```

**Signature**

```ts
export declare const runtimeMetrics: (self: RuntimeFlags) => boolean
```


# RuntimeMetrics

The runtime metrics flag determines whether or not the Effect runtime system
will collect metrics about the Effect runtime. Use of this flag will have a
very small negative impact on performance, but generates very helpful
operational insight into running Effect applications that can be exported to
Prometheus or other tools via Effect Metrics.

To import and use `RuntimeMetrics` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.RuntimeMetrics
```

**Signature**

```ts
export declare const RuntimeMetrics: RuntimeFlag
```


# toSet

Converts the provided `RuntimeFlags` into a `ReadonlySet<number>`.

To import and use `toSet` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.toSet
```

**Signature**

```ts
export declare const toSet: (self: RuntimeFlags) => ReadonlySet<RuntimeFlag>
```


# windDown

Returns `true` if the `WindDown` `RuntimeFlag` is enabled, `false`
otherwise.

To import and use `windDown` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.windDown
```

**Signature**

```ts
export declare const windDown: (self: RuntimeFlags) => boolean
```


# WindDown

The wind down flag determines whether the Effect runtime system will execute
effects in wind-down mode. In wind-down mode, even if interruption is
enabled and a fiber has been interrupted, the fiber will continue its
execution uninterrupted.

To import and use `WindDown` from the "RuntimeFlags" module:

```ts
import * as RuntimeFlags from "effect/RuntimeFlags"
// Can be accessed like this
RuntimeFlags.WindDown
```

**Signature**

```ts
export declare const WindDown: RuntimeFlag
```


# andThen

Creates a `RuntimeFlagsPatch` describing the application of the `self` patch,
followed by `that` patch.

To import and use `andThen` from the "RuntimeFlagsPatch" module:

```ts
import * as RuntimeFlagsPatch from "effect/RuntimeFlagsPatch"
// Can be accessed like this
RuntimeFlagsPatch.andThen
```

**Signature**

```ts
export declare const andThen: {
  (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch
  (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch
}
```


# both

Creates a `RuntimeFlagsPatch` describing application of both the `self` patch
and `that` patch.

To import and use `both` from the "RuntimeFlagsPatch" module:

```ts
import * as RuntimeFlagsPatch from "effect/RuntimeFlagsPatch"
// Can be accessed like this
RuntimeFlagsPatch.both
```

**Signature**

```ts
export declare const both: {
  (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch
  (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch
}
```


# disable

Creates a `RuntimeFlagsPatch` describing disabling the provided `RuntimeFlag`.

To import and use `disable` from the "RuntimeFlagsPatch" module:

```ts
import * as RuntimeFlagsPatch from "effect/RuntimeFlagsPatch"
// Can be accessed like this
RuntimeFlagsPatch.disable
```

**Signature**

```ts
export declare const disable: (flag: RuntimeFlags.RuntimeFlag) => RuntimeFlagsPatch
```


# disabledSet

Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as
disabled by the specified `RuntimeFlagsPatch`.

To import and use `disabledSet` from the "RuntimeFlagsPatch" module:

```ts
import * as RuntimeFlagsPatch from "effect/RuntimeFlagsPatch"
// Can be accessed like this
RuntimeFlagsPatch.disabledSet
```

**Signature**

```ts
export declare const disabledSet: (self: RuntimeFlagsPatch) => ReadonlySet<RuntimeFlags.RuntimeFlag>
```


# either

Creates a `RuntimeFlagsPatch` describing application of either the `self`
patch or `that` patch.

To import and use `either` from the "RuntimeFlagsPatch" module:

```ts
import * as RuntimeFlagsPatch from "effect/RuntimeFlagsPatch"
// Can be accessed like this
RuntimeFlagsPatch.either
```

**Signature**

```ts
export declare const either: {
  (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch
  (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch
}
```


# empty

The empty `RuntimeFlagsPatch`.

To import and use `empty` from the "RuntimeFlagsPatch" module:

```ts
import * as RuntimeFlagsPatch from "effect/RuntimeFlagsPatch"
// Can be accessed like this
RuntimeFlagsPatch.empty
```

**Signature**

```ts
export declare const empty: RuntimeFlagsPatch
```


# enable

Creates a `RuntimeFlagsPatch` describing enabling the provided `RuntimeFlag`.

To import and use `enable` from the "RuntimeFlagsPatch" module:

```ts
import * as RuntimeFlagsPatch from "effect/RuntimeFlagsPatch"
// Can be accessed like this
RuntimeFlagsPatch.enable
```

**Signature**

```ts
export declare const enable: (flag: RuntimeFlags.RuntimeFlag) => RuntimeFlagsPatch
```


# enabledSet

Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as
enabled by the specified `RuntimeFlagsPatch`.

To import and use `enabledSet` from the "RuntimeFlagsPatch" module:

```ts
import * as RuntimeFlagsPatch from "effect/RuntimeFlagsPatch"
// Can be accessed like this
RuntimeFlagsPatch.enabledSet
```

**Signature**

```ts
export declare const enabledSet: (self: RuntimeFlagsPatch) => ReadonlySet<RuntimeFlags.RuntimeFlag>
```


# exclude

Creates a `RuntimeFlagsPatch` which describes exclusion of the specified
`RuntimeFlag` from the set of `RuntimeFlags`.

To import and use `exclude` from the "RuntimeFlagsPatch" module:

```ts
import * as RuntimeFlagsPatch from "effect/RuntimeFlagsPatch"
// Can be accessed like this
RuntimeFlagsPatch.exclude
```

**Signature**

```ts
export declare const exclude: {
  (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch
  (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): RuntimeFlagsPatch
}
```


# includes

Returns `true` if the `RuntimeFlagsPatch` includes the specified
`RuntimeFlag`, `false` otherwise.

To import and use `includes` from the "RuntimeFlagsPatch" module:

```ts
import * as RuntimeFlagsPatch from "effect/RuntimeFlagsPatch"
// Can be accessed like this
RuntimeFlagsPatch.includes
```

**Signature**

```ts
export declare const includes: {
  (flag: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => boolean
  (self: RuntimeFlagsPatch, flag: RuntimeFlagsPatch): boolean
}
```


# inverse

Creates a `RuntimeFlagsPatch` which describes the inverse of the patch
specified by the provided `RuntimeFlagsPatch`.

To import and use `inverse` from the "RuntimeFlagsPatch" module:

```ts
import * as RuntimeFlagsPatch from "effect/RuntimeFlagsPatch"
// Can be accessed like this
RuntimeFlagsPatch.inverse
```

**Signature**

```ts
export declare const inverse: (patch: RuntimeFlagsPatch) => RuntimeFlagsPatch
```


# isActive

Returns `true` if the `RuntimeFlagsPatch` describes the specified
`RuntimeFlag` as active.

To import and use `isActive` from the "RuntimeFlagsPatch" module:

```ts
import * as RuntimeFlagsPatch from "effect/RuntimeFlagsPatch"
// Can be accessed like this
RuntimeFlagsPatch.isActive
```

**Signature**

```ts
export declare const isActive: {
  (flag: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => boolean
  (self: RuntimeFlagsPatch, flag: RuntimeFlagsPatch): boolean
}
```


# isDisabled

Returns `true` if the `RuntimeFlagsPatch` describes the specified
`RuntimeFlag` as disabled.

To import and use `isDisabled` from the "RuntimeFlagsPatch" module:

```ts
import * as RuntimeFlagsPatch from "effect/RuntimeFlagsPatch"
// Can be accessed like this
RuntimeFlagsPatch.isDisabled
```

**Signature**

```ts
export declare const isDisabled: {
  (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => boolean
  (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): boolean
}
```


# isEmpty

Returns `true` if the specified `RuntimeFlagsPatch` is empty.

To import and use `isEmpty` from the "RuntimeFlagsPatch" module:

```ts
import * as RuntimeFlagsPatch from "effect/RuntimeFlagsPatch"
// Can be accessed like this
RuntimeFlagsPatch.isEmpty
```

**Signature**

```ts
export declare const isEmpty: (patch: RuntimeFlagsPatch) => boolean
```


# isEnabled

Returns `true` if the `RuntimeFlagsPatch` describes the specified
`RuntimeFlag` as enabled.

To import and use `isEnabled` from the "RuntimeFlagsPatch" module:

```ts
import * as RuntimeFlagsPatch from "effect/RuntimeFlagsPatch"
// Can be accessed like this
RuntimeFlagsPatch.isEnabled
```

**Signature**

```ts
export declare const isEnabled: {
  (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => boolean
  (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): boolean
}
```


# render

Renders the provided `RuntimeFlagsPatch` to a string.

To import and use `render` from the "RuntimeFlagsPatch" module:

```ts
import * as RuntimeFlagsPatch from "effect/RuntimeFlagsPatch"
// Can be accessed like this
RuntimeFlagsPatch.render
```

**Signature**

```ts
export declare const render: (self: RuntimeFlagsPatch) => string
```


# addDelay

Adds a delay to every interval in a schedule.

**Details**

This function modifies a given schedule by applying an additional delay to
every interval it defines. The delay is determined by the provided function,
which takes the schedule's output and returns a delay duration.

To import and use `addDelay` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.addDelay
```

**Signature**

```ts
export declare const addDelay: {
  <Out>(f: (out: Out) => Duration.DurationInput): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>
  <Out, In, R>(self: Schedule<Out, In, R>, f: (out: Out) => Duration.DurationInput): Schedule<Out, In, R>
}
```


# addDelayEffect

Adds an effectfully computed delay to every interval in a schedule.

**Details**

This function modifies a given schedule by applying an additional delay to
each interval, where the delay is determined by an effectful function. The
function takes the schedules output and returns an effect that produces a
delay duration.

To import and use `addDelayEffect` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.addDelayEffect
```

**Signature**

```ts
export declare const addDelayEffect: {
  <Out, R2>(
    f: (out: Out) => Effect.Effect<Duration.DurationInput, never, R2>
  ): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>
  <Out, In, R, R2>(
    self: Schedule<Out, In, R>,
    f: (out: Out) => Effect.Effect<Duration.DurationInput, never, R2>
  ): Schedule<Out, In, R | R2>
}
```


# andThen

Runs two schedules sequentially, merging their outputs.

**Details**

This function executes two schedules one after the other. The first schedule
runs to completion, and then the second schedule begins execution. Unlike
{@link andThenEither}, this function merges the outputs instead of wrapping
them in `Either`, allowing both schedules to contribute their results
directly.

This is useful when a workflow consists of two phases where the second phase
should start only after the first one has fully completed.

To import and use `andThen` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.andThen
```

**Signature**

```ts
export declare const andThen: {
  <Out2, In2, R2>(
    that: Schedule<Out2, In2, R2>
  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2 | Out, In & In2, R2 | R>
  <Out, In, R, Out2, In2, R2>(
    self: Schedule<Out, In, R>,
    that: Schedule<Out2, In2, R2>
  ): Schedule<Out | Out2, In & In2, R | R2>
}
```


# andThenEither

Runs two schedules sequentially, collecting results in an `Either`.

**Details**

This function combines two schedules in sequence. The first schedule runs to
completion, and then the second schedule starts and runs to completion as
well. The outputs of both schedules are collected into an `Either` structure:

- `Either.Left` contains the output of the second schedule.
- `Either.Right` contains the output of the first schedule.

This is useful when you need to switch from one schedule to another after the
first one finishes, while still keeping track of which schedule produced each
result.

To import and use `andThenEither` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.andThenEither
```

**Signature**

```ts
export declare const andThenEither: {
  <Out2, In2, R2>(
    that: Schedule<Out2, In2, R2>
  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Either.Either<Out2, Out>, In & In2, R2 | R>
  <Out, In, R, Out2, In2, R2>(
    self: Schedule<Out, In, R>,
    that: Schedule<Out2, In2, R2>
  ): Schedule<Either.Either<Out2, Out>, In & In2, R | R2>
}
```


# as

Transforms a schedule to always produce a constant output.

**Details**

This function modifies a given schedule so that instead of returning its
computed outputs, it always returns a constant value.

This is useful when you need a schedule for timing but dont care about its
actual output, or when you want to standardize results across different
scheduling strategies.

To import and use `as` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.as
```

**Signature**

```ts
export declare const as: {
  <Out2>(out: Out2): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R>
  <Out, In, R, Out2>(self: Schedule<Out, In, R>, out: Out2): Schedule<Out2, In, R>
}
```


# asVoid

Transforms a schedule to always return `void` instead of its output.

**Details**

This function modifies a given schedule so that it no longer returns
meaningful outputeach execution produces `void`. This is useful when the
schedule is used only for timing purposes and the actual output of the
schedule is irrelevant.

The schedule still determines when executions should occur, but the results
are discarded.

To import and use `asVoid` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.asVoid
```

**Signature**

```ts
export declare const asVoid: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<void, In, R>
```


# bothInOut

Combines two schedules, preserving both their inputs and outputs.

**Details**

This function merges two schedules so that both their input types and output
types are retained. When executed, the resulting schedule will take inputs
from both original schedules and produce a tuple containing both outputs.

It recurs if either schedule wants to continue, using the shorter delay.

This is useful when you want to track multiple schedules simultaneously,
ensuring that both receive the same inputs and produce combined results.

To import and use `bothInOut` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.bothInOut
```

**Signature**

```ts
export declare const bothInOut: {
  <Out2, In2, R2>(
    that: Schedule<Out2, In2, R2>
  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], readonly [In, In2], R2 | R>
  <Out, In, R, Out2, In2, R2>(
    self: Schedule<Out, In, R>,
    that: Schedule<Out2, In2, R2>
  ): Schedule<[Out, Out2], readonly [In, In2], R | R2>
}
```


# check

Filters schedule executions based on a custom condition.

**Details**

This function modifies a schedule by applying a custom test function to each
input-output pair. The test function determines whether the schedule should
continue or stop. If the function returns `true`, the schedule proceeds as
usual; if it returns `false`, the schedule terminates.

This is useful for conditional retries, custom stop conditions, or
dynamically controlling execution based on observed inputs and outputs.

To import and use `check` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.check
```

**Signature**

```ts
export declare const check: {
  <In, Out>(test: (input: In, output: Out) => boolean): <R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>
  <Out, In, R>(self: Schedule<Out, In, R>, test: (input: In, output: Out) => boolean): Schedule<Out, In, R>
}
```


# checkEffect

Conditionally filters schedule executions using an effectful function.

**Details**

This function modifies a schedule by applying a custom effectful test
function to each input-output pair. The test function determines whether the
schedule should continue (`true`) or stop (`false`).

This is useful when the decision to continue depends on external factors such
as database lookups, API calls, or other asynchronous computations.

To import and use `checkEffect` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.checkEffect
```

**Signature**

```ts
export declare const checkEffect: {
  <In, Out, R2>(
    test: (input: In, output: Out) => Effect.Effect<boolean, never, R2>
  ): <R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>
  <Out, In, R, R2>(
    self: Schedule<Out, In, R>,
    test: (input: In, output: Out) => Effect.Effect<boolean, never, R2>
  ): Schedule<Out, In, R | R2>
}
```


# collectAllInputs

A schedule that collects all inputs into a `Chunk`.

**Details**

This function creates a schedule that never terminates and continuously
collects every input it receives into a `Chunk`. Each time the schedule runs,
it appends the new input to the collected list.

This is useful when you need to track all received inputs over time, such as
logging user actions, recording retry attempts, or accumulating data for
later processing.

To import and use `collectAllInputs` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.collectAllInputs
```

**Signature**

```ts
export declare const collectAllInputs: <A>() => Schedule<Chunk.Chunk<A>, A>
```


# collectAllOutputs

Collects all outputs of a schedule into a `Chunk`.

**Details**

This function modifies a given schedule so that instead of returning
individual outputs, it accumulates them into a `Chunk`. The schedule
continues to run, appending each output to the collected list.

This is useful when you need to track all results over time, such as logging
outputs, aggregating data, or keeping a history of previous values.

To import and use `collectAllOutputs` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.collectAllOutputs
```

**Signature**

```ts
export declare const collectAllOutputs: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Chunk.Chunk<Out>, In, R>
```


# collectUntil

Collects all inputs into a `Chunk` until a condition fails.

**Details**

This function creates a schedule that continuously collects inputs into a
`Chunk` until the given predicate function `f` evaluates to `false`. Once the
condition fails, the schedule stops.

To import and use `collectUntil` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.collectUntil
```

**Signature**

```ts
export declare const collectUntil: <A>(f: Predicate<A>) => Schedule<Chunk.Chunk<A>, A>
```


# collectUntilEffect

Collects all inputs into a `Chunk` until an effectful condition fails.

**Details**

This function creates a schedule that continuously collects inputs into a
`Chunk` until the given effectful predicate `f` returns `false`. The
predicate runs as an effect, meaning it can involve asynchronous computations
like API calls, database lookups, or randomness.

To import and use `collectUntilEffect` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.collectUntilEffect
```

**Signature**

```ts
export declare const collectUntilEffect: <A, R>(
  f: (a: A) => Effect.Effect<boolean, never, R>
) => Schedule<Chunk.Chunk<A>, A, R>
```


# collectWhile

Collects all inputs into a `Chunk` while a condition holds.

**Details**

This function creates a schedule that continuously collects inputs into a
`Chunk` while the given predicate function `f` evaluates to `true`. As soon
as the condition fails, the schedule stops.

To import and use `collectWhile` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.collectWhile
```

**Signature**

```ts
export declare const collectWhile: <A>(f: Predicate<A>) => Schedule<Chunk.Chunk<A>, A>
```


# collectWhileEffect

Collects all inputs into a `Chunk` while an effectful condition holds.

**Details**

This function creates a schedule that continuously collects inputs into a
`Chunk` while the given effectful predicate `f` returns `true`. The predicate
returns an effect, meaning it can depend on external state, such as database
queries, API responses, or real-time user conditions.

As soon as the effectful condition returns `false`, the schedule stops. This
is useful for dynamically controlled data collection, where stopping depends
on an external or asynchronous factor.

To import and use `collectWhileEffect` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.collectWhileEffect
```

**Signature**

```ts
export declare const collectWhileEffect: <A, R>(
  f: (a: A) => Effect.Effect<boolean, never, R>
) => Schedule<Chunk.Chunk<A>, A, R>
```


# compose

Chains two schedules, passing the output of the first as the input to the
second, while selecting the shorter delay between them.

**Details**

This function composes two schedules so that the output of the first schedule
becomes the input of the second schedule. The first schedule executes first,
and once it produces a result, the second schedule receives that result and
continues execution based on it.

This is useful for building complex scheduling workflows where one schedule's
behavior determines how the next schedule behaves.

To import and use `compose` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.compose
```

**Signature**

```ts
export declare const compose: {
  <Out2, Out, R2>(that: Schedule<Out2, Out, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R2 | R>
  <Out, In, R, Out2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, Out, R2>): Schedule<Out2, In, R | R2>
}
```


# count

A schedule that recurs indefinitely, counting the number of recurrences.

**Details**

This schedule never stops and simply counts how many times it has executed.
Each recurrence increases the count, starting from `0`.

This is useful when tracking the number of attempts in retry policies,
measuring execution loops, or implementing infinite polling scenarios.

To import and use `count` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.count
```

**Signature**

```ts
export declare const count: Schedule<number, unknown, never>
```


# cron

Creates a schedule that recurs based on a cron expression.

**Details**

This schedule automatically executes at intervals defined by a cron
expression. It triggers at the beginning of each matched interval and
produces timestamps representing the start and end of the cron window.

The cron `expression` is validated lazily, meaning errors may only be
detected when the schedule is executed.

To import and use `cron` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.cron
```

**Signature**

```ts
export declare const cron: {
  (cron: Cron.Cron): Schedule<[number, number]>
  (expression: string, tz?: DateTime.TimeZone | string): Schedule<[number, number]>
}
```


# dayOfMonth

Creates a schedule that recurs on a specific day of the month.

**Details**

This schedule triggers at midnight on the specified day of each month. It
will not execute in months that have fewer days than the given day. For
example, if the schedule is set to run on the 31st, it will not execute in
months with only 30 days.

The schedule produces a count of executions, starting at 0 and incrementing
with each recurrence.

The `day` parameter is validated lazily, meaning errors may only be detected
when the schedule is executed.

To import and use `dayOfMonth` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.dayOfMonth
```

**Signature**

```ts
export declare const dayOfMonth: (day: number) => Schedule<number>
```


# dayOfWeek

Creates a schedule that recurs on a specific day of the week.

**Details**

This schedule triggers at midnight on the specified day of the week. The
`day` parameter follows the standard convention where `Monday = 1` and
`Sunday = 7`. The schedule produces a count of executions, starting at 0 and
incrementing with each recurrence.

The `day` parameter is validated lazily, meaning errors may only be detected
when the schedule is executed.

To import and use `dayOfWeek` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.dayOfWeek
```

**Signature**

```ts
export declare const dayOfWeek: (day: number) => Schedule<number>
```


# delayed

Modifies a schedule by adding a computed delay before each execution.

**Details**

This function adjusts an existing schedule by applying a transformation to
its delays. Instead of using the default interval, each delay is modified
using the provided function `f`, which takes the current delay and returns a
new delay.

This is useful for dynamically adjusting wait times between executions, such
as introducing jitter, exponential backoff, or custom delay logic.

To import and use `delayed` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.delayed
```

**Signature**

```ts
export declare const delayed: {
  (
    f: (duration: Duration.Duration) => Duration.DurationInput
  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>
  <Out, In, R>(
    self: Schedule<Out, In, R>,
    f: (duration: Duration.Duration) => Duration.DurationInput
  ): Schedule<Out, In, R>
}
```


# delayedEffect

Modifies a schedule by adding an effectfully computed delay before each
execution.

**Details**

This function adjusts an existing schedule by introducing a delay that is
computed via an effect. Instead of using a fixed delay, each interval is
dynamically adjusted based on an effectful function `f`, which takes the
current delay and returns a new delay wrapped in an `Effect`.

This is useful for adaptive scheduling where delays depend on external
factors, such as API calls, database queries, or dynamic system conditions.

To import and use `delayedEffect` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.delayedEffect
```

**Signature**

```ts
export declare const delayedEffect: {
  <R2>(
    f: (duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>
  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>
  <Out, In, R, R2>(
    self: Schedule<Out, In, R>,
    f: (duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>
  ): Schedule<Out, In, R | R2>
}
```


# delayedSchedule

Uses the delays produced by a schedule to further delay its intervals.

**Details**

This function modifies a schedule by using its own output delays to control
its execution timing. Instead of executing immediately at each interval, the
schedule will be delayed by the duration it produces.

To import and use `delayedSchedule` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.delayedSchedule
```

**Signature**

```ts
export declare const delayedSchedule: <In, R>(
  schedule: Schedule<Duration.Duration, In, R>
) => Schedule<Duration.Duration, In, R>
```


# delays

Transforms a schedule to output the delay between each occurrence.

**Details**

This function modifies an existing schedule so that instead of producing its
original output, it now returns the delay between each scheduled execution.

To import and use `delays` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.delays
```

**Signature**

```ts
export declare const delays: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Duration.Duration, In, R>
```


# driver

Creates a driver to manually control the execution of a schedule.

**Details**

This function returns a `ScheduleDriver`, which allows stepping through a
schedule manually while handling delays and sleeping appropriately. A driver
is useful when you need fine-grained control over how a schedule progresses,
rather than relying on automatic execution.

The returned driver exposes methods for retrieving the current state,
executing the next step, and resetting the schedule when needed.

To import and use `driver` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.driver
```

**Signature**

```ts
export declare const driver: <Out, In, R>(self: Schedule<Out, In, R>) => Effect.Effect<ScheduleDriver<Out, In, R>>
```


# duration

Alias of {@link fromDelay}.

To import and use `duration` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.duration
```

**Signature**

```ts
export declare const duration: (duration: Duration.DurationInput) => Schedule<Duration.Duration>
```


# either

Alias of {@link union}.

To import and use `either` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.either
```

**Signature**

```ts
export declare const either: {
  <Out2, In2, R2>(
    that: Schedule<Out2, In2, R2>
  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>
  <Out, In, R, Out2, In2, R2>(
    self: Schedule<Out, In, R>,
    that: Schedule<Out2, In2, R2>
  ): Schedule<[Out, Out2], In & In2, R | R2>
}
```


# eitherWith

Alias of {@link unionWith}.

To import and use `eitherWith` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.eitherWith
```

**Signature**

```ts
export declare const eitherWith: {
  <Out2, In2, R2>(
    that: Schedule<Out2, In2, R2>,
    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals
  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>
  <Out, In, R, Out2, In2, R2>(
    self: Schedule<Out, In, R>,
    that: Schedule<Out2, In2, R2>,
    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals
  ): Schedule<[Out, Out2], In & In2, R | R2>
}
```


# elapsed

Creates a schedule that tracks the total elapsed duration since it started.

**Details**

This schedule executes continuously and returns the total time that has
passed since the first execution. The duration keeps increasing with each
step, providing a way to measure elapsed time.

This is useful for tracking execution time, monitoring delays, or
implementing logic based on how long a process has been running.

To import and use `elapsed` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.elapsed
```

**Signature**

```ts
export declare const elapsed: Schedule<Duration.Duration, unknown, never>
```


# ensuring

Attaches a finalizer to a schedule that runs when the schedule completes.

**Details**

This function returns a new schedule that executes a given finalizer when the
schedule reaches completion. Unlike `Effect.ensuring`, this method does not
guarantee the finalizer will run in all cases. If the schedule never
initializes or is not driven to completion, the finalizer may not execute.
However, if the schedule decides not to continue, the finalizer will be
invoked.

This is useful for cleaning up resources, logging, or executing other side
effects when a schedule completes.

To import and use `ensuring` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.ensuring
```

**Signature**

```ts
export declare const ensuring: {
  <X>(finalizer: Effect.Effect<X, never, never>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>
  <Out, In, R, X>(self: Schedule<Out, In, R>, finalizer: Effect.Effect<X, never, never>): Schedule<Out, In, R>
}
```


# exponential

Creates a schedule that recurs indefinitely with exponentially increasing
delays.

**Details**

This schedule starts with an initial delay of `base` and increases the delay
exponentially on each repetition using the formula `base * factor^n`, where
`n` is the number of times the schedule has executed so far. If no `factor`
is provided, it defaults to `2`, causing the delay to double after each
execution.

To import and use `exponential` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.exponential
```

**Signature**

```ts
export declare const exponential: (base: Duration.DurationInput, factor?: number) => Schedule<Duration.Duration>
```


# fibonacci

Creates a schedule that recurs indefinitely with Fibonacci-based increasing
delays.

**Details**

This schedule starts with an initial delay of `one` and increases subsequent
delays by summing the two previous delays, following the Fibonacci sequence.
The delay pattern follows: `one, one, one + one, (one + one) + one, ...`,
resulting in `1s, 1s, 2s, 3s, 5s, 8s, 13s, ...` if `one = 1s`.

This is useful for progressive backoff strategies, where delays grow
naturally over time without increasing as aggressively as an exponential
schedule.

To import and use `fibonacci` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.fibonacci
```

**Signature**

```ts
export declare const fibonacci: (one: Duration.DurationInput) => Schedule<Duration.Duration>
```


# fixed

Creates a schedule that recurs at a fixed interval.

**Details**

This schedule executes at regular, evenly spaced intervals, returning the
number of times it has run so far. If the action being executed takes longer
than the interval, the next execution will happen immediately to prevent
"pile-ups," ensuring that the schedule remains consistent without overlapping
executions.

```
|-----interval-----|-----interval-----|-----interval-----|
|---------action--------||action|-----|action|-----------|
```

To import and use `fixed` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.fixed
```

**Signature**

```ts
export declare const fixed: (interval: Duration.DurationInput) => Schedule<number>
```


# forever

Creates a schedule that recurs indefinitely, producing a count of
repetitions.

**Details**

This schedule runs indefinitely, returning an increasing count of executions
(`0, 1, 2, 3, ...`). Each step increments the count by one, allowing tracking
of how many times it has executed.

To import and use `forever` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.forever
```

**Signature**

```ts
export declare const forever: Schedule<number, unknown, never>
```


# fromDelay

Creates a schedule that recurs once after a specified duration.

**Details**

This schedule executes a single time after waiting for the given duration.
Once it has executed, it does not repeat.

To import and use `fromDelay` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.fromDelay
```

**Signature**

```ts
export declare const fromDelay: (delay: Duration.DurationInput) => Schedule<Duration.Duration>
```


# fromDelays

Creates a schedule that recurs once for each specified duration, applying the
given delays sequentially.

**Details**

This schedule executes multiple times, each time waiting for the
corresponding duration from the provided list of delays. The first execution
waits for `delay`, the next for the second value in `delays`, and so on. Once
all delays have been used, the schedule stops executing.

This is useful for defining a custom delay sequence that does not follow a
fixed pattern like exponential or Fibonacci backoff.

To import and use `fromDelays` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.fromDelays
```

**Signature**

```ts
export declare const fromDelays: (
  delay: Duration.DurationInput,
  ...delays: Array<Duration.DurationInput>
) => Schedule<Duration.Duration>
```


# fromFunction

Creates a schedule that always recurs, transforming input values using the
specified function.

**Details**

This schedule continuously executes and applies the given function `f` to
each input value, producing a transformed output. The schedule itself does
not control delays or stopping conditions; it simply transforms the input
values as they are processed.

This is useful when defining schedules that map inputs to outputs, allowing
dynamic transformations of incoming data.

To import and use `fromFunction` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.fromFunction
```

**Signature**

```ts
export declare const fromFunction: <A, B>(f: (a: A) => B) => Schedule<B, A>
```


# hourOfDay

Creates a schedule that recurs at a specific hour of each day.

**Details**

This schedule triggers once per day at the specified `hour`, starting at zero
minutes of that hour. The schedule produces a count of executions (`0, 1, 2,
...`), indicating how many times it has been triggered.

The `hour` parameter must be between `0` (midnight) and `23` (11 PM). It is
validated lazily, meaning an invalid value will cause errors only when the
schedule is executed.

This is useful for scheduling daily recurring tasks at a fixed time, such as
running batch jobs or refreshing data.

To import and use `hourOfDay` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.hourOfDay
```

**Signature**

```ts
export declare const hourOfDay: (hour: number) => Schedule<number>
```


# identity

Creates a schedule that always recurs, passing inputs directly as outputs.

**Details**

This schedule runs indefinitely, returning each input value as its output
without modification. It effectively acts as a pass-through that simply
echoes its input values at each step.

To import and use `identity` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.identity
```

**Signature**

```ts
export declare const identity: <A>() => Schedule<A, A>
```


# intersect

Combines two schedules, continuing only if both schedules want to continue,
using the longer delay.

**Details**

This function takes two schedules and creates a new schedule that only
continues execution if both schedules allow it. The interval between
recurrences is determined by the longer delay between the two schedules.

The output of the resulting schedule is a tuple containing the outputs of
both schedules. The input type is the intersection of both schedules' input
types.

This is useful when coordinating multiple scheduling conditions where
execution should proceed only when both schedules permit it.

To import and use `intersect` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.intersect
```

**Signature**

```ts
export declare const intersect: {
  <Out2, In2, R2>(
    that: Schedule<Out2, In2, R2>
  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>
  <Out, In, R, Out2, In2, R2>(
    self: Schedule<Out, In, R>,
    that: Schedule<Out2, In2, R2>
  ): Schedule<[Out, Out2], In & In2, R | R2>
}
```


# intersectWith

Combines two schedules, continuing only if both want to continue, merging
intervals using a custom function.

**Details**

This function takes two schedules and creates a new schedule that only
continues execution if both schedules allow it. Instead of automatically
using the longer delay (like {@link intersect}), this function applies a
user-provided merge function `f` to determine the next interval between
executions.

The output of the resulting schedule is a tuple containing the outputs of
both schedules, and the input type is the intersection of both schedules'
input types.

To import and use `intersectWith` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.intersectWith
```

**Signature**

```ts
export declare const intersectWith: {
  <Out2, In2, R2>(
    that: Schedule<Out2, In2, R2>,
    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals
  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>
  <Out, In, R, Out2, In2, R2>(
    self: Schedule<Out, In, R>,
    that: Schedule<Out2, In2, R2>,
    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals
  ): Schedule<[Out, Out2], In & In2, R | R2>
}
```


# isSchedule

Checks whether a given value is a `Schedule`.

To import and use `isSchedule` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.isSchedule
```

**Signature**

```ts
export declare const isSchedule: (u: unknown) => u is Schedule<unknown, never, unknown>
```


# jittered

Returns a new schedule that randomly adjusts the interval size within a
range.

**Details**

This function modifies a schedule so that its delay between executions is
randomly varied within a range. By default, the delay is adjusted between
`80%` (`0.8 * interval`) and `120%` (`1.2 * interval`) of the original
interval size.

This is useful for adding randomness to repeated executions, reducing
contention in distributed systems, and avoiding synchronized execution
patterns that can cause bottlenecks.

To import and use `jittered` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.jittered
```

**Signature**

```ts
export declare const jittered: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>
```


# jitteredWith

Returns a new schedule that randomly adjusts the interval size within a
user-defined range.

**Details**

This function modifies a schedule so that its delay between executions is
randomly varied within a specified range. Instead of using the default `0.8 -
1.2` range like {@link jittered}, this function allows customizing the `min`
and `max` multipliers.

The delay for each step will be adjusted within `min * original_interval` and
`max * original_interval`. If `min` and `max` are not provided, the defaults
are `0.8` and `1.2`, respectively.

This is useful for introducing randomness into scheduling behavior while
having precise control over the jitter range.

To import and use `jitteredWith` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.jitteredWith
```

**Signature**

```ts
export declare const jitteredWith: {
  (options: {
    min?: number | undefined
    max?: number | undefined
  }): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>
  <Out, In, R>(
    self: Schedule<Out, In, R>,
    options: { min?: number | undefined; max?: number | undefined }
  ): Schedule<Out, In, R>
}
```


# linear

Creates a schedule that recurs indefinitely, increasing the delay linearly.

**Details**

This schedule starts with an initial delay of `base` and increases the delay
on each recurrence in a linear fashion, following the formula:

`delay = base * n`

where `n` is the number of times the schedule has executed so far. This
results in increasing intervals between executions.

This is useful for implementing linear backoff strategies where the wait time
between retries increases at a steady rate.

To import and use `linear` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.linear
```

**Signature**

```ts
export declare const linear: (base: Duration.DurationInput) => Schedule<Duration.Duration>
```


# makeWithState

Creates a new schedule with a custom state and step function.

**Details**

This function constructs a `Schedule` by defining its initial state and a
step function, which determines how the schedule progresses over time. The
step function is called on each iteration with the current time, an input
value, and the schedule's current state. It returns the next state, an output
value, and a decision on whether the schedule should continue or stop.

This function is useful for creating custom scheduling logic that goes beyond
predefined schedules like fixed intervals or exponential backoff. It allows
full control over how the schedule behaves at each step.

To import and use `makeWithState` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.makeWithState
```

**Signature**

```ts
export declare const makeWithState: <S, In, Out, R = never>(
  initial: S,
  step: (
    now: number,
    input: In,
    state: S
  ) => Effect.Effect<readonly [S, Out, ScheduleDecision.ScheduleDecision], never, R>
) => Schedule<Out, In, R>
```


# map

Returns a new schedule that transforms its output using the specified
function.

**Details**

This function modifies an existing schedule so that its outputs are
transformed by the provided function `f`. The timing and recurrence behavior
of the schedule remain unchanged, but the values it produces are mapped to
new values.

This is useful when composing schedules where you need to adjust the output
format or apply additional processing.

To import and use `map` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.map
```

**Signature**

```ts
export declare const map: {
  <Out, Out2>(f: (out: Out) => Out2): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R>
  <Out, In, R, Out2>(self: Schedule<Out, In, R>, f: (out: Out) => Out2): Schedule<Out2, In, R>
}
```


# mapBoth

Transforms both the input and output of a schedule.

**Details**

This function modifies an existing schedule by applying a transformation to
both its input values and its output values. The provided transformation
functions `onInput` and `onOutput` allow you to map the schedule to work with
a different input type while modifying its outputs as well.

To import and use `mapBoth` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.mapBoth
```

**Signature**

```ts
export declare const mapBoth: {
  <In2, In, Out, Out2>(options: {
    readonly onInput: (in2: In2) => In
    readonly onOutput: (out: Out) => Out2
  }): <R>(self: Schedule<Out, In, R>) => Schedule<Out2, In2, R>
  <Out, In, R, In2, Out2>(
    self: Schedule<Out, In, R>,
    options: { readonly onInput: (in2: In2) => In; readonly onOutput: (out: Out) => Out2 }
  ): Schedule<Out2, In2, R>
}
```


# mapBothEffect

Transforms both the input and output of a schedule using effectful
computations.

**Details**

This function modifies an existing schedule by applying effectful
transformations to both its input values and its output values. The provided
effectful functions `onInput` and `onOutput` allow you to transform inputs
and outputs using computations that may involve additional logic, resource
access, or side effects.

To import and use `mapBothEffect` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.mapBothEffect
```

**Signature**

```ts
export declare const mapBothEffect: {
  <In2, In, R2, Out, R3, Out2>(options: {
    readonly onInput: (input: In2) => Effect.Effect<In, never, R2>
    readonly onOutput: (out: Out) => Effect.Effect<Out2, never, R3>
  }): <R>(self: Schedule<Out, In, R>) => Schedule<Out2, In2, R2 | R3 | R>
  <Out, In, R, In2, R2, Out2, R3>(
    self: Schedule<Out, In, R>,
    options: {
      readonly onInput: (input: In2) => Effect.Effect<In, never, R2>
      readonly onOutput: (out: Out) => Effect.Effect<Out2, never, R3>
    }
  ): Schedule<Out2, In2, R | R2 | R3>
}
```


# mapEffect

Returns a new schedule that applies an effectful transformation to its
output.

**Details**

This function modifies an existing schedule by applying an effectful function
`f` to its output values. The timing and recurrence behavior of the schedule
remain unchanged, but each output is mapped to a new value within an
`Effect`.

This is useful when you need to perform side effects or asynchronous
transformations before passing the output forward.

To import and use `mapEffect` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.mapEffect
```

**Signature**

```ts
export declare const mapEffect: {
  <Out, Out2, R2>(
    f: (out: Out) => Effect.Effect<Out2, never, R2>
  ): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R2 | R>
  <Out, In, R, Out2, R2>(
    self: Schedule<Out, In, R>,
    f: (out: Out) => Effect.Effect<Out2, never, R2>
  ): Schedule<Out2, In, R | R2>
}
```


# mapInput

Transforms the input type of a schedule.

**Details**

This function modifies a given schedule by applying a transformation function
to its inputs. Instead of directly receiving values of type `In`, the
schedule will now accept values of type `In2`, which are converted to `In`
using the provided mapping function `f`.

This is useful when you have a schedule that expects a specific input type
but you need to adapt it to work with a different type.

To import and use `mapInput` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.mapInput
```

**Signature**

```ts
export declare const mapInput: {
  <In, In2>(f: (in2: In2) => In): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In2, R>
  <Out, In, R, In2>(self: Schedule<Out, In, R>, f: (in2: In2) => In): Schedule<Out, In2, R>
}
```


# mapInputContext

Transforms the required context of a schedule.

**Details**

This function modifies a schedule by mapping its required context (`R`) into
a new context (`R0`) using the provided function `f`.

This is useful when you need to adapt a schedule to work with a different
dependency environment without changing its core logic.

To import and use `mapInputContext` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.mapInputContext
```

**Signature**

```ts
export declare const mapInputContext: {
  <R0, R>(
    f: (env0: Context.Context<R0>) => Context.Context<R>
  ): <Out, In>(self: Schedule<Out, In, R>) => Schedule<Out, In, R0>
  <Out, In, R, R0>(
    self: Schedule<Out, In, R>,
    f: (env0: Context.Context<R0>) => Context.Context<R>
  ): Schedule<Out, In, R0>
}
```


# mapInputEffect

Transforms the input type of a schedule using an effectful function.

**Details**

This function modifies a schedule by applying an effectful transformation to
its inputs. Instead of directly receiving values of type `In`, the schedule
will now accept values of type `In2`, which are converted to `In` via an
effectful function `f`.

This is useful when the input transformation involves external dependencies,
such as API calls, database lookups, or other asynchronous computations.

To import and use `mapInputEffect` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.mapInputEffect
```

**Signature**

```ts
export declare const mapInputEffect: {
  <In2, In, R2>(
    f: (in2: In2) => Effect.Effect<In, never, R2>
  ): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In2, R2 | R>
  <Out, In, R, In2, R2>(
    self: Schedule<Out, In, R>,
    f: (in2: In2) => Effect.Effect<In, never, R2>
  ): Schedule<Out, In2, R | R2>
}
```


# minuteOfHour

Creates a schedule that recurs every specified minute of each hour.

**Details**

This schedule triggers once per hour at the specified `minute`, starting
exactly at `minute:00` (zero seconds). The schedule produces a count of
executions (`0, 1, 2, ...`), representing how many times it has run.

The `minute` parameter must be between `0` and `59`. It is validated lazily,
meaning an invalid value will cause errors only when the schedule is
executed.

To import and use `minuteOfHour` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.minuteOfHour
```

**Signature**

```ts
export declare const minuteOfHour: (minute: number) => Schedule<number>
```


# modifyDelay

Returns a new schedule that modifies the delay between executions using a
custom function.

**Details**

This function transforms an existing schedule by applying `f` to modify the
delay before each execution. The function receives both the schedule's output
(`out`) and the originally computed delay (`duration`), and returns a new
adjusted delay.

To import and use `modifyDelay` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.modifyDelay
```

**Signature**

```ts
export declare const modifyDelay: {
  <Out>(
    f: (out: Out, duration: Duration.Duration) => Duration.DurationInput
  ): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>
  <Out, In, R>(
    self: Schedule<Out, In, R>,
    f: (out: Out, duration: Duration.Duration) => Duration.DurationInput
  ): Schedule<Out, In, R>
}
```


# modifyDelayEffect

Returns a new schedule that modifies the delay before execution using an
effectful function.

**Details**

This function takes an existing schedule and applies an effectful function
`f` to dynamically adjust the delay before each execution. The function
receives both the schedule's output (`out`) and the originally computed delay
(`duration`), returning a new adjusted delay wrapped in an `Effect`.

To import and use `modifyDelayEffect` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.modifyDelayEffect
```

**Signature**

```ts
export declare const modifyDelayEffect: {
  <Out, R2>(
    f: (out: Out, duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>
  ): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>
  <Out, In, R, R2>(
    self: Schedule<Out, In, R>,
    f: (out: Out, duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>
  ): Schedule<Out, In, R | R2>
}
```


# once

A schedule that executes only once and then stops.

**Details**

This schedule triggers a single execution and then terminates. It does not
repeat or apply any additional logic.

To import and use `once` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.once
```

**Signature**

```ts
export declare const once: Schedule<void, unknown, never>
```


# onDecision

Returns a new schedule that executes an effect every time the schedule makes
a decision.

**Details**

This function enhances an existing schedule by running an effectful function
`f` whenever a scheduling decision is made. The function receives the current
schedule output (`out`) and the decision (`ScheduleDecision`), allowing
additional logic to be executed, such as logging, monitoring, or side
effects.

To import and use `onDecision` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.onDecision
```

**Signature**

```ts
export declare const onDecision: {
  <Out, X, R2>(
    f: (out: Out, decision: ScheduleDecision.ScheduleDecision) => Effect.Effect<X, never, R2>
  ): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>
  <Out, In, R, X, R2>(
    self: Schedule<Out, In, R>,
    f: (out: Out, decision: ScheduleDecision.ScheduleDecision) => Effect.Effect<X, never, R2>
  ): Schedule<Out, In, R | R2>
}
```


# passthrough

Transforms a schedule to pass through its inputs as outputs.

**Details**

This function modifies an existing schedule so that it returns its input
values instead of its original output values. The schedule's timing remains
unchanged, but its outputs are replaced with whatever inputs it receives.

To import and use `passthrough` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.passthrough
```

**Signature**

```ts
export declare const passthrough: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<In, In, R>
```


# provideContext

Returns a new schedule with a provided context, eliminating the need for
external dependencies.

**Details**

This function supplies a required `context` to a schedule, allowing it to run
without requiring external dependencies. After calling this function, the
schedule can be used freely without needing to pass a context at execution
time.

This is useful when working with schedules that rely on contextual
information, such as logging services, database connections, or configuration
settings.

To import and use `provideContext` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.provideContext
```

**Signature**

```ts
export declare const provideContext: {
  <R>(context: Context.Context<R>): <Out, In>(self: Schedule<Out, In, R>) => Schedule<Out, In, never>
  <Out, In, R>(self: Schedule<Out, In, R>, context: Context.Context<R>): Schedule<Out, In, never>
}
```


# provideService

Returns a new schedule with a single required service provided, eliminating
the need for external dependencies.

**Details**

This function supplies a single service dependency to a schedule, allowing it
to run without requiring that service externally. If a schedule depends on
multiple services, consider using `provideContext` instead.

This is useful when working with schedules that require a specific service,
such as logging, metrics, or configuration retrieval.

To import and use `provideService` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.provideService
```

**Signature**

```ts
export declare const provideService: {
  <I, S>(
    tag: Context.Tag<I, S>,
    service: Types.NoInfer<S>
  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, Exclude<R, I>>
  <Out, In, R, I, S>(
    self: Schedule<Out, In, R>,
    tag: Context.Tag<I, S>,
    service: Types.NoInfer<S>
  ): Schedule<Out, In, Exclude<R, I>>
}
```


# recurs

A schedule that recurs a fixed number of times before terminating.

**Details**

This schedule will continue executing until it has been stepped `n` times,
after which it will stop. The output of the schedule is the current count of
recurrences.

To import and use `recurs` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.recurs
```

**Signature**

```ts
export declare const recurs: (n: number) => Schedule<number>
```


# recurUntil

A schedule that recurs until the given predicate evaluates to true.

**Details**

This schedule will continue executing as long as the provided predicate `f`
returns `false` for the input value. Once `f` evaluates to `true`, the
schedule stops recurring.

This is useful for defining schedules that should stop when a certain
condition is met, such as detecting a success state, reaching a threshold, or
avoiding unnecessary retries.

To import and use `recurUntil` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.recurUntil
```

**Signature**

```ts
export declare const recurUntil: <A>(f: Predicate<A>) => Schedule<A, A>
```


# recurUntilEffect

A schedule that recurs until the given effectful predicate evaluates to true.

**Details**

This schedule continues executing as long as the provided effectful predicate
`f` returns `false`. Once `f` evaluates to `true`, the schedule stops
recurring. Unlike {@link recurUntil}, this function allows the stopping
condition to be computed asynchronously or based on external dependencies.

This is useful when the stopping condition depends on an effectful
computation, such as checking a database, making an API call, or retrieving
system state dynamically.

To import and use `recurUntilEffect` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.recurUntilEffect
```

**Signature**

```ts
export declare const recurUntilEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<A, A, R>
```


# recurUntilOption

A schedule that recurs until the input value matches a partial function, then
maps the value.

**Details**

This schedule continues executing until the provided partial function `pf`
returns `Some(value)`. At that point, it stops and maps the resulting value
to an `Option<B>`. If `pf` returns `None`, the schedule continues.

This is useful when defining schedules that should stop once a certain
condition is met and transform the final value before completion.

To import and use `recurUntilOption` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.recurUntilOption
```

**Signature**

```ts
export declare const recurUntilOption: <A, B>(pf: (a: A) => Option.Option<B>) => Schedule<Option.Option<B>, A>
```


# recurUpTo

A schedule that recurs until the specified duration has elapsed.

**Details**

This schedule continues executing for the given `duration`, after which it
stops. The schedule outputs the elapsed time on each recurrence.

This is useful for limiting the duration of retries, enforcing time-based
constraints, or ensuring that an operation does not run indefinitely.

To import and use `recurUpTo` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.recurUpTo
```

**Signature**

```ts
export declare const recurUpTo: (duration: Duration.DurationInput) => Schedule<Duration.Duration>
```


# recurWhile

A schedule that recurs as long as the given predicate evaluates to true.

\*_Details_

This schedule continues executing as long as the provided predicate `f`
returns `true` for the input value. Once `f` evaluates to `false`, the
schedule stops recurring.

To import and use `recurWhile` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.recurWhile
```

**Signature**

```ts
export declare const recurWhile: <A>(f: Predicate<A>) => Schedule<A, A>
```


# recurWhileEffect

A schedule that recurs as long as the given effectful predicate evaluates to
true.

**Details**

This schedule continues executing as long as the provided effectful predicate
`f` returns `true`. Once `f` evaluates to `false`, the schedule stops
recurring. Unlike {@link recurWhile}, this function allows the condition to
be computed dynamically using an effectful computation.

To import and use `recurWhileEffect` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.recurWhileEffect
```

**Signature**

```ts
export declare const recurWhileEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<A, A, R>
```


# reduce

Returns a new schedule that folds over the outputs of this one.

**Details**

This schedule transforms the output by accumulating values over time using a
reducer function `f`. It starts with an initial value `zero` and updates it
each time the schedule produces an output.

This is useful for tracking statistics, aggregating results, or summarizing
data across multiple executions.

To import and use `reduce` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.reduce
```

**Signature**

```ts
export declare const reduce: {
  <Out, Z>(zero: Z, f: (z: Z, out: Out) => Z): <In, R>(self: Schedule<Out, In, R>) => Schedule<Z, In, R>
  <Out, In, R, Z>(self: Schedule<Out, In, R>, zero: Z, f: (z: Z, out: Out) => Z): Schedule<Z, In, R>
}
```


# reduceEffect

Returns a new schedule that effectfully folds over the outputs of this one.

**Details**

This schedule accumulates outputs over time using an effectful reducer
function `f`. It starts with an initial value `zero` and updates it
asynchronously or based on external dependencies.

This is useful for asynchronous state tracking, logging, external metrics
aggregation, or any scenario where accumulation needs to involve an effectful
computation.

To import and use `reduceEffect` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.reduceEffect
```

**Signature**

```ts
export declare const reduceEffect: {
  <Z, Out, R2>(
    zero: Z,
    f: (z: Z, out: Out) => Effect.Effect<Z, never, R2>
  ): <In, R>(self: Schedule<Out, In, R>) => Schedule<Z, In, R2 | R>
  <Out, In, R, Z, R2>(
    self: Schedule<Out, In, R>,
    zero: Z,
    f: (z: Z, out: Out) => Effect.Effect<Z, never, R2>
  ): Schedule<Z, In, R | R2>
}
```


# repeatForever

Alias of {@link forever}.

To import and use `repeatForever` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.repeatForever
```

**Signature**

```ts
export declare const repeatForever: Schedule<number, unknown, never>
```


# repetitions

Returns a new schedule that outputs the number of repetitions of this one.

**Details**

This schedule tracks how many times the given schedule has executed and
outputs the count instead of the original values. The first execution starts
at `0`, and the count increases with each recurrence.

To import and use `repetitions` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.repetitions
```

**Signature**

```ts
export declare const repetitions: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<number, In, R>
```


# resetAfter

Returns a new schedule that automatically resets to its initial state after a
period of inactivity defined by `duration`.

**Details**

This function modifies a schedule so that if no inputs are received for the
specified `duration`, the schedule resets as if it were new.

To import and use `resetAfter` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.resetAfter
```

**Signature**

```ts
export declare const resetAfter: {
  (duration: Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>
  <Out, In, R>(self: Schedule<Out, In, R>, duration: Duration.DurationInput): Schedule<Out, In, R>
}
```


# resetWhen

Resets the schedule when the specified predicate on the schedule output
evaluates to `true`.

**Details**

This function modifies a schedule so that it resets to its initial state
whenever the provided predicate `f` returns `true` for an output value.

To import and use `resetWhen` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.resetWhen
```

**Signature**

```ts
export declare const resetWhen: {
  <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>
  <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>
}
```


# run

Runs a schedule using the provided inputs and collects all outputs.

**Details**

This function executes a given schedule with a sequence of input values and
accumulates all outputs into a `Chunk`. The schedule starts execution at the
specified `now` timestamp and proceeds according to its defined behavior.

This is useful for batch processing, simulating execution, or testing
schedules with predefined input sequences.

To import and use `run` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.run
```

**Signature**

```ts
export declare const run: {
  <In>(
    now: number,
    input: Iterable<In>
  ): <Out, R>(self: Schedule<Out, In, R>) => Effect.Effect<Chunk.Chunk<Out>, never, R>
  <Out, In, R>(self: Schedule<Out, In, R>, now: number, input: Iterable<In>): Effect.Effect<Chunk.Chunk<Out>, never, R>
}
```


# Schedule

A `Schedule<Out, In, R>` defines a recurring schedule, which consumes values
of type `In`, and which returns values of type `Out`.

The `Schedule` type is structured as follows:

```text
           The type of output produced by the schedule
              The type of input consumed by the schedule
                   Additional requirements for the schedule
                  
Schedule<Out, In, Requirements>
```

A schedule operates by consuming values of type `In` (such as errors in the
case of `Effect.retry`, or values in the case of `Effect.repeat`) and
producing values of type `Out`. It determines when to halt or continue the
execution based on input values and its internal state.

The inclusion of a `Requirements` parameter allows the schedule to leverage
additional services or resources as needed.

Schedules are defined as a possibly infinite set of intervals spread out over
time. Each interval defines a window in which recurrence is possible.

When schedules are used to repeat or retry effects, the starting boundary of
each interval produced by a schedule is used as the moment when the effect
will be executed again.

Schedules can be composed in different ways:

- Union: Combines two schedules and recurs if either schedule wants to
  continue, using the shorter delay.
- Intersection: Combines two schedules and recurs only if both schedules want
  to continue, using the longer delay.
- Sequencing: Combines two schedules by running the first one fully, then
  switching to the second.

In addition, schedule inputs and outputs can be transformed, filtered (to
terminate a schedule early in response to some input or output), and so
forth.

A variety of other operators exist for transforming and combining schedules,
and the companion object for `Schedule` contains all common types of
schedules, both for performing retrying, as well as performing repetition.

To import and use `Schedule` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.Schedule
```


# secondOfMinute

Cron-like schedule that recurs at a specific second of each minute.

**Details**

This schedule triggers at the specified `second` of each minute,
starting at zero nanoseconds. It produces a count of executions
(0, 1, 2, ...). The `second` parameter is validated lazily, meaning
invalid values will only be caught at runtime.

To import and use `secondOfMinute` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.secondOfMinute
```

**Signature**

```ts
export declare const secondOfMinute: (second: number) => Schedule<number>
```


# spaced

Returns a schedule that recurs continuously, with each repetition
spaced by the specified `duration` from the last run.

**Details**

This schedule ensures that executions occur at a fixed interval,
maintaining a consistent delay between repetitions. The delay starts
from the end of the last execution, not from the schedule start time.

To import and use `spaced` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.spaced
```

**Signature**

```ts
export declare const spaced: (duration: Duration.DurationInput) => Schedule<number>
```


# stop

A schedule that does not recur and stops immediately.

To import and use `stop` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.stop
```

**Signature**

```ts
export declare const stop: Schedule<void, unknown, never>
```


# succeed

Returns a schedule that recurs indefinitely, always producing the specified
constant value.

To import and use `succeed` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.succeed
```

**Signature**

```ts
export declare const succeed: <A>(value: A) => Schedule<A>
```


# sync

Returns a schedule that recurs indefinitely, evaluating the given function to
produce a constant value.

To import and use `sync` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.sync
```

**Signature**

```ts
export declare const sync: <A>(evaluate: LazyArg<A>) => Schedule<A>
```


# tapInput

Returns a new schedule that runs the given effectful function for each input
before continuing execution.

**Details**

This function allows side effects to be performed on each input processed by
the schedule. It does not modify the schedules behavior but ensures that the
provided function `f` runs before each step.

To import and use `tapInput` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.tapInput
```

**Signature**

```ts
export declare const tapInput: {
  <In2, X, R2>(
    f: (input: In2) => Effect.Effect<X, never, R2>
  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In & In2, R2 | R>
  <Out, In, R, In2, X, R2>(
    self: Schedule<Out, In, R>,
    f: (input: In2) => Effect.Effect<X, never, R2>
  ): Schedule<Out, In & In2, R | R2>
}
```


# tapOutput

Returns a new schedule that runs the given effectful function for each output
before continuing execution.

**Details**

This function allows side effects to be performed on each output produced by
the schedule. It does not modify the schedules behavior but ensures that the
provided function `f` runs after each step.

To import and use `tapOutput` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.tapOutput
```

**Signature**

```ts
export declare const tapOutput: {
  <X, R2, Out>(
    f: (out: Types.NoInfer<Out>) => Effect.Effect<X, never, R2>
  ): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>
  <Out, In, R, X, R2>(
    self: Schedule<Out, In, R>,
    f: (out: Out) => Effect.Effect<X, never, R2>
  ): Schedule<Out, In, R | R2>
}
```


# unfold

Creates a schedule that repeatedly applies a function to transform a state
value, producing a sequence of values.

**Details**

This function starts with an `initial` value and applies `f` recursively to
generate the next state at each step. The schedule continues indefinitely,
producing a stream of values by unfolding the state over time.

To import and use `unfold` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.unfold
```

**Signature**

```ts
export declare const unfold: <A>(initial: A, f: (a: A) => A) => Schedule<A>
```


# union

Combines two schedules, continuing execution as long as at least one of them
allows it, using the shorter delay.

**Details**

This function combines two schedules into a single schedule that executes in
parallel. If either schedule allows continuation, the merged schedule
continues. When both schedules produce delays, the schedule selects the
shorter delay to determine the next step.

The output of the new schedule is a tuple containing the outputs of both
schedules. The input type is the intersection of both schedules' input types.

This is useful for scenarios where multiple scheduling conditions should be
considered, ensuring execution proceeds if at least one schedule permits it.

To import and use `union` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.union
```

**Signature**

```ts
export declare const union: {
  <Out2, In2, R2>(
    that: Schedule<Out2, In2, R2>
  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>
  <Out, In, R, Out2, In2, R2>(
    self: Schedule<Out, In, R>,
    that: Schedule<Out2, In2, R2>
  ): Schedule<[Out, Out2], In & In2, R | R2>
}
```


# unionWith

Combines two schedules, continuing execution as long as at least one of them
wants to continue, merging their intervals using a custom merge function.

**Details**

This function allows you to combine two schedules while defining how their
intervals should be merged. Unlike {@link union}, which simply selects the
shorter delay, this function lets you specify a custom merging strategy for
the schedules intervals.

The merged schedule continues execution as long as at least one of the input
schedules allows it. The next interval is determined by applying the provided
merge function to the intervals of both schedules.

The output of the resulting schedule is a tuple containing the outputs of
both schedules. The input type is the intersection of both schedules' input
types.

To import and use `unionWith` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.unionWith
```

**Signature**

```ts
export declare const unionWith: {
  <Out2, In2, R2>(
    that: Schedule<Out2, In2, R2>,
    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals
  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>
  <Out, In, R, Out2, In2, R2>(
    self: Schedule<Out, In, R>,
    that: Schedule<Out2, In2, R2>,
    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals
  ): Schedule<[Out, Out2], In & In2, R | R2>
}
```


# untilInput

Returns a new schedule that stops execution when the given predicate on the
input evaluates to `true`.

**Details**

This function modifies an existing schedule so that it continues executing
only while the provided predicate returns `false` for incoming inputs. Once
an input satisfies the condition, the schedule terminates immediately.

To import and use `untilInput` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.untilInput
```

**Signature**

```ts
export declare const untilInput: {
  <In>(f: Predicate<In>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>
  <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<In>): Schedule<Out, In, R>
}
```


# untilInputEffect

Returns a new schedule that stops execution when the given effectful
predicate on the input evaluates to `true`.

**Details**

This function modifies an existing schedule so that it continues executing
only while the provided effectful predicate returns `false` for incoming
inputs. The predicate is an `Effect`, meaning it can involve asynchronous
computations or dependency-based logic.

To import and use `untilInputEffect` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.untilInputEffect
```

**Signature**

```ts
export declare const untilInputEffect: {
  <In, R2>(
    f: (input: In) => Effect.Effect<boolean, never, R2>
  ): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>
  <Out, In, R, R2>(
    self: Schedule<Out, In, R>,
    f: (input: In) => Effect.Effect<boolean, never, R2>
  ): Schedule<Out, In, R | R2>
}
```


# untilOutput

Returns a new schedule that stops execution when the given predicate on the
output evaluates to `true`.

**Details**

This function modifies an existing schedule so that it only continues
executing while the given predicate returns false for its output values. Once
the predicate evaluates to `true`, execution stops.

The output of the resulting schedule remains the same, but its duration is
now constrained by a stopping condition based on its own output.

To import and use `untilOutput` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.untilOutput
```

**Signature**

```ts
export declare const untilOutput: {
  <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>
  <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>
}
```


# untilOutputEffect

Returns a new schedule that stops execution when the given effectful
predicate on the output evaluates to `true`.

**Details**

This function modifies an existing schedule so that it only continues
executing while the provided effectful predicate returns `false` for its
output values. Once the predicate returns `true`, execution stops.

To import and use `untilOutputEffect` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.untilOutputEffect
```

**Signature**

```ts
export declare const untilOutputEffect: {
  <Out, R2>(
    f: (out: Out) => Effect.Effect<boolean, never, R2>
  ): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>
  <Out, In, R, R2>(
    self: Schedule<Out, In, R>,
    f: (out: Out) => Effect.Effect<boolean, never, R2>
  ): Schedule<Out, In, R | R2>
}
```


# upTo

Returns a new schedule that limits execution to a fixed duration.

**Details**

This function modifies an existing schedule to stop execution after a
specified duration has passed. The schedule continues as normal until the
duration is reached, at which point it stops automatically.

To import and use `upTo` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.upTo
```

**Signature**

```ts
export declare const upTo: {
  (duration: Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>
  <Out, In, R>(self: Schedule<Out, In, R>, duration: Duration.DurationInput): Schedule<Out, In, R>
}
```


# whileInput

Returns a new schedule that continues execution as long as the given
predicate on the input is true.

**Details**

This function modifies an existing schedule so that it only continues
execution while a specified predicate holds true for its input. If the
predicate evaluates to `false` at any step, the schedule stops.

To import and use `whileInput` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.whileInput
```

**Signature**

```ts
export declare const whileInput: {
  <In>(f: Predicate<In>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>
  <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<In>): Schedule<Out, In, R>
}
```


# whileInputEffect

Returns a new schedule that continues execution for as long as the given
effectful predicate on the input evaluates to `true`.

**Details**

This function modifies an existing schedule so that it only continues
execution while an effectful predicate holds true for its input. If the
predicate evaluates to `false` at any step, the schedule stops.

To import and use `whileInputEffect` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.whileInputEffect
```

**Signature**

```ts
export declare const whileInputEffect: {
  <In, R2>(
    f: (input: In) => Effect.Effect<boolean, never, R2>
  ): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>
  <Out, In, R, R2>(
    self: Schedule<Out, In, R>,
    f: (input: In) => Effect.Effect<boolean, never, R2>
  ): Schedule<Out, In, R | R2>
}
```


# whileOutput

Returns a new schedule that continues execution for as long as the given
predicate on the output evaluates to `true`.

**Details**

This function modifies an existing schedule so that it only continues
execution while a provided condition holds true for its output. If the
predicate returns `false`, the schedule stops.

To import and use `whileOutput` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.whileOutput
```

**Signature**

```ts
export declare const whileOutput: {
  <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>
  <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>
}
```


# whileOutputEffect

Returns a new schedule that continues execution for as long as the given
effectful predicate on the output evaluates to `true`.

**Details**

This function modifies an existing schedule so that it only continues
execution while an effectful condition holds true for its output. If the
effectful predicate returns `false`, the schedule stops.

To import and use `whileOutputEffect` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.whileOutputEffect
```

**Signature**

```ts
export declare const whileOutputEffect: {
  <Out, R2>(
    f: (out: Out) => Effect.Effect<boolean, never, R2>
  ): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>
  <Out, In, R, R2>(
    self: Schedule<Out, In, R>,
    f: (out: Out) => Effect.Effect<boolean, never, R2>
  ): Schedule<Out, In, R | R2>
}
```


# windowed

Creates a schedule that divides time into fixed `interval`-long windows,
triggering execution at the start of each new window.

**Details**

This function produces a schedule that waits until the next time window
boundary before executing. Each window spans a fixed duration specified by
`interval`. If an action completes midway through a window, the schedule
waits until the next full window starts before proceeding.

For example, `windowed(Duration.seconds(10))` would produce a schedule as
follows:

```
     10s        10s        10s       10s
|----------|----------|----------|----------|
|action------|sleep---|act|-sleep|action----|
```

To import and use `windowed` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.windowed
```

**Signature**

```ts
export declare const windowed: (interval: Duration.DurationInput) => Schedule<number>
```


# zipLeft

The same as {@link intersect} but ignores the right output.

To import and use `zipLeft` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.zipLeft
```

**Signature**

```ts
export declare const zipLeft: {
  <Out2, In2, R2>(
    that: Schedule<Out2, In2, R2>
  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In & In2, R2 | R>
  <Out, In, R, Out2, In2, R2>(
    self: Schedule<Out, In, R>,
    that: Schedule<Out2, In2, R2>
  ): Schedule<Out, In & In2, R | R2>
}
```


# zipRight

The same as {@link intersect} but ignores the left output.

To import and use `zipRight` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.zipRight
```

**Signature**

```ts
export declare const zipRight: {
  <Out2, In2, R2>(
    that: Schedule<Out2, In2, R2>
  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In & In2, R2 | R>
  <Out, In, R, Out2, In2, R2>(
    self: Schedule<Out, In, R>,
    that: Schedule<Out2, In2, R2>
  ): Schedule<Out2, In & In2, R | R2>
}
```


# zipWith

Equivalent to {@link intersect} followed by {@link map}.

To import and use `zipWith` from the "Schedule" module:

```ts
import * as Schedule from "effect/Schedule"
// Can be accessed like this
Schedule.zipWith
```

**Signature**

```ts
export declare const zipWith: {
  <Out2, In2, R2, Out, Out3>(
    that: Schedule<Out2, In2, R2>,
    f: (out: Out, out2: Out2) => Out3
  ): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out3, In & In2, R2 | R>
  <Out, In, R, Out2, In2, R2, Out3>(
    self: Schedule<Out, In, R>,
    that: Schedule<Out2, In2, R2>,
    f: (out: Out, out2: Out2) => Out3
  ): Schedule<Out3, In & In2, R | R2>
}
```


# after

Construct an `Interval` that includes all time equal to and after the
specified start time.

To import and use `after` from the "ScheduleInterval" module:

```ts
import * as ScheduleInterval from "effect/ScheduleInterval"
// Can be accessed like this
ScheduleInterval.after
```

**Signature**

```ts
export declare const after: (startMilliseconds: number) => Interval
```


# before

Construct an `Interval` that includes all time equal to and before the
specified end time.

To import and use `before` from the "ScheduleInterval" module:

```ts
import * as ScheduleInterval from "effect/ScheduleInterval"
// Can be accessed like this
ScheduleInterval.before
```

**Signature**

```ts
export declare const before: (endMilliseconds: number) => Interval
```


# empty

An `Interval` of zero-width.

To import and use `empty` from the "ScheduleInterval" module:

```ts
import * as ScheduleInterval from "effect/ScheduleInterval"
// Can be accessed like this
ScheduleInterval.empty
```

**Signature**

```ts
export declare const empty: Interval
```


# intersect

Computes a new `Interval` which is the intersection of this `Interval` and
that `Interval`.

To import and use `intersect` from the "ScheduleInterval" module:

```ts
import * as ScheduleInterval from "effect/ScheduleInterval"
// Can be accessed like this
ScheduleInterval.intersect
```

**Signature**

```ts
export declare const intersect: {
  (that: Interval): (self: Interval) => Interval
  (self: Interval, that: Interval): Interval
}
```


# Interval

An `Interval` represents an interval of time. Intervals can encompass all
time, or no time at all.

To import and use `Interval` from the "ScheduleInterval" module:

```ts
import * as ScheduleInterval from "effect/ScheduleInterval"
// Can be accessed like this
ScheduleInterval.Interval
```


# isEmpty

Returns `true` if the specified `Interval` is empty, `false` otherwise.

To import and use `isEmpty` from the "ScheduleInterval" module:

```ts
import * as ScheduleInterval from "effect/ScheduleInterval"
// Can be accessed like this
ScheduleInterval.isEmpty
```

**Signature**

```ts
export declare const isEmpty: (self: Interval) => boolean
```


# isNonEmpty

Returns `true` if the specified `Interval` is non-empty, `false` otherwise.

To import and use `isNonEmpty` from the "ScheduleInterval" module:

```ts
import * as ScheduleInterval from "effect/ScheduleInterval"
// Can be accessed like this
ScheduleInterval.isNonEmpty
```

**Signature**

```ts
export declare const isNonEmpty: (self: Interval) => boolean
```


# lessThan

Returns `true` if this `Interval` is less than `that` interval, `false`
otherwise.

To import and use `lessThan` from the "ScheduleInterval" module:

```ts
import * as ScheduleInterval from "effect/ScheduleInterval"
// Can be accessed like this
ScheduleInterval.lessThan
```

**Signature**

```ts
export declare const lessThan: {
  (that: Interval): (self: Interval) => boolean
  (self: Interval, that: Interval): boolean
}
```


# make

Constructs a new interval from the two specified endpoints. If the start
endpoint greater than the end endpoint, then a zero size interval will be
returned.

To import and use `make` from the "ScheduleInterval" module:

```ts
import * as ScheduleInterval from "effect/ScheduleInterval"
// Can be accessed like this
ScheduleInterval.make
```

**Signature**

```ts
export declare const make: (startMillis: number, endMillis: number) => Interval
```


# max

Returns the maximum of two `Interval`s.

To import and use `max` from the "ScheduleInterval" module:

```ts
import * as ScheduleInterval from "effect/ScheduleInterval"
// Can be accessed like this
ScheduleInterval.max
```

**Signature**

```ts
export declare const max: { (that: Interval): (self: Interval) => Interval; (self: Interval, that: Interval): Interval }
```


# min

Returns the minimum of two `Interval`s.

To import and use `min` from the "ScheduleInterval" module:

```ts
import * as ScheduleInterval from "effect/ScheduleInterval"
// Can be accessed like this
ScheduleInterval.min
```

**Signature**

```ts
export declare const min: { (that: Interval): (self: Interval) => Interval; (self: Interval, that: Interval): Interval }
```


# size

Calculates the size of the `Interval` as the `Duration` from the start of the
interval to the end of the interval.

To import and use `size` from the "ScheduleInterval" module:

```ts
import * as ScheduleInterval from "effect/ScheduleInterval"
// Can be accessed like this
ScheduleInterval.size
```

**Signature**

```ts
export declare const size: (self: Interval) => Duration.Duration
```


# union

Computes a new `Interval` which is the union of this `Interval` and that
`Interval` as a `Some`, otherwise returns `None` if the two intervals cannot
form a union.

To import and use `union` from the "ScheduleInterval" module:

```ts
import * as ScheduleInterval from "effect/ScheduleInterval"
// Can be accessed like this
ScheduleInterval.union
```

**Signature**

```ts
export declare const union: {
  (that: Interval): (self: Interval) => Option.Option<Interval>
  (self: Interval, that: Interval): Option.Option<Interval>
}
```


# empty

Constructs an empty list of `Interval`s.

To import and use `empty` from the "ScheduleIntervals" module:

```ts
import * as ScheduleIntervals from "effect/ScheduleIntervals"
// Can be accessed like this
ScheduleIntervals.empty
```

**Signature**

```ts
export declare const empty: Intervals
```


# end

The end of the latest interval in the specified `Intervals`.

To import and use `end` from the "ScheduleIntervals" module:

```ts
import * as ScheduleIntervals from "effect/ScheduleIntervals"
// Can be accessed like this
ScheduleIntervals.end
```

**Signature**

```ts
export declare const end: (self: Intervals) => number
```


# fromIterable

Creates `Intervals` from the specified `Iterable<Interval>`.

To import and use `fromIterable` from the "ScheduleIntervals" module:

```ts
import * as ScheduleIntervals from "effect/ScheduleIntervals"
// Can be accessed like this
ScheduleIntervals.fromIterable
```

**Signature**

```ts
export declare const fromIterable: (intervals: Iterable<Interval.Interval>) => Intervals
```


# intersect

Produces the intersection of this `Intervals` and that `Intervals`.

To import and use `intersect` from the "ScheduleIntervals" module:

```ts
import * as ScheduleIntervals from "effect/ScheduleIntervals"
// Can be accessed like this
ScheduleIntervals.intersect
```

**Signature**

```ts
export declare const intersect: {
  (that: Intervals): (self: Intervals) => Intervals
  (self: Intervals, that: Intervals): Intervals
}
```


# Intervals

An `Intervals` represents a list of several `Interval`s.

To import and use `Intervals` from the "ScheduleIntervals" module:

```ts
import * as ScheduleIntervals from "effect/ScheduleIntervals"
// Can be accessed like this
ScheduleIntervals.Intervals
```


# isNonEmpty

Returns `true` if this `Intervals` is non-empty, `false` otherwise.

To import and use `isNonEmpty` from the "ScheduleIntervals" module:

```ts
import * as ScheduleIntervals from "effect/ScheduleIntervals"
// Can be accessed like this
ScheduleIntervals.isNonEmpty
```

**Signature**

```ts
export declare const isNonEmpty: (self: Intervals) => boolean
```


# lessThan

Returns `true` if the start of this `Intervals` is before the start of that
`Intervals`, `false` otherwise.

To import and use `lessThan` from the "ScheduleIntervals" module:

```ts
import * as ScheduleIntervals from "effect/ScheduleIntervals"
// Can be accessed like this
ScheduleIntervals.lessThan
```

**Signature**

```ts
export declare const lessThan: {
  (that: Intervals): (self: Intervals) => boolean
  (self: Intervals, that: Intervals): boolean
}
```


# make

Creates a new `Intervals` from a `List` of `Interval`s.

To import and use `make` from the "ScheduleIntervals" module:

```ts
import * as ScheduleIntervals from "effect/ScheduleIntervals"
// Can be accessed like this
ScheduleIntervals.make
```

**Signature**

```ts
export declare const make: (intervals: Check.Chunk<Interval.Interval>) => Intervals
```


# max

Returns the maximum of the two `Intervals` (i.e. which has the latest start).

To import and use `max` from the "ScheduleIntervals" module:

```ts
import * as ScheduleIntervals from "effect/ScheduleIntervals"
// Can be accessed like this
ScheduleIntervals.max
```

**Signature**

```ts
export declare const max: {
  (that: Intervals): (self: Intervals) => Intervals
  (self: Intervals, that: Intervals): Intervals
}
```


# start

The start of the earliest interval in the specified `Intervals`.

To import and use `start` from the "ScheduleIntervals" module:

```ts
import * as ScheduleIntervals from "effect/ScheduleIntervals"
// Can be accessed like this
ScheduleIntervals.start
```

**Signature**

```ts
export declare const start: (self: Intervals) => number
```


# union

Computes the union of this `Intervals` and that `Intervals`

To import and use `union` from the "ScheduleIntervals" module:

```ts
import * as ScheduleIntervals from "effect/ScheduleIntervals"
// Can be accessed like this
ScheduleIntervals.union
```

**Signature**

```ts
export declare const union: {
  (that: Intervals): (self: Intervals) => Intervals
  (self: Intervals, that: Intervals): Intervals
}
```


# annotations

Merges a set of new annotations with existing ones, potentially overwriting
any duplicates.

To import and use `annotations` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.annotations
```

**Signature**

```ts
export declare const annotations: {
  <S extends Annotable.All>(annotations: Annotations.GenericSchema<Schema.Type<S>>): (self: S) => Annotable.Self<S>
  <S extends Annotable.All>(self: S, annotations: Annotations.GenericSchema<Schema.Type<S>>): Annotable.Self<S>
}
```


# asserts

By default the option `exact` is set to `true`.

To import and use `asserts` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.asserts
```


# attachPropertySignature

Attaches a property signature with the specified key and value to the schema.
This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,
but rather maps to another schema, for example when you want to add a discriminant to a simple union.

To import and use `attachPropertySignature` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.attachPropertySignature
```

**Example**

```ts
import * as S from "effect/Schema"
import { pipe } from "effect/Function"

const Circle = S.Struct({ radius: S.Number })
const Square = S.Struct({ sideLength: S.Number })
const Shape = S.Union(
  Circle.pipe(S.attachPropertySignature("kind", "circle")),
  Square.pipe(S.attachPropertySignature("kind", "square"))
)

assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {
  kind: "circle",
  radius: 10
})
```

**Signature**

```ts
export declare const attachPropertySignature: {
  <K extends PropertyKey, V extends AST.LiteralValue | symbol, A>(
    key: K,
    value: V,
    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>
  ): <I, R>(schema: SchemaClass<A, I, R>) => SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R>
  <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(
    schema: Schema<A, I, R>,
    key: K,
    value: V,
    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>
  ): SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R>
}
```


# between

This filter checks whether the provided number falls within the specified minimum and maximum values.

To import and use `between` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.between
```

**Signature**

```ts
export declare const between: <A extends number>(
  minimum: number,
  maximum: number,
  annotations?: Annotations.Filter<A>
) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>
```


# BigDecimalFromNumber

A schema that transforms a `number` into a `BigDecimal`.
When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.

To import and use `BigDecimalFromNumber` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.BigDecimalFromNumber
```


# BigInt

This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.

It returns an error if the value can't be converted (for example when non-numeric characters are provided).

To import and use `BigInt` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.BigInt
```


# BigIntFromNumber

This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.

It returns an error if the value can't be safely encoded as a `number` due to being out of range.

To import and use `BigIntFromNumber` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.BigIntFromNumber
```


# BooleanFromString

Converts an `string` value into its corresponding `boolean`
("true" as `true` and "false" as `false`).

To import and use `BooleanFromString` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.BooleanFromString
```


# BooleanFromUnknown

Converts an arbitrary value to a `boolean` by testing whether it is truthy.
Uses `!!val` to coerce the value to a `boolean`.

To import and use `BooleanFromUnknown` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.BooleanFromUnknown
```


# brand

Returns a nominal branded schema by applying a brand to a given schema.

```
Schema<A> + B -> Schema<A & Brand<B>>
```

To import and use `brand` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.brand
```

**Example**

```ts
import * as Schema from "effect/Schema"

const Int = Schema.Number.pipe(Schema.int(), Schema.brand("Int"))
type Int = Schema.Schema.Type<typeof Int> // number & Brand<"Int">
```

**Signature**

```ts
export declare const brand: <S extends Schema.AnyNoContext, B extends string | symbol>(
  brand: B,
  annotations?: Annotations.Schema<Schema.Type<S> & Brand<B>>
) => (self: S) => brand<S, B>
```


# Capitalize

This schema converts a string to capitalized one.

To import and use `Capitalize` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.Capitalize
```


# capitalized

Verifies that a string is capitalized.

To import and use `capitalized` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.capitalized
```

**Signature**

```ts
export declare const capitalized: <A extends string>(
  annotations?: Annotations.Filter<A>
) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>
```


# Char

A schema representing a single character.

To import and use `Char` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.Char
```


# clamp

Clamps a number between a minimum and a maximum value.

To import and use `clamp` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.clamp
```

**Signature**

```ts
export declare const clamp: (
  minimum: number,
  maximum: number
) => <A extends number, I, R>(self: Schema<A, I, R>) => transform<Schema<A, I, R>, filter<Schema<A>>>
```


# clampBigDecimal

Clamps a `BigDecimal` between a minimum and a maximum value.

To import and use `clampBigDecimal` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.clampBigDecimal
```

**Signature**

```ts
export declare const clampBigDecimal: (
  minimum: bigDecimal_.BigDecimal,
  maximum: bigDecimal_.BigDecimal
) => <A extends bigDecimal_.BigDecimal, I, R>(self: Schema<A, I, R>) => transform<Schema<A, I, R>, filter<Schema<A>>>
```


# clampBigInt

Clamps a bigint between a minimum and a maximum value.

To import and use `clampBigInt` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.clampBigInt
```

**Signature**

```ts
export declare const clampBigInt: (
  minimum: bigint,
  maximum: bigint
) => <A extends bigint, I, R>(self: Schema<A, I, R>) => transform<Schema<A, I, R>, filter<Schema<A>>>
```


# clampDuration

Clamps a `Duration` between a minimum and a maximum value.

To import and use `clampDuration` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.clampDuration
```

**Signature**

```ts
export declare const clampDuration: (
  minimum: duration_.DurationInput,
  maximum: duration_.DurationInput
) => <A extends duration_.Duration, I, R>(self: Schema<A, I, R>) => transform<Schema<A, I, R>, filter<Schema<A>>>
```


# Date

This schema converts a `string` into a `Date` object using the `new Date`
constructor. It ensures that only valid date strings are accepted,
rejecting any strings that would result in an invalid date, such as `new
Date("Invalid Date")`.

To import and use `Date` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.Date
```


# DateFromNumber

Defines a schema that converts a `number` into a `Date` object using the `new
Date` constructor. This schema does not validate the numerical input,
allowing potentially invalid values such as `NaN`, `Infinity`, and
`-Infinity` to be converted into `Date` objects. During the encoding process,
any invalid `Date` object will be encoded to `NaN`.

To import and use `DateFromNumber` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.DateFromNumber
```


# DateFromSelf

Describes a schema that accommodates potentially invalid `Date` instances,
such as `new Date("Invalid Date")`, without rejection.

To import and use `DateFromSelf` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.DateFromSelf
```


# DateFromString

Defines a schema that attempts to convert a `string` to a `Date` object using
the `new Date` constructor. This conversion is lenient, meaning it does not
reject strings that do not form valid dates (e.g., using `new Date("Invalid
Date")` results in a `Date` object, despite being invalid).

To import and use `DateFromString` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.DateFromString
```


# DateTimeUtc

Defines a schema that attempts to convert a `string` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.

To import and use `DateTimeUtc` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.DateTimeUtc
```


# DateTimeUtcFromDate

Defines a schema that attempts to convert a `Date` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.

To import and use `DateTimeUtcFromDate` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.DateTimeUtcFromDate
```


# DateTimeUtcFromNumber

Defines a schema that attempts to convert a `number` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.

To import and use `DateTimeUtcFromNumber` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.DateTimeUtcFromNumber
```


# DateTimeUtcFromSelf

Describes a schema that represents a `DateTime.Utc` instance.

To import and use `DateTimeUtcFromSelf` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.DateTimeUtcFromSelf
```


# DateTimeZoned

Defines a schema that attempts to convert a `string` to a `DateTime.Zoned` instance.

To import and use `DateTimeZoned` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.DateTimeZoned
```


# DateTimeZonedFromSelf

Describes a schema that represents a `DateTime.Zoned` instance.

To import and use `DateTimeZonedFromSelf` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.DateTimeZonedFromSelf
```


# declare

The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.
This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.

To import and use `declare` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.declare
```

**Signature**

```ts
export declare const declare: {
  <A>(is: (input: unknown) => input is A, annotations?: Annotations.Schema<A>): SchemaClass<A>
  <const P extends ReadonlyArray<Schema.All>, I, A>(
    typeParameters: P,
    options: {
      readonly decode: (
        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }
      ) => (
        input: unknown,
        options: ParseOptions,
        ast: AST.Declaration
      ) => Effect.Effect<A, ParseResult.ParseIssue, never>
      readonly encode: (
        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }
      ) => (
        input: unknown,
        options: ParseOptions,
        ast: AST.Declaration
      ) => Effect.Effect<I, ParseResult.ParseIssue, never>
    },
    annotations?: Annotations.Schema<A, { readonly [K in keyof P]: Schema.Type<P[K]> }>
  ): SchemaClass<A, I, Schema.Context<P[number]>>
}
```


# Defect

Defines a schema for handling JavaScript errors (`Error` instances) and other types of defects.
It decodes objects into Error instances if they match the expected structure (i.e., have a `message` and optionally a `name` and `stack`),
or converts other values to their string representations.

When encoding, it converts `Error` instances back into plain objects containing only the error's name and message,
or other values into their string forms.

This is useful for serializing and deserializing errors across network boundaries where error objects do not natively serialize.

To import and use `Defect` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.Defect
```

**Signature**

```ts
export declare const Defect: Defect
```


# Duration

A schema that converts a JSON-compatible tagged union into a `Duration`.

To import and use `Duration` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.Duration
```


# DurationFromMillis

A schema that transforms a (possibly Infinite) non negative number into a
`Duration`. Treats the value as the number of milliseconds.

To import and use `DurationFromMillis` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.DurationFromMillis
```


# DurationFromNanos

A schema that transforms a non negative `bigint` into a `Duration`. Treats
the value as the number of nanoseconds.

To import and use `DurationFromNanos` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.DurationFromNanos
```


# encodedBoundSchema

The `encodedBoundSchema` function is similar to `encodedSchema` but preserves
the refinements up to the first transformation point in the original schema.

To import and use `encodedBoundSchema` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.encodedBoundSchema
```

**Signature**

```ts
export declare const encodedBoundSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<I>
```


# encodedSchema

The `encodedSchema` function allows you to extract the `Encoded` portion of a
schema, creating a new schema that conforms to the properties defined in the
original schema without retaining any refinements or transformations that
were applied previously.

To import and use `encodedSchema` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.encodedSchema
```

**Signature**

```ts
export declare const encodedSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<I>
```


# equivalence

Given a schema `Schema<A, I, R>`, returns an `Equivalence` instance for `A`.

To import and use `equivalence` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.equivalence
```

**Signature**

```ts
export declare const equivalence: <A, I, R>(schema: Schema<A, I, R>) => Equivalence.Equivalence<A>
```


# extend

Extends a schema with another schema.

Not all extensions are supported, and their support depends on the nature of the involved schemas.

Possible extensions include:

- `Schema.String` with another `Schema.String` refinement or a string literal
- `Schema.Number` with another `Schema.Number` refinement or a number literal
- `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean literal
- A struct with another struct where overlapping fields support extension
- A struct with in index signature
- A struct with a union of supported schemas
- A refinement of a struct with a supported schema
- A suspend of a struct with a supported schema

To import and use `extend` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.extend
```

**Example**

```ts
import * as Schema from "effect/Schema"

const schema = Schema.Struct({
  a: Schema.String,
  b: Schema.String
})

// const extended: Schema<
//   {
//     readonly a: string
//     readonly b: string
//   } & {
//     readonly c: string
//   } & {
//     readonly [x: string]: string
//   }
// >
const extended = Schema.asSchema(
  schema.pipe(
    Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields
    Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures
  )
)
```

**Signature**

```ts
export declare const extend: {
  <That extends Schema.Any>(that: That): <Self extends Schema.Any>(self: Self) => extend<Self, That>
  <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That): extend<Self, That>
}
```


# finite

Ensures that the provided value is a finite number (excluding NaN, +Infinity, and -Infinity).

To import and use `finite` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.finite
```

**Signature**

```ts
export declare const finite: <A extends number>(
  annotations?: Annotations.Filter<A>
) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>
```


# fromKey

Enhances a property signature by specifying a different key for it in the Encoded type.

To import and use `fromKey` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.fromKey
```

**Signature**

```ts
export declare const fromKey: {
  <Key extends PropertyKey>(
    key: Key
  ): <
    TypeToken extends PropertySignature.Token,
    Type,
    EncodedToken extends PropertySignature.Token,
    Encoded,
    HasDefault extends boolean,
    R
  >(
    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>
  ) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>
  <
    Type,
    TypeToken extends PropertySignature.Token,
    Encoded,
    EncodedToken extends PropertySignature.Token,
    HasDefault extends boolean,
    R,
    Key extends PropertyKey
  >(
    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>,
    key: Key
  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>
}
```


# greaterThan

This filter checks whether the provided number is greater than the specified minimum.

To import and use `greaterThan` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.greaterThan
```

**Signature**

```ts
export declare const greaterThan: <A extends number>(
  exclusiveMinimum: number,
  annotations?: Annotations.Filter<A>
) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>
```


# greaterThanOrEqualTo

This filter checks whether the provided number is greater than or equal to the specified minimum.

To import and use `greaterThanOrEqualTo` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.greaterThanOrEqualTo
```

**Signature**

```ts
export declare const greaterThanOrEqualTo: <A extends number>(
  minimum: number,
  annotations?: Annotations.Filter<A>
) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>
```


# head

Get the first element of a `ReadonlyArray`, or `None` if the array is empty.

To import and use `head` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.head
```

**Signature**

```ts
export declare const head: <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>) => SchemaClass<option_.Option<A>, I, R>
```


# headNonEmpty

Get the first element of a `NonEmptyReadonlyArray`.

To import and use `headNonEmpty` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.headNonEmpty
```

**Signature**

```ts
export declare const headNonEmpty: <A, I, R>(
  self: Schema<array_.NonEmptyReadonlyArray<A>, I, R>
) => SchemaClass<A, I, R>
```


# headOrElse

Retrieves the first element of a `ReadonlyArray`.

If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.

To import and use `headOrElse` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.headOrElse
```

**Signature**

```ts
export declare const headOrElse: {
  <A>(fallback?: LazyArg<A>): <I, R>(self: Schema<ReadonlyArray<A>, I, R>) => SchemaClass<A, I, R>
  <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>, fallback?: LazyArg<A>): SchemaClass<A, I, R>
}
```


# int

Ensures that the provided value is an integer number (excluding NaN, +Infinity, and -Infinity).

To import and use `int` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.int
```

**Signature**

```ts
export declare const int: <A extends number>(
  annotations?: Annotations.Filter<A>
) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>
```


# is

By default the option `exact` is set to `true`.

To import and use `is` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.is
```


# isSchema

Tests if a value is a `Schema`.

To import and use `isSchema` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.isSchema
```

**Signature**

```ts
export declare const isSchema: (u: unknown) => u is Schema.Any
```


# JsonNumber

The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid
number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON
format.

To import and use `JsonNumber` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.JsonNumber
```

**Example**

```ts
import * as Schema from "effect/Schema"

const is = Schema.is(S.JsonNumber)

assert.deepStrictEqual(is(42), true)
assert.deepStrictEqual(is(Number.NaN), false)
assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)
assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)
```


# lessThan

This filter checks whether the provided number is less than the specified maximum.

To import and use `lessThan` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.lessThan
```

**Signature**

```ts
export declare const lessThan: <A extends number>(
  exclusiveMaximum: number,
  annotations?: Annotations.Filter<A>
) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>
```


# lessThanOrEqualTo

This schema checks whether the provided number is less than or equal to the specified maximum.

To import and use `lessThanOrEqualTo` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.lessThanOrEqualTo
```

**Signature**

```ts
export declare const lessThanOrEqualTo: <A extends number>(
  maximum: number,
  annotations?: Annotations.Filter<A>
) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>
```


# Lowercase

This schema converts a string to lowercase.

To import and use `Lowercase` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.Lowercase
```


# lowercased

Verifies that a string is lowercased.

To import and use `lowercased` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.lowercased
```

**Signature**

```ts
export declare const lowercased: <A extends string>(
  annotations?: Annotations.Filter<A>
) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>
```


# mutable

Creates a new schema with shallow mutability applied to its properties.

To import and use `mutable` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.mutable
```

**Signature**

```ts
export declare const mutable: <S extends Schema.Any>(schema: S) => mutable<S>
```


# NonEmptyTrimmedString

Useful for validating strings that must contain meaningful characters without
leading or trailing whitespace.

To import and use `NonEmptyTrimmedString` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.NonEmptyTrimmedString
```

**Example**

```ts
import { Schema } from "effect"

console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)("")) // Option.none()
console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(" a ")) // Option.none()
console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)("a")) // Option.some("a")
```


# NonNegativeInt

A non-negative integer. +Infinity is excluded.

To import and use `NonNegativeInt` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.NonNegativeInt
```

**Signature**

```ts
export declare const NonNegativeInt: refine<number, Schema<number, number, never>>
```


# NumberFromString

This schema transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.

It returns an error if the value can't be converted (for example when non-numeric characters are provided).

The following special string values are supported: "NaN", "Infinity", "-Infinity".

To import and use `NumberFromString` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.NumberFromString
```


# optionalToOptional

Converts an optional property to another optional property through a transformation `Option -> Option`.

- `decode`:
  - `none` as argument means the value is missing in the input.
  - `none` as return value means the value will be missing in the output.
- `encode`:
  - `none` as argument means the value is missing in the input.
  - `none` as return value means the value will be missing in the output.

To import and use `optionalToOptional` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.optionalToOptional
```

**Signature**

```ts
export declare const optionalToOptional: <FA, FI, FR, TA, TI, TR>(
  from: Schema<FA, FI, FR>,
  to: Schema<TA, TI, TR>,
  options: {
    readonly decode: (o: option_.Option<FA>) => option_.Option<TI>
    readonly encode: (o: option_.Option<TI>) => option_.Option<FA>
  }
) => PropertySignature<"?:", TA, never, "?:", FI, false, FR | TR>
```


# optionalToRequired

Converts an optional property to a required one through a transformation `Option -> Type`.

- `decode`: `none` as argument means the value is missing in the input.
- `encode`: `none` as return value means the value will be missing in the output.

To import and use `optionalToRequired` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.optionalToRequired
```

**Signature**

```ts
export declare const optionalToRequired: <FA, FI, FR, TA, TI, TR>(
  from: Schema<FA, FI, FR>,
  to: Schema<TA, TI, TR>,
  options: { readonly decode: (o: option_.Option<FA>) => TI; readonly encode: (ti: TI) => option_.Option<FA> }
) => PropertySignature<":", TA, never, "?:", FI, false, FR | TR>
```


# OptionFromNonEmptyTrimmedString

Transforms strings into an Option type, effectively filtering out empty or
whitespace-only strings by trimming them and checking their length. Returns
`none` for invalid inputs and `some` for valid non-empty strings.

To import and use `OptionFromNonEmptyTrimmedString` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.OptionFromNonEmptyTrimmedString
```

**Example**

```ts
import { Schema } from "effect"

console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)("")) // Option.none()
console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(" a ")) // Option.some("a")
console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)("a")) // Option.some("a")
```

**Signature**

```ts
export declare const OptionFromNonEmptyTrimmedString: transform<
  typeof String$,
  OptionFromSelf<typeof NonEmptyTrimmedString>
>
```


# parseJson

The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying
functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.

You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.

Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.

To import and use `parseJson` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.parseJson
```

**Example**

```ts
import * as Schema from "effect/Schema"

assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{"a":"1"}`), { a: "1" })
assert.deepStrictEqual(
  Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{"a":"1"}`),
  { a: 1 }
)
```

**Signature**

```ts
export declare const parseJson: {
  <A, I, R>(schema: Schema<A, I, R>, options?: ParseJsonOptions): SchemaClass<A, string, R>
  (options?: ParseJsonOptions): SchemaClass<unknown, string>
}
```


# parseNumber

Transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.

It returns an error if the value can't be converted (for example when non-numeric characters are provided).

The following special string values are supported: "NaN", "Infinity", "-Infinity".

To import and use `parseNumber` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.parseNumber
```

**Signature**

```ts
export declare const parseNumber: <A extends string, I, R>(
  self: Schema<A, I, R>
) => transformOrFail<Schema<A, I, R>, typeof Number$>
```


# pickLiteral

Creates a new `Schema` from a literal schema.

To import and use `pickLiteral` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.pickLiteral
```

**Example**

```ts
import * as Schema from "effect/Schema"
import { Either } from "effect"

const schema = Schema.Literal("a", "b", "c").pipe(Schema.pickLiteral("a", "b"))

assert.deepStrictEqual(Schema.decodeSync(schema)("a"), "a")
assert.deepStrictEqual(Schema.decodeSync(schema)("b"), "b")
assert.strictEqual(Either.isLeft(Schema.decodeUnknownEither(schema)("c")), true)
```

**Signature**

```ts
export declare const pickLiteral: <A extends AST.LiteralValue, L extends array_.NonEmptyReadonlyArray<A>>(
  ...literals: L
) => <I, R>(_schema: Schema<A, I, R>) => Literal<[...L]>
```


# pluck

Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,
producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.

To import and use `pluck` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.pluck
```

**Example**

```ts
import * as Schema from "effect/Schema"

// ---------------------------------------------
// use case: pull out a single field from a
// struct through a transformation
// ---------------------------------------------

const mytable = Schema.Struct({
  column1: Schema.NumberFromString,
  column2: Schema.Number
})

// const pullOutColumn: S.Schema<number, {
//     readonly column1: string;
// }, never>
const pullOutColumn = mytable.pipe(Schema.pluck("column1"))

console.log(
  Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([
    { column1: "1", column2: 100 },
    { column1: "2", column2: 300 }
  ])
)
// Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
```

**Signature**

```ts
export declare const pluck: {
  <A, I, K extends keyof A & keyof I>(key: K): <R>(schema: Schema<A, I, R>) => Schema<A[K], Simplify<Pick<I, K>>, R>
  <A, I, R, K extends keyof A & keyof I>(schema: Schema<A, I, R>, key: K): Schema<A[K], Simplify<Pick<I, K>>, R>
}
```


# propertySignature

Lifts a `Schema` into a `PropertySignature`.

To import and use `propertySignature` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.propertySignature
```

**Signature**

```ts
export declare const propertySignature: <S extends Schema.All>(self: S) => propertySignature<S>
```


# Redacted

A schema that transforms any type `A` into a `Redacted<A>`.

To import and use `Redacted` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.Redacted
```

**Signature**

```ts
export declare const Redacted: <Value extends Schema.Any>(value: Value) => Redacted<Value>
```


# requiredToOptional

Converts an optional property to a required one through a transformation `Type -> Option`.

- `decode`: `none` as return value means the value will be missing in the output.
- `encode`: `none` as argument means the value is missing in the input.

To import and use `requiredToOptional` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.requiredToOptional
```

**Signature**

```ts
export declare const requiredToOptional: <FA, FI, FR, TA, TI, TR>(
  from: Schema<FA, FI, FR>,
  to: Schema<TA, TI, TR>,
  options: { readonly decode: (fa: FA) => option_.Option<TI>; readonly encode: (o: option_.Option<TI>) => FA }
) => PropertySignature<"?:", TA, never, ":", FI, false, FR | TR>
```


# Serializable

The `Serializable` trait allows objects to define their own schema for
serialization.

To import and use `Serializable` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.Serializable
```


# SerializableWithResult

The `SerializableWithResult` trait is specifically designed to model remote
procedures that require serialization of their input and output, managing
both successful and failed outcomes.

This trait combines functionality from both the `Serializable` and `WithResult`
traits to handle data serialization and the bifurcation of operation results
into success or failure categories.

To import and use `SerializableWithResult` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.SerializableWithResult
```


# split

Returns a schema that allows splitting a string into an array of strings.

To import and use `split` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.split
```

**Signature**

```ts
export declare const split: (separator: string) => transform<typeof String$, Array$<typeof String$>>
```


# standardSchemaV1

Returns a "Standard Schema" object conforming to the [Standard Schema
v1](https://standardschema.dev/) specification.

This function creates a schema whose `validate` method attempts to decode and
validate the provided input synchronously. If the underlying `Schema`
includes any asynchronous components (e.g., asynchronous message resolutions
or checks), then validation will necessarily return a `Promise` instead.

Any detected defects will be reported via a single issue containing no
`path`.

To import and use `standardSchemaV1` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.standardSchemaV1
```

**Example**

```ts
import { Schema } from "effect"

const schema = Schema.Struct({
  name: Schema.String
})

//       StandardSchemaV1<{ readonly name: string; }>
//      
const standardSchema = Schema.standardSchemaV1(schema)
```

**Signature**

```ts
export declare const standardSchemaV1: <A, I>(schema: Schema<A, I, never>) => StandardSchemaV1<I, A>
```


# StringFromBase64

Decodes a base64 (RFC4648) encoded string into a UTF-8 string.

To import and use `StringFromBase64` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.StringFromBase64
```

**Signature**

```ts
export declare const StringFromBase64: Schema<string, string, never>
```


# StringFromBase64Url

Decodes a base64 (URL) encoded string into a UTF-8 string.

To import and use `StringFromBase64Url` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.StringFromBase64Url
```

**Signature**

```ts
export declare const StringFromBase64Url: Schema<string, string, never>
```


# StringFromHex

Decodes a hex encoded string into a UTF-8 string.

To import and use `StringFromHex` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.StringFromHex
```

**Signature**

```ts
export declare const StringFromHex: Schema<string, string, never>
```


# StringFromUriComponent

Decodes a URI component encoded string into a UTF-8 string.
Can be used to store data in a URL.

To import and use `StringFromUriComponent` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.StringFromUriComponent
```

**Example**

```ts
import { Schema } from "effect"

const PaginationSchema = Schema.Struct({
  maxItemPerPage: Schema.Number,
  page: Schema.Number
})

const UrlSchema = Schema.compose(Schema.StringFromUriComponent, Schema.parseJson(PaginationSchema))

console.log(Schema.encodeSync(UrlSchema)({ maxItemPerPage: 10, page: 1 }))
// Output: %7B%22maxItemPerPage%22%3A10%2C%22page%22%3A1%7D
```

**Signature**

```ts
export declare const StringFromUriComponent: transformOrFail<SchemaClass<string, string, never>, typeof String$, never>
```


# Symbol

Converts a string key into a globally shared symbol.

To import and use `Symbol` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.Symbol
```


# tag

Returns a property signature that represents a tag.
A tag is a literal value that is used to distinguish between different types of objects.
The tag is optional when using the `make` method.

To import and use `tag` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.tag
```

**Example**

```ts
import { Schema } from "effect"

const User = Schema.Struct({
  _tag: Schema.tag("User"),
  name: Schema.String,
  age: Schema.Number
})

assert.deepStrictEqual(User.make({ name: "John", age: 44 }), { _tag: "User", name: "John", age: 44 })
```

**Signature**

```ts
export declare const tag: <Tag extends AST.LiteralValue>(tag: Tag) => tag<Tag>
```


# TaggedStruct

A tagged struct is a struct that has a tag property that is used to distinguish between different types of objects.

The tag is optional when using the `make` method.

To import and use `TaggedStruct` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.TaggedStruct
```

**Example**

```ts
import { Schema } from "effect"

const User = Schema.TaggedStruct("User", {
  name: Schema.String,
  age: Schema.Number
})

assert.deepStrictEqual(User.make({ name: "John", age: 44 }), { _tag: "User", name: "John", age: 44 })
```

**Signature**

```ts
export declare const TaggedStruct: <Tag extends AST.LiteralValue, Fields extends Struct.Fields>(
  value: Tag,
  fields: Fields
) => TaggedStruct<Tag, Fields>
```


# TimeZone

Defines a schema that attempts to convert a `string` to a `TimeZone` using the `DateTime.zoneFromString` constructor.

To import and use `TimeZone` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.TimeZone
```


# TimeZoneNamed

Defines a schema that attempts to convert a `string` to a `TimeZone.Named` instance using the `DateTime.zoneUnsafeMakeNamed` constructor.

To import and use `TimeZoneNamed` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.TimeZoneNamed
```


# TimeZoneNamedFromSelf

Describes a schema that represents a `TimeZone.Named` instance.

To import and use `TimeZoneNamedFromSelf` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.TimeZoneNamedFromSelf
```


# TimeZoneOffset

Defines a schema that converts a `number` to a `TimeZone.Offset` instance using the `DateTime.zoneMakeOffset` constructor.

To import and use `TimeZoneOffset` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.TimeZoneOffset
```


# TimeZoneOffsetFromSelf

Describes a schema that represents a `TimeZone.Offset` instance.

To import and use `TimeZoneOffsetFromSelf` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.TimeZoneOffsetFromSelf
```


# transform

Create a new `Schema` by transforming the input and output of an existing `Schema`
using the provided mapping functions.

To import and use `transform` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.transform
```

**Signature**

```ts
export declare const transform: {
  <To extends Schema.Any, From extends Schema.Any>(
    to: To,
    options:
      | {
          readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>
          readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>
          readonly strict?: true
        }
      | {
          readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown
          readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown
          readonly strict: false
        }
  ): (from: From) => transform<From, To>
  <To extends Schema.Any, From extends Schema.Any>(
    from: From,
    to: To,
    options:
      | {
          readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>
          readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>
          readonly strict?: true
        }
      | {
          readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown
          readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown
          readonly strict: false
        }
  ): transform<From, To>
}
```


# transformLiteral

Creates a new `Schema` which transforms literal values.

To import and use `transformLiteral` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.transformLiteral
```

**Example**

```ts
import * as S from "effect/Schema"

const schema = S.transformLiteral(0, "a")

assert.deepStrictEqual(S.decodeSync(schema)(0), "a")
```

**Signature**

```ts
export declare const transformLiteral: <Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(
  from: Encoded,
  to: Type
) => transformLiteral<Type, Encoded>
```


# transformLiterals

Creates a new `Schema` which maps between corresponding literal values.

To import and use `transformLiterals` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.transformLiterals
```

**Example**

```ts
import * as S from "effect/Schema"

const Animal = S.transformLiterals([0, "cat"], [1, "dog"], [2, "cow"])

assert.deepStrictEqual(S.decodeSync(Animal)(1), "dog")
```

**Signature**

```ts
export declare function transformLiterals<
  const A extends AST.Members<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>
>(...pairs: A): Union<{ -readonly [I in keyof A]: transformLiteral<A[I][1], A[I][0]> }>
export declare function transformLiterals<Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(
  pairs: [Encoded, Type]
): transformLiteral<Type, Encoded>
export declare function transformLiterals<
  const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>
>(...pairs: A): Schema<A[number][1], A[number][0]>
```


# transformOrFail

Create a new `Schema` by transforming the input and output of an existing `Schema`
using the provided decoding functions.

To import and use `transformOrFail` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.transformOrFail
```

**Signature**

```ts
export declare const transformOrFail: {
  <To extends Schema.Any, From extends Schema.Any, RD, RE>(
    to: To,
    options:
      | {
          readonly decode: (
            fromA: Schema.Type<From>,
            options: ParseOptions,
            ast: AST.Transformation,
            fromI: Schema.Encoded<From>
          ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>
          readonly encode: (
            toI: Schema.Encoded<To>,
            options: ParseOptions,
            ast: AST.Transformation,
            toA: Schema.Type<To>
          ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>
          readonly strict?: true
        }
      | {
          readonly decode: (
            fromA: Schema.Type<From>,
            options: ParseOptions,
            ast: AST.Transformation,
            fromI: Schema.Encoded<From>
          ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>
          readonly encode: (
            toI: Schema.Encoded<To>,
            options: ParseOptions,
            ast: AST.Transformation,
            toA: Schema.Type<To>
          ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>
          readonly strict: false
        }
  ): (from: From) => transformOrFail<From, To, RD | RE>
  <To extends Schema.Any, From extends Schema.Any, RD, RE>(
    from: From,
    to: To,
    options:
      | {
          readonly decode: (
            fromA: Schema.Type<From>,
            options: ParseOptions,
            ast: AST.Transformation,
            fromI: Schema.Encoded<From>
          ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>
          readonly encode: (
            toI: Schema.Encoded<To>,
            options: ParseOptions,
            ast: AST.Transformation,
            toA: Schema.Type<To>
          ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>
          readonly strict?: true
        }
      | {
          readonly decode: (
            fromA: Schema.Type<From>,
            options: ParseOptions,
            ast: AST.Transformation,
            fromI: Schema.Encoded<From>
          ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>
          readonly encode: (
            toI: Schema.Encoded<To>,
            options: ParseOptions,
            ast: AST.Transformation,
            toA: Schema.Type<To>
          ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>
          readonly strict: false
        }
  ): transformOrFail<From, To, RD | RE>
}
```


# Trim

This schema allows removing whitespaces from the beginning and end of a string.

To import and use `Trim` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.Trim
```


# trimmed

Verifies that a string contains no leading or trailing whitespaces.

Note. This combinator does not make any transformations, it only validates.
If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.

To import and use `trimmed` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.trimmed
```

**Signature**

```ts
export declare const trimmed: <A extends string>(
  annotations?: Annotations.Filter<A>
) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>
```


# typeSchema

The `typeSchema` function allows you to extract the `Type` portion of a
schema, creating a new schema that conforms to the properties defined in the
original schema without considering the initial encoding or transformation
processes.

To import and use `typeSchema` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.typeSchema
```

**Signature**

```ts
export declare const typeSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<A>
```


# Uint8Array

A schema that transforms an array of numbers into a `Uint8Array`.

To import and use `Uint8Array` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.Uint8Array
```


# Uint8ArrayFromBase64

Decodes a base64 (RFC4648) encoded string into a `Uint8Array`.

To import and use `Uint8ArrayFromBase64` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.Uint8ArrayFromBase64
```

**Signature**

```ts
export declare const Uint8ArrayFromBase64: Schema<Uint8Array, string, never>
```


# Uint8ArrayFromBase64Url

Decodes a base64 (URL) encoded string into a `Uint8Array`.

To import and use `Uint8ArrayFromBase64Url` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.Uint8ArrayFromBase64Url
```

**Signature**

```ts
export declare const Uint8ArrayFromBase64Url: Schema<Uint8Array, string, never>
```


# Uint8ArrayFromHex

Decodes a hex encoded string into a `Uint8Array`.

To import and use `Uint8ArrayFromHex` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.Uint8ArrayFromHex
```

**Signature**

```ts
export declare const Uint8ArrayFromHex: Schema<Uint8Array, string, never>
```


# ULID

Represents a Universally Unique Lexicographically Sortable Identifier (ULID).

ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.
This schema ensures that the provided string adheres to the standard ULID format.

To import and use `ULID` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.ULID
```


# Uncapitalize

This schema converts a string to uncapitalized one.

To import and use `Uncapitalize` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.Uncapitalize
```


# uncapitalized

Verifies that a string is uncapitalized.

To import and use `uncapitalized` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.uncapitalized
```

**Signature**

```ts
export declare const uncapitalized: <A extends string>(
  annotations?: Annotations.Filter<A>
) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>
```


# Uppercase

This schema converts a string to uppercase.

To import and use `Uppercase` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.Uppercase
```


# uppercased

Verifies that a string is uppercased.

To import and use `uppercased` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.uppercased
```

**Signature**

```ts
export declare const uppercased: <A extends string>(
  annotations?: Annotations.Filter<A>
) => <I, R>(self: Schema<A, I, R>) => filter<Schema<A, I, R>>
```


# URL

Defines a schema that attempts to convert a `string` to a `URL` object using
the `new URL` constructor.

To import and use `URL` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.URL
```


# URLFromSelf

Defines a schema that represents a `URL` object.

To import and use `URLFromSelf` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.URLFromSelf
```


# UUID

Represents a Universally Unique Identifier (UUID).

This schema ensures that the provided string adheres to the standard UUID format.

To import and use `UUID` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.UUID
```


# validDate

Defines a filter that specifically rejects invalid dates, such as `new
Date("Invalid Date")`. This filter ensures that only properly formatted and
valid date objects are accepted, enhancing data integrity by preventing
erroneous date values from being processed.

To import and use `validDate` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.validDate
```

**Signature**

```ts
export declare const validDate: (
  annotations?: Annotations.Filter<Date>
) => <I, R>(self: Schema<Date, I, R>) => filter<Schema<Date, I, R>>
```


# ValidDateFromSelf

Defines a schema that ensures only valid dates are accepted. This schema
rejects values like `new Date("Invalid Date")`, which, despite being a `Date`
instance, represents an invalid date. Such stringent validation ensures that
all date objects processed through this schema are properly formed and
represent real dates.

To import and use `ValidDateFromSelf` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.ValidDateFromSelf
```


# withConstructorDefault

Enhances a property signature with a default constructor value.

To import and use `withConstructorDefault` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.withConstructorDefault
```

**Signature**

```ts
export declare const withConstructorDefault: {
  <Type>(
    defaultValue: () => Types.NoInfer<Type>
  ): <
    TypeToken extends PropertySignature.Token,
    Key extends PropertyKey,
    EncodedToken extends PropertySignature.Token,
    Encoded,
    R
  >(
    self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>
  ) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>
  <
    TypeToken extends PropertySignature.Token,
    Type,
    Key extends PropertyKey,
    EncodedToken extends PropertySignature.Token,
    Encoded,
    R
  >(
    self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>,
    defaultValue: () => Types.NoInfer<Type>
  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>
}
```


# withDecodingDefault

Enhances a property signature with a default decoding value.

To import and use `withDecodingDefault` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.withDecodingDefault
```

**Signature**

```ts
export declare const withDecodingDefault: {
  <Type>(
    defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>
  ): <Key extends PropertyKey, Encoded, R>(
    self: PropertySignature<"?:", Type, Key, "?:", Encoded, false, R>
  ) => PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, false, R>
  <Type, Key extends PropertyKey, Encoded, R>(
    self: PropertySignature<"?:", Type, Key, "?:", Encoded, false, R>,
    defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>
  ): PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, false, R>
}
```


# withDefaults

Enhances a property signature with a default decoding value and a default constructor value.

To import and use `withDefaults` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.withDefaults
```

**Signature**

```ts
export declare const withDefaults: {
  <Type>(defaults: {
    constructor: () => Types.NoInfer<Exclude<Type, undefined>>
    decoding: () => Types.NoInfer<Exclude<Type, undefined>>
  }): <Key extends PropertyKey, Encoded, R>(
    self: PropertySignature<"?:", Type, Key, "?:", Encoded, boolean, R>
  ) => PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, true, R>
  <Type, Key extends PropertyKey, Encoded, R>(
    self: PropertySignature<"?:", Type, Key, "?:", Encoded, boolean, R>,
    defaults: {
      constructor: () => Types.NoInfer<Exclude<Type, undefined>>
      decoding: () => Types.NoInfer<Exclude<Type, undefined>>
    }
  ): PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, true, R>
}
```


# WithResult

The `WithResult` trait is designed to encapsulate the outcome of an
operation, distinguishing between success and failure cases. Each case is
associated with a schema that defines the structure and types of the success
or failure data.

To import and use `WithResult` from the "Schema" module:

```ts
import * as Schema from "effect/Schema"
// Can be accessed like this
Schema.WithResult
```


# annotations

Merges a set of new annotations with existing ones, potentially overwriting
any duplicates.

To import and use `annotations` from the "SchemaAST" module:

```ts
import * as SchemaAST from "effect/SchemaAST"
// Can be accessed like this
SchemaAST.annotations
```

**Signature**

```ts
export declare const annotations: (ast: AST, a: Annotations) => AST
```


# getTemplateLiteralCapturingRegExp

Generates a regular expression that captures the pattern defined by the given `TemplateLiteral` AST.

To import and use `getTemplateLiteralCapturingRegExp` from the "SchemaAST" module:

```ts
import * as SchemaAST from "effect/SchemaAST"
// Can be accessed like this
SchemaAST.getTemplateLiteralCapturingRegExp
```

**Signature**

```ts
export declare const getTemplateLiteralCapturingRegExp: (ast: TemplateLiteral) => RegExp
```


# getTemplateLiteralRegExp

Generates a regular expression from a `TemplateLiteral` AST node.

To import and use `getTemplateLiteralRegExp` from the "SchemaAST" module:

```ts
import * as SchemaAST from "effect/SchemaAST"
// Can be accessed like this
SchemaAST.getTemplateLiteralRegExp
```

**Signature**

```ts
export declare const getTemplateLiteralRegExp: (ast: TemplateLiteral) => RegExp
```


# keyof

Equivalent at runtime to the TypeScript type-level `keyof` operator.

To import and use `keyof` from the "SchemaAST" module:

```ts
import * as SchemaAST from "effect/SchemaAST"
// Can be accessed like this
SchemaAST.keyof
```

**Signature**

```ts
export declare const keyof: (ast: AST) => AST
```


# mutable

Creates a new AST with shallow mutability applied to its properties.

To import and use `mutable` from the "SchemaAST" module:

```ts
import * as SchemaAST from "effect/SchemaAST"
// Can be accessed like this
SchemaAST.mutable
```

**Signature**

```ts
export declare const mutable: (ast: AST) => AST
```


# omit

Equivalent at runtime to the built-in TypeScript utility type `Omit`.

To import and use `omit` from the "SchemaAST" module:

```ts
import * as SchemaAST from "effect/SchemaAST"
// Can be accessed like this
SchemaAST.omit
```

**Signature**

```ts
export declare const omit: (ast: AST, keys: ReadonlyArray<PropertyKey>) => TypeLiteral | Transformation
```


# partial

Equivalent at runtime to the built-in TypeScript utility type `Partial`.

To import and use `partial` from the "SchemaAST" module:

```ts
import * as SchemaAST from "effect/SchemaAST"
// Can be accessed like this
SchemaAST.partial
```

**Signature**

```ts
export declare const partial: (ast: AST, options?: { readonly exact: true }) => AST
```


# pick

Equivalent at runtime to the built-in TypeScript utility type `Pick`.

To import and use `pick` from the "SchemaAST" module:

```ts
import * as SchemaAST from "effect/SchemaAST"
// Can be accessed like this
SchemaAST.pick
```

**Signature**

```ts
export declare const pick: (ast: AST, keys: ReadonlyArray<PropertyKey>) => TypeLiteral | Transformation
```


# PropertySignatureTransformation

Represents a `PropertySignature -> PropertySignature` transformation

The semantic of `decode` is:

- `none()` represents the absence of the key/value pair
- `some(value)` represents the presence of the key/value pair

The semantic of `encode` is:

- `none()` you don't want to output the key/value pair
- `some(value)` you want to output the key/value pair

To import and use `PropertySignatureTransformation` from the "SchemaAST" module:

```ts
import * as SchemaAST from "effect/SchemaAST"
// Can be accessed like this
SchemaAST.PropertySignatureTransformation
```


# required

Equivalent at runtime to the built-in TypeScript utility type `Required`.

To import and use `required` from the "SchemaAST" module:

```ts
import * as SchemaAST from "effect/SchemaAST"
// Can be accessed like this
SchemaAST.required
```

**Signature**

```ts
export declare const required: (ast: AST) => AST
```


# addFinalizer

Adds a finalizer to this scope. The finalizer is guaranteed to be run when
the scope is closed. Use this when the finalizer does not need to know the
`Exit` value that the scope is closed with.

To import and use `addFinalizer` from the "Scope" module:

```ts
import * as Scope from "effect/Scope"
// Can be accessed like this
Scope.addFinalizer
```

**Signature**

```ts
export declare const addFinalizer: (self: Scope, finalizer: Effect.Effect<unknown>) => Effect.Effect<void>
```


# addFinalizerExit

Adds a finalizer to this scope. The finalizer receives the `Exit` value
when the scope is closed, allowing it to perform different actions based
on the exit status.

To import and use `addFinalizerExit` from the "Scope" module:

```ts
import * as Scope from "effect/Scope"
// Can be accessed like this
Scope.addFinalizerExit
```

**Signature**

```ts
export declare const addFinalizerExit: (self: Scope, finalizer: Scope.Finalizer) => Effect.Effect<void>
```


# close

Closes this scope with the specified exit value, running all finalizers that
have been added to the scope.

To import and use `close` from the "Scope" module:

```ts
import * as Scope from "effect/Scope"
// Can be accessed like this
Scope.close
```

**Signature**

```ts
export declare const close: (self: CloseableScope, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>
```


# CloseableScope

A scope that can be explicitly closed with a specified exit value.

To import and use `CloseableScope` from the "Scope" module:

```ts
import * as Scope from "effect/Scope"
// Can be accessed like this
Scope.CloseableScope
```


# CloseableScopeTypeId

The type of the unique identifier for `CloseableScope`.

To import and use `CloseableScopeTypeId` from the "Scope" module:

```ts
import * as Scope from "effect/Scope"
// Can be accessed like this
Scope.CloseableScopeTypeId
```


# extend

Extends the scope of an `Effect` that requires a scope into this scope.
It provides this scope to the effect but does not close the scope when the
effect completes execution. This allows extending a scoped value into a
larger scope.

To import and use `extend` from the "Scope" module:

```ts
import * as Scope from "effect/Scope"
// Can be accessed like this
Scope.extend
```

**Signature**

```ts
export declare const extend: {
  (scope: Scope): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Scope>>
  <A, E, R>(effect: Effect.Effect<A, E, R>, scope: Scope): Effect.Effect<A, E, Exclude<R, Scope>>
}
```


# fork

Forks a new child scope with the specified execution strategy. The child scope
will automatically be closed when this scope is closed.

To import and use `fork` from the "Scope" module:

```ts
import * as Scope from "effect/Scope"
// Can be accessed like this
Scope.fork
```

**Signature**

```ts
export declare const fork: (self: Scope, strategy: ExecutionStrategy.ExecutionStrategy) => Effect.Effect<CloseableScope>
```


# make

Creates a new closeable scope where finalizers will run according to the
specified `ExecutionStrategy`. If no execution strategy is provided, `sequential`
will be used by default.

To import and use `make` from the "Scope" module:

```ts
import * as Scope from "effect/Scope"
// Can be accessed like this
Scope.make
```

**Signature**

```ts
export declare const make: (executionStrategy?: ExecutionStrategy.ExecutionStrategy) => Effect.Effect<CloseableScope>
```


# Scope

Represents a scope that manages finalizers and can fork child scopes.

To import and use `Scope` from the "Scope" module:

```ts
import * as Scope from "effect/Scope"
// Can be accessed like this
Scope.Scope
```


# ScopeTypeId

The type of the unique identifier for `Scope`.

To import and use `ScopeTypeId` from the "Scope" module:

```ts
import * as Scope from "effect/Scope"
// Can be accessed like this
Scope.ScopeTypeId
```


# use

Provides this closeable scope to an `Effect` that requires a scope,
guaranteeing that the scope is closed with the result of that effect as
soon as the effect completes execution, whether by success, failure, or
interruption.

To import and use `use` from the "Scope" module:

```ts
import * as Scope from "effect/Scope"
// Can be accessed like this
Scope.use
```

**Signature**

```ts
export declare const use: {
  (scope: CloseableScope): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Scope>>
  <A, E, R>(effect: Effect.Effect<A, E, R>, scope: CloseableScope): Effect.Effect<A, E, Exclude<R, Scope>>
}
```


# Lookup

Similar to `Cache.Lookup`, but executes the lookup function within a `Scope`.

To import and use `Lookup` from the "ScopedCache" module:

```ts
import * as ScopedCache from "effect/ScopedCache"
// Can be accessed like this
ScopedCache.Lookup
```


# make

Constructs a new cache with the specified capacity, time to live, and
lookup function.

To import and use `make` from the "ScopedCache" module:

```ts
import * as ScopedCache from "effect/ScopedCache"
// Can be accessed like this
ScopedCache.make
```

**Signature**

```ts
export declare const make: <Key, Value, Error = never, Environment = never>(options: {
  readonly lookup: Lookup<Key, Value, Error, Environment>
  readonly capacity: number
  readonly timeToLive: Duration.DurationInput
}) => Effect.Effect<ScopedCache<Key, Value, Error>, never, Scope.Scope | Environment>
```


# makeWith

Constructs a new cache with the specified capacity, time to live, and
lookup function, where the time to live can depend on the `Exit` value
returned by the lookup function.

To import and use `makeWith` from the "ScopedCache" module:

```ts
import * as ScopedCache from "effect/ScopedCache"
// Can be accessed like this
ScopedCache.makeWith
```

**Signature**

```ts
export declare const makeWith: <Key, Value, Error = never, Environment = never>(options: {
  readonly capacity: number
  readonly lookup: Lookup<Key, Value, Error, Environment>
  readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput
}) => Effect.Effect<ScopedCache<Key, Value, Error>, never, Scope.Scope | Environment>
```


# fromAcquire

Creates a new `ScopedRef` from an effect that resourcefully produces a
value.

To import and use `fromAcquire` from the "ScopedRef" module:

```ts
import * as ScopedRef from "effect/ScopedRef"
// Can be accessed like this
ScopedRef.fromAcquire
```

**Signature**

```ts
export declare const fromAcquire: <A, E, R>(
  acquire: Effect.Effect<A, E, R>
) => Effect.Effect<ScopedRef<A>, E, Scope.Scope | R>
```


# get

Retrieves the current value of the scoped reference.

To import and use `get` from the "ScopedRef" module:

```ts
import * as ScopedRef from "effect/ScopedRef"
// Can be accessed like this
ScopedRef.get
```

**Signature**

```ts
export declare const get: <A>(self: ScopedRef<A>) => Effect.Effect<A>
```


# make

Creates a new `ScopedRef` from the specified value. This method should
not be used for values whose creation require the acquisition of resources.

To import and use `make` from the "ScopedRef" module:

```ts
import * as ScopedRef from "effect/ScopedRef"
// Can be accessed like this
ScopedRef.make
```

**Signature**

```ts
export declare const make: <A>(evaluate: LazyArg<A>) => Effect.Effect<ScopedRef<A>, never, Scope.Scope>
```


# ScopedRef

A `ScopedRef` is a reference whose value is associated with resources,
which must be released properly. You can both get the current value of any
`ScopedRef`, as well as set it to a new value (which may require new
resources). The reference itself takes care of properly releasing resources
for the old value whenever a new value is obtained.

To import and use `ScopedRef` from the "ScopedRef" module:

```ts
import * as ScopedRef from "effect/ScopedRef"
// Can be accessed like this
ScopedRef.ScopedRef
```


# set

Sets the value of this reference to the specified resourcefully-created
value. Any resources associated with the old value will be released.

This method will not return until either the reference is successfully
changed to the new value, with old resources released, or until the attempt
to acquire a new value fails.

To import and use `set` from the "ScopedRef" module:

```ts
import * as ScopedRef from "effect/ScopedRef"
// Can be accessed like this
ScopedRef.set
```

**Signature**

```ts
export declare const set: {
  <A, R, E>(acquire: Effect.Effect<A, E, R>): (self: ScopedRef<A>) => Effect.Effect<void, E, Exclude<R, Scope.Scope>>
  <A, R, E>(self: ScopedRef<A>, acquire: Effect.Effect<A, E, R>): Effect.Effect<void, E, Exclude<R, Scope.Scope>>
}
```


# getSemigroup

Lift a `Semigroup` into 'F', the inner values are combined using the provided `Semigroup`.

To import and use `getSemigroup` from the "SemiApplicative" module:

```ts
import * as SemiApplicative from "@effect/typeclass/SemiApplicative"
// Can be accessed like this
SemiApplicative.getSemigroup
```

**Signature**

```ts
export declare const getSemigroup: <F extends TypeLambda>(
  F: SemiApplicative<F>
) => <A, R, O, E>(S: Semigroup<A>) => Semigroup<Kind<F, R, O, E, A>>
```


# lift2

Lifts a binary function into `F`.

To import and use `lift2` from the "SemiApplicative" module:

```ts
import * as SemiApplicative from "@effect/typeclass/SemiApplicative"
// Can be accessed like this
SemiApplicative.lift2
```

**Signature**

```ts
export declare const lift2: <F extends TypeLambda>(
  F: SemiApplicative<F>
) => <A, B, C>(
  f: (a: A, b: B) => C
) => {
  <R2, O2, E2>(
    that: Kind<F, R2, O2, E2, B>
  ): <R1, O1, E1>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, C>
  <R1, O1, E1, R2, O2, E2>(
    self: Kind<F, R1, O1, E1, A>,
    that: Kind<F, R2, O2, E2, B>
  ): Kind<F, R1 & R2, O1 | O2, E1 | E2, C>
}
```


# zipWith

Zips two `F` values together using a provided function, returning a new `F` of the result.

To import and use `zipWith` from the "SemiApplicative" module:

```ts
import * as SemiApplicative from "@effect/typeclass/SemiApplicative"
// Can be accessed like this
SemiApplicative.zipWith
```

**Signature**

```ts
export declare const zipWith: <F extends TypeLambda>(
  F: SemiApplicative<F>
) => {
  <R2, O2, E2, B, A, C>(
    that: Kind<F, R2, O2, E2, B>,
    f: (a: A, b: B) => C
  ): <R1, O1, E1>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, C>
  <R1, O1, E1, A, R2, O2, E2, B, C>(
    self: Kind<F, R1, O1, E1, A>,
    that: Kind<F, R2, O2, E2, B>,
    f: (a: A, b: B) => C
  ): Kind<F, R1 & R2, O1 | O2, E1 | E2, C>
}
```


# array

Given a type `A`, this function creates and returns a `Semigroup` for `ReadonlyArray<A>`.
The returned `Semigroup` combines two arrays by concatenating them.

To import and use `array` from the "Semigroup" module:

```ts
import * as Semigroup from "@effect/typeclass/Semigroup"
// Can be accessed like this
Semigroup.array
```

**Signature**

```ts
export declare const array: <A>() => Semigroup<ReadonlyArray<A>>
```


# first

Always return the first argument.

To import and use `first` from the "Semigroup" module:

```ts
import * as Semigroup from "@effect/typeclass/Semigroup"
// Can be accessed like this
Semigroup.first
```

**Signature**

```ts
export declare const first: <A = never>() => Semigroup<A>
```


# intercalate

The `intercalate` API returns a function that takes a `Semigroup` instance and a separator value, and returns a new
`Semigroup` instance that combines values with the given separator.

This API is useful when you want to combine values with a specific separator. For example, when you want to concatenate
an array of strings with a separator string in between.

It is interesting to note that there is no equivalent API in the `Monoid` module. This is because the value `empty`,
which is required for the `Monoid` interface, cannot exist.

To import and use `intercalate` from the "Semigroup" module:

```ts
import * as Semigroup from "@effect/typeclass/Semigroup"
// Can be accessed like this
Semigroup.intercalate
```

**Signature**

```ts
export declare const intercalate: {
  <A>(separator: A): (S: Semigroup<A>) => Semigroup<A>
  <A>(S: Semigroup<A>, separator: A): Semigroup<A>
}
```


# last

Always return the last argument.

To import and use `last` from the "Semigroup" module:

```ts
import * as Semigroup from "@effect/typeclass/Semigroup"
// Can be accessed like this
Semigroup.last
```

**Signature**

```ts
export declare const last: <A = never>() => Semigroup<A>
```


# max

`Semigroup` that returns last maximum of elements.

To import and use `max` from the "Semigroup" module:

```ts
import * as Semigroup from "@effect/typeclass/Semigroup"
// Can be accessed like this
Semigroup.max
```

**Signature**

```ts
export declare const max: <A>(O: Order<A>) => Semigroup<A>
```


# min

`Semigroup` that returns last minimum of elements.

To import and use `min` from the "Semigroup" module:

```ts
import * as Semigroup from "@effect/typeclass/Semigroup"
// Can be accessed like this
Semigroup.min
```

**Signature**

```ts
export declare const min: <A>(O: Order<A>) => Semigroup<A>
```


# reverse

The dual of a `Semigroup`, obtained by flipping the arguments of `combine`.

To import and use `reverse` from the "Semigroup" module:

```ts
import * as Semigroup from "@effect/typeclass/Semigroup"
// Can be accessed like this
Semigroup.reverse
```

**Signature**

```ts
export declare const reverse: <A>(S: Semigroup<A>) => Semigroup<A>
```


# struct

This function creates and returns a new `Semigroup` for a struct of values based on the given `Semigroup`s for each property in the struct.
The returned `Semigroup` combines two structs of the same type by applying the corresponding `Semigroup` passed as arguments to each property in the struct.

It is useful when you need to combine two structs of the same type and you have a specific way of combining each property of the struct.

To import and use `struct` from the "Semigroup" module:

```ts
import * as Semigroup from "@effect/typeclass/Semigroup"
// Can be accessed like this
Semigroup.struct
```

**Signature**

```ts
export declare const struct: <R extends { readonly [x: string]: Semigroup<any> }>(
  fields: R
) => Semigroup<{ readonly [K in keyof R]: [R[K]] extends [Semigroup<infer A>] ? A : never }>
```


# tuple

Similar to `Promise.all` but operates on `Semigroup`s.

```
[Semigroup<A>, Semigroup<B>, ...] -> Semigroup<[A, B, ...]>
```

This function creates and returns a new `Semigroup` for a tuple of values based on the given `Semigroup`s for each element in the tuple.
The returned `Semigroup` combines two tuples of the same type by applying the corresponding `Semigroup` passed as arguments to each element in the tuple.

It is useful when you need to combine two tuples of the same type and you have a specific way of combining each element of the tuple.

To import and use `tuple` from the "Semigroup" module:

```ts
import * as Semigroup from "@effect/typeclass/Semigroup"
// Can be accessed like this
Semigroup.tuple
```

**Signature**

```ts
export declare const tuple: <T extends ReadonlyArray<Semigroup<any>>>(
  ...elements: T
) => Semigroup<{ readonly [I in keyof T]: [T[I]] extends [Semigroup<infer A>] ? A : never }>
```


# appendElement

Appends an element to the end of a tuple.

To import and use `appendElement` from the "SemiProduct" module:

```ts
import * as SemiProduct from "@effect/typeclass/SemiProduct"
// Can be accessed like this
SemiProduct.appendElement
```

**Signature**

```ts
export declare const appendElement: <F extends TypeLambda>(
  F: SemiProduct<F>
) => {
  <R2, O2, E2, B>(
    that: Kind<F, R2, O2, E2, B>
  ): <R1, O1, E1, A extends ReadonlyArray<any>>(
    self: Kind<F, R1, O1, E1, A>
  ) => Kind<F, R1 & R2, O2 | O1, E2 | E1, [...A, B]>
  <R1, O1, E1, A extends ReadonlyArray<any>, R2, O2, E2, B>(
    self: Kind<F, R1, O1, E1, A>,
    that: Kind<F, R2, O2, E2, B>
  ): Kind<F, R1 & R2, O1 | O2, E1 | E2, [...A, B]>
}
```


# productComposition

Returns a default `product` composition.

To import and use `productComposition` from the "SemiProduct" module:

```ts
import * as SemiProduct from "@effect/typeclass/SemiProduct"
// Can be accessed like this
SemiProduct.productComposition
```

**Signature**

```ts
export declare const productComposition: <F extends TypeLambda, G extends TypeLambda>(
  F: SemiApplicative<F>,
  G: SemiProduct<G>
) => <FR1, FO1, FE1, GR1, GO1, GE1, A, FR2, FO2, FE2, GR2, GO2, GE2, B>(
  self: Kind<F, FR1, FO1, FE1, Kind<G, GR1, GO1, GE1, A>>,
  that: Kind<F, FR2, FO2, FE2, Kind<G, GR2, GO2, GE2, B>>
) => Kind<F, FR1 & FR2, FO1 | FO2, FE1 | FE2, Kind<G, GR1 & GR2, GO1 | GO2, GE1 | GE2, [A, B]>>
```


# productMany

Returns a default `productMany` implementation.

To import and use `productMany` from the "SemiProduct" module:

```ts
import * as SemiProduct from "@effect/typeclass/SemiProduct"
// Can be accessed like this
SemiProduct.productMany
```

**Signature**

```ts
export declare const productMany: <F extends TypeLambda>(
  map: Covariant<F>["map"],
  product: SemiProduct<F>["product"]
) => SemiProduct<F>["productMany"]
```


# productManyComposition

Returns a default `productMany` composition.

To import and use `productManyComposition` from the "SemiProduct" module:

```ts
import * as SemiProduct from "@effect/typeclass/SemiProduct"
// Can be accessed like this
SemiProduct.productManyComposition
```

**Signature**

```ts
export declare const productManyComposition: <F extends TypeLambda, G extends TypeLambda>(
  F: SemiApplicative<F>,
  G: SemiProduct<G>
) => <FR, FO, FE, GR, GO, GE, A>(
  self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>,
  collection: Iterable<Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>>
) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, [A, ...Array<A>]>>
```


# json

A layer that uses JSON serialization for encoding and decoding messages.
This is useful for testing and not recommended to use in production.

To import and use `json` from the "Serialization" module:

```ts
import * as Serialization from "@effect/cluster/Serialization"
// Can be accessed like this
Serialization.json
```

**Signature**

```ts
export declare const json: Layer.Layer<Serialization, never, never>
```


# Serialization

An interface to serialize user messages that will be sent between pods.

To import and use `Serialization` from the "Serialization" module:

```ts
import * as Serialization from "@effect/cluster/Serialization"
// Can be accessed like this
Serialization.Serialization
```


# isSerializedEnvelope

Ensures that the given value is a SerializedEnvelope.

To import and use `isSerializedEnvelope` from the "SerializedEnvelope" module:

```ts
import * as SerializedEnvelope from "@effect/cluster/SerializedEnvelope"
// Can be accessed like this
SerializedEnvelope.isSerializedEnvelope
```

**Signature**

```ts
export declare function isSerializedEnvelope(value: unknown): value is SerializedEnvelope
```


# make

Construct a new `SerializedEnvelope`

To import and use `make` from the "SerializedEnvelope" module:

```ts
import * as SerializedEnvelope from "@effect/cluster/SerializedEnvelope"
// Can be accessed like this
SerializedEnvelope.make
```

**Signature**

```ts
export declare function make(
  recipientAddress: RecipientAddress.RecipientAddress,
  messageId: string,
  body: SerializedMessage.SerializedMessage
): SerializedEnvelope
```


# schema

This is the schema for a value.

To import and use `schema` from the "SerializedEnvelope" module:

```ts
import * as SerializedEnvelope from "@effect/cluster/SerializedEnvelope"
// Can be accessed like this
SerializedEnvelope.schema
```

**Signature**

```ts
export declare const schema: Schema.Schema<SerializedEnvelope, SerializedEnvelope.Encoded, never>
```


# SerializedEnvelope

A SerializedEnvelope is the message that goes over the wire between pods.
Inside the Envelope, you have the encoded messages, plus some informations on where it should be routed to.

To import and use `SerializedEnvelope` from the "SerializedEnvelope" module:

```ts
import * as SerializedEnvelope from "@effect/cluster/SerializedEnvelope"
// Can be accessed like this
SerializedEnvelope.SerializedEnvelope
```


# make

Construct a new `SerializedMessage` from its internal string value.

To import and use `make` from the "SerializedMessage" module:

```ts
import * as SerializedMessage from "@effect/cluster/SerializedMessage"
// Can be accessed like this
SerializedMessage.make
```

**Signature**

```ts
export declare function make(value: string): SerializedMessage
```


# schema

This is the schema for a value.

To import and use `schema` from the "SerializedMessage" module:

```ts
import * as SerializedMessage from "@effect/cluster/SerializedMessage"
// Can be accessed like this
SerializedMessage.schema
```

**Signature**

```ts
export declare const schema: Schema.Schema<SerializedMessage, SerializedMessage.Encoded, never>
```


# SerializedMessage

Represents a Message that has been serialized.

To import and use `SerializedMessage` from the "SerializedMessage" module:

```ts
import * as SerializedMessage from "@effect/cluster/SerializedMessage"
// Can be accessed like this
SerializedMessage.SerializedMessage
```


# make

Constructs a shard id from its numerical value.
The shard id is currently built up by making the hash of the entity id, and then modulo the max amount of shards configured in ManagerConfig.

To import and use `make` from the "ShardId" module:

```ts
import * as ShardId from "@effect/cluster/ShardId"
// Can be accessed like this
ShardId.make
```

**Signature**

```ts
export declare function make(value: number): ShardId
```


# schema

This is the schema for a ShardId.

To import and use `schema` from the "ShardId" module:

```ts
import * as ShardId from "@effect/cluster/ShardId"
// Can be accessed like this
ShardId.schema
```

**Signature**

```ts
export declare const schema: Schema.Schema<ShardId, ShardId.Encoded, never>
```


# ShardId

A shard is a logical grouping of multiple entities. There could be thousands of entities in your system,
so instead of managing every single entity id, the shard manager group them by shard id, and when they are assigned
or moved around, we always move all the entities with the same shard id.

To import and use `ShardId` from the "ShardId" module:

```ts
import * as ShardId from "@effect/cluster/ShardId"
// Can be accessed like this
ShardId.ShardId
```


# broadcaster

Get an object that allows broadcasting messages to a given topic type.
You can provide a custom send timeout to override the one globally defined.

To import and use `broadcaster` from the "Sharding" module:

```ts
import * as Sharding from "@effect/cluster/Sharding"
// Can be accessed like this
Sharding.broadcaster
```

**Signature**

```ts
export declare const broadcaster: <Msg extends Message.Message.Any>(
  topicType: RecipentType.TopicType<Msg>
) => Effect.Effect<Broadcaster<Msg>, never, Sharding>
```


# getAssignedShardIds

Gets the list of shardIds assigned to the current Pod

To import and use `getAssignedShardIds` from the "Sharding" module:

```ts
import * as Sharding from "@effect/cluster/Sharding"
// Can be accessed like this
Sharding.getAssignedShardIds
```

**Signature**

```ts
export declare const getAssignedShardIds: Effect.Effect<HashSet.HashSet<ShardId.ShardId>, never, Sharding>
```


# getPods

Get the list of pods currently registered to the Shard Manager

To import and use `getPods` from the "Sharding" module:

```ts
import * as Sharding from "@effect/cluster/Sharding"
// Can be accessed like this
Sharding.getPods
```

**Signature**

```ts
export declare const getPods: Effect.Effect<HashSet.HashSet<PodAddress.PodAddress>, never, Sharding>
```


# messenger

Get an object that allows sending messages to a given entity type.
You can provide a custom send timeout to override the one globally defined.

To import and use `messenger` from the "Sharding" module:

```ts
import * as Sharding from "@effect/cluster/Sharding"
// Can be accessed like this
Sharding.messenger
```

**Signature**

```ts
export declare const messenger: <Msg extends Message.Message.Any>(
  entityType: RecipentType.EntityType<Msg>
) => Effect.Effect<Messenger<Msg>, never, Sharding>
```


# register

Notify the shard manager that shards can now be assigned to this pod.

To import and use `register` from the "Sharding" module:

```ts
import * as Sharding from "@effect/cluster/Sharding"
// Can be accessed like this
Sharding.register
```

**Signature**

```ts
export declare const register: Effect.Effect<void, never, Sharding>
```


# registerEntity

Register a new entity type, allowing pods to send messages to entities of this type.

To import and use `registerEntity` from the "Sharding" module:

```ts
import * as Sharding from "@effect/cluster/Sharding"
// Can be accessed like this
Sharding.registerEntity
```

**Signature**

```ts
export declare const registerEntity: <Msg extends Message.Message.Any>(
  entityType: RecipentType.EntityType<Msg>
) => <R>(
  behavior: RecipientBehaviour.RecipientBehaviour<Msg, R>,
  options?: RecipientBehaviour.EntityBehaviourOptions | undefined
) => Effect.Effect<void, never, Sharding | Exclude<R, RecipientBehaviourContext.RecipientBehaviourContext>>
```


# registerScoped

Same as `register`, but will automatically call `unregister` when the `Scope` is terminated.

To import and use `registerScoped` from the "Sharding" module:

```ts
import * as Sharding from "@effect/cluster/Sharding"
// Can be accessed like this
Sharding.registerScoped
```

**Signature**

```ts
export declare const registerScoped: Effect.Effect<void, never, Sharding | Scope.Scope>
```


# registerSingleton

Start a computation that is guaranteed to run only on a single pod.
Each pod should call `registerSingleton` but only a single pod will actually run it at any given time.

To import and use `registerSingleton` from the "Sharding" module:

```ts
import * as Sharding from "@effect/cluster/Sharding"
// Can be accessed like this
Sharding.registerSingleton
```

**Signature**

```ts
export declare const registerSingleton: <R>(
  name: string,
  run: Effect.Effect<void, never, R>
) => Effect.Effect<void, never, Sharding | R>
```


# registerTopic

Register a new topic type, allowing pods to broadcast messages to subscribers.

To import and use `registerTopic` from the "Sharding" module:

```ts
import * as Sharding from "@effect/cluster/Sharding"
// Can be accessed like this
Sharding.registerTopic
```

**Signature**

```ts
export declare const registerTopic: <Msg extends Message.Message.Any>(
  topicType: RecipentType.TopicType<Msg>
) => <R>(
  behavior: RecipientBehaviour.RecipientBehaviour<Msg, R>,
  options?: RecipientBehaviour.EntityBehaviourOptions | undefined
) => Effect.Effect<void, never, Sharding | Exclude<R, RecipientBehaviourContext.RecipientBehaviourContext>>
```


# sendMessageToLocalEntityManagerWithoutRetries

Sends a raw message to the local entity manager without performing reties.
Those are up to the caller.

To import and use `sendMessageToLocalEntityManagerWithoutRetries` from the "Sharding" module:

```ts
import * as Sharding from "@effect/cluster/Sharding"
// Can be accessed like this
Sharding.sendMessageToLocalEntityManagerWithoutRetries
```

**Signature**

```ts
export declare const sendMessageToLocalEntityManagerWithoutRetries: (
  message: SerializedEnvelope.SerializedEnvelope
) => Effect.Effect<
  MessageState.MessageState<SerializedMessage.SerializedMessage>,
  ShardingException.ShardingException,
  Sharding
>
```


# unregister

Notify the shard manager that shards must be unassigned from this pod.

To import and use `unregister` from the "Sharding" module:

```ts
import * as Sharding from "@effect/cluster/Sharding"
// Can be accessed like this
Sharding.unregister
```

**Signature**

```ts
export declare const unregister: Effect.Effect<void, never, Sharding>
```


# defaults

Provides the default values for the ShardingConfig.

To import and use `defaults` from the "ShardingConfig" module:

```ts
import * as ShardingConfig from "@effect/cluster/ShardingConfig"
// Can be accessed like this
ShardingConfig.defaults
```

**Signature**

```ts
export declare const defaults: Layer.Layer<ShardingConfig, never, never>
```


# fromConfig

Reads the ShardingConfig from the effect/ConfigProvider

To import and use `fromConfig` from the "ShardingConfig" module:

```ts
import * as ShardingConfig from "@effect/cluster/ShardingConfig"
// Can be accessed like this
ShardingConfig.fromConfig
```

**Signature**

```ts
export declare const fromConfig: Layer.Layer<ShardingConfig, ConfigError.ConfigError, never>
```


# ShardingConfig

Sharding configuration

To import and use `ShardingConfig` from the "ShardingConfig" module:

```ts
import * as ShardingConfig from "@effect/cluster/ShardingConfig"
// Can be accessed like this
ShardingConfig.ShardingConfig
```


# withDefaults

Provides the ShardingConfig, values that are omitted will be read from the defaults

To import and use `withDefaults` from the "ShardingConfig" module:

```ts
import * as ShardingConfig from "@effect/cluster/ShardingConfig"
// Can be accessed like this
ShardingConfig.withDefaults
```

**Signature**

```ts
export declare const withDefaults: (customs: Partial<ShardingConfig>) => Layer.Layer<ShardingConfig>
```


# PodHealthChecked

Constructs the event that occurs when the health of a Pod has been checked

To import and use `PodHealthChecked` from the "ShardingEvent" module:

```ts
import * as ShardingEvent from "@effect/cluster/ShardingEvent"
// Can be accessed like this
ShardingEvent.PodHealthChecked
```

**Signature**

```ts
export declare function PodHealthChecked(pod: PodAddress.PodAddress): PodHealthChecked
```


# PodRegistered

Constructs the event that occurs when a new Pod has registered

To import and use `PodRegistered` from the "ShardingEvent" module:

```ts
import * as ShardingEvent from "@effect/cluster/ShardingEvent"
// Can be accessed like this
ShardingEvent.PodRegistered
```

**Signature**

```ts
export declare function PodRegistered(pod: PodAddress.PodAddress): PodRegistered
```


# PodUnregistered

Constructs the event that occurs when a pod has unregistered

To import and use `PodUnregistered` from the "ShardingEvent" module:

```ts
import * as ShardingEvent from "@effect/cluster/ShardingEvent"
// Can be accessed like this
ShardingEvent.PodUnregistered
```

**Signature**

```ts
export declare function PodUnregistered(pod: PodAddress.PodAddress): PodUnregistered
```


# ShardingEvent

This are the events that may occur over the ShardManager during its lifetime.

To import and use `ShardingEvent` from the "ShardingEvent" module:

```ts
import * as ShardingEvent from "@effect/cluster/ShardingEvent"
// Can be accessed like this
ShardingEvent.ShardingEvent
```


# ShardsAssigned

Constructs the event that occurs when new shards are assigned to Pod.

To import and use `ShardsAssigned` from the "ShardingEvent" module:

```ts
import * as ShardingEvent from "@effect/cluster/ShardingEvent"
// Can be accessed like this
ShardingEvent.ShardsAssigned
```

**Signature**

```ts
export declare function ShardsAssigned(
  pod: PodAddress.PodAddress,
  shards: HashSet.HashSet<ShardId.ShardId>
): ShardsAssigned
```


# ShardsUnassigned

Constructs the event that occurs when shards are unassigned to a Pod

To import and use `ShardsUnassigned` from the "ShardingEvent" module:

```ts
import * as ShardingEvent from "@effect/cluster/ShardingEvent"
// Can be accessed like this
ShardingEvent.ShardsUnassigned
```

**Signature**

```ts
export declare function ShardsUnassigned(
  pod: PodAddress.PodAddress,
  shards: HashSet.HashSet<ShardId.ShardId>
): ShardsUnassigned
```


# EntityRegistered

Constructs and event that occurs when a new EntityType gets registered.

To import and use `EntityRegistered` from the "ShardingRegistrationEvent" module:

```ts
import * as ShardingRegistrationEvent from "@effect/cluster/ShardingRegistrationEvent"
// Can be accessed like this
ShardingRegistrationEvent.EntityRegistered
```

**Signature**

```ts
export declare function EntityRegistered<Msg extends Message.Message.Any>(
  entityType: RecipientType.EntityType<Msg>
): ShardingRegistrationEvent
```


# SingletonRegistered

Constructs a new event that occurs when a new Singleton is registered.

To import and use `SingletonRegistered` from the "ShardingRegistrationEvent" module:

```ts
import * as ShardingRegistrationEvent from "@effect/cluster/ShardingRegistrationEvent"
// Can be accessed like this
ShardingRegistrationEvent.SingletonRegistered
```

**Signature**

```ts
export declare function SingletonRegistered(name: string): ShardingRegistrationEvent
```


# TopicRegistered

Constructs a new event that occurs when a topic is Registered.

To import and use `TopicRegistered` from the "ShardingRegistrationEvent" module:

```ts
import * as ShardingRegistrationEvent from "@effect/cluster/ShardingRegistrationEvent"
// Can be accessed like this
ShardingRegistrationEvent.TopicRegistered
```

**Signature**

```ts
export declare function TopicRegistered<Msg extends Message.Message.Any>(
  topicType: RecipientType.TopicType<Msg>
): ShardingRegistrationEvent
```


# ShardManagerClient

ShardManagerClient provides the methods exposed by the ShardManager and called by the Pod.

To import and use `ShardManagerClient` from the "ShardManagerClient" module:

```ts
import * as ShardManagerClient from "@effect/cluster/ShardManagerClient"
// Can be accessed like this
ShardManagerClient.ShardManagerClient
```


# AsyncInputConsumer

Consumer-side view of `SingleProducerAsyncInput` for variance purposes.

To import and use `AsyncInputConsumer` from the "SingleProducerAsyncInput" module:

```ts
import * as SingleProducerAsyncInput from "effect/SingleProducerAsyncInput"
// Can be accessed like this
SingleProducerAsyncInput.AsyncInputConsumer
```


# AsyncInputProducer

Producer-side view of `SingleProducerAsyncInput` for variance purposes.

To import and use `AsyncInputProducer` from the "SingleProducerAsyncInput" module:

```ts
import * as SingleProducerAsyncInput from "effect/SingleProducerAsyncInput"
// Can be accessed like this
SingleProducerAsyncInput.AsyncInputProducer
```


# SingleProducerAsyncInput

An MVar-like abstraction for sending data to channels asynchronously which is
designed for one producer and multiple consumers.

Features the following semantics:

- Buffer of size 1.
- When emitting, the producer waits for a consumer to pick up the value to
  prevent "reading ahead" too much.
- Once an emitted element is read by a consumer, it is cleared from the
  buffer, so that at most one consumer sees every emitted element.
- When sending a done or error signal, the producer does not wait for a
  consumer to pick up the signal. The signal stays in the buffer after
  being read by a consumer, so it can be propagated to multiple consumers.
- Trying to publish another emit/error/done after an error/done have
  already been published results in an interruption.

To import and use `SingleProducerAsyncInput` from the "SingleProducerAsyncInput" module:

```ts
import * as SingleProducerAsyncInput from "effect/SingleProducerAsyncInput"
// Can be accessed like this
SingleProducerAsyncInput.SingleProducerAsyncInput
```


# as

Replaces this sink's result with the provided value.

To import and use `as` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.as
```

**Signature**

```ts
export declare const as: {
  <A2>(a: A2): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E, R>
  <A, In, L, E, R, A2>(self: Sink<A, In, L, E, R>, a: A2): Sink<A2, In, L, E, R>
}
```


# collectAll

A sink that collects all elements into a `Chunk`.

To import and use `collectAll` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.collectAll
```

**Signature**

```ts
export declare const collectAll: <In>() => Sink<Chunk.Chunk<In>, In>
```


# collectAllFrom

Repeatedly runs the sink and accumulates its results into a `Chunk`.

To import and use `collectAllFrom` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.collectAllFrom
```

**Signature**

```ts
export declare const collectAllFrom: <A, In, L extends In, E, R>(
  self: Sink<A, In, L, E, R>
) => Sink<Chunk.Chunk<A>, In, L, E, R>
```


# collectAllN

A sink that collects first `n` elements into a chunk.

To import and use `collectAllN` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.collectAllN
```

**Signature**

```ts
export declare const collectAllN: <In>(n: number) => Sink<Chunk.Chunk<In>, In, In>
```


# collectAllToMap

A sink that collects all of its inputs into a map. The keys are extracted
from inputs using the keying function `key`; if multiple inputs use the
same key, they are merged using the `merge` function.

To import and use `collectAllToMap` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.collectAllToMap
```

**Signature**

```ts
export declare const collectAllToMap: <In, K>(
  key: (input: In) => K,
  merge: (x: In, y: In) => In
) => Sink<HashMap.HashMap<K, In>, In>
```


# collectAllToMapN

A sink that collects first `n` keys into a map. The keys are calculated
from inputs using the keying function `key`; if multiple inputs use the the
same key, they are merged using the `merge` function.

To import and use `collectAllToMapN` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.collectAllToMapN
```

**Signature**

```ts
export declare const collectAllToMapN: <In, K>(
  n: number,
  key: (input: In) => K,
  merge: (x: In, y: In) => In
) => Sink<HashMap.HashMap<K, In>, In, In>
```


# collectAllToSet

A sink that collects all of its inputs into a set.

To import and use `collectAllToSet` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.collectAllToSet
```

**Signature**

```ts
export declare const collectAllToSet: <In>() => Sink<HashSet.HashSet<In>, In>
```


# collectAllToSetN

A sink that collects first `n` distinct inputs into a set.

To import and use `collectAllToSetN` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.collectAllToSetN
```

**Signature**

```ts
export declare const collectAllToSetN: <In>(n: number) => Sink<HashSet.HashSet<In>, In, In>
```


# collectAllUntil

Accumulates incoming elements into a chunk until predicate `p` is
satisfied.

To import and use `collectAllUntil` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.collectAllUntil
```

**Signature**

```ts
export declare const collectAllUntil: <In>(p: Predicate<In>) => Sink<Chunk.Chunk<In>, In, In>
```


# collectAllUntilEffect

Accumulates incoming elements into a chunk until effectful predicate `p` is
satisfied.

To import and use `collectAllUntilEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.collectAllUntilEffect
```

**Signature**

```ts
export declare const collectAllUntilEffect: <In, E, R>(
  p: (input: In) => Effect.Effect<boolean, E, R>
) => Sink<Chunk.Chunk<In>, In, In, E, R>
```


# collectAllWhile

Accumulates incoming elements into a chunk as long as they verify predicate
`p`.

To import and use `collectAllWhile` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.collectAllWhile
```

**Signature**

```ts
export declare const collectAllWhile: {
  <In, Out extends In>(refinement: Refinement<In, Out>): Sink<Chunk.Chunk<Out>, In, In>
  <In>(predicate: Predicate<In>): Sink<Chunk.Chunk<In>, In, In>
}
```


# collectAllWhileEffect

Accumulates incoming elements into a chunk as long as they verify effectful
predicate `p`.

To import and use `collectAllWhileEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.collectAllWhileEffect
```

**Signature**

```ts
export declare const collectAllWhileEffect: <In, E, R>(
  predicate: (input: In) => Effect.Effect<boolean, E, R>
) => Sink<Chunk.Chunk<In>, In, In, E, R>
```


# collectAllWhileWith

Repeatedly runs the sink for as long as its results satisfy the predicate
`p`. The sink's results will be accumulated using the stepping function `f`.

To import and use `collectAllWhileWith` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.collectAllWhileWith
```

**Signature**

```ts
export declare const collectAllWhileWith: {
  <A, S>(options: {
    readonly initial: S
    readonly while: Predicate<A>
    readonly body: (s: S, a: A) => S
  }): <In, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<S, In, L, E, R>
  <A, In, L extends In, E, R, S>(
    self: Sink<A, In, L, E, R>,
    options: { readonly initial: S; readonly while: Predicate<A>; readonly body: (s: S, a: A) => S }
  ): Sink<S, In, L, E, R>
}
```


# collectLeftover

Collects the leftovers from the stream when the sink succeeds and returns
them as part of the sink's result.

To import and use `collectLeftover` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.collectLeftover
```

**Signature**

```ts
export declare const collectLeftover: <A, In, L, E, R>(
  self: Sink<A, In, L, E, R>
) => Sink<[A, Chunk.Chunk<L>], In, never, E, R>
```


# context

Accesses the whole context of the sink.

To import and use `context` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.context
```

**Signature**

```ts
export declare const context: <R>() => Sink<Context.Context<R>, unknown, never, never, R>
```


# contextWith

Accesses the context of the sink.

To import and use `contextWith` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.contextWith
```

**Signature**

```ts
export declare const contextWith: <R, Z>(f: (context: Context.Context<R>) => Z) => Sink<Z, unknown, never, never, R>
```


# contextWithEffect

Accesses the context of the sink in the context of an effect.

To import and use `contextWithEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.contextWithEffect
```

**Signature**

```ts
export declare const contextWithEffect: <R0, A, E, R>(
  f: (context: Context.Context<R0>) => Effect.Effect<A, E, R>
) => Sink<A, unknown, never, E, R0 | R>
```


# contextWithSink

Accesses the context of the sink in the context of a sink.

To import and use `contextWithSink` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.contextWithSink
```

**Signature**

```ts
export declare const contextWithSink: <R0, A, In, L, E, R>(
  f: (context: Context.Context<R0>) => Sink<A, In, L, E, R>
) => Sink<A, In, L, E, R0 | R>
```


# count

A sink that counts the number of elements fed to it.

To import and use `count` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.count
```

**Signature**

```ts
export declare const count: Sink<number, unknown, never, never, never>
```


# die

Creates a sink halting with the specified defect.

To import and use `die` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.die
```

**Signature**

```ts
export declare const die: (defect: unknown) => Sink<never, unknown>
```


# dieMessage

Creates a sink halting with the specified message, wrapped in a
`RuntimeException`.

To import and use `dieMessage` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.dieMessage
```

**Signature**

```ts
export declare const dieMessage: (message: string) => Sink<never, unknown>
```


# dieSync

Creates a sink halting with the specified defect.

To import and use `dieSync` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.dieSync
```

**Signature**

```ts
export declare const dieSync: (evaluate: LazyArg<unknown>) => Sink<never, unknown>
```


# dimap

Transforms both inputs and result of this sink using the provided
functions.

To import and use `dimap` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.dimap
```

**Signature**

```ts
export declare const dimap: {
  <In0, In, A, A2>(options: {
    readonly onInput: (input: In0) => In
    readonly onDone: (a: A) => A2
  }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E, R>
  <A, In, L, E, R, In0, A2>(
    self: Sink<A, In, L, E, R>,
    options: { readonly onInput: (input: In0) => In; readonly onDone: (a: A) => A2 }
  ): Sink<A2, In0, L, E, R>
}
```


# dimapChunks

Transforms both input chunks and result of this sink using the provided
functions.

To import and use `dimapChunks` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.dimapChunks
```

**Signature**

```ts
export declare const dimapChunks: {
  <In0, In, A, A2>(options: {
    readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>
    readonly onDone: (a: A) => A2
  }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E, R>
  <A, In, L, E, R, In0, A2>(
    self: Sink<A, In, L, E, R>,
    options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>; readonly onDone: (a: A) => A2 }
  ): Sink<A2, In0, L, E, R>
}
```


# dimapChunksEffect

Effectfully transforms both input chunks and result of this sink using the
provided functions. `f` and `g` must preserve chunking-invariance.

To import and use `dimapChunksEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.dimapChunksEffect
```

**Signature**

```ts
export declare const dimapChunksEffect: {
  <In0, In, E2, R2, A, A2, E3, R3>(options: {
    readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>
    readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>
  }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>
  <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(
    self: Sink<A, In, L, E, R>,
    options: {
      readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>
      readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>
    }
  ): Sink<A2, In0, L, E | E2 | E3, R | R2 | R3>
}
```


# dimapEffect

Effectfully transforms both inputs and result of this sink using the
provided functions.

To import and use `dimapEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.dimapEffect
```

**Signature**

```ts
export declare const dimapEffect: {
  <In0, In, E2, R2, A, A2, E3, R3>(options: {
    readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>
    readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>
  }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>
  <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(
    self: Sink<A, In, L, E, R>,
    options: {
      readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>
      readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>
    }
  ): Sink<A2, In0, L, E | E2 | E3, R | R2 | R3>
}
```


# drain

A sink that ignores its inputs.

To import and use `drain` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.drain
```

**Signature**

```ts
export declare const drain: Sink<void, unknown, never, never, never>
```


# drop

Creates a sink that drops `n` elements.

To import and use `drop` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.drop
```

**Signature**

```ts
export declare const drop: <In>(n: number) => Sink<unknown, In, In>
```


# dropUntil

Drops incoming elements until the predicate is satisfied.

To import and use `dropUntil` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.dropUntil
```

**Signature**

```ts
export declare const dropUntil: <In>(predicate: Predicate<In>) => Sink<unknown, In, In>
```


# dropUntilEffect

Drops incoming elements until the effectful predicate is satisfied.

To import and use `dropUntilEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.dropUntilEffect
```

**Signature**

```ts
export declare const dropUntilEffect: <In, E, R>(
  predicate: (input: In) => Effect.Effect<boolean, E, R>
) => Sink<unknown, In, In, E, R>
```


# dropWhile

Drops incoming elements as long as the predicate is satisfied.

To import and use `dropWhile` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.dropWhile
```

**Signature**

```ts
export declare const dropWhile: <In>(predicate: Predicate<In>) => Sink<unknown, In, In>
```


# dropWhileEffect

Drops incoming elements as long as the effectful predicate is satisfied.

To import and use `dropWhileEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.dropWhileEffect
```

**Signature**

```ts
export declare const dropWhileEffect: <In, E, R>(
  predicate: (input: In) => Effect.Effect<boolean, E, R>
) => Sink<unknown, In, In, E, R>
```


# ensuring

Returns a new sink with an attached finalizer. The finalizer is guaranteed
to be executed so long as the sink begins execution (and regardless of
whether or not it completes).

To import and use `ensuring` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.ensuring
```

**Signature**

```ts
export declare const ensuring: {
  <X, R2>(
    finalizer: Effect.Effect<X, never, R2>
  ): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, R2 | R>
  <A, In, L, E, R, X, R2>(self: Sink<A, In, L, E, R>, finalizer: Effect.Effect<X, never, R2>): Sink<A, In, L, E, R | R2>
}
```


# ensuringWith

Returns a new sink with an attached finalizer. The finalizer is guaranteed
to be executed so long as the sink begins execution (and regardless of
whether or not it completes).

To import and use `ensuringWith` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.ensuringWith
```

**Signature**

```ts
export declare const ensuringWith: {
  <A, E, X, R2>(
    finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>
  ): <In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, R2 | R>
  <A, In, L, E, R, X, R2>(
    self: Sink<A, In, L, E, R>,
    finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>
  ): Sink<A, In, L, E, R | R2>
}
```


# every

A sink that returns whether all elements satisfy the specified predicate.

To import and use `every` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.every
```

**Signature**

```ts
export declare const every: <In>(predicate: Predicate<In>) => Sink<boolean, In, In>
```


# fail

A sink that always fails with the specified error.

To import and use `fail` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.fail
```

**Signature**

```ts
export declare const fail: <E>(e: E) => Sink<never, unknown, never, E>
```


# failCause

Creates a sink halting with a specified `Cause`.

To import and use `failCause` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.failCause
```

**Signature**

```ts
export declare const failCause: <E>(cause: Cause.Cause<E>) => Sink<never, unknown, never, E>
```


# failCauseSync

Creates a sink halting with a specified lazily evaluated `Cause`.

To import and use `failCauseSync` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.failCauseSync
```

**Signature**

```ts
export declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Sink<never, unknown, never, E>
```


# failSync

A sink that always fails with the specified lazily evaluated error.

To import and use `failSync` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.failSync
```

**Signature**

```ts
export declare const failSync: <E>(evaluate: LazyArg<E>) => Sink<never, unknown, never, E>
```


# filterInput

Filters the sink's input with the given predicate.

To import and use `filterInput` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.filterInput
```

**Signature**

```ts
export declare const filterInput: {
  <In, In1 extends In, In2 extends In1>(
    f: Refinement<In1, In2>
  ): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In2, L, E, R>
  <In, In1 extends In>(f: Predicate<In1>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In1, L, E, R>
}
```


# filterInputEffect

Effectfully filter the input of this sink using the specified predicate.

To import and use `filterInputEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.filterInputEffect
```

**Signature**

```ts
export declare const filterInputEffect: {
  <In, In1 extends In, E2, R2>(
    f: (input: In1) => Effect.Effect<boolean, E2, R2>
  ): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In1, L, E2 | E, R2 | R>
  <A, In, L, E, R, In1 extends In, E2, R2>(
    self: Sink<A, In, L, E, R>,
    f: (input: In1) => Effect.Effect<boolean, E2, R2>
  ): Sink<A, In1, L, E | E2, R | R2>
}
```


# findEffect

Creates a sink that produces values until one verifies the predicate `f`.

To import and use `findEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.findEffect
```

**Signature**

```ts
export declare const findEffect: {
  <A, E2, R2>(
    f: (a: A) => Effect.Effect<boolean, E2, R2>
  ): <In, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<Option.Option<A>, In, L, E2 | E, R2 | R>
  <A, In, L extends In, E, R, E2, R2>(
    self: Sink<A, In, L, E, R>,
    f: (a: A) => Effect.Effect<boolean, E2, R2>
  ): Sink<Option.Option<A>, In, L, E | E2, R | R2>
}
```


# flatMap

Runs this sink until it yields a result, then uses that result to create
another sink from the provided function which will continue to run until it
yields a result.

This function essentially runs sinks in sequence.

To import and use `flatMap` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.flatMap
```

**Signature**

```ts
export declare const flatMap: {
  <A, A1, In, In1 extends In, L1, E1, R1>(
    f: (a: A) => Sink<A1, In1, L1, E1, R1>
  ): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A1, In & In1, L1 | L, E1 | E, R1 | R>
  <A, In, L, E, R, A1, In1 extends In, L1, E1, R1>(
    self: Sink<A, In, L, E, R>,
    f: (a: A) => Sink<A1, In1, L1, E1, R1>
  ): Sink<A1, In & In1, L | L1, E | E1, R | R1>
}
```


# fold

A sink that folds its inputs with the provided function, termination
predicate and initial state.

To import and use `fold` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.fold
```

**Signature**

```ts
export declare const fold: <S, In>(s: S, contFn: Predicate<S>, f: (s: S, input: In) => S) => Sink<S, In, In>
```


# foldChunks

A sink that folds its input chunks with the provided function, termination
predicate and initial state. `contFn` condition is checked only for the
initial value and at the end of processing of each chunk. `f` and `contFn`
must preserve chunking-invariance.

To import and use `foldChunks` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.foldChunks
```

**Signature**

```ts
export declare const foldChunks: <S, In>(
  s: S,
  contFn: Predicate<S>,
  f: (s: S, chunk: Chunk.Chunk<In>) => S
) => Sink<S, In>
```


# foldChunksEffect

A sink that effectfully folds its input chunks with the provided function,
termination predicate and initial state. `contFn` condition is checked only
for the initial value and at the end of processing of each chunk. `f` and
`contFn` must preserve chunking-invariance.

To import and use `foldChunksEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.foldChunksEffect
```

**Signature**

```ts
export declare const foldChunksEffect: <S, In, E, R>(
  s: S,
  contFn: Predicate<S>,
  f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>
) => Sink<S, In, In, E, R>
```


# foldEffect

A sink that effectfully folds its inputs with the provided function,
termination predicate and initial state.

To import and use `foldEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.foldEffect
```

**Signature**

```ts
export declare const foldEffect: <S, In, E, R>(
  s: S,
  contFn: Predicate<S>,
  f: (s: S, input: In) => Effect.Effect<S, E, R>
) => Sink<S, In, In, E, R>
```


# foldLeft

A sink that folds its inputs with the provided function and initial state.

To import and use `foldLeft` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.foldLeft
```

**Signature**

```ts
export declare const foldLeft: <S, In>(s: S, f: (s: S, input: In) => S) => Sink<S, In>
```


# foldLeftChunks

A sink that folds its input chunks with the provided function and initial
state. `f` must preserve chunking-invariance.

To import and use `foldLeftChunks` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.foldLeftChunks
```

**Signature**

```ts
export declare const foldLeftChunks: <S, In>(s: S, f: (s: S, chunk: Chunk.Chunk<In>) => S) => Sink<S, In>
```


# foldLeftChunksEffect

A sink that effectfully folds its input chunks with the provided function
and initial state. `f` must preserve chunking-invariance.

To import and use `foldLeftChunksEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.foldLeftChunksEffect
```

**Signature**

```ts
export declare const foldLeftChunksEffect: <S, In, E, R>(
  s: S,
  f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>
) => Sink<S, In, never, E, R>
```


# foldLeftEffect

A sink that effectfully folds its inputs with the provided function and
initial state.

To import and use `foldLeftEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.foldLeftEffect
```

**Signature**

```ts
export declare const foldLeftEffect: <S, In, E, R>(
  s: S,
  f: (s: S, input: In) => Effect.Effect<S, E, R>
) => Sink<S, In, In, E, R>
```


# foldSink

Folds over the result of the sink

To import and use `foldSink` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.foldSink
```

**Signature**

```ts
export declare const foldSink: {
  <E, A1, In, In1 extends In, L1, E1, R1, A, A2, In2 extends In, L2, E2, R2>(options: {
    readonly onFailure: (err: E) => Sink<A1, In1, L1, E1, R1>
    readonly onSuccess: (a: A) => Sink<A2, In2, L2, E2, R2>
  }): <L, R>(self: Sink<A, In, L, E, R>) => Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R1 | R2 | R>
  <A, In, L, E, R, A1, In1 extends In, L1, E1, R1, A2, In2 extends In, L2, E2, R2>(
    self: Sink<A, In, L, E, R>,
    options: {
      readonly onFailure: (err: E) => Sink<A1, In1, L1, E1, R1>
      readonly onSuccess: (a: A) => Sink<A2, In2, L2, E2, R2>
    }
  ): Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R | R1 | R2>
}
```


# foldUntil

Creates a sink that folds elements of type `In` into a structure of type
`S` until `max` elements have been folded.

Like `Sink.foldWeighted`, but with a constant cost function of `1`.

To import and use `foldUntil` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.foldUntil
```

**Signature**

```ts
export declare const foldUntil: <In, S>(s: S, max: number, f: (s: S, input: In) => S) => Sink<S, In, In>
```


# foldUntilEffect

Creates a sink that effectfully folds elements of type `In` into a
structure of type `S` until `max` elements have been folded.

Like `Sink.foldWeightedEffect` but with a constant cost function of `1`.

To import and use `foldUntilEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.foldUntilEffect
```

**Signature**

```ts
export declare const foldUntilEffect: <S, In, E, R>(
  s: S,
  max: number,
  f: (s: S, input: In) => Effect.Effect<S, E, R>
) => Sink<S, In, In, E, R>
```


# foldWeighted

Creates a sink that folds elements of type `In` into a structure of type
`S`, until `max` worth of elements (determined by the `costFn`) have been
folded.

To import and use `foldWeighted` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.foldWeighted
```

**Signature**

```ts
export declare const foldWeighted: <S, In>(options: {
  readonly initial: S
  readonly maxCost: number
  readonly cost: (s: S, input: In) => number
  readonly body: (s: S, input: In) => S
}) => Sink<S, In, In>
```


# foldWeightedDecompose

Creates a sink that folds elements of type `In` into a structure of type
`S`, until `max` worth of elements (determined by the `costFn`) have been
folded.

The `decompose` function will be used for decomposing elements that cause
an `S` aggregate to cross `max` into smaller elements. For example:

```ts
pipe(
  Stream.make(1, 5, 1),
  Stream.transduce(
    Sink.foldWeightedDecompose(
      Chunk.empty<number>(),
      4,
      (n: number) => n,
      (n: number) => Chunk.make(n - 1, 1),
      (acc, el) => pipe(acc, Chunk.append(el))
    )
  ),
  Stream.runCollect
)
```

The stream would emit the elements `Chunk(1), Chunk(4), Chunk(1, 1)`.

Be vigilant with this function, it has to generate "simpler" values or the
fold may never end. A value is considered indivisible if `decompose` yields
the empty chunk or a single-valued chunk. In these cases, there is no other
choice than to yield a value that will cross the threshold.

`Sink.foldWeightedDecomposeEffect` allows the decompose function to return an
effect value, and consequently it allows the sink to fail.

To import and use `foldWeightedDecompose` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.foldWeightedDecompose
```

**Signature**

```ts
export declare const foldWeightedDecompose: <S, In>(options: {
  readonly initial: S
  readonly maxCost: number
  readonly cost: (s: S, input: In) => number
  readonly decompose: (input: In) => Chunk.Chunk<In>
  readonly body: (s: S, input: In) => S
}) => Sink<S, In, In>
```


# foldWeightedDecomposeEffect

Creates a sink that effectfully folds elements of type `In` into a
structure of type `S`, until `max` worth of elements (determined by the
`costFn`) have been folded.

The `decompose` function will be used for decomposing elements that cause
an `S` aggregate to cross `max` into smaller elements. Be vigilant with
this function, it has to generate "simpler" values or the fold may never
end. A value is considered indivisible if `decompose` yields the empty
chunk or a single-valued chunk. In these cases, there is no other choice
than to yield a value that will cross the threshold.

See `Sink.foldWeightedDecompose` for an example.

To import and use `foldWeightedDecomposeEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.foldWeightedDecomposeEffect
```

**Signature**

```ts
export declare const foldWeightedDecomposeEffect: <S, In, E, R, E2, R2, E3, R3>(options: {
  readonly initial: S
  readonly maxCost: number
  readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>
  readonly decompose: (input: In) => Effect.Effect<Chunk.Chunk<In>, E2, R2>
  readonly body: (s: S, input: In) => Effect.Effect<S, E3, R3>
}) => Sink<S, In, In, E | E2 | E3, R | R2 | R3>
```


# foldWeightedEffect

Creates a sink that effectfully folds elements of type `In` into a
structure of type `S`, until `max` worth of elements (determined by the
`costFn`) have been folded.

To import and use `foldWeightedEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.foldWeightedEffect
```

**Signature**

```ts
export declare const foldWeightedEffect: <S, In, E, R, E2, R2>(options: {
  readonly initial: S
  readonly maxCost: number
  readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>
  readonly body: (s: S, input: In) => Effect.Effect<S, E2, R2>
}) => Sink<S, In, In, E | E2, R | R2>
```


# forEach

A sink that executes the provided effectful function for every element fed
to it.

To import and use `forEach` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.forEach
```

**Signature**

```ts
export declare const forEach: <In, X, E, R>(f: (input: In) => Effect.Effect<X, E, R>) => Sink<void, In, never, E, R>
```


# forEachChunk

A sink that executes the provided effectful function for every chunk fed to
it.

To import and use `forEachChunk` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.forEachChunk
```

**Signature**

```ts
export declare const forEachChunk: <In, X, E, R>(
  f: (input: Chunk.Chunk<In>) => Effect.Effect<X, E, R>
) => Sink<void, In, never, E, R>
```


# forEachChunkWhile

A sink that executes the provided effectful function for every chunk fed to
it until `f` evaluates to `false`.

To import and use `forEachChunkWhile` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.forEachChunkWhile
```

**Signature**

```ts
export declare const forEachChunkWhile: <In, E, R>(
  f: (input: Chunk.Chunk<In>) => Effect.Effect<boolean, E, R>
) => Sink<void, In, In, E, R>
```


# forEachWhile

A sink that executes the provided effectful function for every element fed
to it until `f` evaluates to `false`.

To import and use `forEachWhile` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.forEachWhile
```

**Signature**

```ts
export declare const forEachWhile: <In, E, R>(
  f: (input: In) => Effect.Effect<boolean, E, R>
) => Sink<void, In, In, E, R>
```


# fromChannel

Creates a sink from a `Channel`.

To import and use `fromChannel` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.fromChannel
```

**Signature**

```ts
export declare const fromChannel: <L, In, E, A, R>(
  channel: Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R>
) => Sink<A, In, L, E, R>
```


# fromEffect

Creates a single-value sink produced from an effect.

To import and use `fromEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.fromEffect
```

**Signature**

```ts
export declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Sink<A, unknown, never, E, R>
```


# fromPubSub

Create a sink which publishes each element to the specified `PubSub`.

To import and use `fromPubSub` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.fromPubSub
```

**Signature**

```ts
export declare const fromPubSub: <In>(
  pubsub: PubSub.PubSub<In>,
  options?: { readonly shutdown?: boolean | undefined }
) => Sink<void, In>
```


# fromPush

Creates a sink from a chunk processing function.

To import and use `fromPush` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.fromPush
```

**Signature**

```ts
export declare const fromPush: <In, L0, R0, L, R>(
  push: Effect.Effect<
    (_: Option.Option<Chunk.Chunk<In>>) => Effect.Effect<void, readonly [Either.Either<R0, L0>, Chunk.Chunk<L>], R>,
    never,
    R
  >
) => Sink<R0, In, L, L0, Exclude<R, Scope.Scope>>
```


# fromQueue

Create a sink which enqueues each element into the specified queue.

To import and use `fromQueue` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.fromQueue
```

**Signature**

```ts
export declare const fromQueue: <In>(
  queue: Queue.Enqueue<In>,
  options?: { readonly shutdown?: boolean | undefined }
) => Sink<void, In>
```


# head

Creates a sink containing the first value.

To import and use `head` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.head
```

**Signature**

```ts
export declare const head: <In>() => Sink<Option.Option<In>, In, In>
```


# ignoreLeftover

Drains the remaining elements from the stream after the sink finishes

To import and use `ignoreLeftover` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.ignoreLeftover
```

**Signature**

```ts
export declare const ignoreLeftover: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, never, E, R>
```


# last

Creates a sink containing the last value.

To import and use `last` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.last
```

**Signature**

```ts
export declare const last: <In>() => Sink<Option.Option<In>, In, In>
```


# leftover

Creates a sink that does not consume any input but provides the given chunk
as its leftovers

To import and use `leftover` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.leftover
```

**Signature**

```ts
export declare const leftover: <L>(chunk: Chunk.Chunk<L>) => Sink<void, unknown, L>
```


# map

Transforms this sink's result.

To import and use `map` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.map
```

**Signature**

```ts
export declare const map: {
  <A, A2>(f: (a: A) => A2): <In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E, R>
  <A, In, L, E, R, A2>(self: Sink<A, In, L, E, R>, f: (a: A) => A2): Sink<A2, In, L, E, R>
}
```


# mapEffect

Effectfully transforms this sink's result.

To import and use `mapEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.mapEffect
```

**Signature**

```ts
export declare const mapEffect: {
  <A, A2, E2, R2>(
    f: (a: A) => Effect.Effect<A2, E2, R2>
  ): <In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E2 | E, R2 | R>
  <A, In, L, E, R, A2, E2, R2>(
    self: Sink<A, In, L, E, R>,
    f: (a: A) => Effect.Effect<A2, E2, R2>
  ): Sink<A2, In, L, E | E2, R | R2>
}
```


# mapError

Transforms the errors emitted by this sink using `f`.

To import and use `mapError` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.mapError
```

**Signature**

```ts
export declare const mapError: {
  <E, E2>(f: (error: E) => E2): <A, In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E2, R>
  <A, In, L, E, R, E2>(self: Sink<A, In, L, E, R>, f: (error: E) => E2): Sink<A, In, L, E2, R>
}
```


# mapInput

Transforms this sink's input elements.

To import and use `mapInput` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.mapInput
```

**Signature**

```ts
export declare const mapInput: {
  <In0, In>(f: (input: In0) => In): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E, R>
  <A, In, L, E, R, In0>(self: Sink<A, In, L, E, R>, f: (input: In0) => In): Sink<A, In0, L, E, R>
}
```


# mapInputChunks

Transforms this sink's input chunks. `f` must preserve chunking-invariance.

To import and use `mapInputChunks` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.mapInputChunks
```

**Signature**

```ts
export declare const mapInputChunks: {
  <In0, In>(
    f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>
  ): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E, R>
  <A, In, L, E, R, In0>(
    self: Sink<A, In, L, E, R>,
    f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>
  ): Sink<A, In0, L, E, R>
}
```


# mapInputChunksEffect

Effectfully transforms this sink's input chunks. `f` must preserve
chunking-invariance.

To import and use `mapInputChunksEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.mapInputChunksEffect
```

**Signature**

```ts
export declare const mapInputChunksEffect: {
  <In0, In, E2, R2>(
    f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>
  ): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E2 | E, R2 | R>
  <A, In, L, E, R, In0, E2, R2>(
    self: Sink<A, In, L, E, R>,
    f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>
  ): Sink<A, In0, L, E | E2, R | R2>
}
```


# mapInputEffect

Effectfully transforms this sink's input elements.

To import and use `mapInputEffect` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.mapInputEffect
```

**Signature**

```ts
export declare const mapInputEffect: {
  <In0, In, E2, R2>(
    f: (input: In0) => Effect.Effect<In, E2, R2>
  ): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E2 | E, R2 | R>
  <A, In, L, E, R, In0, E2, R2>(
    self: Sink<A, In, L, E, R>,
    f: (input: In0) => Effect.Effect<In, E2, R2>
  ): Sink<A, In0, L, E | E2, R | R2>
}
```


# mapLeftover

Transforms the leftovers emitted by this sink using `f`.

To import and use `mapLeftover` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.mapLeftover
```

**Signature**

```ts
export declare const mapLeftover: {
  <L, L2>(f: (leftover: L) => L2): <A, In, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L2, E, R>
  <A, In, L, E, R, L2>(self: Sink<A, In, L, E, R>, f: (leftover: L) => L2): Sink<A, In, L2, E, R>
}
```


# mkString

Creates a sink which transforms it's inputs into a string.

To import and use `mkString` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.mkString
```

**Signature**

```ts
export declare const mkString: Sink<string, unknown, never, never, never>
```


# never

Creates a sink which never terminates.

To import and use `never` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.never
```

**Signature**

```ts
export declare const never: Sink<never, unknown, never, never, never>
```


# orElse

Switch to another sink in case of failure

To import and use `orElse` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.orElse
```

**Signature**

```ts
export declare const orElse: {
  <A2, In2, L2, E2, R2>(
    that: LazyArg<Sink<A2, In2, L2, E2, R2>>
  ): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2 | A, In & In2, L2 | L, E2 | E, R2 | R>
  <A, In, L, E, R, A2, In2, L2, E2, R2>(
    self: Sink<A, In, L, E, R>,
    that: LazyArg<Sink<A2, In2, L2, E2, R2>>
  ): Sink<A | A2, In & In2, L | L2, E | E2, R | R2>
}
```


# provideContext

Provides the sink with its required context, which eliminates its
dependency on `R`.

To import and use `provideContext` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.provideContext
```

**Signature**

```ts
export declare const provideContext: {
  <R>(context: Context.Context<R>): <A, In, L, E>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, never>
  <A, In, L, E, R>(self: Sink<A, In, L, E, R>, context: Context.Context<R>): Sink<A, In, L, E, never>
}
```


# race

Runs both sinks in parallel on the input, , returning the result or the
error from the one that finishes first.

To import and use `race` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.race
```

**Signature**

```ts
export declare const race: {
  <R1, E1, In1, L1, A1>(
    that: Sink<A1, In1, L1, E1, R1>
  ): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A1 | A, In & In1, L1 | L, E1 | E, R1 | R>
  <A, In, L, E, R, A1, In1, L1, E1, R1>(
    self: Sink<A, In, L, E, R>,
    that: Sink<A1, In1, L1, E1, R1>
  ): Sink<A | A1, In & In1, L | L1, E | E1, R | R1>
}
```


# raceBoth

Runs both sinks in parallel on the input, returning the result or the error
from the one that finishes first.

To import and use `raceBoth` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.raceBoth
```

**Signature**

```ts
export declare const raceBoth: {
  <A1, In1, L1, E1, R1>(
    that: Sink<A1, In1, L1, E1, R1>,
    options?: { readonly capacity?: number | undefined } | undefined
  ): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<Either.Either<A1, A>, In & In1, L1 | L, E1 | E, R1 | R>
  <A, In, L, E, R, A1, In1, L1, E1, R1>(
    self: Sink<A, In, L, E, R>,
    that: Sink<A1, In1, L1, E1, R1>,
    options?: { readonly capacity?: number | undefined } | undefined
  ): Sink<Either.Either<A1, A>, In & In1, L | L1, E | E1, R | R1>
}
```


# raceWith

Runs both sinks in parallel on the input, using the specified merge
function as soon as one result or the other has been computed.

To import and use `raceWith` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.raceWith
```

**Signature**

```ts
export declare const raceWith: {
  <A2, In2, L2, E2, R2, A, E, A3, A4>(options: {
    readonly other: Sink<A2, In2, L2, E2, R2>
    readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E2 | E, A3>
    readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E2 | E, A4>
    readonly capacity?: number | undefined
  }): <In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A3 | A4, In & In2, L2 | L, E2 | E, R2 | R>
  <A, In, L, E, R, A2, In2, L2, E2, R2, A3, A4>(
    self: Sink<A, In, L, E, R>,
    options: {
      readonly other: Sink<A2, In2, L2, E2, R2>
      readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E | E2, A3>
      readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E | E2, A4>
      readonly capacity?: number | undefined
    }
  ): Sink<A3 | A4, In & In2, L | L2, E | E2, R | R2>
}
```


# Sink

A `Sink<A, In, L, E, R>` is used to consume elements produced by a `Stream`.
You can think of a sink as a function that will consume a variable amount of
`In` elements (could be 0, 1, or many), might fail with an error of type `E`,
and will eventually yield a value of type `A` together with a remainder of
type `L` (i.e. any leftovers).

To import and use `Sink` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.Sink
```


# some

A sink that returns whether an element satisfies the specified predicate.

To import and use `some` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.some
```

**Signature**

```ts
export declare const some: <In>(predicate: Predicate<In>) => Sink<boolean, In, In>
```


# splitWhere

Splits the sink on the specified predicate, returning a new sink that
consumes elements until an element after the first satisfies the specified
predicate.

To import and use `splitWhere` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.splitWhere
```

**Signature**

```ts
export declare const splitWhere: {
  <In>(f: Predicate<In>): <A, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, In, E, R>
  <A, In, L extends In, E, R>(self: Sink<A, In, L, E, R>, f: Predicate<In>): Sink<A, In, In, E, R>
}
```


# succeed

A sink that immediately ends with the specified value.

To import and use `succeed` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.succeed
```

**Signature**

```ts
export declare const succeed: <A>(a: A) => Sink<A, unknown>
```


# sum

A sink that sums incoming numeric values.

To import and use `sum` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.sum
```

**Signature**

```ts
export declare const sum: Sink<number, number, never, never, never>
```


# summarized

Summarize a sink by running an effect when the sink starts and again when
it completes.

To import and use `summarized` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.summarized
```

**Signature**

```ts
export declare const summarized: {
  <A2, E2, R2, A3>(
    summary: Effect.Effect<A2, E2, R2>,
    f: (start: A2, end: A2) => A3
  ): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, A3], In, L, E2 | E, R2 | R>
  <A, In, L, E, R, A2, E2, R2, A3>(
    self: Sink<A, In, L, E, R>,
    summary: Effect.Effect<A2, E2, R2>,
    f: (start: A2, end: A2) => A3
  ): Sink<[A, A3], In, L, E | E2, R | R2>
}
```


# suspend

Returns a lazily constructed sink that may require effects for its
creation.

To import and use `suspend` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.suspend
```

**Signature**

```ts
export declare const suspend: <A, In, L, E, R>(evaluate: LazyArg<Sink<A, In, L, E, R>>) => Sink<A, In, L, E, R>
```


# sync

A sink that immediately ends with the specified lazy value.

To import and use `sync` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.sync
```

**Signature**

```ts
export declare const sync: <A>(evaluate: LazyArg<A>) => Sink<A, unknown>
```


# take

A sink that takes the specified number of values.

To import and use `take` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.take
```

**Signature**

```ts
export declare const take: <In>(n: number) => Sink<Chunk.Chunk<In>, In, In>
```


# toChannel

Creates a `Channel` from a Sink.

To import and use `toChannel` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.toChannel
```

**Signature**

```ts
export declare const toChannel: <A, In, L, E, R>(
  self: Sink<A, In, L, E, R>
) => Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R>
```


# unwrap

Creates a sink produced from an effect.

To import and use `unwrap` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.unwrap
```

**Signature**

```ts
export declare const unwrap: <A, In, L, E2, R2, E, R>(
  effect: Effect.Effect<Sink<A, In, L, E2, R2>, E, R>
) => Sink<A, In, L, E2 | E, R2 | R>
```


# unwrapScoped

Creates a sink produced from a scoped effect.

To import and use `unwrapScoped` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.unwrapScoped
```

**Signature**

```ts
export declare const unwrapScoped: <A, In, L, E, R>(
  effect: Effect.Effect<Sink<A, In, L, E, R>, E, R>
) => Sink<A, In, L, E, Exclude<R, Scope.Scope>>
```


# unwrapScopedWith

Constructs a `Sink` from a function which receives a `Scope` and returns
an effect that will result in a `Sink` if successful.

To import and use `unwrapScopedWith` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.unwrapScopedWith
```

**Signature**

```ts
export declare const unwrapScopedWith: <A, In, L, E, R>(
  f: (scope: Scope.Scope) => Effect.Effect<Sink<A, In, L, E, R>, E, R>
) => Sink<A, In, L, E, R>
```


# withDuration

Returns the sink that executes this one and times its execution.

To import and use `withDuration` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.withDuration
```

**Signature**

```ts
export declare const withDuration: <A, In, L, E, R>(
  self: Sink<A, In, L, E, R>
) => Sink<[A, Duration.Duration], In, L, E, R>
```


# zip

Feeds inputs to this sink until it yields a result, then switches over to
the provided sink until it yields a result, finally combining the two
results into a tuple.

To import and use `zip` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.zip
```

**Signature**

```ts
export declare const zip: {
  <A2, In, In2 extends In, L2, E2, R2>(
    that: Sink<A2, In2, L2, E2, R2>,
    options?: { readonly concurrent?: boolean | undefined } | undefined
  ): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, A2], In & In2, L2 | L, E2 | E, R2 | R>
  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(
    self: Sink<A, In, L, E, R>,
    that: Sink<A2, In2, L2, E2, R2>,
    options?: { readonly concurrent?: boolean | undefined } | undefined
  ): Sink<[A, A2], In & In2, L | L2, E | E2, R | R2>
}
```


# zipLeft

Like `Sink.zip` but keeps only the result from this sink.

To import and use `zipLeft` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.zipLeft
```

**Signature**

```ts
export declare const zipLeft: {
  <A2, In, In2 extends In, L2, E2, R2>(
    that: Sink<A2, In2, L2, E2, R2>,
    options?: { readonly concurrent?: boolean | undefined } | undefined
  ): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In & In2, L2 | L, E2 | E, R2 | R>
  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(
    self: Sink<A, In, L, E, R>,
    that: Sink<A2, In2, L2, E2, R2>,
    options?: { readonly concurrent?: boolean | undefined } | undefined
  ): Sink<A, In & In2, L | L2, E | E2, R | R2>
}
```


# zipRight

Like `Sink.zip` but keeps only the result from `that` sink.

To import and use `zipRight` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.zipRight
```

**Signature**

```ts
export declare const zipRight: {
  <A2, In, In2 extends In, L2, E2, R2>(
    that: Sink<A2, In2, L2, E2, R2>,
    options?: { readonly concurrent?: boolean | undefined } | undefined
  ): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In & In2, L2 | L, E2 | E, R2 | R>
  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(
    self: Sink<A, In, L, E, R>,
    that: Sink<A2, In2, L2, E2, R2>,
    options?: { readonly concurrent?: boolean | undefined } | undefined
  ): Sink<A2, In & In2, L | L2, E | E2, R | R2>
}
```


# zipWith

Feeds inputs to this sink until it yields a result, then switches over to
the provided sink until it yields a result, finally combining the two
results with `f`.

To import and use `zipWith` from the "Sink" module:

```ts
import * as Sink from "effect/Sink"
// Can be accessed like this
Sink.zipWith
```

**Signature**

```ts
export declare const zipWith: {
  <A2, In, In2 extends In, L2, E2, R2, A, A3>(
    that: Sink<A2, In2, L2, E2, R2>,
    f: (a: A, a2: A2) => A3,
    options?: { readonly concurrent?: boolean | undefined } | undefined
  ): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A3, In & In2, L2 | L, E2 | E, R2 | R>
  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2, A3>(
    self: Sink<A, In, L, E, R>,
    that: Sink<A2, In2, L2, E2, R2>,
    f: (a: A, a2: A2) => A3,
    options?: { readonly concurrent?: boolean | undefined } | undefined
  ): Sink<A3, In & In2, L | L2, E | E2, R | R2>
}
```


# fromIterable

Creates a new `SortedMap` from an iterable collection of key/value pairs.

To import and use `fromIterable` from the "SortedMap" module:

```ts
import * as SortedMap from "effect/SortedMap"
// Can be accessed like this
SortedMap.fromIterable
```

**Signature**

```ts
export declare const fromIterable: {
  <B>(ord: Order<B>): <K extends B, V>(iterable: Iterable<readonly [K, V]>) => SortedMap<K, V>
  <K extends B, V, B>(iterable: Iterable<readonly [K, V]>, ord: Order<B>): SortedMap<K, V>
}
```


# getOrder

Gets the `Order<K>` that the `SortedMap<K, V>` is using.

To import and use `getOrder` from the "SortedMap" module:

```ts
import * as SortedMap from "effect/SortedMap"
// Can be accessed like this
SortedMap.getOrder
```

**Signature**

```ts
export declare const getOrder: <K, V>(self: SortedMap<K, V>) => Order<K>
```


# every

Check if a predicate holds true for every `SortedSet` element.

To import and use `every` from the "SortedSet" module:

```ts
import * as SortedSet from "effect/SortedSet"
// Can be accessed like this
SortedSet.every
```

**Signature**

```ts
export declare const every: {
  <A>(predicate: Predicate<A>): (self: SortedSet<A>) => boolean
  <A>(self: SortedSet<A>, predicate: Predicate<A>): boolean
}
```


# fromIterable

Creates a new `SortedSet` from an iterable collection of values.

To import and use `fromIterable` from the "SortedSet" module:

```ts
import * as SortedSet from "effect/SortedSet"
// Can be accessed like this
SortedSet.fromIterable
```

**Signature**

```ts
export declare const fromIterable: {
  <B>(ord: Order<B>): <A extends B>(iterable: Iterable<A>) => SortedSet<A>
  <A extends B, B>(iterable: Iterable<A>, ord: Order<B>): SortedSet<A>
}
```


# some

Check if a predicate holds true for some `SortedSet` element.

To import and use `some` from the "SortedSet" module:

```ts
import * as SortedSet from "effect/SortedSet"
// Can be accessed like this
SortedSet.some
```

**Signature**

```ts
export declare const some: {
  <A>(predicate: Predicate<A>): (self: SortedSet<A>) => boolean
  <A>(self: SortedSet<A>, predicate: Predicate<A>): boolean
}
```


# findById

Create a resolver that resolves results by id.

To import and use `findById` from the "SqlResolver" module:

```ts
import * as SqlResolver from "@effect/sql/SqlResolver"
// Can be accessed like this
SqlResolver.findById
```

**Signature**

```ts
export declare const findById: <T extends string, I, II, RI, A, IA, Row, E, RA = never, R = never>(
  tag: T,
  options:
    | {
        readonly Id: Schema.Schema<I, II, RI>
        readonly Result: Schema.Schema<A, IA>
        readonly ResultId: (result: Types.NoInfer<A>, row: Types.NoInfer<Row>) => I
        readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<Row>, E>
        readonly withContext?: false
      }
    | {
        readonly Id: Schema.Schema<I, II, RI>
        readonly Result: Schema.Schema<A, IA, RA>
        readonly ResultId: (result: Types.NoInfer<A>, row: Types.NoInfer<Row>) => I
        readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<Row>, E, R>
        readonly withContext: true
      }
) => Effect.Effect<SqlResolver<T, I, Option.Option<A>, E, RI>, never, RA | R>
```


# grouped

Create a resolver the can return multiple results for a single request.

Results are grouped by a common key extracted from the request and result.

To import and use `grouped` from the "SqlResolver" module:

```ts
import * as SqlResolver from "@effect/sql/SqlResolver"
// Can be accessed like this
SqlResolver.grouped
```

**Signature**

```ts
export declare const grouped: <T extends string, I, II, K, RI, A, IA, Row, E, RA = never, R = never>(
  tag: T,
  options:
    | {
        readonly Request: Schema.Schema<I, II, RI>
        readonly RequestGroupKey: (request: Types.NoInfer<I>) => K
        readonly Result: Schema.Schema<A, IA>
        readonly ResultGroupKey: (result: Types.NoInfer<A>, row: Types.NoInfer<Row>) => K
        readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<Row>, E>
        readonly withContext?: false
      }
    | {
        readonly Request: Schema.Schema<I, II, RI>
        readonly RequestGroupKey: (request: Types.NoInfer<I>) => K
        readonly Result: Schema.Schema<A, IA, RA>
        readonly ResultGroupKey: (result: Types.NoInfer<A>, row: Types.NoInfer<Row>) => K
        readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<Row>, E, R>
        readonly withContext: true
      }
) => Effect.Effect<SqlResolver<T, I, Array<A>, E, RI>, never, RA | R>
```


# ordered

Create a resolver for a sql query with a request schema and a result schema.

The request schema is used to validate the input of the query.
The result schema is used to validate the output of the query.

Results are mapped to the requests in order, so the length of the results must match the length of the requests.

To import and use `ordered` from the "SqlResolver" module:

```ts
import * as SqlResolver from "@effect/sql/SqlResolver"
// Can be accessed like this
SqlResolver.ordered
```

**Signature**

```ts
export declare const ordered: <T extends string, I, II, RI, A, IA, _, E, RA = never, R = never>(
  tag: T,
  options:
    | {
        readonly Request: Schema.Schema<I, II, RI>
        readonly Result: Schema.Schema<A, IA>
        readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<_>, E>
        readonly withContext?: false
      }
    | {
        readonly Request: Schema.Schema<I, II, RI>
        readonly Result: Schema.Schema<A, IA, RA>
        readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<_>, E, R>
        readonly withContext: true
      }
) => Effect.Effect<SqlResolver<T, I, A, E | ResultLengthMismatch, RI>, never, RA | R>
```


# void

Create a resolver that performs side effects.

To import and use `void` from the "SqlResolver" module:

```ts
import * as SqlResolver from "@effect/sql/SqlResolver"
// Can be accessed like this
SqlResolver.void
```


# findAll

Run a sql query with a request schema and a result schema.

To import and use `findAll` from the "SqlSchema" module:

```ts
import * as SqlSchema from "@effect/sql/SqlSchema"
// Can be accessed like this
SqlSchema.findAll
```

**Signature**

```ts
export declare const findAll: <IR, II, IA, AR, AI, A, R, E>(options: {
  readonly Request: Schema.Schema<IA, II, IR>
  readonly Result: Schema.Schema<A, AI, AR>
  readonly execute: (request: II) => Effect.Effect<ReadonlyArray<unknown>, E, R>
}) => (request: IA) => Effect.Effect<ReadonlyArray<A>, E | ParseError, R | IR | AR>
```


# findOne

Run a sql query with a request schema and a result schema and return the first result.

To import and use `findOne` from the "SqlSchema" module:

```ts
import * as SqlSchema from "@effect/sql/SqlSchema"
// Can be accessed like this
SqlSchema.findOne
```

**Signature**

```ts
export declare const findOne: <IR, II, IA, AR, AI, A, R, E>(options: {
  readonly Request: Schema.Schema<IA, II, IR>
  readonly Result: Schema.Schema<A, AI, AR>
  readonly execute: (request: II) => Effect.Effect<ReadonlyArray<unknown>, E, R>
}) => (request: IA) => Effect.Effect<Option.Option<A>, E | ParseError, R | IR | AR>
```


# single

Run a sql query with a request schema and a result schema and return the first result.

To import and use `single` from the "SqlSchema" module:

```ts
import * as SqlSchema from "@effect/sql/SqlSchema"
// Can be accessed like this
SqlSchema.single
```

**Signature**

```ts
export declare const single: <IR, II, IA, AR, AI, A, R, E>(options: {
  readonly Request: Schema.Schema<IA, II, IR>
  readonly Result: Schema.Schema<A, AI, AR>
  readonly execute: (request: II) => Effect.Effect<ReadonlyArray<unknown>, E, R>
}) => (request: IA) => Effect.Effect<A, E | ParseError | Cause.NoSuchElementException, R | IR | AR>
```


# void

Run a sql query with a request schema and discard the result.

To import and use `void` from the "SqlSchema" module:

```ts
import * as SqlSchema from "@effect/sql/SqlSchema"
// Can be accessed like this
SqlSchema.void
```


# makeParser

Create a SSE parser.

Adapted from https://github.com/rexxars/eventsource-parser under MIT license.

To import and use `makeParser` from the "Sse" module:

```ts
import * as Sse from "@effect/experimental/Sse"
// Can be accessed like this
Sse.makeParser
```

**Signature**

```ts
export declare function makeParser(onParse: (event: AnyEvent) => void): Parser
```


# acquireUseRelease

Treats the specified `acquire` transaction as the acquisition of a
resource. The `acquire` transaction will be executed interruptibly. If it
is a success and is committed the specified `release` workflow will be
executed uninterruptibly as soon as the `use` workflow completes execution.

To import and use `acquireUseRelease` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.acquireUseRelease
```

**Signature**

```ts
export declare const acquireUseRelease: {
  <A, A2, E2, R2, A3, E3, R3>(
    use: (resource: A) => STM<A2, E2, R2>,
    release: (resource: A) => STM<A3, E3, R3>
  ): <E, R>(acquire: STM<A, E, R>) => Effect.Effect<A2, E2 | E3 | E, R2 | R3 | R>
  <A, E, R, A2, E2, R2, A3, E3, R3>(
    acquire: STM<A, E, R>,
    use: (resource: A) => STM<A2, E2, R2>,
    release: (resource: A) => STM<A3, E3, R3>
  ): Effect.Effect<A2, E | E2 | E3, R | R2 | R3>
}
```


# all

Runs all the provided transactional effects in sequence respecting the
structure provided in input.

Supports multiple arguments, a single argument tuple / array or record /
struct.

To import and use `all` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.all
```

**Signature**

```ts
export declare const all: All.Signature
```


# as

Maps the success value of this effect to the specified constant value.

To import and use `as` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.as
```

**Signature**

```ts
export declare const as: {
  <A2>(value: A2): <A, E, R>(self: STM<A, E, R>) => STM<A2, E, R>
  <A, E, R, A2>(self: STM<A, E, R>, value: A2): STM<A2, E, R>
}
```


# asSome

Maps the success value of this effect to an optional value.

To import and use `asSome` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.asSome
```

**Signature**

```ts
export declare const asSome: <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>
```


# asSomeError

Maps the error value of this effect to an optional value.

To import and use `asSomeError` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.asSomeError
```

**Signature**

```ts
export declare const asSomeError: <A, E, R>(self: STM<A, E, R>) => STM<A, Option.Option<E>, R>
```


# asVoid

This function maps the success value of an `STM` to `void`. If the original
`STM` succeeds, the returned `STM` will also succeed. If the original `STM`
fails, the returned `STM` will fail with the same error.

To import and use `asVoid` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.asVoid
```

**Signature**

```ts
export declare const asVoid: <A, E, R>(self: STM<A, E, R>) => STM<void, E, R>
```


# attempt

Creates an `STM` value from a partial (but pure) function.

To import and use `attempt` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.attempt
```

**Signature**

```ts
export declare const attempt: <A>(evaluate: LazyArg<A>) => STM<A, unknown>
```


# catchAll

Recovers from all errors.

To import and use `catchAll` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.catchAll
```

**Signature**

```ts
export declare const catchAll: {
  <E, B, E1, R1>(f: (e: E) => STM<B, E1, R1>): <A, R>(self: STM<A, E, R>) => STM<B | A, E1, R1 | R>
  <A, E, R, B, E1, R1>(self: STM<A, E, R>, f: (e: E) => STM<B, E1, R1>): STM<A | B, E1, R | R1>
}
```


# catchSome

Recovers from some or all of the error cases.

To import and use `catchSome` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.catchSome
```

**Signature**

```ts
export declare const catchSome: {
  <E, A2, E2, R2>(
    pf: (error: E) => Option.Option<STM<A2, E2, R2>>
  ): <A, R>(self: STM<A, E, R>) => STM<A2 | A, E | E2, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: STM<A, E, R>,
    pf: (error: E) => Option.Option<STM<A2, E2, R2>>
  ): STM<A | A2, E | E2, R | R2>
}
```


# catchTag

Recovers from the specified tagged error.

To import and use `catchTag` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.catchTag
```

**Signature**

```ts
export declare const catchTag: {
  <K extends E["_tag"] & string, E extends { _tag: string }, A1, E1, R1>(
    k: K,
    f: (e: Extract<E, { _tag: K }>) => STM<A1, E1, R1>
  ): <A, R>(self: STM<A, E, R>) => STM<A1 | A, E1 | Exclude<E, { _tag: K }>, R1 | R>
  <A, E extends { _tag: string }, R, K extends E["_tag"] & string, A1, E1, R1>(
    self: STM<A, E, R>,
    k: K,
    f: (e: Extract<E, { _tag: K }>) => STM<A1, E1, R1>
  ): STM<A | A1, E1 | Exclude<E, { _tag: K }>, R | R1>
}
```


# catchTags

Recovers from multiple tagged errors.

To import and use `catchTags` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.catchTags
```

**Signature**

```ts
export declare const catchTags: {
  <
    E extends { _tag: string },
    Cases extends { [K in E["_tag"]]+?: (error: Extract<E, { _tag: K }>) => STM<any, any, any> }
  >(
    cases: Cases
  ): <A, R>(
    self: STM<A, E, R>
  ) => STM<
    | A
    | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<infer A, any, any> ? A : never }[keyof Cases],
    | Exclude<E, { _tag: keyof Cases }>
    | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, infer E, any> ? E : never }[keyof Cases],
    | R
    | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, any, infer R> ? R : never }[keyof Cases]
  >
  <
    R,
    E extends { _tag: string },
    A,
    Cases extends { [K in E["_tag"]]+?: (error: Extract<E, { _tag: K }>) => STM<any, any, any> }
  >(
    self: STM<A, E, R>,
    cases: Cases
  ): STM<
    | A
    | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<infer A, any, any> ? A : never }[keyof Cases],
    | Exclude<E, { _tag: keyof Cases }>
    | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, infer E, any> ? E : never }[keyof Cases],
    | R
    | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, any, infer R> ? R : never }[keyof Cases]
  >
}
```


# check

Checks the condition, and if it's true, returns unit, otherwise, retries.

To import and use `check` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.check
```

**Signature**

```ts
export declare const check: (predicate: LazyArg<boolean>) => STM<void>
```


# collect

Simultaneously filters and maps the value produced by this effect.

To import and use `collect` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.collect
```

**Signature**

```ts
export declare const collect: {
  <A, A2>(pf: (a: A) => Option.Option<A2>): <E, R>(self: STM<A, E, R>) => STM<A2, E, R>
  <A, E, R, A2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<A2>): STM<A2, E, R>
}
```


# collectSTM

Simultaneously filters and maps the value produced by this effect.

To import and use `collectSTM` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.collectSTM
```

**Signature**

```ts
export declare const collectSTM: {
  <A, A2, E2, R2>(pf: (a: A) => Option.Option<STM<A2, E2, R2>>): <E, R>(self: STM<A, E, R>) => STM<A2, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<STM<A2, E2, R2>>): STM<A2, E | E2, R | R2>
}
```


# commit

Commits this transaction atomically.

To import and use `commit` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.commit
```

**Signature**

```ts
export declare const commit: <A, E, R>(self: STM<A, E, R>) => Effect.Effect<A, E, R>
```


# commitEither

Commits this transaction atomically, regardless of whether the transaction
is a success or a failure.

To import and use `commitEither` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.commitEither
```

**Signature**

```ts
export declare const commitEither: <A, E, R>(self: STM<A, E, R>) => Effect.Effect<A, E, R>
```


# cond

Similar to Either.cond, evaluate the predicate, return the given A as
success if predicate returns true, and the given E as error otherwise

To import and use `cond` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.cond
```

**Signature**

```ts
export declare const cond: <A, E>(predicate: LazyArg<boolean>, error: LazyArg<E>, result: LazyArg<A>) => STM<A, E>
```


# context

Retrieves the environment inside an stm.

To import and use `context` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.context
```

**Signature**

```ts
export declare const context: <R>() => STM<Context.Context<R>, never, R>
```


# contextWith

Accesses the environment of the transaction to perform a transaction.

To import and use `contextWith` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.contextWith
```

**Signature**

```ts
export declare const contextWith: <R0, R>(f: (environment: Context.Context<R0>) => R) => STM<R, never, R0>
```


# contextWithSTM

Accesses the environment of the transaction to perform a transaction.

To import and use `contextWithSTM` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.contextWithSTM
```

**Signature**

```ts
export declare const contextWithSTM: <R0, A, E, R>(
  f: (environment: Context.Context<R0>) => STM<A, E, R>
) => STM<A, E, R0 | R>
```


# die

Fails the transactional effect with the specified defect.

To import and use `die` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.die
```

**Signature**

```ts
export declare const die: (defect: unknown) => STM<never>
```


# dieMessage

Kills the fiber running the effect with a `Cause.RuntimeException` that
contains the specified message.

To import and use `dieMessage` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.dieMessage
```

**Signature**

```ts
export declare const dieMessage: (message: string) => STM<never>
```


# dieSync

Fails the transactional effect with the specified lazily evaluated defect.

To import and use `dieSync` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.dieSync
```

**Signature**

```ts
export declare const dieSync: (evaluate: LazyArg<unknown>) => STM<never>
```


# either

Converts the failure channel into an `Either`.

To import and use `either` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.either
```

**Signature**

```ts
export declare const either: <A, E, R>(self: STM<A, E, R>) => STM<Either.Either<A, E>, never, R>
```


# ensuring

Executes the specified finalization transaction whether or not this effect
succeeds. Note that as with all STM transactions, if the full transaction
fails, everything will be rolled back.

To import and use `ensuring` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.ensuring
```

**Signature**

```ts
export declare const ensuring: {
  <R1, B>(finalizer: STM<B, never, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E, R1 | R>
  <A, E, R, R1, B>(self: STM<A, E, R>, finalizer: STM<B, never, R1>): STM<A, E, R | R1>
}
```


# eventually

Returns an effect that ignores errors and runs repeatedly until it
eventually succeeds.

To import and use `eventually` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.eventually
```

**Signature**

```ts
export declare const eventually: <A, E, R>(self: STM<A, E, R>) => STM<A, E, R>
```


# every

Determines whether all elements of the `Iterable<A>` satisfy the effectual
predicate.

To import and use `every` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.every
```

**Signature**

```ts
export declare const every: {
  <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<boolean, E, R>
  <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<boolean, E, R>
}
```


# exists

Determines whether any element of the `Iterable[A]` satisfies the effectual
predicate `f`.

To import and use `exists` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.exists
```

**Signature**

```ts
export declare const exists: {
  <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<boolean, E, R>
  <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<boolean, E, R>
}
```


# fail

Fails the transactional effect with the specified error.

To import and use `fail` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.fail
```

**Signature**

```ts
export declare const fail: <E>(error: E) => STM<never, E>
```


# failSync

Fails the transactional effect with the specified lazily evaluated error.

To import and use `failSync` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.failSync
```

**Signature**

```ts
export declare const failSync: <E>(evaluate: LazyArg<E>) => STM<never, E>
```


# fiberId

Returns the fiber id of the fiber committing the transaction.

To import and use `fiberId` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.fiberId
```

**Signature**

```ts
export declare const fiberId: STM<FiberId.FiberId, never, never>
```


# filter

Filters the collection using the specified effectual predicate.

To import and use `filter` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.filter
```

**Signature**

```ts
export declare const filter: {
  <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<Array<A>, E, R>
  <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<Array<A>, E, R>
}
```


# filterNot

Filters the collection using the specified effectual predicate, removing
all elements that satisfy the predicate.

To import and use `filterNot` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.filterNot
```

**Signature**

```ts
export declare const filterNot: {
  <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<Array<A>, E, R>
  <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<Array<A>, E, R>
}
```


# filterOrDie

Dies with specified defect if the predicate fails.

To import and use `filterOrDie` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.filterOrDie
```

**Signature**

```ts
export declare const filterOrDie: {
  <A, B extends A>(
    refinement: Refinement<NoInfer<A>, B>,
    defect: LazyArg<unknown>
  ): <E, R>(self: STM<A, E, R>) => STM<B, E, R>
  <A>(predicate: Predicate<NoInfer<A>>, defect: LazyArg<unknown>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>
  <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>, defect: LazyArg<unknown>): STM<B, E, R>
  <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>, defect: LazyArg<unknown>): STM<A, E, R>
}
```


# filterOrDieMessage

Dies with a `Cause.RuntimeException` having the specified message if the
predicate fails.

To import and use `filterOrDieMessage` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.filterOrDieMessage
```

**Signature**

```ts
export declare const filterOrDieMessage: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, message: string): <E, R>(self: STM<A, E, R>) => STM<B, E, R>
  <A>(predicate: Predicate<NoInfer<A>>, message: string): <E, R>(self: STM<A, E, R>) => STM<A, E, R>
  <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>, message: string): STM<B, E, R>
  <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>, message: string): STM<A, E, R>
}
```


# filterOrElse

Supplies `orElse` if the predicate fails.

To import and use `filterOrElse` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.filterOrElse
```

**Signature**

```ts
export declare const filterOrElse: {
  <A, B extends A, C, E2, R2>(
    refinement: Refinement<NoInfer<A>, B>,
    orElse: (a: NoInfer<A>) => STM<C, E2, R2>
  ): <E, R>(self: STM<A, E, R>) => STM<B | C, E2 | E, R2 | R>
  <A, B, E2, R2>(
    predicate: Predicate<NoInfer<A>>,
    orElse: (a: NoInfer<A>) => STM<B, E2, R2>
  ): <E, R>(self: STM<A, E, R>) => STM<A | B, E2 | E, R2 | R>
  <A, E, R, B extends A, C, E2, R2>(
    self: STM<A, E, R>,
    refinement: Refinement<A, B>,
    orElse: (a: A) => STM<C, E2, R2>
  ): STM<B | C, E | E2, R | R2>
  <A, E, R, B, E2, R2>(
    self: STM<A, E, R>,
    predicate: Predicate<A>,
    orElse: (a: A) => STM<B, E2, R2>
  ): STM<A | B, E | E2, R | R2>
}
```


# filterOrFail

Fails with the specified error if the predicate fails.

To import and use `filterOrFail` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.filterOrFail
```

**Signature**

```ts
export declare const filterOrFail: {
  <A, B extends A, E2>(
    refinement: Refinement<NoInfer<A>, B>,
    orFailWith: (a: NoInfer<A>) => E2
  ): <E, R>(self: STM<A, E, R>) => STM<B, E2 | E, R>
  <A, E2>(
    predicate: Predicate<NoInfer<A>>,
    orFailWith: (a: NoInfer<A>) => E2
  ): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R>
  <A, E, R, B extends A, E2>(
    self: STM<A, E, R>,
    refinement: Refinement<A, B>,
    orFailWith: (a: A) => E2
  ): STM<B, E | E2, R>
  <A, E, R, E2>(self: STM<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): STM<A, E | E2, R>
}
```


# firstSuccessOf

This function takes an iterable of `STM` values and returns a new
`STM` value that represents the first `STM` value in the iterable
that succeeds. If all of the `Effect` values in the iterable fail, then
the resulting `STM` value will fail as well.

This function is sequential, meaning that the `STM` values in the
iterable will be executed in sequence, and the first one that succeeds
will determine the outcome of the resulting `STM` value.

To import and use `firstSuccessOf` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.firstSuccessOf
```

**Signature**

```ts
export declare const firstSuccessOf: <A, E, R>(effects: Iterable<STM<A, E, R>>) => STM<A, E, R>
```


# flatMap

Feeds the value produced by this effect to the specified function, and then
runs the returned effect as well to produce its results.

To import and use `flatMap` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.flatMap
```

**Signature**

```ts
export declare const flatMap: {
  <A, A2, E1, R1>(f: (a: A) => STM<A2, E1, R1>): <E, R>(self: STM<A, E, R>) => STM<A2, E1 | E, R1 | R>
  <A, E, R, A2, E1, R1>(self: STM<A, E, R>, f: (a: A) => STM<A2, E1, R1>): STM<A2, E | E1, R | R1>
}
```


# flatten

Flattens out a nested `STM` effect.

To import and use `flatten` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.flatten
```

**Signature**

```ts
export declare const flatten: <A, E2, R2, E, R>(self: STM<STM<A, E2, R2>, E, R>) => STM<A, E2 | E, R2 | R>
```


# flip

Flips the success and failure channels of this transactional effect. This
allows you to use all methods on the error channel, possibly before
flipping back.

To import and use `flip` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.flip
```

**Signature**

```ts
export declare const flip: <A, E, R>(self: STM<A, E, R>) => STM<E, A, R>
```


# flipWith

Swaps the error/value parameters, applies the function `f` and flips the
parameters back

To import and use `flipWith` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.flipWith
```

**Signature**

```ts
export declare const flipWith: {
  <E, A, R, E2, A2, R2>(f: (stm: STM<E, A, R>) => STM<E2, A2, R2>): (self: STM<A, E, R>) => STM<A | A2, E | E2, R | R2>
  <A, E, R, E2, A2, R2>(self: STM<A, E, R>, f: (stm: STM<E, A, R>) => STM<E2, A2, R2>): STM<A | A2, E | E2, R | R2>
}
```


# forEach

Applies the function `f` to each element of the `Iterable<A>` and returns
a transactional effect that produces a new `Chunk<A2>`.

To import and use `forEach` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.forEach
```

**Signature**

```ts
export declare const forEach: {
  <A, A2, E, R>(
    f: (a: A) => STM<A2, E, R>,
    options?: { readonly discard?: false | undefined } | undefined
  ): (elements: Iterable<A>) => STM<Array<A2>, E, R>
  <A, A2, E, R>(
    f: (a: A) => STM<A2, E, R>,
    options: { readonly discard: true }
  ): (elements: Iterable<A>) => STM<void, E, R>
  <A, A2, E, R>(
    elements: Iterable<A>,
    f: (a: A) => STM<A2, E, R>,
    options?: { readonly discard?: false | undefined } | undefined
  ): STM<Array<A2>, E, R>
  <A, A2, E, R>(elements: Iterable<A>, f: (a: A) => STM<A2, E, R>, options: { readonly discard: true }): STM<void, E, R>
}
```


# fromEither

Lifts an `Either` into a `STM`.

To import and use `fromEither` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.fromEither
```

**Signature**

```ts
export declare const fromEither: <A, E>(either: Either.Either<A, E>) => STM<A, E>
```


# fromOption

Lifts an `Option` into a `STM`.

To import and use `fromOption` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.fromOption
```

**Signature**

```ts
export declare const fromOption: <A>(option: Option.Option<A>) => STM<A, Option.Option<never>>
```


# head

Returns a successful effect with the head of the list if the list is
non-empty or fails with the error `None` if the list is empty.

To import and use `head` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.head
```

**Signature**

```ts
export declare const head: <A, E, R>(self: STM<Iterable<A>, E, R>) => STM<A, Option.Option<E>, R>
```


# if

Runs `onTrue` if the result of `b` is `true` and `onFalse` otherwise.

To import and use `if` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.if
```


# ignore

Returns a new effect that ignores the success or failure of this effect.

To import and use `ignore` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.ignore
```

**Signature**

```ts
export declare const ignore: <A, E, R>(self: STM<A, E, R>) => STM<void, never, R>
```


# interrupt

Interrupts the fiber running the effect.

To import and use `interrupt` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.interrupt
```

**Signature**

```ts
export declare const interrupt: STM<never, never, never>
```


# interruptAs

Interrupts the fiber running the effect with the specified `FiberId`.

To import and use `interruptAs` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.interruptAs
```

**Signature**

```ts
export declare const interruptAs: (fiberId: FiberId.FiberId) => STM<never>
```


# isFailure

Returns whether this transactional effect is a failure.

To import and use `isFailure` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.isFailure
```

**Signature**

```ts
export declare const isFailure: <A, E, R>(self: STM<A, E, R>) => STM<boolean, never, R>
```


# isSTM

Returns `true` if the provided value is an `STM`, `false` otherwise.

To import and use `isSTM` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.isSTM
```

**Signature**

```ts
export declare const isSTM: (u: unknown) => u is STM<unknown, unknown, unknown>
```


# isSuccess

Returns whether this transactional effect is a success.

To import and use `isSuccess` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.isSuccess
```

**Signature**

```ts
export declare const isSuccess: <A, E, R>(self: STM<A, E, R>) => STM<boolean, never, R>
```


# iterate

Iterates with the specified transactional function. The moral equivalent
of:

```ts
const s = initial

while (cont(s)) {
  s = body(s)
}

return s
```

To import and use `iterate` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.iterate
```

**Signature**

```ts
export declare const iterate: <Z, E, R>(
  initial: Z,
  options: { readonly while: Predicate<Z>; readonly body: (z: Z) => STM<Z, E, R> }
) => STM<Z, E, R>
```


# loop

Loops with the specified transactional function, collecting the results
into a list. The moral equivalent of:

```ts
const as = []
let s = initial

while (cont(s)) {
  as.push(body(s))
  s = inc(s)
}

return as
```

To import and use `loop` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.loop
```

**Signature**

```ts
export declare const loop: {
  <Z, A, E, R>(
    initial: Z,
    options: {
      readonly while: (z: Z) => boolean
      readonly step: (z: Z) => Z
      readonly body: (z: Z) => STM<A, E, R>
      readonly discard?: false | undefined
    }
  ): STM<Array<A>, E, R>
  <Z, A, E, R>(
    initial: Z,
    options: {
      readonly while: (z: Z) => boolean
      readonly step: (z: Z) => Z
      readonly body: (z: Z) => STM<A, E, R>
      readonly discard: true
    }
  ): STM<void, E, R>
}
```


# map

Maps the value produced by the effect.

To import and use `map` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.map
```

**Signature**

```ts
export declare const map: {
  <A, B>(f: (a: A) => B): <E, R>(self: STM<A, E, R>) => STM<B, E, R>
  <A, E, R, B>(self: STM<A, E, R>, f: (a: A) => B): STM<B, E, R>
}
```


# mapAttempt

Maps the value produced by the effect with the specified function that may
throw exceptions but is otherwise pure, translating any thrown exceptions
into typed failed effects.

To import and use `mapAttempt` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.mapAttempt
```

**Signature**

```ts
export declare const mapAttempt: {
  <A, B>(f: (a: A) => B): <E, R>(self: STM<A, E, R>) => STM<B, unknown, R>
  <A, E, R, B>(self: STM<A, E, R>, f: (a: A) => B): STM<B, unknown, R>
}
```


# mapBoth

Returns an `STM` effect whose failure and success channels have been mapped
by the specified pair of functions, `f` and `g`.

To import and use `mapBoth` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.mapBoth
```

**Signature**

```ts
export declare const mapBoth: {
  <E, E2, A, A2>(options: {
    readonly onFailure: (error: E) => E2
    readonly onSuccess: (value: A) => A2
  }): <R>(self: STM<A, E, R>) => STM<A2, E2, R>
  <A, E, R, E2, A2>(
    self: STM<A, E, R>,
    options: { readonly onFailure: (error: E) => E2; readonly onSuccess: (value: A) => A2 }
  ): STM<A2, E2, R>
}
```


# mapError

Maps from one error type to another.

To import and use `mapError` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.mapError
```

**Signature**

```ts
export declare const mapError: {
  <E, E2>(f: (error: E) => E2): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>
  <A, E, R, E2>(self: STM<A, E, R>, f: (error: E) => E2): STM<A, E2, R>
}
```


# mapInputContext

Transforms the environment being provided to this effect with the specified
function.

To import and use `mapInputContext` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.mapInputContext
```

**Signature**

```ts
export declare const mapInputContext: {
  <R0, R>(f: (context: Context.Context<R0>) => Context.Context<R>): <A, E>(self: STM<A, E, R>) => STM<A, E, R0>
  <A, E, R0, R>(self: STM<A, E, R>, f: (context: Context.Context<R0>) => Context.Context<R>): STM<A, E, R0>
}
```


# match

Folds over the `STM` effect, handling both failure and success, but not
retry.

To import and use `match` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.match
```

**Signature**

```ts
export declare const match: {
  <E, A2, A, A3>(options: {
    readonly onFailure: (error: E) => A2
    readonly onSuccess: (value: A) => A3
  }): <R>(self: STM<A, E, R>) => STM<A2 | A3, never, R>
  <A, E, R, A2, A3>(
    self: STM<A, E, R>,
    options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3 }
  ): STM<A2 | A3, never, R>
}
```


# matchSTM

Effectfully folds over the `STM` effect, handling both failure and success.

To import and use `matchSTM` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.matchSTM
```

**Signature**

```ts
export declare const matchSTM: {
  <E, A1, E1, R1, A, A2, E2, R2>(options: {
    readonly onFailure: (e: E) => STM<A1, E1, R1>
    readonly onSuccess: (a: A) => STM<A2, E2, R2>
  }): <R>(self: STM<A, E, R>) => STM<A1 | A2, E1 | E2, R1 | R2 | R>
  <A, E, R, A1, E1, R1, A2, E2, R2>(
    self: STM<A, E, R>,
    options: { readonly onFailure: (e: E) => STM<A1, E1, R1>; readonly onSuccess: (a: A) => STM<A2, E2, R2> }
  ): STM<A1 | A2, E1 | E2, R | R1 | R2>
}
```


# merge

Returns a new effect where the error channel has been merged into the
success channel to their common combined type.

To import and use `merge` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.merge
```

**Signature**

```ts
export declare const merge: <A, E, R>(self: STM<A, E, R>) => STM<E | A, never, R>
```


# mergeAll

Merges an `Iterable<STM>` to a single `STM`, working sequentially.

To import and use `mergeAll` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.mergeAll
```

**Signature**

```ts
export declare const mergeAll: {
  <A2, A>(zero: A2, f: (a2: A2, a: A) => A2): <E, R>(iterable: Iterable<STM<A, E, R>>) => STM<A2, E, R>
  <A, E, R, A2>(iterable: Iterable<STM<A, E, R>>, zero: A2, f: (a2: A2, a: A) => A2): STM<A2, E, R>
}
```


# negate

Returns a new effect where boolean value of this effect is negated.

To import and use `negate` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.negate
```

**Signature**

```ts
export declare const negate: <E, R>(self: STM<boolean, E, R>) => STM<boolean, E, R>
```


# none

Requires the option produced by this value to be `None`.

To import and use `none` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.none
```

**Signature**

```ts
export declare const none: <A, E, R>(self: STM<Option.Option<A>, E, R>) => STM<void, Option.Option<E>, R>
```


# option

Converts the failure channel into an `Option`.

To import and use `option` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.option
```

**Signature**

```ts
export declare const option: <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, never, R>
```


# orDie

Translates `STM` effect failure into death of the fiber, making all
failures unchecked and not a part of the type of the effect.

To import and use `orDie` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.orDie
```

**Signature**

```ts
export declare const orDie: <A, E, R>(self: STM<A, E, R>) => STM<A, never, R>
```


# orDieWith

Keeps none of the errors, and terminates the fiber running the `STM` effect
with them, using the specified function to convert the `E` into a defect.

To import and use `orDieWith` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.orDieWith
```

**Signature**

```ts
export declare const orDieWith: {
  <E>(f: (error: E) => unknown): <A, R>(self: STM<A, E, R>) => STM<A, never, R>
  <A, E, R>(self: STM<A, E, R>, f: (error: E) => unknown): STM<A, never, R>
}
```


# orElse

Tries this effect first, and if it fails or retries, tries the other
effect.

To import and use `orElse` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.orElse
```

**Signature**

```ts
export declare const orElse: {
  <A2, E2, R2>(that: LazyArg<STM<A2, E2, R2>>): <A, E, R>(self: STM<A, E, R>) => STM<A2 | A, E2, R2 | R>
  <A, E, R, A2, E2, R2>(self: STM<A, E, R>, that: LazyArg<STM<A2, E2, R2>>): STM<A | A2, E2, R | R2>
}
```


# orElseEither

Returns a transactional effect that will produce the value of this effect
in left side, unless it fails or retries, in which case, it will produce
the value of the specified effect in right side.

To import and use `orElseEither` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.orElseEither
```

**Signature**

```ts
export declare const orElseEither: {
  <A2, E2, R2>(that: LazyArg<STM<A2, E2, R2>>): <A, E, R>(self: STM<A, E, R>) => STM<Either.Either<A2, A>, E2, R2 | R>
  <A, E, R, A2, E2, R2>(self: STM<A, E, R>, that: LazyArg<STM<A2, E2, R2>>): STM<Either.Either<A2, A>, E2, R | R2>
}
```


# orElseFail

Tries this effect first, and if it fails or retries, fails with the
specified error.

To import and use `orElseFail` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.orElseFail
```

**Signature**

```ts
export declare const orElseFail: {
  <E2>(error: LazyArg<E2>): <A, E, R>(self: STM<A, E, R>) => STM<A, E2, R>
  <A, E, R, E2>(self: STM<A, E, R>, error: LazyArg<E2>): STM<A, E2, R>
}
```


# orElseOptional

Returns an effect that will produce the value of this effect, unless it
fails with the `None` value, in which case it will produce the value of the
specified effect.

To import and use `orElseOptional` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.orElseOptional
```

**Signature**

```ts
export declare const orElseOptional: {
  <A2, E2, R2>(
    that: LazyArg<STM<A2, Option.Option<E2>, R2>>
  ): <A, E, R>(self: STM<A, Option.Option<E>, R>) => STM<A2 | A, Option.Option<E2 | E>, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: STM<A, Option.Option<E>, R>,
    that: LazyArg<STM<A2, Option.Option<E2>, R2>>
  ): STM<A | A2, Option.Option<E | E2>, R | R2>
}
```


# orElseSucceed

Tries this effect first, and if it fails or retries, succeeds with the
specified value.

To import and use `orElseSucceed` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.orElseSucceed
```

**Signature**

```ts
export declare const orElseSucceed: {
  <A2>(value: LazyArg<A2>): <A, E, R>(self: STM<A, E, R>) => STM<A2 | A, never, R>
  <A, E, R, A2>(self: STM<A, E, R>, value: LazyArg<A2>): STM<A | A2, never, R>
}
```


# orTry

Tries this effect first, and if it enters retry, then it tries the other
effect. This is an equivalent of Haskell's orElse.

To import and use `orTry` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.orTry
```

**Signature**

```ts
export declare const orTry: {
  <A1, E1, R1>(that: LazyArg<STM<A1, E1, R1>>): <A, E, R>(self: STM<A, E, R>) => STM<A1 | A, E1 | E, R1 | R>
  <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: LazyArg<STM<A1, E1, R1>>): STM<A | A1, E | E1, R | R1>
}
```


# partition

Feeds elements of type `A` to a function `f` that returns an effect.
Collects all successes and failures in a tupled fashion.

To import and use `partition` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.partition
```

**Signature**

```ts
export declare const partition: {
  <A, A2, E, R>(
    f: (a: A) => STM<A2, E, R>
  ): (elements: Iterable<A>) => STM<[excluded: Array<E>, satisfying: Array<A2>], never, R>
  <A, A2, E, R>(
    elements: Iterable<A>,
    f: (a: A) => STM<A2, E, R>
  ): STM<[excluded: Array<E>, satisfying: Array<A2>], never, R>
}
```


# provideContext

Provides the transaction its required environment, which eliminates its
dependency on `R`.

To import and use `provideContext` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.provideContext
```

**Signature**

```ts
export declare const provideContext: {
  <R>(env: Context.Context<R>): <A, E>(self: STM<A, E, R>) => STM<A, E>
  <A, E, R>(self: STM<A, E, R>, env: Context.Context<R>): STM<A, E>
}
```


# provideService

Provides the effect with the single service it requires. If the transactional
effect requires more than one service use `provideEnvironment` instead.

To import and use `provideService` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.provideService
```

**Signature**

```ts
export declare const provideService: {
  <I, S>(tag: Context.Tag<I, S>, resource: NoInfer<S>): <A, E, R>(self: STM<A, E, R>) => STM<A, E, Exclude<R, I>>
  <A, E, R, I, S>(self: STM<A, E, R>, tag: Context.Tag<I, S>, resource: NoInfer<S>): STM<A, E, Exclude<R, I>>
}
```


# provideServiceSTM

Provides the effect with the single service it requires. If the transactional
effect requires more than one service use `provideEnvironment` instead.

To import and use `provideServiceSTM` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.provideServiceSTM
```

**Signature**

```ts
export declare const provideServiceSTM: {
  <I, S, E1, R1>(
    tag: Context.Tag<I, S>,
    stm: STM<NoInfer<S>, E1, R1>
  ): <A, E, R>(self: STM<A, E, R>) => STM<A, E1 | E, R1 | Exclude<R, I>>
  <A, E, R, I, S, E1, R1>(
    self: STM<A, E, R>,
    tag: Context.Tag<I, S>,
    stm: STM<NoInfer<S>, E1, R1>
  ): STM<A, E1 | E, R1 | Exclude<R, I>>
}
```


# provideSomeContext

Splits the context into two parts, providing one part using the
specified layer and leaving the remainder `R0`.

To import and use `provideSomeContext` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.provideSomeContext
```

**Signature**

```ts
export declare const provideSomeContext: {
  <R>(context: Context.Context<R>): <R1, E, A>(self: STM<A, E, R1>) => STM<A, E, Exclude<R1, R>>
  <R, R1, E, A>(self: STM<A, E, R1>, context: Context.Context<R>): STM<A, E, Exclude<R1, R>>
}
```


# reduce

Folds an `Iterable<A>` using an effectual function f, working sequentially
from left to right.

To import and use `reduce` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.reduce
```

**Signature**

```ts
export declare const reduce: {
  <S, A, E, R>(zero: S, f: (s: S, a: A) => STM<S, E, R>): (iterable: Iterable<A>) => STM<S, E, R>
  <S, A, E, R>(iterable: Iterable<A>, zero: S, f: (s: S, a: A) => STM<S, E, R>): STM<S, E, R>
}
```


# reduceAll

Reduces an `Iterable<STM>` to a single `STM`, working sequentially.

To import and use `reduceAll` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.reduceAll
```

**Signature**

```ts
export declare const reduceAll: {
  <A, E2, R2>(
    initial: STM<A, E2, R2>,
    f: (x: A, y: A) => A
  ): <E, R>(iterable: Iterable<STM<A, E, R>>) => STM<A, E2 | E, R2 | R>
  <A, E, R, E2, R2>(
    iterable: Iterable<STM<A, E, R>>,
    initial: STM<A, E2, R2>,
    f: (x: A, y: A) => A
  ): STM<A, E | E2, R | R2>
}
```


# reduceRight

Folds an `Iterable<A>` using an effectual function f, working sequentially
from right to left.

To import and use `reduceRight` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.reduceRight
```

**Signature**

```ts
export declare const reduceRight: {
  <S, A, R, E>(zero: S, f: (s: S, a: A) => STM<S, E, R>): (iterable: Iterable<A>) => STM<S, E, R>
  <S, A, R, E>(iterable: Iterable<A>, zero: S, f: (s: S, a: A) => STM<S, E, R>): STM<S, E, R>
}
```


# refineOrDie

Keeps some of the errors, and terminates the fiber with the rest.

To import and use `refineOrDie` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.refineOrDie
```

**Signature**

```ts
export declare const refineOrDie: {
  <E, E2>(pf: (error: E) => Option.Option<E2>): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>
  <A, E, R, E2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<E2>): STM<A, E2, R>
}
```


# refineOrDieWith

Keeps some of the errors, and terminates the fiber with the rest, using the
specified function to convert the `E` into a `Throwable`.

To import and use `refineOrDieWith` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.refineOrDieWith
```

**Signature**

```ts
export declare const refineOrDieWith: {
  <E, E2>(pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>
  <A, E, R, E2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): STM<A, E2, R>
}
```


# reject

Fail with the returned value if the `PartialFunction` matches, otherwise
continue with our held value.

To import and use `reject` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.reject
```

**Signature**

```ts
export declare const reject: {
  <A, E2>(pf: (a: A) => Option.Option<E2>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R>
  <A, E, R, E2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<E2>): STM<A, E | E2, R>
}
```


# rejectSTM

Continue with the returned computation if the specified partial function
matches, translating the successful match into a failure, otherwise continue
with our held value.

To import and use `rejectSTM` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.rejectSTM
```

**Signature**

```ts
export declare const rejectSTM: {
  <A, E2, R2>(pf: (a: A) => Option.Option<STM<E2, E2, R2>>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R2 | R>
  <A, E, R, E2, R2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<STM<E2, E2, R2>>): STM<A, E | E2, R | R2>
}
```


# repeatUntil

Repeats this `STM` effect until its result satisfies the specified
predicate.

**WARNING**: `repeatUntil` uses a busy loop to repeat the effect and will
consume a thread until it completes (it cannot yield). This is because STM
describes a single atomic transaction which must either complete, retry or
fail a transaction before yielding back to the Effect runtime.

- Use `retryUntil` instead if you don't need to maintain transaction
  state for repeats.
- Ensure repeating the STM effect will eventually satisfy the predicate.

To import and use `repeatUntil` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.repeatUntil
```

**Signature**

```ts
export declare const repeatUntil: {
  <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>
  <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>
}
```


# repeatWhile

Repeats this `STM` effect while its result satisfies the specified
predicate.

**WARNING**: `repeatWhile` uses a busy loop to repeat the effect and will
consume a thread until it completes (it cannot yield). This is because STM
describes a single atomic transaction which must either complete, retry or
fail a transaction before yielding back to the Effect runtime.

- Use `retryWhile` instead if you don't need to maintain transaction
  state for repeats.
- Ensure repeating the STM effect will eventually not satisfy the
  predicate.

To import and use `repeatWhile` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.repeatWhile
```

**Signature**

```ts
export declare const repeatWhile: {
  <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>
  <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>
}
```


# replicate

Replicates the given effect n times. If 0 or negative numbers are given, an
empty `Chunk` will be returned.

To import and use `replicate` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.replicate
```

**Signature**

```ts
export declare const replicate: {
  (n: number): <A, E, R>(self: STM<A, E, R>) => Array<STM<A, E, R>>
  <A, E, R>(self: STM<A, E, R>, n: number): Array<STM<A, E, R>>
}
```


# replicateSTM

Performs this transaction the specified number of times and collects the
results.

To import and use `replicateSTM` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.replicateSTM
```

**Signature**

```ts
export declare const replicateSTM: {
  (n: number): <A, E, R>(self: STM<A, E, R>) => STM<Array<A>, E, R>
  <A, E, R>(self: STM<A, E, R>, n: number): STM<Array<A>, E, R>
}
```


# replicateSTMDiscard

Performs this transaction the specified number of times, discarding the
results.

To import and use `replicateSTMDiscard` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.replicateSTMDiscard
```

**Signature**

```ts
export declare const replicateSTMDiscard: {
  (n: number): <A, E, R>(self: STM<A, E, R>) => STM<void, E, R>
  <A, E, R>(self: STM<A, E, R>, n: number): STM<void, E, R>
}
```


# retry

Abort and retry the whole transaction when any of the underlying
transactional variables have changed.

To import and use `retry` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.retry
```

**Signature**

```ts
export declare const retry: STM<never, never, never>
```


# retryUntil

Filters the value produced by this effect, retrying the transaction until
the predicate returns `true` for the value.

To import and use `retryUntil` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.retryUntil
```

**Signature**

```ts
export declare const retryUntil: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: STM<A, E, R>) => STM<B, E, R>
  <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>
  <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>): STM<B, E, R>
  <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>
}
```


# retryWhile

Filters the value produced by this effect, retrying the transaction while
the predicate returns `true` for the value.

To import and use `retryWhile` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.retryWhile
```

**Signature**

```ts
export declare const retryWhile: {
  <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>
  <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>
}
```


# some

Converts an option on values into an option on errors.

To import and use `some` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.some
```

**Signature**

```ts
export declare const some: <A, E, R>(self: STM<Option.Option<A>, E, R>) => STM<A, Option.Option<E>, R>
```


# STM

`STM<A, E, R>` represents an effect that can be performed transactionally,
resulting in a failure `E` or a value `A` that may require an environment
`R` to execute.

Software Transactional Memory is a technique which allows composition of
arbitrary atomic operations. It is the software analog of transactions in
database systems.

The API is lifted directly from the Haskell package Control.Concurrent.STM
although the implementation does not resemble the Haskell one at all.

See http://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM.html

STM in Haskell was introduced in:

Composable memory transactions, by Tim Harris, Simon Marlow, Simon Peyton
Jones, and Maurice Herlihy, in ACM Conference on Principles and Practice of
Parallel Programming 2005.

See https://www.microsoft.com/en-us/research/publication/composable-memory-transactions/

See also:
Lock Free Data Structures using STMs in Haskell, by Anthony Discolo, Tim
Harris, Simon Marlow, Simon Peyton Jones, Satnam Singh) FLOPS 2006: Eighth
International Symposium on Functional and Logic Programming, Fuji Susono,
JAPAN, April 2006

https://www.microsoft.com/en-us/research/publication/lock-free-data-structures-using-stms-in-haskell/

The implemtation is based on the ZIO STM module, while JS environments have
no race conditions from multiple threads STM provides greater benefits for
synchronization of Fibers and transactional data-types can be quite useful.

To import and use `STM` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.STM
```


# succeed

Returns an `STM` effect that succeeds with the specified value.

To import and use `succeed` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.succeed
```

**Signature**

```ts
export declare const succeed: <A>(value: A) => STM<A>
```


# succeedNone

Returns an effect with the empty value.

To import and use `succeedNone` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.succeedNone
```

**Signature**

```ts
export declare const succeedNone: STM<Option.Option<never>, never, never>
```


# succeedSome

Returns an effect with the optional value.

To import and use `succeedSome` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.succeedSome
```

**Signature**

```ts
export declare const succeedSome: <A>(value: A) => STM<Option.Option<A>>
```


# summarized

Summarizes a `STM` effect by computing a provided value before and after
execution, and then combining the values to produce a summary, together
with the result of execution.

To import and use `summarized` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.summarized
```

**Signature**

```ts
export declare const summarized: {
  <A2, E2, R2, A3>(
    summary: STM<A2, E2, R2>,
    f: (before: A2, after: A2) => A3
  ): <A, E, R>(self: STM<A, E, R>) => STM<[A3, A], E2 | E, R2 | R>
  <A, E, R, A2, E2, R2, A3>(
    self: STM<A, E, R>,
    summary: STM<A2, E2, R2>,
    f: (before: A2, after: A2) => A3
  ): STM<[A3, A], E | E2, R | R2>
}
```


# suspend

Suspends creation of the specified transaction lazily.

To import and use `suspend` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.suspend
```

**Signature**

```ts
export declare const suspend: <A, E, R>(evaluate: LazyArg<STM<A, E, R>>) => STM<A, E, R>
```


# sync

Returns an `STM` effect that succeeds with the specified lazily evaluated
value.

To import and use `sync` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.sync
```

**Signature**

```ts
export declare const sync: <A>(evaluate: () => A) => STM<A>
```


# tap

"Peeks" at the success of transactional effect.

To import and use `tap` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.tap
```

**Signature**

```ts
export declare const tap: {
  <A, X, E2, R2>(f: (a: A) => STM<X, E2, R2>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R2 | R>
  <A, E, R, X, E2, R2>(self: STM<A, E, R>, f: (a: A) => STM<X, E2, R2>): STM<A, E | E2, R | R2>
}
```


# tapBoth

"Peeks" at both sides of an transactional effect.

To import and use `tapBoth` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.tapBoth
```

**Signature**

```ts
export declare const tapBoth: {
  <XE extends E, A2, E2, R2, XA extends A, A3, E3, R3, A, E>(options: {
    readonly onFailure: (error: XE) => STM<A2, E2, R2>
    readonly onSuccess: (value: XA) => STM<A3, E3, R3>
  }): <R>(self: STM<A, E, R>) => STM<A, E | E2 | E3, R2 | R3 | R>
  <A, E, R, XE extends E, A2, E2, R2, XA extends A, A3, E3, R3>(
    self: STM<A, E, R>,
    options: { readonly onFailure: (error: XE) => STM<A2, E2, R2>; readonly onSuccess: (value: XA) => STM<A3, E3, R3> }
  ): STM<A, E | E2 | E3, R | R2 | R3>
}
```


# tapError

"Peeks" at the error of the transactional effect.

To import and use `tapError` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.tapError
```

**Signature**

```ts
export declare const tapError: {
  <E, X, E2, R2>(f: (error: NoInfer<E>) => STM<X, E2, R2>): <A, R>(self: STM<A, E, R>) => STM<A, E | E2, R2 | R>
  <A, E, R, X, E2, R2>(self: STM<A, E, R>, f: (error: E) => STM<X, E2, R2>): STM<A, E | E2, R | R2>
}
```


# try

Imports a synchronous side-effect into a pure value, translating any thrown
exceptions into typed failed effects.

To import and use `try` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.try
```


# unless

The moral equivalent of `if (!p) exp`

To import and use `unless` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.unless
```

**Signature**

```ts
export declare const unless: {
  (predicate: LazyArg<boolean>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>
  <A, E, R>(self: STM<A, E, R>, predicate: LazyArg<boolean>): STM<Option.Option<A>, E, R>
}
```


# unlessSTM

The moral equivalent of `if (!p) exp` when `p` has side-effects

To import and use `unlessSTM` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.unlessSTM
```

**Signature**

```ts
export declare const unlessSTM: {
  <E2, R2>(predicate: STM<boolean, E2, R2>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E2 | E, R2 | R>
  <A, E, R, E2, R2>(self: STM<A, E, R>, predicate: STM<boolean, E2, R2>): STM<Option.Option<A>, E | E2, R | R2>
}
```


# unsome

Converts an option on errors into an option on values.

To import and use `unsome` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.unsome
```

**Signature**

```ts
export declare const unsome: <A, E, R>(self: STM<A, Option.Option<E>, R>) => STM<Option.Option<A>, E, R>
```


# validateAll

Feeds elements of type `A` to `f` and accumulates all errors in error
channel or successes in success channel.

This combinator is lossy meaning that if there are errors all successes
will be lost. To retain all information please use `STM.partition`.

To import and use `validateAll` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.validateAll
```

**Signature**

```ts
export declare const validateAll: {
  <A, B, E, R>(f: (a: A) => STM<B, E, R>): (elements: Iterable<A>) => STM<Array<B>, [E, ...Array<E>], R>
  <A, B, E, R>(elements: Iterable<A>, f: (a: A) => STM<B, E, R>): STM<Array<B>, [E, ...Array<E>], R>
}
```


# validateFirst

Feeds elements of type `A` to `f` until it succeeds. Returns first success
or the accumulation of all errors.

To import and use `validateFirst` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.validateFirst
```

**Signature**

```ts
export declare const validateFirst: {
  <A, B, E, R>(f: (a: A) => STM<B, E, R>): (elements: Iterable<A>) => STM<B, Array<E>, R>
  <A, B, E, R>(elements: Iterable<A>, f: (a: A) => STM<B, E, R>): STM<B, Array<E>, R>
}
```


# void

Returns an `STM` effect that succeeds with `void`.

To import and use `void` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.void
```


# when

The moral equivalent of `if (p) exp`.

To import and use `when` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.when
```

**Signature**

```ts
export declare const when: {
  (predicate: LazyArg<boolean>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>
  <A, E, R>(self: STM<A, E, R>, predicate: LazyArg<boolean>): STM<Option.Option<A>, E, R>
}
```


# whenSTM

The moral equivalent of `if (p) exp` when `p` has side-effects.

To import and use `whenSTM` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.whenSTM
```

**Signature**

```ts
export declare const whenSTM: {
  <E2, R2>(predicate: STM<boolean, E2, R2>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E2 | E, R2 | R>
  <A, E, R, E2, R2>(self: STM<A, E, R>, predicate: STM<boolean, E2, R2>): STM<Option.Option<A>, E | E2, R | R2>
}
```


# zip

Sequentially zips this value with the specified one.

To import and use `zip` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.zip
```

**Signature**

```ts
export declare const zip: {
  <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<[A, A1], E1 | E, R1 | R>
  <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<[A, A1], E | E1, R | R1>
}
```


# zipLeft

Sequentially zips this value with the specified one, discarding the second
element of the tuple.

To import and use `zipLeft` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.zipLeft
```

**Signature**

```ts
export declare const zipLeft: {
  <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E1 | E, R1 | R>
  <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<A, E | E1, R | R1>
}
```


# zipRight

Sequentially zips this value with the specified one, discarding the first
element of the tuple.

To import and use `zipRight` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.zipRight
```

**Signature**

```ts
export declare const zipRight: {
  <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A1, E1 | E, R1 | R>
  <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<A1, E | E1, R | R1>
}
```


# zipWith

Sequentially zips this value with the specified one, combining the values
using the specified combiner function.

To import and use `zipWith` from the "STM" module:

```ts
import * as STM from "effect/STM"
// Can be accessed like this
STM.zipWith
```

**Signature**

```ts
export declare const zipWith: {
  <A1, E1, R1, A, A2>(
    that: STM<A1, E1, R1>,
    f: (a: A, b: A1) => A2
  ): <E, R>(self: STM<A, E, R>) => STM<A2, E1 | E, R1 | R>
  <A, E, R, A1, E1, R1, A2>(self: STM<A, E, R>, that: STM<A1, E1, R1>, f: (a: A, b: A1) => A2): STM<A2, E | E1, R | R1>
}
```


# memory

A layer that stores data in-memory.
This is useful for testing with a single pod only.

To import and use `memory` from the "Storage" module:

```ts
import * as Storage from "@effect/cluster/Storage"
// Can be accessed like this
Storage.memory
```

**Signature**

```ts
export declare const memory: Layer.Layer<Storage, never, never>
```


# noop

A layer that does nothing, useful for testing.

To import and use `noop` from the "Storage" module:

```ts
import * as Storage from "@effect/cluster/Storage"
// Can be accessed like this
Storage.noop
```

**Signature**

```ts
export declare const noop: Layer.Layer<Storage, never, never>
```


# Storage

The storage Service is responsible of persisting assignments and registered pods.
The storage is expected to be shared among all pods, so it works also as communication of assignments between Pods.

To import and use `Storage` from the "Storage" module:

```ts
import * as Storage from "@effect/cluster/Storage"
// Can be accessed like this
Storage.Storage
```


# accumulate

Collects each underlying Chunk of the stream into a new chunk, and emits it
on each pull.

To import and use `accumulate` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.accumulate
```

**Signature**

```ts
export declare const accumulate: <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>
```


# accumulateChunks

Re-chunks the elements of the stream by accumulating each underlying chunk.

To import and use `accumulateChunks` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.accumulateChunks
```

**Signature**

```ts
export declare const accumulateChunks: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
```


# acquireRelease

Creates a stream from a single value that will get cleaned up after the
stream is consumed.

To import and use `acquireRelease` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.acquireRelease
```

**Example**

```ts
import { Console, Effect, Stream } from "effect"

// Simulating File operations
const open = (filename: string) =>
  Effect.gen(function* () {
    yield* Console.log(`Opening ${filename}`)
    return {
      getLines: Effect.succeed(["Line 1", "Line 2", "Line 3"]),
      close: Console.log(`Closing ${filename}`)
    }
  })

const stream = Stream.acquireRelease(open("file.txt"), (file) => file.close).pipe(
  Stream.flatMap((file) => file.getLines)
)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Opening file.txt
// Closing file.txt
// { _id: 'Chunk', values: [ [ 'Line 1', 'Line 2', 'Line 3' ] ] }
```

**Signature**

```ts
export declare const acquireRelease: <A, E, R, R2, X>(
  acquire: Effect.Effect<A, E, R>,
  release: (resource: A, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<X, never, R2>
) => Stream<A, E, R | R2>
```


# aggregate

Aggregates elements of this stream using the provided sink for as long as
the downstream operators on the stream are busy.

This operator divides the stream into two asynchronous "islands". Operators
upstream of this operator run on one fiber, while downstream operators run
on another. Whenever the downstream fiber is busy processing elements, the
upstream fiber will feed elements into the sink until it signals
completion.

Any sink can be used here, but see `Sink.foldWeightedEffect` and
`Sink.foldUntilEffect` for sinks that cover the common usecases.

To import and use `aggregate` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.aggregate
```

**Signature**

```ts
export declare const aggregate: {
  <B, A, A2, E2, R2>(sink: Sink.Sink<B, A | A2, A2, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R>
  <A, E, R, B, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<B, A | A2, A2, E2, R2>): Stream<B, E | E2, R | R2>
}
```


# aggregateWithin

Like `aggregateWithinEither`, but only returns the `Right` results.

To import and use `aggregateWithin` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.aggregateWithin
```

**Signature**

```ts
export declare const aggregateWithin: {
  <B, A, A2, E2, R2, C, R3>(
    sink: Sink.Sink<B, A | A2, A2, E2, R2>,
    schedule: Schedule.Schedule<C, Option.Option<B>, R3>
  ): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R3 | R>
  <A, E, R, B, A2, E2, R2, C, R3>(
    self: Stream<A, E, R>,
    sink: Sink.Sink<B, A | A2, A2, E2, R2>,
    schedule: Schedule.Schedule<C, Option.Option<B>, R3>
  ): Stream<B, E | E2, R | R2 | R3>
}
```


# aggregateWithinEither

Aggregates elements using the provided sink until it completes, or until
the delay signalled by the schedule has passed.

This operator divides the stream into two asynchronous islands. Operators
upstream of this operator run on one fiber, while downstream operators run
on another. Elements will be aggregated by the sink until the downstream
fiber pulls the aggregated value, or until the schedule's delay has passed.

Aggregated elements will be fed into the schedule to determine the delays
between pulls.

To import and use `aggregateWithinEither` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.aggregateWithinEither
```

**Signature**

```ts
export declare const aggregateWithinEither: {
  <B, A, A2, E2, R2, C, R3>(
    sink: Sink.Sink<B, A | A2, A2, E2, R2>,
    schedule: Schedule.Schedule<C, Option.Option<B>, R3>
  ): <E, R>(self: Stream<A, E, R>) => Stream<Either.Either<B, C>, E2 | E, R2 | R3 | R>
  <A, E, R, B, A2, E2, R2, C, R3>(
    self: Stream<A, E, R>,
    sink: Sink.Sink<B, A | A2, A2, E2, R2>,
    schedule: Schedule.Schedule<C, Option.Option<B>, R3>
  ): Stream<Either.Either<B, C>, E | E2, R | R2 | R3>
}
```


# as

Maps the success values of this stream to the specified constant value.

To import and use `as` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.as
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.range(1, 5).pipe(Stream.as(null))

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ null, null, null, null, null ] }
```

**Signature**

```ts
export declare const as: {
  <B>(value: B): <A, E, R>(self: Stream<A, E, R>) => Stream<B, E, R>
  <A, E, R, B>(self: Stream<A, E, R>, value: B): Stream<B, E, R>
}
```


# async

Creates a stream from an asynchronous callback that can be called multiple
times. The optionality of the error type `E` in `Emit` can be used to
signal the end of the stream by setting it to `None`.

The registration function can optionally return an `Effect`, which will be
executed if the `Fiber` executing this Effect is interrupted.

To import and use `async` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.async
```

**Example**

```ts
import type { StreamEmit } from "effect"
import { Chunk, Effect, Option, Stream } from "effect"

const events = [1, 2, 3, 4]

const stream = Stream.async((emit: StreamEmit.Emit<never, never, number, void>) => {
  events.forEach((n) => {
    setTimeout(() => {
      if (n === 3) {
        emit(Effect.fail(Option.none())) // Terminate the stream
      } else {
        emit(Effect.succeed(Chunk.of(n))) // Add the current item to the stream
      }
    }, 100 * n)
  })
})

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2 ] }
```


# asyncEffect

Creates a stream from an asynchronous callback that can be called multiple
times The registration of the callback itself returns an effect. The
optionality of the error type `E` can be used to signal the end of the
stream, by setting it to `None`.

To import and use `asyncEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.asyncEffect
```

**Signature**

```ts
export declare const asyncEffect: <A, E = never, R = never>(
  register: (emit: Emit.Emit<R, E, A, void>) => Effect.Effect<unknown, E, R>,
  bufferSize?:
    | number
    | "unbounded"
    | { readonly bufferSize?: number | undefined; readonly strategy?: "dropping" | "sliding" | "suspend" | undefined }
    | undefined
) => Stream<A, E, R>
```


# asyncPush

Creates a stream from an external push-based resource.

You can use the `emit` helper to emit values to the stream. The `emit` helper
returns a boolean indicating whether the value was emitted or not.

You can also use the `emit` helper to signal the end of the stream by
using apis such as `emit.end` or `emit.fail`.

By default it uses an "unbounded" buffer size.
You can customize the buffer size and strategy by passing an object as the
second argument with the `bufferSize` and `strategy` fields.

To import and use `asyncPush` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.asyncPush
```

**Example**

```ts
import { Effect, Stream } from "effect"

Stream.asyncPush<string>(
  (emit) =>
    Effect.acquireRelease(
      Effect.gen(function* () {
        yield* Effect.log("subscribing")
        return setInterval(() => emit.single("tick"), 1000)
      }),
      (handle) =>
        Effect.gen(function* () {
          yield* Effect.log("unsubscribing")
          clearInterval(handle)
        })
    ),
  { bufferSize: 16, strategy: "dropping" }
)
```

**Signature**

```ts
export declare const asyncPush: <A, E = never, R = never>(
  register: (emit: Emit.EmitOpsPush<E, A>) => Effect.Effect<unknown, E, R | Scope.Scope>,
  options?:
    | { readonly bufferSize: "unbounded" }
    | { readonly bufferSize?: number | undefined; readonly strategy?: "dropping" | "sliding" | undefined }
    | undefined
) => Stream<A, E, Exclude<R, Scope.Scope>>
```


# asyncScoped

Creates a stream from an asynchronous callback that can be called multiple
times. The registration of the callback itself returns an a scoped
resource. The optionality of the error type `E` can be used to signal the
end of the stream, by setting it to `None`.

To import and use `asyncScoped` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.asyncScoped
```

**Signature**

```ts
export declare const asyncScoped: <A, E = never, R = never>(
  register: (emit: Emit.Emit<R, E, A, void>) => Effect.Effect<unknown, E, R | Scope.Scope>,
  bufferSize?:
    | number
    | "unbounded"
    | { readonly bufferSize?: number | undefined; readonly strategy?: "dropping" | "sliding" | "suspend" | undefined }
    | undefined
) => Stream<A, E, Exclude<R, Scope.Scope>>
```


# bind

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

To import and use `bind` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.bind
```

**Example**

```ts
import { Chunk, Effect, pipe, Stream } from "effect"

const result = pipe(
  Stream.Do,
  Stream.bind("x", () => Stream.succeed(2)),
  Stream.bind("y", () => Stream.succeed(3)),
  Stream.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))
```

**Signature**

```ts
export declare const bind: {
  <N extends string, A, B, E2, R2>(
    tag: Exclude<N, keyof A>,
    f: (_: NoInfer<A>) => Stream<B, E2, R2>,
    options?:
      | { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined }
      | undefined
  ): <E, R>(self: Stream<A, E, R>) => Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E2 | E, R2 | R>
  <A, E, R, N extends string, B, E2, R2>(
    self: Stream<A, E, R>,
    tag: Exclude<N, keyof A>,
    f: (_: NoInfer<A>) => Stream<B, E2, R2>,
    options?:
      | { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined }
      | undefined
  ): Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E | E2, R | R2>
}
```


# bindEffect

Binds an effectful value in a `do` scope

To import and use `bindEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.bindEffect
```

**Signature**

```ts
export declare const bindEffect: {
  <N extends string, A, B, E2, R2>(
    tag: Exclude<N, keyof A>,
    f: (_: NoInfer<A>) => Effect.Effect<B, E2, R2>,
    options?: { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined }
  ): <E, R>(self: Stream<A, E, R>) => Stream<{ [K in keyof A | N]: K extends keyof A ? A[K] : B }, E | E2, R | R2>
  <A, E, R, N extends string, B, E2, R2>(
    self: Stream<A, E, R>,
    tag: Exclude<N, keyof A>,
    f: (_: NoInfer<A>) => Effect.Effect<B, E2, R2>,
    options?: { readonly concurrency?: number | "unbounded" | undefined; readonly unordered?: boolean | undefined }
  ): Stream<{ [K in keyof A | N]: K extends keyof A ? A[K] : B }, E | E2, R | R2>
}
```


# bindTo

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

To import and use `bindTo` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.bindTo
```

**Example**

```ts
import { Chunk, Effect, pipe, Stream } from "effect"

const result = pipe(
  Stream.Do,
  Stream.bind("x", () => Stream.succeed(2)),
  Stream.bind("y", () => Stream.succeed(3)),
  Stream.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))
```

**Signature**

```ts
export declare const bindTo: {
  <N extends string>(name: N): <A, E, R>(self: Stream<A, E, R>) => Stream<{ [K in N]: A }, E, R>
  <A, E, R, N extends string>(self: Stream<A, E, R>, name: N): Stream<{ [K in N]: A }, E, R>
}
```


# branchAfter

Returns a `Stream` that first collects `n` elements from the input `Stream`,
and then creates a new `Stream` using the specified function, and sends all
the following elements through that.

To import and use `branchAfter` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.branchAfter
```

**Signature**

```ts
export declare const branchAfter: {
  <A, A2, E2, R2>(
    n: number,
    f: (input: Chunk.Chunk<A>) => Stream<A2, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    n: number,
    f: (input: Chunk.Chunk<A>) => Stream<A2, E2, R2>
  ): Stream<A2, E | E2, R | R2>
}
```


# broadcast

Fan out the stream, producing a list of streams that have the same elements
as this stream. The driver stream will only ever advance the `maximumLag`
chunks before the slowest downstream stream.

To import and use `broadcast` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.broadcast
```

**Example**

```ts
import { Console, Effect, Fiber, Schedule, Stream } from "effect"

const numbers = Effect.scoped(
  Stream.range(1, 20).pipe(
    Stream.tap((n) => Console.log(`Emit ${n} element before broadcasting`)),
    Stream.broadcast(2, 5),
    Stream.flatMap(([first, second]) =>
      Effect.gen(function* () {
        const fiber1 = yield* Stream.runFold(first, 0, (acc, e) => Math.max(acc, e)).pipe(
          Effect.andThen((max) => Console.log(`Maximum: ${max}`)),
          Effect.fork
        )
        const fiber2 = yield* second.pipe(
          Stream.schedule(Schedule.spaced("1 second")),
          Stream.runForEach((n) => Console.log(`Logging to the Console: ${n}`)),
          Effect.fork
        )
        yield* Fiber.join(fiber1).pipe(Effect.zip(Fiber.join(fiber2), { concurrent: true }))
      })
    ),
    Stream.runCollect
  )
)

// Effect.runPromise(numbers).then(console.log)
// Emit 1 element before broadcasting
// Emit 2 element before broadcasting
// Emit 3 element before broadcasting
// Emit 4 element before broadcasting
// Emit 5 element before broadcasting
// Emit 6 element before broadcasting
// Emit 7 element before broadcasting
// Emit 8 element before broadcasting
// Emit 9 element before broadcasting
// Emit 10 element before broadcasting
// Emit 11 element before broadcasting
// Logging to the Console: 1
// Logging to the Console: 2
// Logging to the Console: 3
// Logging to the Console: 4
// Logging to the Console: 5
// Emit 12 element before broadcasting
// Emit 13 element before broadcasting
// Emit 14 element before broadcasting
// Emit 15 element before broadcasting
// Emit 16 element before broadcasting
// Logging to the Console: 6
// Logging to the Console: 7
// Logging to the Console: 8
// Logging to the Console: 9
// Logging to the Console: 10
// Emit 17 element before broadcasting
// Emit 18 element before broadcasting
// Emit 19 element before broadcasting
// Emit 20 element before broadcasting
// Logging to the Console: 11
// Logging to the Console: 12
// Logging to the Console: 13
// Logging to the Console: 14
// Logging to the Console: 15
// Maximum: 20
// Logging to the Console: 16
// Logging to the Console: 17
// Logging to the Console: 18
// Logging to the Console: 19
// Logging to the Console: 20
// { _id: 'Chunk', values: [ undefined ] }
```

**Signature**

```ts
export declare const broadcast: {
  <N extends number>(
    n: N,
    maximumLag:
      | number
      | { readonly capacity: "unbounded"; readonly replay?: number | undefined }
      | {
          readonly capacity: number
          readonly strategy?: "sliding" | "dropping" | "suspend" | undefined
          readonly replay?: number | undefined
        }
  ): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<TupleOf<N, Stream<A, E>>, never, Scope.Scope | R>
  <A, E, R, N extends number>(
    self: Stream<A, E, R>,
    n: N,
    maximumLag:
      | number
      | { readonly capacity: "unbounded"; readonly replay?: number | undefined }
      | {
          readonly capacity: number
          readonly strategy?: "sliding" | "dropping" | "suspend" | undefined
          readonly replay?: number | undefined
        }
  ): Effect.Effect<TupleOf<N, Stream<A, E>>, never, Scope.Scope | R>
}
```


# broadcastDynamic

Fan out the stream, producing a dynamic number of streams that have the
same elements as this stream. The driver stream will only ever advance the
`maximumLag` chunks before the slowest downstream stream.

To import and use `broadcastDynamic` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.broadcastDynamic
```

**Signature**

```ts
export declare const broadcastDynamic: {
  (
    maximumLag:
      | number
      | { readonly capacity: "unbounded"; readonly replay?: number | undefined }
      | {
          readonly capacity: number
          readonly strategy?: "sliding" | "dropping" | "suspend" | undefined
          readonly replay?: number | undefined
        }
  ): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Stream<A, E>, never, Scope.Scope | R>
  <A, E, R>(
    self: Stream<A, E, R>,
    maximumLag:
      | number
      | { readonly capacity: "unbounded"; readonly replay?: number | undefined }
      | {
          readonly capacity: number
          readonly strategy?: "sliding" | "dropping" | "suspend" | undefined
          readonly replay?: number | undefined
        }
  ): Effect.Effect<Stream<A, E>, never, Scope.Scope | R>
}
```


# broadcastedQueues

Converts the stream to a scoped list of queues. Every value will be
replicated to every queue with the slowest queue being allowed to buffer
`maximumLag` chunks before the driver is back pressured.

Queues can unsubscribe from upstream by shutting down.

To import and use `broadcastedQueues` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.broadcastedQueues
```

**Signature**

```ts
export declare const broadcastedQueues: {
  <N extends number>(
    n: N,
    maximumLag:
      | number
      | { readonly capacity: "unbounded"; readonly replay?: number | undefined }
      | {
          readonly capacity: number
          readonly strategy?: "sliding" | "dropping" | "suspend" | undefined
          readonly replay?: number | undefined
        }
  ): <A, E, R>(
    self: Stream<A, E, R>
  ) => Effect.Effect<TupleOf<N, Queue.Dequeue<Take.Take<A, E>>>, never, Scope.Scope | R>
  <A, E, R, N extends number>(
    self: Stream<A, E, R>,
    n: N,
    maximumLag:
      | number
      | { readonly capacity: "unbounded"; readonly replay?: number | undefined }
      | {
          readonly capacity: number
          readonly strategy?: "sliding" | "dropping" | "suspend" | undefined
          readonly replay?: number | undefined
        }
  ): Effect.Effect<TupleOf<N, Queue.Dequeue<Take.Take<A, E>>>, never, Scope.Scope | R>
}
```


# broadcastedQueuesDynamic

Converts the stream to a scoped dynamic amount of queues. Every chunk will
be replicated to every queue with the slowest queue being allowed to buffer
`maximumLag` chunks before the driver is back pressured.

Queues can unsubscribe from upstream by shutting down.

To import and use `broadcastedQueuesDynamic` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.broadcastedQueuesDynamic
```

**Signature**

```ts
export declare const broadcastedQueuesDynamic: {
  (
    maximumLag:
      | number
      | { readonly capacity: "unbounded"; readonly replay?: number | undefined }
      | {
          readonly capacity: number
          readonly strategy?: "sliding" | "dropping" | "suspend" | undefined
          readonly replay?: number | undefined
        }
  ): <A, E, R>(
    self: Stream<A, E, R>
  ) => Effect.Effect<Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope>, never, Scope.Scope | R>
  <A, E, R>(
    self: Stream<A, E, R>,
    maximumLag:
      | number
      | { readonly capacity: "unbounded"; readonly replay?: number | undefined }
      | {
          readonly capacity: number
          readonly strategy?: "sliding" | "dropping" | "suspend" | undefined
          readonly replay?: number | undefined
        }
  ): Effect.Effect<Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope>, never, Scope.Scope | R>
}
```


# buffer

Allows a faster producer to progress independently of a slower consumer by
buffering up to `capacity` elements in a queue.

Note: This combinator destroys the chunking structure. It's recommended to
use rechunk afterwards. Additionally, prefer capacities that are powers
of 2 for better performance.

To import and use `buffer` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.buffer
```

**Example**

```ts
import { Console, Effect, Schedule, Stream } from "effect"

const stream = Stream.range(1, 10).pipe(
  Stream.tap((n) => Console.log(`before buffering: ${n}`)),
  Stream.buffer({ capacity: 4 }),
  Stream.tap((n) => Console.log(`after buffering: ${n}`)),
  Stream.schedule(Schedule.spaced("5 seconds"))
)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// before buffering: 1
// before buffering: 2
// before buffering: 3
// before buffering: 4
// before buffering: 5
// before buffering: 6
// after buffering: 1
// after buffering: 2
// before buffering: 7
// after buffering: 3
// before buffering: 8
// after buffering: 4
// before buffering: 9
// after buffering: 5
// before buffering: 10
// ...
```

**Signature**

```ts
export declare const buffer: {
  (
    options:
      | { readonly capacity: "unbounded" }
      | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend" | undefined }
  ): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R>(
    self: Stream<A, E, R>,
    options:
      | { readonly capacity: "unbounded" }
      | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend" | undefined }
  ): Stream<A, E, R>
}
```


# bufferChunks

Allows a faster producer to progress independently of a slower consumer by
buffering up to `capacity` chunks in a queue.

To import and use `bufferChunks` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.bufferChunks
```

**Signature**

```ts
export declare const bufferChunks: {
  (options: {
    readonly capacity: number
    readonly strategy?: "dropping" | "sliding" | "suspend" | undefined
  }): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R>(
    self: Stream<A, E, R>,
    options: { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend" | undefined }
  ): Stream<A, E, R>
}
```


# catchAll

Switches over to the stream produced by the provided function in case this
one fails with a typed error.

To import and use `catchAll` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.catchAll
```

**Signature**

```ts
export declare const catchAll: {
  <E, A2, E2, R2>(f: (error: E) => Stream<A2, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (error: E) => Stream<A2, E2, R2>): Stream<A | A2, E2, R | R2>
}
```


# catchAllCause

Switches over to the stream produced by the provided function in case this
one fails. Allows recovery from all causes of failure, including
interruption if the stream is uninterruptible.

To import and use `catchAllCause` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.catchAllCause
```

**Signature**

```ts
export declare const catchAllCause: {
  <E, A2, E2, R2>(
    f: (cause: Cause.Cause<E>) => Stream<A2, E2, R2>
  ): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    f: (cause: Cause.Cause<E>) => Stream<A2, E2, R2>
  ): Stream<A | A2, E2, R | R2>
}
```


# catchSome

Switches over to the stream produced by the provided function in case this
one fails with some typed error.

To import and use `catchSome` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.catchSome
```

**Signature**

```ts
export declare const catchSome: {
  <E, A2, E2, R2>(
    pf: (error: E) => Option.Option<Stream<A2, E2, R2>>
  ): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E | E2, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    pf: (error: E) => Option.Option<Stream<A2, E2, R2>>
  ): Stream<A | A2, E | E2, R | R2>
}
```


# catchSomeCause

Switches over to the stream produced by the provided function in case this
one fails with some errors. Allows recovery from all causes of failure,
including interruption if the stream is uninterruptible.

To import and use `catchSomeCause` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.catchSomeCause
```

**Signature**

```ts
export declare const catchSomeCause: {
  <E, A2, E2, R2>(
    pf: (cause: Cause.Cause<E>) => Option.Option<Stream<A2, E2, R2>>
  ): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E | E2, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    pf: (cause: Cause.Cause<E>) => Option.Option<Stream<A2, E2, R2>>
  ): Stream<A | A2, E | E2, R | R2>
}
```


# catchTag

Switches over to the stream produced by the provided function in case this
one fails with an error matching the given `_tag`.

To import and use `catchTag` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.catchTag
```

**Signature**

```ts
export declare const catchTag: {
  <K extends E["_tag"] & string, E extends { _tag: string }, A1, E1, R1>(
    k: K,
    f: (e: Extract<E, { _tag: K }>) => Stream<A1, E1, R1>
  ): <A, R>(self: Stream<A, E, R>) => Stream<A1 | A, E1 | Exclude<E, { _tag: K }>, R1 | R>
  <A, E extends { _tag: string }, R, K extends E["_tag"] & string, A1, E1, R1>(
    self: Stream<A, E, R>,
    k: K,
    f: (e: Extract<E, { _tag: K }>) => Stream<A1, E1, R1>
  ): Stream<A | A1, E1 | Exclude<E, { _tag: K }>, R | R1>
}
```


# catchTags

Switches over to the stream produced by one of the provided functions, in
case this one fails with an error matching one of the given `_tag`'s.

To import and use `catchTags` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.catchTags
```

**Signature**

```ts
export declare const catchTags: {
  <
    E extends { _tag: string },
    Cases extends { [K in E["_tag"]]+?: (error: Extract<E, { _tag: K }>) => Stream<any, any, any> }
  >(
    cases: Cases
  ): <A, R>(
    self: Stream<A, E, R>
  ) => Stream<
    | A
    | {
        [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer A, infer _E, infer _R>
          ? A
          : never
      }[keyof Cases],
    | Exclude<E, { _tag: keyof Cases }>
    | {
        [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _A, infer E, infer _R>
          ? E
          : never
      }[keyof Cases],
    | R
    | {
        [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _A, infer _E, infer R>
          ? R
          : never
      }[keyof Cases]
  >
  <
    A,
    E extends { _tag: string },
    R,
    Cases extends { [K in E["_tag"]]+?: (error: Extract<E, { _tag: K }>) => Stream<any, any, any> }
  >(
    self: Stream<A, E, R>,
    cases: Cases
  ): Stream<
    | A
    | {
        [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _R, infer _E, infer A>
          ? A
          : never
      }[keyof Cases],
    | Exclude<E, { _tag: keyof Cases }>
    | {
        [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _R, infer E, infer _A>
          ? E
          : never
      }[keyof Cases],
    | R
    | {
        [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer R, infer _E, infer _A>
          ? R
          : never
      }[keyof Cases]
  >
}
```


# changes

Returns a new stream that only emits elements that are not equal to the
previous element emitted, using natural equality to determine whether two
elements are equal.

To import and use `changes` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.changes
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.make(1, 1, 1, 2, 2, 3, 4).pipe(Stream.changes)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4 ] }
```

**Signature**

```ts
export declare const changes: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
```


# changesWith

Returns a new stream that only emits elements that are not equal to the
previous element emitted, using the specified function to determine whether
two elements are equal.

To import and use `changesWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.changesWith
```

**Signature**

```ts
export declare const changesWith: {
  <A>(f: (x: A, y: A) => boolean): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R>(self: Stream<A, E, R>, f: (x: A, y: A) => boolean): Stream<A, E, R>
}
```


# changesWithEffect

Returns a new stream that only emits elements that are not equal to the
previous element emitted, using the specified effectual function to
determine whether two elements are equal.

To import and use `changesWithEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.changesWithEffect
```

**Signature**

```ts
export declare const changesWithEffect: {
  <A, E2, R2>(
    f: (x: A, y: A) => Effect.Effect<boolean, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (x: A, y: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>
}
```


# chunks

Exposes the underlying chunks of the stream as a stream of chunks of
elements.

To import and use `chunks` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.chunks
```

**Signature**

```ts
export declare const chunks: <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>
```


# chunksWith

Performs the specified stream transformation with the chunk structure of
the stream exposed.

To import and use `chunksWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.chunksWith
```

**Signature**

```ts
export declare const chunksWith: {
  <A, E, R, A2, E2, R2>(
    f: (stream: Stream<Chunk.Chunk<A>, E, R>) => Stream<Chunk.Chunk<A2>, E2, R2>
  ): (self: Stream<A, E, R>) => Stream<A2, E | E2, R | R2>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    f: (stream: Stream<Chunk.Chunk<A>, E, R>) => Stream<Chunk.Chunk<A2>, E2, R2>
  ): Stream<A2, E | E2, R | R2>
}
```


# combine

Combines the elements from this stream and the specified stream by
repeatedly applying the function `f` to extract an element using both sides
and conceptually "offer" it to the destination stream. `f` can maintain
some internal state to control the combining process, with the initial
state being specified by `s`.

Where possible, prefer `Stream.combineChunks` for a more efficient
implementation.

To import and use `combine` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.combine
```

**Signature**

```ts
export declare const combine: {
  <A2, E2, R2, S, R3, E, A, R4, R5, A3>(
    that: Stream<A2, E2, R2>,
    s: S,
    f: (
      s: S,
      pullLeft: Effect.Effect<A, Option.Option<E>, R3>,
      pullRight: Effect.Effect<A2, Option.Option<E2>, R4>
    ) => Effect.Effect<Exit.Exit<readonly [A3, S], Option.Option<E2 | E>>, never, R5>
  ): <R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>
  <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(
    self: Stream<A, E, R>,
    that: Stream<A2, E2, R2>,
    s: S,
    f: (
      s: S,
      pullLeft: Effect.Effect<A, Option.Option<E>, R3>,
      pullRight: Effect.Effect<A2, Option.Option<E2>, R4>
    ) => Effect.Effect<Exit.Exit<readonly [A3, S], Option.Option<E2 | E>>, never, R5>
  ): Stream<A3, E2 | E, R | R2 | R3 | R4 | R5>
}
```


# combineChunks

Combines the chunks from this stream and the specified stream by repeatedly
applying the function `f` to extract a chunk using both sides and
conceptually "offer" it to the destination stream. `f` can maintain some
internal state to control the combining process, with the initial state
being specified by `s`.

To import and use `combineChunks` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.combineChunks
```

**Signature**

```ts
export declare const combineChunks: {
  <A2, E2, R2, S, R3, E, A, R4, R5, A3>(
    that: Stream<A2, E2, R2>,
    s: S,
    f: (
      s: S,
      pullLeft: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R3>,
      pullRight: Effect.Effect<Chunk.Chunk<A2>, Option.Option<E2>, R4>
    ) => Effect.Effect<Exit.Exit<readonly [Chunk.Chunk<A3>, S], Option.Option<E2 | E>>, never, R5>
  ): <R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>
  <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(
    self: Stream<A, E, R>,
    that: Stream<A2, E2, R2>,
    s: S,
    f: (
      s: S,
      pullLeft: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R3>,
      pullRight: Effect.Effect<Chunk.Chunk<A2>, Option.Option<E2>, R4>
    ) => Effect.Effect<Exit.Exit<readonly [Chunk.Chunk<A3>, S], Option.Option<E2 | E>>, never, R5>
  ): Stream<A3, E2 | E, R | R2 | R3 | R4 | R5>
}
```


# concat

Concatenates the specified stream with this stream, resulting in a stream
that emits the elements from this stream and then the elements from the
specified stream.

To import and use `concat` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.concat
```

**Example**

```ts
import { Effect, Stream } from "effect"

const s1 = Stream.make(1, 2, 3)
const s2 = Stream.make(4, 5)

const stream = Stream.concat(s1, s2)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }
```

**Signature**

```ts
export declare const concat: {
  <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>
}
```


# concatAll

Concatenates all of the streams in the chunk to one stream.

To import and use `concatAll` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.concatAll
```

**Example**

```ts
import { Chunk, Effect, Stream } from "effect"

const s1 = Stream.make(1, 2, 3)
const s2 = Stream.make(4, 5)
const s3 = Stream.make(6, 7, 8)

const stream = Stream.concatAll(Chunk.make(s1, s2, s3))

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [
//     1, 2, 3, 4,
//     5, 6, 7, 8
//   ]
// }
```

**Signature**

```ts
export declare const concatAll: <A, E, R>(streams: Chunk.Chunk<Stream<A, E, R>>) => Stream<A, E, R>
```


# context

Accesses the whole context of the stream.

To import and use `context` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.context
```

**Signature**

```ts
export declare const context: <R>() => Stream<Context.Context<R>, never, R>
```


# contextWith

Accesses the context of the stream.

To import and use `contextWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.contextWith
```

**Signature**

```ts
export declare const contextWith: <R, A>(f: (env: Context.Context<R>) => A) => Stream<A, never, R>
```


# contextWithEffect

Accesses the context of the stream in the context of an effect.

To import and use `contextWithEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.contextWithEffect
```

**Signature**

```ts
export declare const contextWithEffect: <R0, A, E, R>(
  f: (env: Context.Context<R0>) => Effect.Effect<A, E, R>
) => Stream<A, E, R0 | R>
```


# contextWithStream

Accesses the context of the stream in the context of a stream.

To import and use `contextWithStream` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.contextWithStream
```

**Signature**

```ts
export declare const contextWithStream: <R0, A, E, R>(
  f: (env: Context.Context<R0>) => Stream<A, E, R>
) => Stream<A, E, R0 | R>
```


# cross

Composes this stream with the specified stream to create a cartesian
product of elements. The `right` stream would be run multiple times, for
every element in the `left` stream.

See also `Stream.zip` for the more common point-wise variant.

To import and use `cross` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.cross
```

**Example**

```ts
import { Effect, Stream } from "effect"

const s1 = Stream.make(1, 2, 3)
const s2 = Stream.make("a", "b")

const product = Stream.cross(s1, s2)

// Effect.runPromise(Stream.runCollect(product)).then(console.log)
// {
//   _id: "Chunk",
//   values: [
//     [ 1, "a" ], [ 1, "b" ], [ 2, "a" ], [ 2, "b" ], [ 3, "a" ], [ 3, "b" ]
//   ]
// }
```

**Signature**

```ts
export declare const cross: {
  <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<[AL, AR], EL | ER, RL | RR>
  <AL, ER, RR, AR, EL, RL>(left: Stream<AL, ER, RR>, right: Stream<AR, EL, RL>): Stream<[AL, AR], EL | ER, RL | RR>
}
```


# crossLeft

Composes this stream with the specified stream to create a cartesian
product of elements, but keeps only elements from `left` stream. The `right`
stream would be run multiple times, for every element in the `left` stream.

See also `Stream.zipLeft` for the more common point-wise variant.

To import and use `crossLeft` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.crossLeft
```

**Signature**

```ts
export declare const crossLeft: {
  <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, EL | ER, RL | RR>
  <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>
}
```


# crossRight

Composes this stream with the specified stream to create a cartesian
product of elements, but keeps only elements from the `right` stream. The
`left` stream would be run multiple times, for every element in the `right`
stream.

See also `Stream.zipRight` for the more common point-wise variant.

To import and use `crossRight` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.crossRight
```

**Signature**

```ts
export declare const crossRight: {
  <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, EL | ER, RL | RR>
  <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>
}
```


# crossWith

Composes this stream with the specified stream to create a cartesian
product of elements with a specified function. The `right` stream would be
run multiple times, for every element in the `left` stream.

See also `Stream.zipWith` for the more common point-wise variant.

To import and use `crossWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.crossWith
```

**Signature**

```ts
export declare const crossWith: {
  <AR, ER, RR, AL, A>(
    right: Stream<AR, ER, RR>,
    f: (left: AL, right: AR) => A
  ): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>
  <AL, EL, RL, AR, ER, RR, A>(
    left: Stream<AL, EL, RL>,
    right: Stream<AR, ER, RR>,
    f: (left: AL, right: AR) => A
  ): Stream<A, EL | ER, RL | RR>
}
```


# debounce

Delays the emission of values by holding new values for a set duration. If
no new values arrive during that time the value is emitted, however if a
new value is received during the holding period the previous value is
discarded and the process is repeated with the new value.

This operator is useful if you have a stream of "bursty" events which
eventually settle down and you only need the final event of the burst. For
example, a search engine may only want to initiate a search after a user
has paused typing so as to not prematurely recommend results.

To import and use `debounce` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.debounce
```

**Example**

```ts
import { Effect, Stream } from "effect"

let last = Date.now()
const log = (message: string) =>
  Effect.sync(() => {
    const end = Date.now()
    console.log(`${message} after ${end - last}ms`)
    last = end
  })

const stream = Stream.make(1, 2, 3).pipe(
  Stream.concat(
    Stream.fromEffect(Effect.sleep("200 millis").pipe(Effect.as(4))) // Emit 4 after 200 ms
  ),
  Stream.concat(Stream.make(5, 6)), // Continue with more rapid values
  Stream.concat(
    Stream.fromEffect(Effect.sleep("150 millis").pipe(Effect.as(7))) // Emit 7 after 150 ms
  ),
  Stream.concat(Stream.make(8)),
  Stream.tap((n) => log(`Received ${n}`)),
  Stream.debounce("100 millis"), // Only emit values after a pause of at least 100 milliseconds,
  Stream.tap((n) => log(`> Emitted ${n}`))
)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Received 1 after 5ms
// Received 2 after 2ms
// Received 3 after 0ms
// > Emitted 3 after 104ms
// Received 4 after 99ms
// Received 5 after 1ms
// Received 6 after 0ms
// > Emitted 6 after 101ms
// Received 7 after 50ms
// Received 8 after 1ms
// > Emitted 8 after 101ms
// { _id: 'Chunk', values: [ 3, 6, 8 ] }
```

**Signature**

```ts
export declare const debounce: {
  (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>
}
```


# decodeText

Decode Uint8Array chunks into a stream of strings using the specified encoding.

To import and use `decodeText` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.decodeText
```

**Signature**

```ts
export declare const decodeText: {
  (encoding?: string | undefined): <E, R>(self: Stream<Uint8Array, E, R>) => Stream<string, E, R>
  <E, R>(self: Stream<Uint8Array, E, R>, encoding?: string | undefined): Stream<string, E, R>
}
```


# DefaultChunkSize

The default chunk size used by the various combinators and constructors of
`Stream`.

To import and use `DefaultChunkSize` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.DefaultChunkSize
```

**Signature**

```ts
export declare const DefaultChunkSize: number
```


# die

The stream that dies with the specified defect.

To import and use `die` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.die
```

**Signature**

```ts
export declare const die: (defect: unknown) => Stream<never>
```


# dieMessage

The stream that dies with an exception described by `message`.

To import and use `dieMessage` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.dieMessage
```

**Signature**

```ts
export declare const dieMessage: (message: string) => Stream<never>
```


# dieSync

The stream that dies with the specified lazily evaluated defect.

To import and use `dieSync` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.dieSync
```

**Signature**

```ts
export declare const dieSync: (evaluate: LazyArg<unknown>) => Stream<never>
```


# distributedWith

More powerful version of `Stream.broadcast`. Allows to provide a function
that determines what queues should receive which elements. The decide
function will receive the indices of the queues in the resulting list.

To import and use `distributedWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.distributedWith
```

**Signature**

```ts
export declare const distributedWith: {
  <N extends number, A>(options: {
    readonly size: N
    readonly maximumLag: number
    readonly decide: (a: A) => Effect.Effect<Predicate<number>>
  }): <E, R>(
    self: Stream<A, E, R>
  ) => Effect.Effect<TupleOf<N, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>>, never, Scope.Scope | R>
  <A, E, R, N extends number>(
    self: Stream<A, E, R>,
    options: {
      readonly size: N
      readonly maximumLag: number
      readonly decide: (a: A) => Effect.Effect<Predicate<number>>
    }
  ): Effect.Effect<TupleOf<N, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>>, never, Scope.Scope | R>
}
```


# distributedWithDynamic

More powerful version of `Stream.distributedWith`. This returns a function
that will produce new queues and corresponding indices. You can also
provide a function that will be executed after the final events are
enqueued in all queues. Shutdown of the queues is handled by the driver.
Downstream users can also shutdown queues manually. In this case the driver
will continue but no longer backpressure on them.

To import and use `distributedWithDynamic` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.distributedWithDynamic
```

**Signature**

```ts
export declare const distributedWithDynamic: {
  <A>(options: {
    readonly maximumLag: number
    readonly decide: (a: A) => Effect.Effect<Predicate<number>, never, never>
  }): <E, R>(
    self: Stream<A, E, R>
  ) => Effect.Effect<
    Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>], never, never>,
    never,
    Scope.Scope | R
  >
  <A, E, R>(
    self: Stream<A, E, R>,
    options: { readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>, never, never> }
  ): Effect.Effect<
    Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>], never, never>,
    never,
    Scope.Scope | R
  >
}
```


# Do

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

To import and use `Do` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.Do
```

**Example**

```ts
import { Chunk, Effect, pipe, Stream } from "effect"

const result = pipe(
  Stream.Do,
  Stream.bind("x", () => Stream.succeed(2)),
  Stream.bind("y", () => Stream.succeed(3)),
  Stream.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))
```

**Signature**

```ts
export declare const Do: Stream<{}, never, never>
```


# drain

Converts this stream to a stream that executes its effects but emits no
elements. Useful for sequencing effects using streams:

To import and use `drain` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.drain
```

**Example**

```ts
import { Effect, Stream } from "effect"

// We create a stream and immediately drain it.
const stream = Stream.range(1, 6).pipe(Stream.drain)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [] }
```

**Signature**

```ts
export declare const drain: <A, E, R>(self: Stream<A, E, R>) => Stream<never, E, R>
```


# drainFork

Drains the provided stream in the background for as long as this stream is
running. If this stream ends before `other`, `other` will be interrupted.
If `other` fails, this stream will fail with that error.

To import and use `drainFork` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.drainFork
```

**Signature**

```ts
export declare const drainFork: {
  <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A, E | E2, R | R2>
}
```


# drop

Drops the specified number of elements from this stream.

To import and use `drop` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.drop
```

**Signature**

```ts
export declare const drop: {
  (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>
}
```


# dropRight

Drops the last specified number of elements from this stream.

To import and use `dropRight` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.dropRight
```

**Signature**

```ts
export declare const dropRight: {
  (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>
}
```


# dropUntil

Drops all elements of the stream until the specified predicate evaluates to
`true`.

To import and use `dropUntil` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.dropUntil
```

**Signature**

```ts
export declare const dropUntil: {
  <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>
}
```


# dropUntilEffect

Drops all elements of the stream until the specified effectful predicate
evaluates to `true`.

To import and use `dropUntilEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.dropUntilEffect
```

**Signature**

```ts
export declare const dropUntilEffect: {
  <A, E2, R2>(
    predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E, R, E2, R2>(
    self: Stream<A, E, R>,
    predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>
  ): Stream<A, E | E2, R | R2>
}
```


# dropWhile

Drops all elements of the stream for as long as the specified predicate
evaluates to `true`.

To import and use `dropWhile` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.dropWhile
```

**Signature**

```ts
export declare const dropWhile: {
  <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>
}
```


# dropWhileEffect

Drops all elements of the stream for as long as the specified predicate
produces an effect that evalutates to `true`

To import and use `dropWhileEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.dropWhileEffect
```

**Signature**

```ts
export declare const dropWhileEffect: {
  <A, E2, R2>(
    predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E, R, E2, R2>(
    self: Stream<A, E, R>,
    predicate: (a: A) => Effect.Effect<boolean, E2, R2>
  ): Stream<A, E | E2, R | R2>
}
```


# either

Returns a stream whose failures and successes have been lifted into an
`Either`. The resulting stream cannot fail, because the failures have been
exposed as part of the `Either` success case.

To import and use `either` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.either
```

**Signature**

```ts
export declare const either: <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A, E>, never, R>
```


# empty

The empty stream.

To import and use `empty` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.empty
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.empty

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [] }
```

**Signature**

```ts
export declare const empty: Stream<never, never, never>
```


# encodeText

Encode a stream of strings into a stream of Uint8Array chunks using the specified encoding.

To import and use `encodeText` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.encodeText
```

**Signature**

```ts
export declare const encodeText: <E, R>(self: Stream<string, E, R>) => Stream<Uint8Array, E, R>
```


# ensuring

Executes the provided finalizer after this stream's finalizers run.

To import and use `ensuring` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.ensuring
```

**Example**

```ts
import { Console, Effect, Stream } from "effect"

const program = Stream.fromEffect(Console.log("Application Logic.")).pipe(
  Stream.concat(Stream.finalizer(Console.log("Finalizing the stream"))),
  Stream.ensuring(Console.log("Doing some other works after stream's finalization"))
)

// Effect.runPromise(Stream.runCollect(program)).then(console.log)
// Application Logic.
// Finalizing the stream
// Doing some other works after stream's finalization
// { _id: 'Chunk', values: [ undefined, undefined ] }
```

**Signature**

```ts
export declare const ensuring: {
  <X, R2>(finalizer: Effect.Effect<X, never, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>
  <A, E, R, X, R2>(self: Stream<A, E, R>, finalizer: Effect.Effect<X, never, R2>): Stream<A, E, R | R2>
}
```


# ensuringWith

Executes the provided finalizer after this stream's finalizers run.

To import and use `ensuringWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.ensuringWith
```

**Signature**

```ts
export declare const ensuringWith: {
  <E, R2>(
    finalizer: (exit: Exit.Exit<unknown, E>) => Effect.Effect<unknown, never, R2>
  ): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>
  <A, E, R, R2>(
    self: Stream<A, E, R>,
    finalizer: (exit: Exit.Exit<unknown, E>) => Effect.Effect<unknown, never, R2>
  ): Stream<A, E, R | R2>
}
```


# execute

Creates a stream that executes the specified effect but emits no elements.

To import and use `execute` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.execute
```

**Signature**

```ts
export declare const execute: <X, E, R>(effect: Effect.Effect<X, E, R>) => Stream<never, E, R>
```


# fail

Terminates with the specified error.

To import and use `fail` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fail
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.fail("Uh oh!")

Effect.runPromiseExit(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }
// }
```

**Signature**

```ts
export declare const fail: <E>(error: E) => Stream<never, E>
```


# failCause

The stream that always fails with the specified `Cause`.

To import and use `failCause` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.failCause
```

**Signature**

```ts
export declare const failCause: <E>(cause: Cause.Cause<E>) => Stream<never, E>
```


# failCauseSync

The stream that always fails with the specified lazily evaluated `Cause`.

To import and use `failCauseSync` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.failCauseSync
```

**Signature**

```ts
export declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Stream<never, E>
```


# failSync

Terminates with the specified lazily evaluated error.

To import and use `failSync` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.failSync
```

**Signature**

```ts
export declare const failSync: <E>(evaluate: LazyArg<E>) => Stream<never, E>
```


# filter

Filters the elements emitted by this stream using the provided function.

To import and use `filter` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.filter
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.range(1, 11).pipe(Stream.filter((n) => n % 2 === 0))

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 2, 4, 6, 8, 10 ] }
```

**Signature**

```ts
export declare const filter: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>
  <A, B extends A>(predicate: Predicate<B>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>
  <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>
}
```


# filterEffect

Effectfully filters the elements emitted by this stream.

To import and use `filterEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.filterEffect
```

**Signature**

```ts
export declare const filterEffect: {
  <A, E2, R2>(
    f: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>
}
```


# filterMap

Performs a filter and map in a single step.

To import and use `filterMap` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.filterMap
```

**Signature**

```ts
export declare const filterMap: {
  <A, B>(pf: (a: A) => Option.Option<B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>
  <A, E, R, B>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<B>): Stream<B, E, R>
}
```


# filterMapEffect

Performs an effectful filter and map in a single step.

To import and use `filterMapEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.filterMapEffect
```

**Signature**

```ts
export declare const filterMapEffect: {
  <A, A2, E2, R2>(
    pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>
  ): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>
  ): Stream<A2, E | E2, R | R2>
}
```


# filterMapWhile

Transforms all elements of the stream for as long as the specified partial
function is defined.

To import and use `filterMapWhile` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.filterMapWhile
```

**Signature**

```ts
export declare const filterMapWhile: {
  <A, A2>(pf: (a: A) => Option.Option<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>
  <A, E, R, A2>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<A2>): Stream<A2, E, R>
}
```


# filterMapWhileEffect

Effectfully transforms all elements of the stream for as long as the
specified partial function is defined.

To import and use `filterMapWhileEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.filterMapWhileEffect
```

**Signature**

```ts
export declare const filterMapWhileEffect: {
  <A, A2, E2, R2>(
    pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>
  ): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>
  ): Stream<A2, E | E2, R | R2>
}
```


# finalizer

Creates a one-element stream that never fails and executes the finalizer
when it ends.

To import and use `finalizer` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.finalizer
```

**Example**

```ts
import { Console, Effect, Stream } from "effect"

const application = Stream.fromEffect(Console.log("Application Logic."))

const deleteDir = (dir: string) => Console.log(`Deleting dir: ${dir}`)

const program = application.pipe(
  Stream.concat(
    Stream.finalizer(deleteDir("tmp").pipe(Effect.andThen(Console.log("Temporary directory was deleted."))))
  )
)

// Effect.runPromise(Stream.runCollect(program)).then(console.log)
// Application Logic.
// Deleting dir: tmp
// Temporary directory was deleted.
// { _id: 'Chunk', values: [ undefined, undefined ] }
```

**Signature**

```ts
export declare const finalizer: <R, X>(finalizer: Effect.Effect<X, never, R>) => Stream<void, never, R>
```


# find

Finds the first element emitted by this stream that satisfies the provided
predicate.

To import and use `find` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.find
```

**Signature**

```ts
export declare const find: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>
  <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>
  <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>
}
```


# findEffect

Finds the first element emitted by this stream that satisfies the provided
effectful predicate.

To import and use `findEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.findEffect
```

**Signature**

```ts
export declare const findEffect: {
  <A, E2, R2>(
    predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E, R, E2, R2>(
    self: Stream<A, E, R>,
    predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>
  ): Stream<A, E | E2, R | R2>
}
```


# flatMap

Returns a stream made of the concatenation in strict order of all the
streams produced by passing each element of this stream to `f0`

To import and use `flatMap` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.flatMap
```

**Signature**

```ts
export declare const flatMap: {
  <A, A2, E2, R2>(
    f: (a: A) => Stream<A2, E2, R2>,
    options?:
      | {
          readonly concurrency?: number | "unbounded" | undefined
          readonly bufferSize?: number | undefined
          readonly switch?: boolean | undefined
        }
      | undefined
  ): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    f: (a: A) => Stream<A2, E2, R2>,
    options?:
      | {
          readonly concurrency?: number | "unbounded" | undefined
          readonly bufferSize?: number | undefined
          readonly switch?: boolean | undefined
        }
      | undefined
  ): Stream<A2, E | E2, R | R2>
}
```


# flatten

Flattens this stream-of-streams into a stream made of the concatenation in
strict order of all the streams.

To import and use `flatten` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.flatten
```

**Signature**

```ts
export declare const flatten: {
  (
    options?:
      | { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined }
      | undefined
  ): <A, E2, R2, E, R>(self: Stream<Stream<A, E2, R2>, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E2, R2, E, R>(
    self: Stream<Stream<A, E2, R2>, E, R>,
    options?:
      | { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined }
      | undefined
  ): Stream<A, E2 | E, R2 | R>
}
```


# flattenChunks

Submerges the chunks carried by this stream into the stream's structure,
while still preserving them.

To import and use `flattenChunks` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.flattenChunks
```

**Signature**

```ts
export declare const flattenChunks: <A, E, R>(self: Stream<Chunk.Chunk<A>, E, R>) => Stream<A, E, R>
```


# flattenEffect

Flattens `Effect` values into the stream's structure, preserving all
information about the effect.

To import and use `flattenEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.flattenEffect
```

**Signature**

```ts
export declare const flattenEffect: {
  (
    options?:
      | { readonly concurrency?: number | "unbounded" | undefined; readonly unordered?: boolean | undefined }
      | undefined
  ): <A, E2, R2, E, R>(self: Stream<Effect.Effect<A, E2, R2>, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E2, R2, E, R>(
    self: Stream<Effect.Effect<A, E2, R2>, E, R>,
    options?:
      | { readonly concurrency?: number | "unbounded" | undefined; readonly unordered?: boolean | undefined }
      | undefined
  ): Stream<A, E2 | E, R2 | R>
}
```


# flattenExitOption

Unwraps `Exit` values that also signify end-of-stream by failing with `None`.

For `Exit` values that do not signal end-of-stream, prefer:

```ts
stream.mapZIO(ZIO.done(_))
```

To import and use `flattenExitOption` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.flattenExitOption
```

**Signature**

```ts
export declare const flattenExitOption: <A, E2, E, R>(
  self: Stream<Exit.Exit<A, Option.Option<E2>>, E, R>
) => Stream<A, E | E2, R>
```


# flattenIterables

Submerges the iterables carried by this stream into the stream's structure,
while still preserving them.

To import and use `flattenIterables` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.flattenIterables
```

**Signature**

```ts
export declare const flattenIterables: <A, E, R>(self: Stream<Iterable<A>, E, R>) => Stream<A, E, R>
```


# flattenTake

Unwraps `Exit` values and flatten chunks that also signify end-of-stream
by failing with `None`.

To import and use `flattenTake` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.flattenTake
```

**Signature**

```ts
export declare const flattenTake: <A, E2, E, R>(self: Stream<Take.Take<A, E2>, E, R>) => Stream<A, E | E2, R>
```


# forever

Repeats this stream forever.

To import and use `forever` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.forever
```

**Signature**

```ts
export declare const forever: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
```


# fromAsyncIterable

Creates a stream from an `AsyncIterable`.

To import and use `fromAsyncIterable` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromAsyncIterable
```

**Example**

```ts
import { Effect, Stream } from "effect"

const myAsyncIterable = async function* () {
  yield 1
  yield 2
}

const stream = Stream.fromAsyncIterable(
  myAsyncIterable(),
  (e) => new Error(String(e)) // Error Handling
)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2 ] }
```

**Signature**

```ts
export declare const fromAsyncIterable: <A, E>(iterable: AsyncIterable<A>, onError: (e: unknown) => E) => Stream<A, E>
```


# fromChannel

Creates a stream from a `Channel`.

To import and use `fromChannel` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromChannel
```

**Signature**

```ts
export declare const fromChannel: <A, E, R>(
  channel: Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown, R>
) => Stream<A, E, R>
```


# fromChunk

Creates a stream from a `Chunk` of values.

To import and use `fromChunk` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromChunk
```

**Example**

```ts
import { Chunk, Effect, Stream } from "effect"

// Creating a stream with values from a single Chunk
const stream = Stream.fromChunk(Chunk.make(1, 2, 3))

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3 ] }
```

**Signature**

```ts
export declare const fromChunk: <A>(chunk: Chunk.Chunk<A>) => Stream<A>
```


# fromChunkPubSub

Creates a stream from a subscription to a `PubSub`.

To import and use `fromChunkPubSub` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromChunkPubSub
```

**Signature**

```ts
export declare const fromChunkPubSub: {
  <A>(
    pubsub: PubSub.PubSub<Chunk.Chunk<A>>,
    options: { readonly scoped: true; readonly shutdown?: boolean | undefined }
  ): Effect.Effect<Stream<A>, never, Scope.Scope>
  <A>(
    pubsub: PubSub.PubSub<Chunk.Chunk<A>>,
    options?: { readonly scoped?: false | undefined; readonly shutdown?: boolean | undefined } | undefined
  ): Stream<A>
}
```


# fromChunkQueue

Creates a stream from a `Queue` of values.

To import and use `fromChunkQueue` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromChunkQueue
```

**Signature**

```ts
export declare const fromChunkQueue: <A>(
  queue: Queue.Dequeue<Chunk.Chunk<A>>,
  options?: { readonly shutdown?: boolean | undefined }
) => Stream<A>
```


# fromChunks

Creates a stream from an arbitrary number of chunks.

To import and use `fromChunks` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromChunks
```

**Example**

```ts
import { Chunk, Effect, Stream } from "effect"

// Creating a stream with values from multiple Chunks
const stream = Stream.fromChunks(Chunk.make(1, 2, 3), Chunk.make(4, 5, 6))

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6 ] }
```

**Signature**

```ts
export declare const fromChunks: <A>(...chunks: Array<Chunk.Chunk<A>>) => Stream<A>
```


# fromEffect

Either emits the success value of this effect or terminates the stream
with the failure value of this effect.

To import and use `fromEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromEffect
```

**Example**

```ts
import { Effect, Random, Stream } from "effect"

const stream = Stream.fromEffect(Random.nextInt)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Example Output: { _id: 'Chunk', values: [ 922694024 ] }
```

**Signature**

```ts
export declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, R>
```


# fromEffectOption

Creates a stream from an effect producing a value of type `A` or an empty
`Stream`.

To import and use `fromEffectOption` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromEffectOption
```

**Signature**

```ts
export declare const fromEffectOption: <A, E, R>(effect: Effect.Effect<A, Option.Option<E>, R>) => Stream<A, E, R>
```


# fromEventListener

Creates a `Stream` using addEventListener.

To import and use `fromEventListener` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromEventListener
```

**Signature**

```ts
export declare const fromEventListener: <A = unknown>(
  target: EventListener<A>,
  type: string,
  options?:
    | boolean
    | {
        readonly capture?: boolean
        readonly passive?: boolean
        readonly once?: boolean
        readonly bufferSize?: number | "unbounded" | undefined
      }
    | undefined
) => Stream<A>
```


# fromIterable

Creates a new `Stream` from an iterable collection of values.

To import and use `fromIterable` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromIterable
```

**Example**

```ts
import { Effect, Stream } from "effect"

const numbers = [1, 2, 3]

const stream = Stream.fromIterable(numbers)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3 ] }
```

**Signature**

```ts
export declare const fromIterable: <A>(iterable: Iterable<A>) => Stream<A>
```


# fromIterableEffect

Creates a stream from an effect producing a value of type `Iterable<A>`.

To import and use `fromIterableEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromIterableEffect
```

**Example**

```ts
import { Context, Effect, Stream } from "effect"

class Database extends Context.Tag("Database")<Database, { readonly getUsers: Effect.Effect<Array<string>> }>() {}

const getUsers = Database.pipe(Effect.andThen((_) => _.getUsers))

const stream = Stream.fromIterableEffect(getUsers)

// Effect.runPromise(
//   Stream.runCollect(stream.pipe(Stream.provideService(Database, { getUsers: Effect.succeed(["user1", "user2"]) })))
// ).then(console.log)
// { _id: 'Chunk', values: [ 'user1', 'user2' ] }
```

**Signature**

```ts
export declare const fromIterableEffect: <A, E, R>(effect: Effect.Effect<Iterable<A>, E, R>) => Stream<A, E, R>
```


# fromIteratorSucceed

Creates a stream from an iterator

To import and use `fromIteratorSucceed` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromIteratorSucceed
```

**Signature**

```ts
export declare const fromIteratorSucceed: <A>(iterator: IterableIterator<A>, maxChunkSize?: number) => Stream<A>
```


# fromPubSub

Creates a stream from a subscription to a `PubSub`.

To import and use `fromPubSub` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromPubSub
```

**Signature**

```ts
export declare const fromPubSub: {
  <A>(
    pubsub: PubSub.PubSub<A>,
    options: {
      readonly scoped: true
      readonly maxChunkSize?: number | undefined
      readonly shutdown?: boolean | undefined
    }
  ): Effect.Effect<Stream<A>, never, Scope.Scope>
  <A>(
    pubsub: PubSub.PubSub<A>,
    options?:
      | {
          readonly scoped?: false | undefined
          readonly maxChunkSize?: number | undefined
          readonly shutdown?: boolean | undefined
        }
      | undefined
  ): Stream<A>
}
```


# fromPull

Creates a stream from an effect that pulls elements from another stream.

See `Stream.toPull` for reference.

To import and use `fromPull` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromPull
```

**Signature**

```ts
export declare const fromPull: <R, R2, E, A>(
  effect: Effect.Effect<Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R2>, never, Scope.Scope | R>
) => Stream<A, E, R2 | Exclude<R, Scope.Scope>>
```


# fromQueue

Creates a stream from a queue of values

To import and use `fromQueue` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromQueue
```

**Signature**

```ts
export declare const fromQueue: <A>(
  queue: Queue.Dequeue<A>,
  options?: { readonly maxChunkSize?: number | undefined; readonly shutdown?: boolean | undefined }
) => Stream<A>
```


# fromReadableStream

Creates a stream from a `ReadableStream`.

See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.

To import and use `fromReadableStream` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromReadableStream
```

**Signature**

```ts
export declare const fromReadableStream: {
  <A, E>(options: {
    readonly evaluate: LazyArg<ReadableStream<A>>
    readonly onError: (error: unknown) => E
    readonly releaseLockOnEnd?: boolean | undefined
  }): Stream<A, E>
  <A, E>(evaluate: LazyArg<ReadableStream<A>>, onError: (error: unknown) => E): Stream<A, E>
}
```


# fromReadableStreamByob

Creates a stream from a `ReadableStreamBYOBReader`.

See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamBYOBReader.

To import and use `fromReadableStreamByob` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromReadableStreamByob
```

**Signature**

```ts
export declare const fromReadableStreamByob: {
  <E>(options: {
    readonly evaluate: LazyArg<ReadableStream<Uint8Array>>
    readonly onError: (error: unknown) => E
    readonly bufferSize?: number | undefined
    readonly releaseLockOnEnd?: boolean | undefined
  }): Stream<Uint8Array, E>
  <E>(
    evaluate: LazyArg<ReadableStream<Uint8Array>>,
    onError: (error: unknown) => E,
    allocSize?: number
  ): Stream<Uint8Array, E>
}
```


# fromSchedule

Creates a stream from a `Schedule` that does not require any further
input. The stream will emit an element for each value output from the
schedule, continuing for as long as the schedule continues.

To import and use `fromSchedule` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromSchedule
```

**Example**

```ts
import { Effect, Schedule, Stream } from "effect"

// Emits values every 1 second for a total of 5 emissions
const schedule = Schedule.spaced("1 second").pipe(Schedule.compose(Schedule.recurs(5)))

const stream = Stream.fromSchedule(schedule)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }
```

**Signature**

```ts
export declare const fromSchedule: <A, R>(schedule: Schedule.Schedule<A, unknown, R>) => Stream<A, never, R>
```


# fromTPubSub

Creates a stream from a subscription to a `TPubSub`.

To import and use `fromTPubSub` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromTPubSub
```

**Signature**

```ts
export declare const fromTPubSub: <A>(pubsub: TPubSub<A>) => Stream<A>
```


# fromTQueue

Creates a stream from a TQueue of values

To import and use `fromTQueue` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.fromTQueue
```

**Signature**

```ts
export declare const fromTQueue: <A>(queue: TDequeue<A>) => Stream<A>
```


# groupAdjacentBy

Creates a pipeline that groups on adjacent keys, calculated by the
specified function.

To import and use `groupAdjacentBy` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.groupAdjacentBy
```

**Signature**

```ts
export declare const groupAdjacentBy: {
  <A, K>(f: (a: A) => K): <E, R>(self: Stream<A, E, R>) => Stream<[K, Chunk.NonEmptyChunk<A>], E, R>
  <A, E, R, K>(self: Stream<A, E, R>, f: (a: A) => K): Stream<[K, Chunk.NonEmptyChunk<A>], E, R>
}
```


# groupBy

More powerful version of `Stream.groupByKey`.

To import and use `groupBy` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.groupBy
```

**Example**

```ts
import { Chunk, Effect, GroupBy, Stream } from "effect"

const groupByKeyResult = Stream.fromIterable([
  "Mary",
  "James",
  "Robert",
  "Patricia",
  "John",
  "Jennifer",
  "Rebecca",
  "Peter"
]).pipe(Stream.groupBy((name) => Effect.succeed([name.substring(0, 1), name])))

const stream = GroupBy.evaluate(groupByKeyResult, (key, stream) =>
  Stream.fromEffect(Stream.runCollect(stream).pipe(Effect.andThen((chunk) => [key, Chunk.size(chunk)] as const)))
)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [ [ 'M', 1 ], [ 'J', 3 ], [ 'R', 2 ], [ 'P', 2 ] ]
// }
```

**Signature**

```ts
export declare const groupBy: {
  <A, K, V, E2, R2>(
    f: (a: A) => Effect.Effect<readonly [K, V], E2, R2>,
    options?: { readonly bufferSize?: number | undefined } | undefined
  ): <E, R>(self: Stream<A, E, R>) => GroupBy.GroupBy<K, V, E2 | E, R2 | R>
  <A, E, R, K, V, E2, R2>(
    self: Stream<A, E, R>,
    f: (a: A) => Effect.Effect<readonly [K, V], E2, R2>,
    options?: { readonly bufferSize?: number | undefined } | undefined
  ): GroupBy.GroupBy<K, V, E | E2, R | R2>
}
```


# groupByKey

Partition a stream using a function and process each stream individually.
This returns a data structure that can be used to further filter down which
groups shall be processed.

After calling apply on the GroupBy object, the remaining groups will be
processed in parallel and the resulting streams merged in a
nondeterministic fashion.

Up to `buffer` elements may be buffered in any group stream before the
producer is backpressured. Take care to consume from all streams in order
to prevent deadlocks.

For example, to collect the first 2 words for every starting letter from a
stream of words:

```ts
import * as GroupBy from "./GroupBy"
import * as Stream from "./Stream"
import { pipe } from "./Function"

pipe(
  Stream.fromIterable(["hello", "world", "hi", "holla"]),
  Stream.groupByKey((word) => word[0]),
  GroupBy.evaluate((key, stream) =>
    pipe(
      stream,
      Stream.take(2),
      Stream.map((words) => [key, words] as const)
    )
  )
)
```

To import and use `groupByKey` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.groupByKey
```

**Signature**

```ts
export declare const groupByKey: {
  <A, K>(
    f: (a: A) => K,
    options?: { readonly bufferSize?: number | undefined }
  ): <E, R>(self: Stream<A, E, R>) => GroupBy.GroupBy<K, A, E, R>
  <A, E, R, K>(
    self: Stream<A, E, R>,
    f: (a: A) => K,
    options?: { readonly bufferSize?: number | undefined }
  ): GroupBy.GroupBy<K, A, E, R>
}
```


# grouped

Partitions the stream with specified `chunkSize`.

To import and use `grouped` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.grouped
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.range(0, 8).pipe(Stream.grouped(3))

// Effect.runPromise(Stream.runCollect(stream)).then((chunks) => console.log("%o", chunks))
// {
//   _id: 'Chunk',
//   values: [
//     { _id: 'Chunk', values: [ 0, 1, 2, [length]: 3 ] },
//     { _id: 'Chunk', values: [ 3, 4, 5, [length]: 3 ] },
//     { _id: 'Chunk', values: [ 6, 7, 8, [length]: 3 ] },
//     [length]: 3
//   ]
// }
```

**Signature**

```ts
export declare const grouped: {
  (chunkSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>
  <A, E, R>(self: Stream<A, E, R>, chunkSize: number): Stream<Chunk.Chunk<A>, E, R>
}
```


# groupedWithin

Partitions the stream with the specified `chunkSize` or until the specified
`duration` has passed, whichever is satisfied first.

To import and use `groupedWithin` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.groupedWithin
```

**Example**

```ts
import { Chunk, Effect, Schedule, Stream } from "effect"

const stream = Stream.range(0, 9).pipe(
  Stream.repeat(Schedule.spaced("1 second")),
  Stream.groupedWithin(18, "1.5 seconds"),
  Stream.take(3)
)

// Effect.runPromise(Stream.runCollect(stream)).then((chunks) => console.log(Chunk.toArray(chunks)))
// [
//   {
//     _id: 'Chunk',
//     values: [
//       0, 1, 2, 3, 4, 5, 6,
//       7, 8, 9, 0, 1, 2, 3,
//       4, 5, 6, 7
//     ]
//   },
//   {
//     _id: 'Chunk',
//     values: [
//       8, 9, 0, 1, 2,
//       3, 4, 5, 6, 7,
//       8, 9
//     ]
//   },
//   {
//     _id: 'Chunk',
//     values: [
//       0, 1, 2, 3, 4, 5, 6,
//       7, 8, 9, 0, 1, 2, 3,
//       4, 5, 6, 7
//     ]
//   }
// ]
```

**Signature**

```ts
export declare const groupedWithin: {
  (
    chunkSize: number,
    duration: Duration.DurationInput
  ): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>
  <A, E, R>(self: Stream<A, E, R>, chunkSize: number, duration: Duration.DurationInput): Stream<Chunk.Chunk<A>, E, R>
}
```


# haltAfter

Specialized version of haltWhen which halts the evaluation of this stream
after the given duration.

An element in the process of being pulled will not be interrupted when the
given duration completes. See `interruptAfter` for this behavior.

To import and use `haltAfter` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.haltAfter
```

**Signature**

```ts
export declare const haltAfter: {
  (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>
}
```


# haltWhen

Halts the evaluation of this stream when the provided effect completes. The
given effect will be forked as part of the returned stream, and its success
will be discarded.

An element in the process of being pulled will not be interrupted when the
effect completes. See `interruptWhen` for this behavior.

If the effect completes with a failure, the stream will emit that failure.

To import and use `haltWhen` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.haltWhen
```

**Signature**

```ts
export declare const haltWhen: {
  <X, E2, R2>(effect: Effect.Effect<X, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E, R, X, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>
}
```


# haltWhenDeferred

Halts the evaluation of this stream when the provided promise resolves.

If the promise completes with a failure, the stream will emit that failure.

To import and use `haltWhenDeferred` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.haltWhenDeferred
```

**Signature**

```ts
export declare const haltWhenDeferred: {
  <X, E2>(deferred: Deferred.Deferred<X, E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>
  <A, E, R, X, E2>(self: Stream<A, E, R>, deferred: Deferred.Deferred<X, E2>): Stream<A, E | E2, R>
}
```


# identity

The identity pipeline, which does not modify streams in any way.

To import and use `identity` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.identity
```

**Signature**

```ts
export declare const identity: <A, E = never, R = never>() => Stream<A, E, R>
```


# interleave

Interleaves this stream and the specified stream deterministically by
alternating pulling values from this stream and the specified stream. When
one stream is exhausted all remaining values in the other stream will be
pulled.

To import and use `interleave` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.interleave
```

**Example**

```ts
import { Effect, Stream } from "effect"

const s1 = Stream.make(1, 2, 3)
const s2 = Stream.make(4, 5, 6)

const stream = Stream.interleave(s1, s2)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 4, 2, 5, 3, 6 ] }
```

**Signature**

```ts
export declare const interleave: {
  <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>
}
```


# interleaveWith

Combines this stream and the specified stream deterministically using the
stream of boolean values `pull` to control which stream to pull from next.
A value of `true` indicates to pull from this stream and a value of `false`
indicates to pull from the specified stream. Only consumes as many elements
as requested by the `pull` stream. If either this stream or the specified
stream are exhausted further requests for values from that stream will be
ignored.

To import and use `interleaveWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.interleaveWith
```

**Example**

```ts
import { Effect, Stream } from "effect"

const s1 = Stream.make(1, 3, 5, 7, 9)
const s2 = Stream.make(2, 4, 6, 8, 10)

const booleanStream = Stream.make(true, false, false).pipe(Stream.forever)

const stream = Stream.interleaveWith(s1, s2, booleanStream)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [
//     1, 2,  4, 3, 6,
//     8, 5, 10, 7, 9
//   ]
// }
```

**Signature**

```ts
export declare const interleaveWith: {
  <A2, E2, R2, E3, R3>(
    that: Stream<A2, E2, R2>,
    decider: Stream<boolean, E3, R3>
  ): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E3 | E, R2 | R3 | R>
  <A, E, R, A2, E2, R2, E3, R3>(
    self: Stream<A, E, R>,
    that: Stream<A2, E2, R2>,
    decider: Stream<boolean, E3, R3>
  ): Stream<A | A2, E | E2 | E3, R | R2 | R3>
}
```


# interruptAfter

Specialized version of `Stream.interruptWhen` which interrupts the
evaluation of this stream after the given `Duration`.

To import and use `interruptAfter` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.interruptAfter
```

**Signature**

```ts
export declare const interruptAfter: {
  (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>
}
```


# interruptWhen

Interrupts the evaluation of this stream when the provided effect
completes. The given effect will be forked as part of this stream, and its
success will be discarded. This combinator will also interrupt any
in-progress element being pulled from upstream.

If the effect completes with a failure before the stream completes, the
returned stream will emit that failure.

To import and use `interruptWhen` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.interruptWhen
```

**Signature**

```ts
export declare const interruptWhen: {
  <X, E2, R2>(effect: Effect.Effect<X, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E, R, X, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>
}
```


# interruptWhenDeferred

Interrupts the evaluation of this stream when the provided promise
resolves. This combinator will also interrupt any in-progress element being
pulled from upstream.

If the promise completes with a failure, the stream will emit that failure.

To import and use `interruptWhenDeferred` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.interruptWhenDeferred
```

**Signature**

```ts
export declare const interruptWhenDeferred: {
  <X, E2>(deferred: Deferred.Deferred<X, E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>
  <A, E, R, X, E2>(self: Stream<A, E, R>, deferred: Deferred.Deferred<X, E2>): Stream<A, E | E2, R>
}
```


# intersperse

Intersperse stream with provided `element`.

To import and use `intersperse` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.intersperse
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3, 4, 5).pipe(Stream.intersperse(0))

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [
//     1, 0, 2, 0, 3,
//     0, 4, 0, 5
//   ]
// }
```

**Signature**

```ts
export declare const intersperse: {
  <A2>(element: A2): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>
  <A, E, R, A2>(self: Stream<A, E, R>, element: A2): Stream<A | A2, E, R>
}
```


# intersperseAffixes

Intersperse the specified element, also adding a prefix and a suffix.

To import and use `intersperseAffixes` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.intersperseAffixes
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3, 4, 5).pipe(
  Stream.intersperseAffixes({
    start: "[",
    middle: "-",
    end: "]"
  })
)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [
//     '[', 1,   '-', 2,   '-',
//     3,   '-', 4,   '-', 5,
//     ']'
//   ]
// }
```

**Signature**

```ts
export declare const intersperseAffixes: {
  <A2, A3, A4>(options: {
    readonly start: A2
    readonly middle: A3
    readonly end: A4
  }): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A3 | A4 | A, E, R>
  <A, E, R, A2, A3, A4>(
    self: Stream<A, E, R>,
    options: { readonly start: A2; readonly middle: A3; readonly end: A4 }
  ): Stream<A | A2 | A3 | A4, E, R>
}
```


# iterate

The infinite stream of iterative function application: a, f(a), f(f(a)),
f(f(f(a))), ...

To import and use `iterate` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.iterate
```

**Example**

```ts
import { Effect, Stream } from "effect"

// An infinite Stream of numbers starting from 1 and incrementing
const stream = Stream.iterate(1, (n) => n + 1)

// Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(10)))).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ] }
```

**Signature**

```ts
export declare const iterate: <A>(value: A, next: (value: A) => A) => Stream<A>
```


# let

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

To import and use `let` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.let
```

**Example**

```ts
import { Chunk, Effect, pipe, Stream } from "effect"

const result = pipe(
  Stream.Do,
  Stream.bind("x", () => Stream.succeed(2)),
  Stream.bind("y", () => Stream.succeed(3)),
  Stream.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))
```


# make

Creates a stream from an sequence of values.

To import and use `make` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.make
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3 ] }
```

**Signature**

```ts
export declare const make: <As extends Array<any>>(...as: As) => Stream<As[number]>
```


# map

Transforms the elements of this stream using the supplied function.

To import and use `map` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.map
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3).pipe(Stream.map((n) => n + 1))

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 2, 3, 4 ] }
```

**Signature**

```ts
export declare const map: {
  <A, B>(f: (a: A) => B): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>
  <A, E, R, B>(self: Stream<A, E, R>, f: (a: A) => B): Stream<B, E, R>
}
```


# mapAccum

Statefully maps over the elements of this stream to produce new elements.

To import and use `mapAccum` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mapAccum
```

**Example**

```ts
import { Effect, Stream } from "effect"

const runningTotal = (stream: Stream.Stream<number>): Stream.Stream<number> =>
  stream.pipe(Stream.mapAccum(0, (s, a) => [s + a, s + a]))

// input:  0, 1, 2, 3, 4, 5, 6
// Effect.runPromise(Stream.runCollect(runningTotal(Stream.range(0, 6)))).then(
//   console.log
// )
// { _id: "Chunk", values: [ 0, 1, 3, 6, 10, 15, 21 ] }
```

**Signature**

```ts
export declare const mapAccum: {
  <S, A, A2>(s: S, f: (s: S, a: A) => readonly [S, A2]): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>
  <A, E, R, S, A2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => readonly [S, A2]): Stream<A2, E, R>
}
```


# mapAccumEffect

Statefully and effectfully maps over the elements of this stream to produce
new elements.

To import and use `mapAccumEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mapAccumEffect
```

**Signature**

```ts
export declare const mapAccumEffect: {
  <S, A, A2, E2, R2>(
    s: S,
    f: (s: S, a: A) => Effect.Effect<readonly [S, A2], E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>
  <A, E, R, S, A2, E2, R2>(
    self: Stream<A, E, R>,
    s: S,
    f: (s: S, a: A) => Effect.Effect<readonly [S, A2], E2, R2>
  ): Stream<A2, E | E2, R | R2>
}
```


# mapBoth

Returns a stream whose failure and success channels have been mapped by the
specified `onFailure` and `onSuccess` functions.

To import and use `mapBoth` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mapBoth
```

**Signature**

```ts
export declare const mapBoth: {
  <E, E2, A, A2>(options: {
    readonly onFailure: (e: E) => E2
    readonly onSuccess: (a: A) => A2
  }): <R>(self: Stream<A, E, R>) => Stream<A2, E2, R>
  <A, E, R, E2, A2>(
    self: Stream<A, E, R>,
    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }
  ): Stream<A2, E2, R>
}
```


# mapChunks

Transforms the chunks emitted by this stream.

To import and use `mapChunks` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mapChunks
```

**Signature**

```ts
export declare const mapChunks: {
  <A, B>(f: (chunk: Chunk.Chunk<A>) => Chunk.Chunk<B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>
  <A, E, R, B>(self: Stream<A, E, R>, f: (chunk: Chunk.Chunk<A>) => Chunk.Chunk<B>): Stream<B, E, R>
}
```


# mapChunksEffect

Effectfully transforms the chunks emitted by this stream.

To import and use `mapChunksEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mapChunksEffect
```

**Signature**

```ts
export declare const mapChunksEffect: {
  <A, B, E2, R2>(
    f: (chunk: Chunk.Chunk<A>) => Effect.Effect<Chunk.Chunk<B>, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R>
  <A, E, R, B, E2, R2>(
    self: Stream<A, E, R>,
    f: (chunk: Chunk.Chunk<A>) => Effect.Effect<Chunk.Chunk<B>, E2, R2>
  ): Stream<B, E | E2, R | R2>
}
```


# mapConcat

Maps each element to an iterable, and flattens the iterables into the
output of this stream.

To import and use `mapConcat` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mapConcat
```

**Example**

```ts
import { Effect, Stream } from "effect"

const numbers = Stream.make("1-2-3", "4-5", "6").pipe(
  Stream.mapConcat((s) => s.split("-")),
  Stream.map((s) => parseInt(s))
)

// Effect.runPromise(Stream.runCollect(numbers)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6 ] }
```

**Signature**

```ts
export declare const mapConcat: {
  <A, A2>(f: (a: A) => Iterable<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>
  <A, E, R, A2>(self: Stream<A, E, R>, f: (a: A) => Iterable<A2>): Stream<A2, E, R>
}
```


# mapConcatChunk

Maps each element to a chunk, and flattens the chunks into the output of
this stream.

To import and use `mapConcatChunk` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mapConcatChunk
```

**Signature**

```ts
export declare const mapConcatChunk: {
  <A, A2>(f: (a: A) => Chunk.Chunk<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>
  <A, E, R, A2>(self: Stream<A, E, R>, f: (a: A) => Chunk.Chunk<A2>): Stream<A2, E, R>
}
```


# mapConcatChunkEffect

Effectfully maps each element to a chunk, and flattens the chunks into the
output of this stream.

To import and use `mapConcatChunkEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mapConcatChunkEffect
```

**Signature**

```ts
export declare const mapConcatChunkEffect: {
  <A, A2, E2, R2>(
    f: (a: A) => Effect.Effect<Chunk.Chunk<A2>, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    f: (a: A) => Effect.Effect<Chunk.Chunk<A2>, E2, R2>
  ): Stream<A2, E | E2, R | R2>
}
```


# mapConcatEffect

Effectfully maps each element to an iterable, and flattens the iterables
into the output of this stream.

To import and use `mapConcatEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mapConcatEffect
```

**Signature**

```ts
export declare const mapConcatEffect: {
  <A, A2, E2, R2>(
    f: (a: A) => Effect.Effect<Iterable<A2>, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    f: (a: A) => Effect.Effect<Iterable<A2>, E2, R2>
  ): Stream<A2, E | E2, R | R2>
}
```


# mapEffect

Maps over elements of the stream with the specified effectful function.

To import and use `mapEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mapEffect
```

**Example**

```ts
import { Effect, Random, Stream } from "effect"

const stream = Stream.make(10, 20, 30).pipe(Stream.mapEffect((n) => Random.nextIntBetween(0, n)))

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Example Output: { _id: 'Chunk', values: [ 7, 19, 8 ] }
```

**Signature**

```ts
export declare const mapEffect: {
  <A, A2, E2, R2>(
    f: (a: A) => Effect.Effect<A2, E2, R2>,
    options?:
      | { readonly concurrency?: number | "unbounded" | undefined; readonly unordered?: boolean | undefined }
      | undefined
  ): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>
  <A, A2, E2, R2, K>(
    f: (a: A) => Effect.Effect<A2, E2, R2>,
    options: { readonly key: (a: A) => K; readonly bufferSize?: number | undefined }
  ): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    f: (a: A) => Effect.Effect<A2, E2, R2>,
    options?:
      | { readonly concurrency?: number | "unbounded" | undefined; readonly unordered?: boolean | undefined }
      | undefined
  ): Stream<A2, E | E2, R | R2>
  <A, E, R, A2, E2, R2, K>(
    self: Stream<A, E, R>,
    f: (a: A) => Effect.Effect<A2, E2, R2>,
    options: { readonly key: (a: A) => K; readonly bufferSize?: number | undefined }
  ): Stream<A2, E | E2, R | R2>
}
```


# mapError

Transforms the errors emitted by this stream using `f`.

To import and use `mapError` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mapError
```

**Signature**

```ts
export declare const mapError: {
  <E, E2>(f: (error: E) => E2): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>
  <A, E, R, E2>(self: Stream<A, E, R>, f: (error: E) => E2): Stream<A, E2, R>
}
```


# mapErrorCause

Transforms the full causes of failures emitted by this stream.

To import and use `mapErrorCause` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mapErrorCause
```

**Signature**

```ts
export declare const mapErrorCause: {
  <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>
  <A, E, R, E2>(self: Stream<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Stream<A, E2, R>
}
```


# mapInputContext

Transforms the context being provided to the stream with the specified
function.

To import and use `mapInputContext` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mapInputContext
```

**Signature**

```ts
export declare const mapInputContext: {
  <R0, R>(f: (env: Context.Context<R0>) => Context.Context<R>): <A, E>(self: Stream<A, E, R>) => Stream<A, E, R0>
  <A, E, R0, R>(self: Stream<A, E, R>, f: (env: Context.Context<R0>) => Context.Context<R>): Stream<A, E, R0>
}
```


# merge

Merges this stream and the specified stream together.

New produced stream will terminate when both specified stream terminate if
no termination strategy is specified.

To import and use `merge` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.merge
```

**Example**

```ts
import { Effect, Schedule, Stream } from "effect"

const s1 = Stream.make(1, 2, 3).pipe(Stream.schedule(Schedule.spaced("100 millis")))
const s2 = Stream.make(4, 5, 6).pipe(Stream.schedule(Schedule.spaced("200 millis")))

const stream = Stream.merge(s1, s2)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 4, 2, 3, 5, 6 ] }
```

**Signature**

```ts
export declare const merge: {
  <A2, E2, R2>(
    that: Stream<A2, E2, R2>,
    options?: { readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined } | undefined
  ): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    that: Stream<A2, E2, R2>,
    options?: { readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined } | undefined
  ): Stream<A | A2, E | E2, R | R2>
}
```


# mergeAll

Merges a variable list of streams in a non-deterministic fashion. Up to `n`
streams may be consumed in parallel and up to `outputBuffer` chunks may be
buffered by this operator.

To import and use `mergeAll` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mergeAll
```

**Signature**

```ts
export declare const mergeAll: {
  (options: {
    readonly concurrency: number | "unbounded"
    readonly bufferSize?: number | undefined
  }): <A, E, R>(streams: Iterable<Stream<A, E, R>>) => Stream<A, E, R>
  <A, E, R>(
    streams: Iterable<Stream<A, E, R>>,
    options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number | undefined }
  ): Stream<A, E, R>
}
```


# mergeEither

Merges this stream and the specified stream together to produce a stream of
eithers.

To import and use `mergeEither` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mergeEither
```

**Signature**

```ts
export declare const mergeEither: {
  <A2, E2, R2>(
    that: Stream<A2, E2, R2>
  ): <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A2, A>, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<Either.Either<A2, A>, E | E2, R | R2>
}
```


# mergeLeft

Merges this stream and the specified stream together, discarding the values
from the right stream.

To import and use `mergeLeft` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mergeLeft
```

**Signature**

```ts
export declare const mergeLeft: {
  <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, ER | EL, RR | RL>
  <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>
}
```


# mergeRight

Merges this stream and the specified stream together, discarding the values
from the left stream.

To import and use `mergeRight` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mergeRight
```

**Signature**

```ts
export declare const mergeRight: {
  <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, ER | EL, RR | RL>
  <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>
}
```


# mergeWith

Merges this stream and the specified stream together to a common element
type with the specified mapping functions.

New produced stream will terminate when both specified stream terminate if
no termination strategy is specified.

To import and use `mergeWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mergeWith
```

**Example**

```ts
import { Effect, Schedule, Stream } from "effect"

const s1 = Stream.make("1", "2", "3").pipe(Stream.schedule(Schedule.spaced("100 millis")))
const s2 = Stream.make(4.1, 5.3, 6.2).pipe(Stream.schedule(Schedule.spaced("200 millis")))

const stream = Stream.mergeWith(s1, s2, {
  onSelf: (s) => parseInt(s),
  onOther: (n) => Math.floor(n)
})

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 4, 2, 3, 5, 6 ] }
```

**Signature**

```ts
export declare const mergeWith: {
  <A2, E2, R2, A, A3, A4>(
    other: Stream<A2, E2, R2>,
    options: {
      readonly onSelf: (a: A) => A3
      readonly onOther: (a2: A2) => A4
      readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined
    }
  ): <E, R>(self: Stream<A, E, R>) => Stream<A3 | A4, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2, A3, A4>(
    self: Stream<A, E, R>,
    other: Stream<A2, E2, R2>,
    options: {
      readonly onSelf: (a: A) => A3
      readonly onOther: (a2: A2) => A4
      readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined
    }
  ): Stream<A3 | A4, E | E2, R | R2>
}
```


# mergeWithTag

Merges a struct of streams into a single stream of tagged values.

To import and use `mergeWithTag` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mergeWithTag
```

**Example**

```ts
import { Stream } from "effect"
// Stream.Stream<{ _tag: "a"; value: number; } | { _tag: "b"; value: string; }>
const res = Stream.mergeWithTag(
  {
    a: Stream.make(0),
    b: Stream.make("")
  },
  { concurrency: "unbounded" }
)
```

**Signature**

```ts
export declare const mergeWithTag: {
  <S extends { [k in string]: Stream<any, any, any> }>(
    streams: S,
    options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number | undefined }
  ): Stream<
    { [K in keyof S]: { _tag: K; value: Stream.Success<S[K]> } }[keyof S],
    Stream.Error<S[keyof S]>,
    Stream.Context<S[keyof S]>
  >
  (options: {
    readonly concurrency: number | "unbounded"
    readonly bufferSize?: number | undefined
  }): <S extends { [k in string]: Stream<any, any, any> }>(
    streams: S
  ) => Stream<
    { [K in keyof S]: { _tag: K; value: Stream.Success<S[K]> } }[keyof S],
    Stream.Error<S[keyof S]>,
    Stream.Context<S[keyof S]>
  >
}
```


# mkString

Returns a combined string resulting from concatenating each of the values
from the stream.

To import and use `mkString` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.mkString
```

**Signature**

```ts
export declare const mkString: <E, R>(self: Stream<string, E, R>) => Effect.Effect<string, E, R>
```


# never

The stream that never produces any value or fails with any error.

To import and use `never` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.never
```

**Signature**

```ts
export declare const never: Stream<never, never, never>
```


# onDone

Runs the specified effect if this stream ends.

To import and use `onDone` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.onDone
```

**Signature**

```ts
export declare const onDone: {
  <X, R2>(cleanup: () => Effect.Effect<X, never, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>
  <A, E, R, X, R2>(self: Stream<A, E, R>, cleanup: () => Effect.Effect<X, never, R2>): Stream<A, E, R | R2>
}
```


# onEnd

Adds an effect to be executed at the end of the stream.

To import and use `onEnd` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.onEnd
```

**Example**

```ts
import { Console, Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3).pipe(
  Stream.map((n) => n * 2),
  Stream.tap((n) => Console.log(`after mapping: ${n}`)),
  Stream.onEnd(Console.log("Stream ended"))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// after mapping: 2
// after mapping: 4
// after mapping: 6
// Stream ended
// { _id: 'Chunk', values: [ 2, 4, 6 ] }
```

**Signature**

```ts
export declare const onEnd: {
  <_, E2, R2>(effect: Effect.Effect<_, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E, R, _, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<_, E2, R2>): Stream<A, E | E2, R | R2>
}
```


# onError

Runs the specified effect if this stream fails, providing the error to the
effect if it exists.

Note: Unlike `Effect.onError` there is no guarantee that the provided
effect will not be interrupted.

To import and use `onError` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.onError
```

**Signature**

```ts
export declare const onError: {
  <E, X, R2>(
    cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>
  ): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>
  <A, E, R, X, R2>(
    self: Stream<A, E, R>,
    cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>
  ): Stream<A, E, R | R2>
}
```


# onStart

Adds an effect to be executed at the start of the stream.

To import and use `onStart` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.onStart
```

**Example**

```ts
import { Console, Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3).pipe(
  Stream.onStart(Console.log("Stream started")),
  Stream.map((n) => n * 2),
  Stream.tap((n) => Console.log(`after mapping: ${n}`))
)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Stream started
// after mapping: 2
// after mapping: 4
// after mapping: 6
// { _id: 'Chunk', values: [ 2, 4, 6 ] }
```

**Signature**

```ts
export declare const onStart: {
  <_, E2, R2>(effect: Effect.Effect<_, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E, R, _, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<_, E2, R2>): Stream<A, E | E2, R | R2>
}
```


# orDie

Translates any failure into a stream termination, making the stream
infallible and all failures unchecked.

To import and use `orDie` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.orDie
```

**Signature**

```ts
export declare const orDie: <A, E, R>(self: Stream<A, E, R>) => Stream<A, never, R>
```


# orDieWith

Keeps none of the errors, and terminates the stream with them, using the
specified function to convert the `E` into a defect.

To import and use `orDieWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.orDieWith
```

**Signature**

```ts
export declare const orDieWith: {
  <E>(f: (e: E) => unknown): <A, R>(self: Stream<A, E, R>) => Stream<A, never, R>
  <A, E, R>(self: Stream<A, E, R>, f: (e: E) => unknown): Stream<A, never, R>
}
```


# orElse

Switches to the provided stream in case this one fails with a typed error.

See also `Stream.catchAll`.

To import and use `orElse` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.orElse
```

**Signature**

```ts
export declare const orElse: {
  <A2, E2, R2>(that: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: LazyArg<Stream<A2, E2, R2>>): Stream<A | A2, E2, R | R2>
}
```


# orElseEither

Switches to the provided stream in case this one fails with a typed error.

See also `Stream.catchAll`.

To import and use `orElseEither` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.orElseEither
```

**Signature**

```ts
export declare const orElseEither: {
  <A2, E2, R2>(
    that: LazyArg<Stream<A2, E2, R2>>
  ): <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A2, A>, E2, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    that: LazyArg<Stream<A2, E2, R2>>
  ): Stream<Either.Either<A2, A>, E2, R | R2>
}
```


# orElseFail

Fails with given error in case this one fails with a typed error.

See also `Stream.catchAll`.

To import and use `orElseFail` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.orElseFail
```

**Signature**

```ts
export declare const orElseFail: {
  <E2>(error: LazyArg<E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2, R>
  <A, E, R, E2>(self: Stream<A, E, R>, error: LazyArg<E2>): Stream<A, E2, R>
}
```


# orElseIfEmpty

Produces the specified element if this stream is empty.

To import and use `orElseIfEmpty` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.orElseIfEmpty
```

**Signature**

```ts
export declare const orElseIfEmpty: {
  <A2>(element: LazyArg<A2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>
  <A, E, R, A2>(self: Stream<A, E, R>, element: LazyArg<A2>): Stream<A | A2, E, R>
}
```


# orElseIfEmptyChunk

Produces the specified chunk if this stream is empty.

To import and use `orElseIfEmptyChunk` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.orElseIfEmptyChunk
```

**Signature**

```ts
export declare const orElseIfEmptyChunk: {
  <A2>(chunk: LazyArg<Chunk.Chunk<A2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>
  <A, E, R, A2>(self: Stream<A, E, R>, chunk: LazyArg<Chunk.Chunk<A2>>): Stream<A | A2, E, R>
}
```


# orElseIfEmptyStream

Switches to the provided stream in case this one is empty.

To import and use `orElseIfEmptyStream` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.orElseIfEmptyStream
```

**Signature**

```ts
export declare const orElseIfEmptyStream: {
  <A2, E2, R2>(stream: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, stream: LazyArg<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>
}
```


# orElseSucceed

Succeeds with the specified value if this one fails with a typed error.

To import and use `orElseSucceed` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.orElseSucceed
```

**Signature**

```ts
export declare const orElseSucceed: {
  <A2>(value: LazyArg<A2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, never, R>
  <A, E, R, A2>(self: Stream<A, E, R>, value: LazyArg<A2>): Stream<A | A2, never, R>
}
```


# paginate

Like `Stream.unfold`, but allows the emission of values to end one step further
than the unfolding of the state. This is useful for embedding paginated
APIs, hence the name.

To import and use `paginate` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.paginate
```

**Example**

```ts
import { Effect, Option, Stream } from "effect"

const stream = Stream.paginate(0, (n) => [n, n < 3 ? Option.some(n + 1) : Option.none()])

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3 ] }
```

**Signature**

```ts
export declare const paginate: <S, A>(s: S, f: (s: S) => readonly [A, Option.Option<S>]) => Stream<A>
```


# paginateChunk

Like `Stream.unfoldChunk`, but allows the emission of values to end one step
further than the unfolding of the state. This is useful for embedding
paginated APIs, hence the name.

To import and use `paginateChunk` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.paginateChunk
```

**Signature**

```ts
export declare const paginateChunk: <S, A>(s: S, f: (s: S) => readonly [Chunk.Chunk<A>, Option.Option<S>]) => Stream<A>
```


# paginateChunkEffect

Like `Stream.unfoldChunkEffect`, but allows the emission of values to end one step
further than the unfolding of the state. This is useful for embedding
paginated APIs, hence the name.

To import and use `paginateChunkEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.paginateChunkEffect
```

**Signature**

```ts
export declare const paginateChunkEffect: <S, A, E, R>(
  s: S,
  f: (s: S) => Effect.Effect<readonly [Chunk.Chunk<A>, Option.Option<S>], E, R>
) => Stream<A, E, R>
```


# paginateEffect

Like `Stream.unfoldEffect` but allows the emission of values to end one step
further than the unfolding of the state. This is useful for embedding
paginated APIs, hence the name.

To import and use `paginateEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.paginateEffect
```

**Signature**

```ts
export declare const paginateEffect: <S, A, E, R>(
  s: S,
  f: (s: S) => Effect.Effect<readonly [A, Option.Option<S>], E, R>
) => Stream<A, E, R>
```


# partition

Splits a stream into two substreams based on a predicate.

**Details**

The `Stream.partition` function splits a stream into two parts: one for
elements that satisfy the predicate (evaluated to `true`) and another for
those that do not (evaluated to `false`).

The faster stream may advance up to `bufferSize` elements ahead of the slower
one.

To import and use `partition` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.partition
```

**Example**

```ts
// Title: Partitioning a Stream into Even and Odd Numbers
import { Effect, Stream } from "effect"

const partition = Stream.range(1, 9).pipe(Stream.partition((n) => n % 2 === 0, { bufferSize: 5 }))

const program = Effect.scoped(
  Effect.gen(function* () {
    const [odds, evens] = yield* partition
    console.log(yield* Stream.runCollect(odds))
    console.log(yield* Stream.runCollect(evens))
  })
)

// Effect.runPromise(program)
// { _id: 'Chunk', values: [ 1, 3, 5, 7, 9 ] }
// { _id: 'Chunk', values: [ 2, 4, 6, 8 ] }
```

**Signature**

```ts
export declare const partition: {
  <C extends A, B extends A, A = C>(
    refinement: Refinement<NoInfer<A>, B>,
    options?: { bufferSize?: number | undefined } | undefined
  ): <E, R>(
    self: Stream<C, E, R>
  ) => Effect.Effect<[excluded: Stream<Exclude<C, B>, E, never>, satisfying: Stream<B, E, never>], E, R | Scope.Scope>
  <A>(
    predicate: Predicate<A>,
    options?: { bufferSize?: number | undefined } | undefined
  ): <E, R>(
    self: Stream<A, E, R>
  ) => Effect.Effect<[excluded: Stream<A, E, never>, satisfying: Stream<A, E, never>], E, Scope.Scope | R>
  <C extends A, E, R, B extends A, A = C>(
    self: Stream<C, E, R>,
    refinement: Refinement<A, B>,
    options?: { bufferSize?: number | undefined } | undefined
  ): Effect.Effect<[excluded: Stream<Exclude<C, B>, E, never>, satisfying: Stream<B, E, never>], E, R | Scope.Scope>
  <A, E, R>(
    self: Stream<A, E, R>,
    predicate: Predicate<A>,
    options?: { bufferSize?: number | undefined } | undefined
  ): Effect.Effect<[excluded: Stream<A, E, never>, satisfying: Stream<A, E, never>], E, R | Scope.Scope>
}
```


# partitionEither

Splits a stream into two substreams based on an effectful condition.

**Details**

The `Stream.partitionEither` function is used to divide a stream into two
parts: one for elements that satisfy a condition producing `Either.left`
values, and another for those that produce `Either.right` values. This
function applies an effectful predicate to each element in the stream to
determine which substream it belongs to.

The faster stream may advance up to `bufferSize` elements ahead of the slower
one.

To import and use `partitionEither` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.partitionEither
```

**Example**

```ts
// Title: Partitioning a Stream with an Effectful Predicate
import { Effect, Either, Stream } from "effect"

const partition = Stream.range(1, 9).pipe(
  Stream.partitionEither((n) => Effect.succeed(n % 2 === 0 ? Either.right(n) : Either.left(n)), { bufferSize: 5 })
)

const program = Effect.scoped(
  Effect.gen(function* () {
    const [evens, odds] = yield* partition
    console.log(yield* Stream.runCollect(evens))
    console.log(yield* Stream.runCollect(odds))
  })
)

// Effect.runPromise(program)
// { _id: 'Chunk', values: [ 1, 3, 5, 7, 9 ] }
// { _id: 'Chunk', values: [ 2, 4, 6, 8 ] }
```

**Signature**

```ts
export declare const partitionEither: {
  <A, A3, A2, E2, R2>(
    predicate: (a: NoInfer<A>) => Effect.Effect<Either.Either<A3, A2>, E2, R2>,
    options?: { readonly bufferSize?: number | undefined } | undefined
  ): <E, R>(
    self: Stream<A, E, R>
  ) => Effect.Effect<[left: Stream<A2, E2 | E, never>, right: Stream<A3, E2 | E, never>], E2 | E, Scope.Scope | R2 | R>
  <A, E, R, A3, A2, E2, R2>(
    self: Stream<A, E, R>,
    predicate: (a: A) => Effect.Effect<Either.Either<A3, A2>, E2, R2>,
    options?: { readonly bufferSize?: number | undefined } | undefined
  ): Effect.Effect<[left: Stream<A2, E | E2, never>, right: Stream<A3, E | E2, never>], E | E2, Scope.Scope | R | R2>
}
```


# peel

Peels off enough material from the stream to construct a `Z` using the
provided `Sink` and then returns both the `Z` and the rest of the
`Stream` in a scope. Like all scoped values, the provided stream is
valid only within the scope.

To import and use `peel` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.peel
```

**Signature**

```ts
export declare const peel: {
  <A2, A, E2, R2>(
    sink: Sink.Sink<A2, A, A, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Effect.Effect<[A2, Stream<A, E, never>], E2 | E, Scope.Scope | R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    sink: Sink.Sink<A2, A, A, E2, R2>
  ): Effect.Effect<[A2, Stream<A, E, never>], E | E2, Scope.Scope | R | R2>
}
```


# pipeThrough

Pipes all of the values from this stream through the provided sink.

See also `Stream.transduce`.

To import and use `pipeThrough` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.pipeThrough
```

**Signature**

```ts
export declare const pipeThrough: {
  <A2, A, L, E2, R2>(sink: Sink.Sink<A2, A, L, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<L, E2 | E, R2 | R>
  <A, E, R, A2, L, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, L, E2, R2>): Stream<L, E | E2, R | R2>
}
```


# pipeThroughChannel

Pipes all the values from this stream through the provided channel.

To import and use `pipeThroughChannel` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.pipeThroughChannel
```

**Signature**

```ts
export declare const pipeThroughChannel: {
  <R2, E, E2, A, A2>(
    channel: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>
  ): <R>(self: Stream<A, E, R>) => Stream<A2, E2, R2 | R>
  <R, R2, E, E2, A, A2>(
    self: Stream<A, E, R>,
    channel: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>
  ): Stream<A2, E2, R | R2>
}
```


# pipeThroughChannelOrFail

Pipes all values from this stream through the provided channel, passing
through any error emitted by this stream unchanged.

To import and use `pipeThroughChannelOrFail` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.pipeThroughChannelOrFail
```

**Signature**

```ts
export declare const pipeThroughChannelOrFail: {
  <R2, E, E2, A, A2>(
    chan: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>
  ): <R>(self: Stream<A, E, R>) => Stream<A2, E | E2, R2 | R>
  <R, R2, E, E2, A, A2>(
    self: Stream<A, E, R>,
    chan: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>
  ): Stream<A2, E | E2, R | R2>
}
```


# prepend

Emits the provided chunk before emitting any other value.

To import and use `prepend` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.prepend
```

**Signature**

```ts
export declare const prepend: {
  <B>(values: Chunk.Chunk<B>): <A, E, R>(self: Stream<A, E, R>) => Stream<B | A, E, R>
  <A, E, R, B>(self: Stream<A, E, R>, values: Chunk.Chunk<B>): Stream<A | B, E, R>
}
```


# provideContext

Provides the stream with its required context, which eliminates its
dependency on `R`.

To import and use `provideContext` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.provideContext
```

**Signature**

```ts
export declare const provideContext: {
  <R>(context: Context.Context<R>): <A, E>(self: Stream<A, E, R>) => Stream<A, E>
  <A, E, R>(self: Stream<A, E, R>, context: Context.Context<R>): Stream<A, E>
}
```


# provideLayer

Provides a `Layer` to the stream, which translates it to another level.

To import and use `provideLayer` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.provideLayer
```

**Signature**

```ts
export declare const provideLayer: {
  <RIn, E2, ROut>(layer: Layer.Layer<ROut, E2, RIn>): <A, E>(self: Stream<A, E, ROut>) => Stream<A, E2 | E, RIn>
  <A, E, RIn, E2, ROut>(self: Stream<A, E, ROut>, layer: Layer.Layer<ROut, E2, RIn>): Stream<A, E | E2, RIn>
}
```


# provideService

Provides the stream with the single service it requires. If the stream
requires more than one service use `Stream.provideContext` instead.

To import and use `provideService` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.provideService
```

**Signature**

```ts
export declare const provideService: {
  <I, S>(tag: Context.Tag<I, S>, resource: NoInfer<S>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, Exclude<R, I>>
  <A, E, R, I, S>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, resource: NoInfer<S>): Stream<A, E, Exclude<R, I>>
}
```


# provideServiceEffect

Provides the stream with the single service it requires. If the stream
requires more than one service use `Stream.provideContext` instead.

To import and use `provideServiceEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.provideServiceEffect
```

**Signature**

```ts
export declare const provideServiceEffect: {
  <I, S, E2, R2>(
    tag: Context.Tag<I, S>,
    effect: Effect.Effect<NoInfer<S>, E2, R2>
  ): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | Exclude<R, I>>
  <A, E, R, I, S, E2, R2>(
    self: Stream<A, E, R>,
    tag: Context.Tag<I, S>,
    effect: Effect.Effect<NoInfer<S>, E2, R2>
  ): Stream<A, E2 | E, R2 | Exclude<R, I>>
}
```


# provideServiceStream

Provides the stream with the single service it requires. If the stream
requires more than one service use `Stream.provideContext` instead.

To import and use `provideServiceStream` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.provideServiceStream
```

**Signature**

```ts
export declare const provideServiceStream: {
  <I, S, E2, R2>(
    tag: Context.Tag<I, S>,
    stream: Stream<NoInfer<S>, E2, R2>
  ): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | Exclude<R, I>>
  <A, E, R, I, S, E2, R2>(
    self: Stream<A, E, R>,
    tag: Context.Tag<I, S>,
    stream: Stream<NoInfer<S>, E2, R2>
  ): Stream<A, E2 | E, R2 | Exclude<R, I>>
}
```


# provideSomeLayer

Splits the context into two parts, providing one part using the
specified layer and leaving the remainder `R0`.

To import and use `provideSomeLayer` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.provideSomeLayer
```

**Signature**

```ts
export declare const provideSomeLayer: {
  <RIn, E2, ROut>(
    layer: Layer.Layer<ROut, E2, RIn>
  ): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, RIn | Exclude<R, ROut>>
  <A, E, R, RIn, E2, ROut>(
    self: Stream<A, E, R>,
    layer: Layer.Layer<ROut, E2, RIn>
  ): Stream<A, E | E2, RIn | Exclude<R, ROut>>
}
```


# race

Returns a stream that mirrors the first upstream to emit an item.
As soon as one of the upstream emits a first value, the other is interrupted.
The resulting stream will forward all items from the "winning" source stream.
Any upstream failures will cause the returned stream to fail.

To import and use `race` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.race
```

**Example**

```ts
import { Stream, Schedule, Console, Effect } from "effect"

const stream = Stream.fromSchedule(Schedule.spaced("2 millis")).pipe(
  Stream.race(Stream.fromSchedule(Schedule.spaced("1 millis"))),
  Stream.take(6),
  Stream.tap(Console.log)
)

Effect.runPromise(Stream.runDrain(stream))
// Output each millisecond from the first stream, the rest streams are interrupted
// 0
// 1
// 2
// 3
// 4
// 5
```

**Signature**

```ts
export declare const race: {
  <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL | AR, EL | ER, RL | RR>
  <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL | AR, EL | ER, RL | RR>
}
```


# raceAll

Returns a stream that mirrors the first upstream to emit an item.
As soon as one of the upstream emits a first value, all the others are interrupted.
The resulting stream will forward all items from the "winning" source stream.
Any upstream failures will cause the returned stream to fail.

To import and use `raceAll` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.raceAll
```

**Example**

```ts
import { Stream, Schedule, Console, Effect } from "effect"

const stream = Stream.raceAll(
  Stream.fromSchedule(Schedule.spaced("1 millis")),
  Stream.fromSchedule(Schedule.spaced("2 millis")),
  Stream.fromSchedule(Schedule.spaced("4 millis"))
).pipe(Stream.take(6), Stream.tap(Console.log))

Effect.runPromise(Stream.runDrain(stream))
// Output each millisecond from the first stream, the rest streams are interrupted
// 0
// 1
// 2
// 3
// 4
// 5
```

**Signature**

```ts
export declare const raceAll: <S extends ReadonlyArray<Stream<any, any, any>>>(
  ...streams: S
) => Stream<Stream.Success<S[number]>, Stream.Error<S[number]>, Stream.Context<S[number]>>
```


# range

Constructs a stream from a range of integers, including both endpoints.

To import and use `range` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.range
```

**Example**

```ts
import { Effect, Stream } from "effect"

// A Stream with a range of numbers from 1 to 5
const stream = Stream.range(1, 5)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }
```

**Signature**

```ts
export declare const range: (min: number, max: number, chunkSize?: number) => Stream<number>
```


# rechunk

Re-chunks the elements of the stream into chunks of `n` elements each. The
last chunk might contain less than `n` elements.

To import and use `rechunk` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.rechunk
```

**Signature**

```ts
export declare const rechunk: {
  (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>
}
```


# refineOrDie

Keeps some of the errors, and terminates the fiber with the rest

To import and use `refineOrDie` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.refineOrDie
```

**Signature**

```ts
export declare const refineOrDie: {
  <E, E2>(pf: (error: E) => Option.Option<E2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>
  <A, E, R, E2>(self: Stream<A, E, R>, pf: (error: E) => Option.Option<E2>): Stream<A, E2, R>
}
```


# refineOrDieWith

Keeps some of the errors, and terminates the fiber with the rest, using the
specified function to convert the `E` into a defect.

To import and use `refineOrDieWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.refineOrDieWith
```

**Signature**

```ts
export declare const refineOrDieWith: {
  <E, E2>(
    pf: (error: E) => Option.Option<E2>,
    f: (error: E) => unknown
  ): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>
  <A, E, R, E2>(self: Stream<A, E, R>, pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): Stream<A, E2, R>
}
```


# repeat

Repeats the entire stream using the specified schedule. The stream will
execute normally, and then repeat again according to the provided schedule.

To import and use `repeat` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.repeat
```

**Example**

```ts
import { Effect, Schedule, Stream } from "effect"

const stream = Stream.repeat(Stream.succeed(1), Schedule.forever)

// Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// { _id: 'Chunk', values: [ 1, 1, 1, 1, 1 ] }
```

**Signature**

```ts
export declare const repeat: {
  <B, R2>(schedule: Schedule.Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>
  <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>): Stream<A, E, R | R2>
}
```


# repeatEffect

Creates a stream from an effect producing a value of type `A` which repeats
forever.

To import and use `repeatEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.repeatEffect
```

**Example**

```ts
import { Effect, Random, Stream } from "effect"

const stream = Stream.repeatEffect(Random.nextInt)

// Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// Example Output: { _id: 'Chunk', values: [ 3891571149, 4239494205, 2352981603, 2339111046, 1488052210 ] }
```

**Signature**

```ts
export declare const repeatEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, R>
```


# repeatEffectChunk

Creates a stream from an effect producing chunks of `A` values which
repeats forever.

To import and use `repeatEffectChunk` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.repeatEffectChunk
```

**Signature**

```ts
export declare const repeatEffectChunk: <A, E, R>(effect: Effect.Effect<Chunk.Chunk<A>, E, R>) => Stream<A, E, R>
```


# repeatEffectChunkOption

Creates a stream from an effect producing chunks of `A` values until it
fails with `None`.

To import and use `repeatEffectChunkOption` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.repeatEffectChunkOption
```

**Signature**

```ts
export declare const repeatEffectChunkOption: <A, E, R>(
  effect: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>
) => Stream<A, E, R>
```


# repeatEffectOption

Creates a stream from an effect producing values of type `A` until it fails
with `None`.

To import and use `repeatEffectOption` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.repeatEffectOption
```

**Example**

```ts
// In this example, we're draining an Iterator to create a stream from it
import { Stream, Effect, Option } from "effect"

const drainIterator = <A>(it: Iterator<A>): Stream.Stream<A> =>
  Stream.repeatEffectOption(
    Effect.sync(() => it.next()).pipe(
      Effect.andThen((res) => {
        if (res.done) {
          return Effect.fail(Option.none())
        }
        return Effect.succeed(res.value)
      })
    )
  )
```

**Signature**

```ts
export declare const repeatEffectOption: <A, E, R>(effect: Effect.Effect<A, Option.Option<E>, R>) => Stream<A, E, R>
```


# repeatEffectWithSchedule

Creates a stream from an effect producing a value of type `A`, which is
repeated using the specified schedule.

To import and use `repeatEffectWithSchedule` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.repeatEffectWithSchedule
```

**Signature**

```ts
export declare const repeatEffectWithSchedule: <A, E, R, X, A0 extends A, R2>(
  effect: Effect.Effect<A, E, R>,
  schedule: Schedule.Schedule<X, A0, R2>
) => Stream<A, E, R | R2>
```


# repeatEither

Repeats the entire stream using the specified schedule. The stream will
execute normally, and then repeat again according to the provided schedule.
The schedule output will be emitted at the end of each repetition.

To import and use `repeatEither` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.repeatEither
```

**Signature**

```ts
export declare const repeatEither: {
  <B, R2>(
    schedule: Schedule.Schedule<B, unknown, R2>
  ): <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A, B>, E, R2 | R>
  <A, E, R, B, R2>(
    self: Stream<A, E, R>,
    schedule: Schedule.Schedule<B, unknown, R2>
  ): Stream<Either.Either<A, B>, E, R | R2>
}
```


# repeatElements

Repeats each element of the stream using the provided schedule. Repetitions
are done in addition to the first execution, which means using
`Schedule.recurs(1)` actually results in the original effect, plus an
additional recurrence, for a total of two repetitions of each value in the
stream.

To import and use `repeatElements` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.repeatElements
```

**Signature**

```ts
export declare const repeatElements: {
  <B, R2>(schedule: Schedule.Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>
  <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>): Stream<A, E, R | R2>
}
```


# repeatElementsWith

Repeats each element of the stream using the provided schedule. When the
schedule is finished, then the output of the schedule will be emitted into
the stream. Repetitions are done in addition to the first execution, which
means using `Schedule.recurs(1)` actually results in the original effect,
plus an additional recurrence, for a total of two repetitions of each value
in the stream.

This function accepts two conversion functions, which allow the output of
this stream and the output of the provided schedule to be unified into a
single type. For example, `Either` or similar data type.

To import and use `repeatElementsWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.repeatElementsWith
```

**Signature**

```ts
export declare const repeatElementsWith: {
  <B, R2, A, C>(
    schedule: Schedule.Schedule<B, unknown, R2>,
    options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C }
  ): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>
  <A, E, R, B, R2, C>(
    self: Stream<A, E, R>,
    schedule: Schedule.Schedule<B, unknown, R2>,
    options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C }
  ): Stream<C, E, R | R2>
}
```


# repeatValue

Repeats the provided value infinitely.

To import and use `repeatValue` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.repeatValue
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.repeatValue(0)

// Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// { _id: 'Chunk', values: [ 0, 0, 0, 0, 0 ] }
```

**Signature**

```ts
export declare const repeatValue: <A>(value: A) => Stream<A>
```


# repeatWith

Repeats the entire stream using the specified schedule. The stream will
execute normally, and then repeat again according to the provided schedule.
The schedule output will be emitted at the end of each repetition and can
be unified with the stream elements using the provided functions.

To import and use `repeatWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.repeatWith
```

**Signature**

```ts
export declare const repeatWith: {
  <B, R2, A, C>(
    schedule: Schedule.Schedule<B, unknown, R2>,
    options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C }
  ): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>
  <A, E, R, B, R2, C>(
    self: Stream<A, E, R>,
    schedule: Schedule.Schedule<B, unknown, R2>,
    options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C }
  ): Stream<C, E, R | R2>
}
```


# retry

When the stream fails, retry it according to the given schedule

This retries the entire stream, so will re-execute all of the stream's
acquire operations.

The schedule is reset as soon as the first element passes through the
stream again.

To import and use `retry` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.retry
```

**Signature**

```ts
export declare const retry: {
  <E0 extends E, R2, E, X>(
    schedule: Schedule.Schedule<X, E0, R2>
  ): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>
  <A, E, R, X, E0 extends E, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<X, E0, R2>): Stream<A, E, R | R2>
}
```


# run

Runs the sink on the stream to produce either the sink's result or an error.

To import and use `run` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.run
```

**Signature**

```ts
export declare const run: {
  <A2, A, E2, R2>(
    sink: Sink.Sink<A2, A, unknown, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Effect.Effect<A2, E2 | E, Exclude<R | R2, Scope.Scope>>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    sink: Sink.Sink<A2, A, unknown, E2, R2>
  ): Effect.Effect<A2, E | E2, Exclude<R | R2, Scope.Scope>>
}
```


# runCollect

Runs the stream and collects all of its elements to a chunk.

To import and use `runCollect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runCollect
```

**Signature**

```ts
export declare const runCollect: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Chunk.Chunk<A>, E, R>
```


# runCount

Runs the stream and emits the number of elements processed

To import and use `runCount` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runCount
```

**Signature**

```ts
export declare const runCount: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<number, E, R>
```


# runDrain

Runs the stream only for its effects. The emitted elements are discarded.

To import and use `runDrain` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runDrain
```

**Signature**

```ts
export declare const runDrain: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E, R>
```


# runFold

Executes a pure fold over the stream of values - reduces all elements in
the stream to a value of type `S`.

To import and use `runFold` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runFold
```

**Signature**

```ts
export declare const runFold: {
  <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, R>
  <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Effect.Effect<S, E, R>
}
```


# runFoldEffect

Executes an effectful fold over the stream of values.

To import and use `runFoldEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runFoldEffect
```

**Signature**

```ts
export declare const runFoldEffect: {
  <S, A, E2, R2>(
    s: S,
    f: (s: S, a: A) => Effect.Effect<S, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Exclude<R | R2, Scope.Scope>>
  <A, E, R, S, E2, R2>(
    self: Stream<A, E, R>,
    s: S,
    f: (s: S, a: A) => Effect.Effect<S, E2, R2>
  ): Effect.Effect<S, E | E2, Exclude<R | R2, Scope.Scope>>
}
```


# runFoldScoped

Executes a pure fold over the stream of values. Returns a scoped value that
represents the scope of the stream.

To import and use `runFoldScoped` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runFoldScoped
```

**Signature**

```ts
export declare const runFoldScoped: {
  <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, Scope.Scope | R>
  <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Effect.Effect<S, E, Scope.Scope | R>
}
```


# runFoldScopedEffect

Executes an effectful fold over the stream of values. Returns a scoped
value that represents the scope of the stream.

To import and use `runFoldScopedEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runFoldScopedEffect
```

**Signature**

```ts
export declare const runFoldScopedEffect: {
  <S, A, E2, R2>(
    s: S,
    f: (s: S, a: A) => Effect.Effect<S, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Scope.Scope | R2 | R>
  <A, E, R, S, E2, R2>(
    self: Stream<A, E, R>,
    s: S,
    f: (s: S, a: A) => Effect.Effect<S, E2, R2>
  ): Effect.Effect<S, E | E2, Scope.Scope | R | R2>
}
```


# runFoldWhile

Reduces the elements in the stream to a value of type `S`. Stops the fold
early when the condition is not fulfilled. Example:

To import and use `runFoldWhile` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runFoldWhile
```

**Signature**

```ts
export declare const runFoldWhile: {
  <S, A>(s: S, cont: Predicate<S>, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, R>
  <A, E, R, S>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => S): Effect.Effect<S, E, R>
}
```


# runFoldWhileEffect

Executes an effectful fold over the stream of values. Stops the fold early
when the condition is not fulfilled.

To import and use `runFoldWhileEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runFoldWhileEffect
```

**Signature**

```ts
export declare const runFoldWhileEffect: {
  <S, A, E2, R2>(
    s: S,
    cont: Predicate<S>,
    f: (s: S, a: A) => Effect.Effect<S, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Exclude<R | R2, Scope.Scope>>
  <A, E, R, S, E2, R2>(
    self: Stream<A, E, R>,
    s: S,
    cont: Predicate<S>,
    f: (s: S, a: A) => Effect.Effect<S, E2, R2>
  ): Effect.Effect<S, E | E2, Exclude<R | R2, Scope.Scope>>
}
```


# runFoldWhileScoped

Executes a pure fold over the stream of values. Returns a scoped value that
represents the scope of the stream. Stops the fold early when the condition
is not fulfilled.

To import and use `runFoldWhileScoped` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runFoldWhileScoped
```

**Signature**

```ts
export declare const runFoldWhileScoped: {
  <S, A>(
    s: S,
    cont: Predicate<S>,
    f: (s: S, a: A) => S
  ): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, Scope.Scope | R>
  <A, E, R, S>(
    self: Stream<A, E, R>,
    s: S,
    cont: Predicate<S>,
    f: (s: S, a: A) => S
  ): Effect.Effect<S, E, Scope.Scope | R>
}
```


# runFoldWhileScopedEffect

Executes an effectful fold over the stream of values. Returns a scoped
value that represents the scope of the stream. Stops the fold early when
the condition is not fulfilled.

To import and use `runFoldWhileScopedEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runFoldWhileScopedEffect
```

**Signature**

```ts
export declare const runFoldWhileScopedEffect: {
  <S, A, E2, R2>(
    s: S,
    cont: Predicate<S>,
    f: (s: S, a: A) => Effect.Effect<S, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, R2 | R | Scope.Scope>
  <A, E, R, S, E2, R2>(
    self: Stream<A, E, R>,
    s: S,
    cont: Predicate<S>,
    f: (s: S, a: A) => Effect.Effect<S, E2, R2>
  ): Effect.Effect<S, E | E2, Scope.Scope | R | R2>
}
```


# runForEach

Consumes all elements of the stream, passing them to the specified
callback.

To import and use `runForEach` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runForEach
```

**Signature**

```ts
export declare const runForEach: {
  <A, X, E2, R2>(
    f: (a: A) => Effect.Effect<X, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R>
  <A, E, R, X, E2, R2>(
    self: Stream<A, E, R>,
    f: (a: A) => Effect.Effect<X, E2, R2>
  ): Effect.Effect<void, E | E2, R | R2>
}
```


# runForEachChunk

Consumes all elements of the stream, passing them to the specified
callback.

To import and use `runForEachChunk` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runForEachChunk
```

**Signature**

```ts
export declare const runForEachChunk: {
  <A, X, E2, R2>(
    f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R>
  <A, E, R, X, E2, R2>(
    self: Stream<A, E, R>,
    f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>
  ): Effect.Effect<void, E | E2, R | R2>
}
```


# runForEachChunkScoped

Like `Stream.runForEachChunk`, but returns a scoped effect so the
finalization order can be controlled.

To import and use `runForEachChunkScoped` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runForEachChunkScoped
```

**Signature**

```ts
export declare const runForEachChunkScoped: {
  <A, X, E2, R2>(
    f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>
  <A, E, R, X, E2, R2>(
    self: Stream<A, E, R>,
    f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>
  ): Effect.Effect<void, E | E2, Scope.Scope | R | R2>
}
```


# runForEachScoped

Like `Stream.forEach`, but returns a scoped effect so the finalization
order can be controlled.

To import and use `runForEachScoped` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runForEachScoped
```

**Signature**

```ts
export declare const runForEachScoped: {
  <A, X, E2, R2>(
    f: (a: A) => Effect.Effect<X, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>
  <A, E, R, X, E2, R2>(
    self: Stream<A, E, R>,
    f: (a: A) => Effect.Effect<X, E2, R2>
  ): Effect.Effect<void, E | E2, Scope.Scope | R | R2>
}
```


# runForEachWhile

Consumes elements of the stream, passing them to the specified callback,
and terminating consumption when the callback returns `false`.

To import and use `runForEachWhile` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runForEachWhile
```

**Signature**

```ts
export declare const runForEachWhile: {
  <A, E2, R2>(
    f: (a: A) => Effect.Effect<boolean, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R>
  <A, E, R, E2, R2>(
    self: Stream<A, E, R>,
    f: (a: A) => Effect.Effect<boolean, E2, R2>
  ): Effect.Effect<void, E | E2, R | R2>
}
```


# runForEachWhileScoped

Like `Stream.runForEachWhile`, but returns a scoped effect so the
finalization order can be controlled.

To import and use `runForEachWhileScoped` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runForEachWhileScoped
```

**Signature**

```ts
export declare const runForEachWhileScoped: {
  <A, E2, R2>(
    f: (a: A) => Effect.Effect<boolean, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>
  <A, E, R, E2, R2>(
    self: Stream<A, E, R>,
    f: (a: A) => Effect.Effect<boolean, E2, R2>
  ): Effect.Effect<void, E | E2, Scope.Scope | R | R2>
}
```


# runHead

Runs the stream to completion and yields the first value emitted by it,
discarding the rest of the elements.

To import and use `runHead` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runHead
```

**Signature**

```ts
export declare const runHead: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>
```


# runIntoPubSub

Publishes elements of this stream to a `PubSub`. Stream failure and ending will
also be signalled.

To import and use `runIntoPubSub` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runIntoPubSub
```

**Signature**

```ts
export declare const runIntoPubSub: {
  <A, E>(pubsub: PubSub.PubSub<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, R>
  <A, E, R>(self: Stream<A, E, R>, pubsub: PubSub.PubSub<Take.Take<A, E>>): Effect.Effect<void, never, R>
}
```


# runIntoPubSubScoped

Like `Stream.runIntoPubSub`, but provides the result as a scoped effect to
allow for scope composition.

To import and use `runIntoPubSubScoped` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runIntoPubSubScoped
```

**Signature**

```ts
export declare const runIntoPubSubScoped: {
  <A, E>(
    pubsub: PubSub.PubSub<Take.Take<A, E>>
  ): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>
  <A, E, R>(self: Stream<A, E, R>, pubsub: PubSub.PubSub<Take.Take<A, E>>): Effect.Effect<void, never, Scope.Scope | R>
}
```


# runIntoQueue

Enqueues elements of this stream into a queue. Stream failure and ending
will also be signalled.

To import and use `runIntoQueue` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runIntoQueue
```

**Signature**

```ts
export declare const runIntoQueue: {
  <A, E>(queue: Queue.Enqueue<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, R>
  <A, E, R>(self: Stream<A, E, R>, queue: Queue.Enqueue<Take.Take<A, E>>): Effect.Effect<void, never, R>
}
```


# runIntoQueueElementsScoped

Like `Stream.runIntoQueue`, but provides the result as a scoped [[ZIO]]
to allow for scope composition.

To import and use `runIntoQueueElementsScoped` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runIntoQueueElementsScoped
```

**Signature**

```ts
export declare const runIntoQueueElementsScoped: {
  <A, E>(
    queue: Queue.Enqueue<Exit.Exit<A, Option.Option<E>>>
  ): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>
  <A, E, R>(
    self: Stream<A, E, R>,
    queue: Queue.Enqueue<Exit.Exit<A, Option.Option<E>>>
  ): Effect.Effect<void, never, Scope.Scope | R>
}
```


# runIntoQueueScoped

Like `Stream.runIntoQueue`, but provides the result as a scoped effect
to allow for scope composition.

To import and use `runIntoQueueScoped` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runIntoQueueScoped
```

**Signature**

```ts
export declare const runIntoQueueScoped: {
  <A, E>(
    queue: Queue.Enqueue<Take.Take<A, E>>
  ): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>
  <A, E, R>(self: Stream<A, E, R>, queue: Queue.Enqueue<Take.Take<A, E>>): Effect.Effect<void, never, Scope.Scope | R>
}
```


# runLast

Runs the stream to completion and yields the last value emitted by it,
discarding the rest of the elements.

To import and use `runLast` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runLast
```

**Signature**

```ts
export declare const runLast: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>
```


# runSum

Runs the stream to a sink which sums elements, provided they are Numeric.

To import and use `runSum` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.runSum
```

**Signature**

```ts
export declare const runSum: <E, R>(self: Stream<number, E, R>) => Effect.Effect<number, E, R>
```


# scan

Statefully maps over the elements of this stream to produce all
intermediate results of type `S` given an initial S.

To import and use `scan` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.scan
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.range(1, 6).pipe(Stream.scan(0, (a, b) => a + b))

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0,  1,  3, 6, 10, 15, 21 ] }
```

**Signature**

```ts
export declare const scan: {
  <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Stream<S, E, R>
  <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Stream<S, E, R>
}
```


# scanEffect

Statefully and effectfully maps over the elements of this stream to produce
all intermediate results of type `S` given an initial S.

To import and use `scanEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.scanEffect
```

**Signature**

```ts
export declare const scanEffect: {
  <S, A, E2, R2>(
    s: S,
    f: (s: S, a: A) => Effect.Effect<S, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Stream<S, E2 | E, R2 | R>
  <A, E, R, S, E2, R2>(
    self: Stream<A, E, R>,
    s: S,
    f: (s: S, a: A) => Effect.Effect<S, E2, R2>
  ): Stream<S, E | E2, R | R2>
}
```


# scanReduce

Statefully maps over the elements of this stream to produce all
intermediate results.

See also `Stream.scan`.

To import and use `scanReduce` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.scanReduce
```

**Signature**

```ts
export declare const scanReduce: {
  <A2, A>(f: (a2: A2 | A, a: A) => A2): <E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>
  <A, E, R, A2>(self: Stream<A, E, R>, f: (a2: A | A2, a: A) => A2): Stream<A | A2, E, R>
}
```


# scanReduceEffect

Statefully and effectfully maps over the elements of this stream to produce
all intermediate results.

See also `Stream.scanEffect`.

To import and use `scanReduceEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.scanReduceEffect
```

**Signature**

```ts
export declare const scanReduceEffect: {
  <A2, A, E2, R2>(
    f: (a2: A2 | A, a: A) => Effect.Effect<A2 | A, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    f: (a2: A | A2, a: A) => Effect.Effect<A | A2, E2, R2>
  ): Stream<A | A2, E | E2, R | R2>
}
```


# schedule

Schedules the output of the stream using the provided `schedule`.

To import and use `schedule` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.schedule
```

**Signature**

```ts
export declare const schedule: {
  <X, A0 extends A, R2, A>(
    schedule: Schedule.Schedule<X, A0, R2>
  ): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>
  <A, E, R, X, A0 extends A, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<X, A0, R2>): Stream<A, E, R | R2>
}
```


# scheduleWith

Schedules the output of the stream using the provided `schedule` and emits
its output at the end (if `schedule` is finite). Uses the provided function
to align the stream and schedule outputs on the same type.

To import and use `scheduleWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.scheduleWith
```

**Signature**

```ts
export declare const scheduleWith: {
  <B, A0 extends A, R2, A, C>(
    schedule: Schedule.Schedule<B, A0, R2>,
    options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C }
  ): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>
  <A, E, R, B, A0 extends A, R2, C>(
    self: Stream<A, E, R>,
    schedule: Schedule.Schedule<B, A0, R2>,
    options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C }
  ): Stream<C, E, R | R2>
}
```


# scoped

Creates a single-valued stream from a scoped resource.

To import and use `scoped` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.scoped
```

**Example**

```ts
import { Console, Effect, Stream } from "effect"

// Creating a single-valued stream from a scoped resource
const stream = Stream.scoped(Effect.acquireRelease(Console.log("acquire"), () => Console.log("release"))).pipe(
  Stream.flatMap(() => Console.log("use"))
)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// acquire
// use
// release
// { _id: 'Chunk', values: [ undefined ] }
```

**Signature**

```ts
export declare const scoped: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, Exclude<R, Scope.Scope>>
```


# scopedWith

Use a function that receives a scope and returns an effect to emit an output
element. The output element will be the result of the returned effect, if
successful.

To import and use `scopedWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.scopedWith
```

**Signature**

```ts
export declare const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect.Effect<A, E, R>) => Stream<A, E, R>
```


# share

Returns a new Stream that multicasts the original Stream, subscribing to it as soon as the first consumer subscribes.
As long as there is at least one consumer, the upstream will continue running and emitting data.
When all consumers have exited, the upstream will be finalized.

To import and use `share` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.share
```

**Signature**

```ts
export declare const share: {
  <A, E>(
    config:
      | {
          readonly capacity: "unbounded"
          readonly replay?: number | undefined
          readonly idleTimeToLive?: Duration.DurationInput | undefined
        }
      | {
          readonly capacity: number
          readonly strategy?: "sliding" | "dropping" | "suspend" | undefined
          readonly replay?: number | undefined
          readonly idleTimeToLive?: Duration.DurationInput | undefined
        }
  ): <R>(self: Stream<A, E, R>) => Effect.Effect<Stream<A, E>, never, R | Scope.Scope>
  <A, E, R>(
    self: Stream<A, E, R>,
    config:
      | {
          readonly capacity: "unbounded"
          readonly replay?: number | undefined
          readonly idleTimeToLive?: Duration.DurationInput | undefined
        }
      | {
          readonly capacity: number
          readonly strategy?: "sliding" | "dropping" | "suspend" | undefined
          readonly replay?: number | undefined
          readonly idleTimeToLive?: Duration.DurationInput | undefined
        }
  ): Effect.Effect<Stream<A, E>, never, R | Scope.Scope>
}
```


# sliding

Emits a sliding window of `n` elements.

```ts
import * as Stream from "./Stream"
import { pipe } from "./Function"

pipe(Stream.make(1, 2, 3, 4), Stream.sliding(2), Stream.runCollect)
// => Chunk(Chunk(1, 2), Chunk(2, 3), Chunk(3, 4))
```

To import and use `sliding` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.sliding
```

**Signature**

```ts
export declare const sliding: {
  (chunkSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>
  <A, E, R>(self: Stream<A, E, R>, chunkSize: number): Stream<Chunk.Chunk<A>, E, R>
}
```


# slidingSize

Like `sliding`, but with a configurable `stepSize` parameter.

To import and use `slidingSize` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.slidingSize
```

**Signature**

```ts
export declare const slidingSize: {
  (chunkSize: number, stepSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>
  <A, E, R>(self: Stream<A, E, R>, chunkSize: number, stepSize: number): Stream<Chunk.Chunk<A>, E, R>
}
```


# some

Converts an option on values into an option on errors.

To import and use `some` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.some
```

**Signature**

```ts
export declare const some: <A, E, R>(self: Stream<Option.Option<A>, E, R>) => Stream<A, Option.Option<E>, R>
```


# someOrElse

Extracts the optional value, or returns the given 'default'.

To import and use `someOrElse` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.someOrElse
```

**Signature**

```ts
export declare const someOrElse: {
  <A2>(fallback: LazyArg<A2>): <A, E, R>(self: Stream<Option.Option<A>, E, R>) => Stream<A2 | A, E, R>
  <A, E, R, A2>(self: Stream<Option.Option<A>, E, R>, fallback: LazyArg<A2>): Stream<A | A2, E, R>
}
```


# someOrFail

Extracts the optional value, or fails with the given error 'e'.

To import and use `someOrFail` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.someOrFail
```

**Signature**

```ts
export declare const someOrFail: {
  <E2>(error: LazyArg<E2>): <A, E, R>(self: Stream<Option.Option<A>, E, R>) => Stream<A, E2 | E, R>
  <A, E, R, E2>(self: Stream<Option.Option<A>, E, R>, error: LazyArg<E2>): Stream<A, E | E2, R>
}
```


# split

Splits elements based on a predicate or refinement.

```ts
import * as Stream from "./Stream"
import { pipe } from "./Function"

pipe(
  Stream.range(1, 10),
  Stream.split((n) => n % 4 === 0),
  Stream.runCollect
)
// => Chunk(Chunk(1, 2, 3), Chunk(5, 6, 7), Chunk(9))
```

To import and use `split` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.split
```

**Signature**

```ts
export declare const split: {
  <A, B extends A>(
    refinement: Refinement<NoInfer<A>, B>
  ): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<Exclude<A, B>>, E, R>
  <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>
  <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<Chunk.Chunk<Exclude<A, B>>, E, R>
  <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<Chunk.Chunk<A>, E, R>
}
```


# splitLines

Splits strings on newlines. Handles both Windows newlines (`\r\n`) and UNIX
newlines (`\n`).

To import and use `splitLines` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.splitLines
```

**Signature**

```ts
export declare const splitLines: <E, R>(self: Stream<string, E, R>) => Stream<string, E, R>
```


# splitOnChunk

Splits elements on a delimiter and transforms the splits into desired output.

To import and use `splitOnChunk` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.splitOnChunk
```

**Signature**

```ts
export declare const splitOnChunk: {
  <A>(delimiter: Chunk.Chunk<A>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>
  <A, E, R>(self: Stream<A, E, R>, delimiter: Chunk.Chunk<A>): Stream<Chunk.Chunk<A>, E, R>
}
```


# Stream

A `Stream<A, E, R>` is a description of a program that, when evaluated, may
emit zero or more values of type `A`, may fail with errors of type `E`, and
uses an context of type `R`. One way to think of `Stream` is as a
`Effect` program that could emit multiple values.

`Stream` is a purely functional _pull_ based stream. Pull based streams offer
inherent laziness and backpressure, relieving users of the need to manage
buffers between operators. As an optimization, `Stream` does not emit
single values, but rather an array of values. This allows the cost of effect
evaluation to be amortized.

`Stream` forms a monad on its `A` type parameter, and has error management
facilities for its `E` type parameter, modeled similarly to `Effect` (with
some adjustments for the multiple-valued nature of `Stream`). These aspects
allow for rich and expressive composition of streams.

To import and use `Stream` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.Stream
```


# succeed

Creates a single-valued pure stream.

To import and use `succeed` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.succeed
```

**Example**

```ts
import { Effect, Stream } from "effect"

// A Stream with a single number
const stream = Stream.succeed(3)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 3 ] }
```

**Signature**

```ts
export declare const succeed: <A>(value: A) => Stream<A>
```


# suspend

Returns a lazily constructed stream.

To import and use `suspend` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.suspend
```

**Signature**

```ts
export declare const suspend: <A, E, R>(stream: LazyArg<Stream<A, E, R>>) => Stream<A, E, R>
```


# sync

Creates a single-valued pure stream.

To import and use `sync` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.sync
```

**Signature**

```ts
export declare const sync: <A>(evaluate: LazyArg<A>) => Stream<A>
```


# take

Takes the specified number of elements from this stream.

To import and use `take` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.take
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.take(
  Stream.iterate(0, (n) => n + 1),
  5
)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }
```

**Signature**

```ts
export declare const take: {
  (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>
}
```


# takeRight

Takes the last specified number of elements from this stream.

To import and use `takeRight` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.takeRight
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.takeRight(Stream.make(1, 2, 3, 4, 5, 6), 3)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 4, 5, 6 ] }
```

**Signature**

```ts
export declare const takeRight: {
  (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>
}
```


# takeUntil

Takes all elements of the stream until the specified predicate evaluates to
`true`.

To import and use `takeUntil` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.takeUntil
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.takeUntil(
  Stream.iterate(0, (n) => n + 1),
  (n) => n === 4
)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }
```

**Signature**

```ts
export declare const takeUntil: {
  <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>
}
```


# takeUntilEffect

Takes all elements of the stream until the specified effectual predicate
evaluates to `true`.

To import and use `takeUntilEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.takeUntilEffect
```

**Signature**

```ts
export declare const takeUntilEffect: {
  <A, E2, R2>(
    predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E, R, E2, R2>(
    self: Stream<A, E, R>,
    predicate: (a: A) => Effect.Effect<boolean, E2, R2>
  ): Stream<A, E | E2, R | R2>
}
```


# takeWhile

Takes all elements of the stream for as long as the specified predicate
evaluates to `true`.

To import and use `takeWhile` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.takeWhile
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.takeWhile(
  Stream.iterate(0, (n) => n + 1),
  (n) => n < 5
)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }
```

**Signature**

```ts
export declare const takeWhile: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>
  <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>
  <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>
}
```


# tap

Adds an effect to consumption of every element of the stream.

To import and use `tap` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.tap
```

**Example**

```ts
import { Console, Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3).pipe(
  Stream.tap((n) => Console.log(`before mapping: ${n}`)),
  Stream.map((n) => n * 2),
  Stream.tap((n) => Console.log(`after mapping: ${n}`))
)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// before mapping: 1
// after mapping: 2
// before mapping: 2
// after mapping: 4
// before mapping: 3
// after mapping: 6
// { _id: 'Chunk', values: [ 2, 4, 6 ] }
```

**Signature**

```ts
export declare const tap: {
  <A, X, E2, R2>(
    f: (a: NoInfer<A>) => Effect.Effect<X, E2, R2>
  ): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: NoInfer<A>) => Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>
}
```


# tapBoth

Returns a stream that effectfully "peeks" at the failure or success of
the stream.

To import and use `tapBoth` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.tapBoth
```

**Signature**

```ts
export declare const tapBoth: {
  <E, X1, E2, R2, A, X2, E3, R3>(options: {
    readonly onFailure: (e: NoInfer<E>) => Effect.Effect<X1, E2, R2>
    readonly onSuccess: (a: NoInfer<A>) => Effect.Effect<X2, E3, R3>
  }): <R>(self: Stream<A, E, R>) => Stream<A, E | E2 | E3, R2 | R3 | R>
  <A, E, R, X1, E2, R2, X2, E3, R3>(
    self: Stream<A, E, R>,
    options: {
      readonly onFailure: (e: NoInfer<E>) => Effect.Effect<X1, E2, R2>
      readonly onSuccess: (a: NoInfer<A>) => Effect.Effect<X2, E3, R3>
    }
  ): Stream<A, E | E2 | E3, R | R2 | R3>
}
```


# tapError

Returns a stream that effectfully "peeks" at the failure of the stream.

To import and use `tapError` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.tapError
```

**Signature**

```ts
export declare const tapError: {
  <E, X, E2, R2>(
    f: (error: NoInfer<E>) => Effect.Effect<X, E2, R2>
  ): <A, R>(self: Stream<A, E, R>) => Stream<A, E | E2, R2 | R>
  <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (error: E) => Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>
}
```


# tapErrorCause

Returns a stream that effectfully "peeks" at the cause of failure of the
stream.

To import and use `tapErrorCause` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.tapErrorCause
```

**Signature**

```ts
export declare const tapErrorCause: {
  <E, X, E2, R2>(
    f: (cause: Cause.Cause<NoInfer<E>>) => Effect.Effect<X, E2, R2>
  ): <A, R>(self: Stream<A, E, R>) => Stream<A, E | E2, R2 | R>
  <A, E, R, X, E2, R2>(
    self: Stream<A, E, R>,
    f: (cause: Cause.Cause<E>) => Effect.Effect<X, E2, R2>
  ): Stream<A, E | E2, R | R2>
}
```


# tapSink

Sends all elements emitted by this stream to the specified sink in addition
to emitting them.

To import and use `tapSink` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.tapSink
```

**Signature**

```ts
export declare const tapSink: {
  <A, E2, R2>(sink: Sink.Sink<unknown, A, unknown, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E, R, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<unknown, A, unknown, E2, R2>): Stream<A, E | E2, R | R2>
}
```


# throttle

Delays the chunks of this stream according to the given bandwidth
parameters using the token bucket algorithm. Allows for burst in the
processing of elements by allowing the token bucket to accumulate tokens up
to a `units + burst` threshold. The weight of each chunk is determined by
the `cost` function.

If using the "enforce" strategy, chunks that do not meet the bandwidth
constraints are dropped. If using the "shape" strategy, chunks are delayed
until they can be emitted without exceeding the bandwidth constraints.

Defaults to the "shape" strategy.

To import and use `throttle` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.throttle
```

**Example**

```ts
import { Chunk, Effect, Schedule, Stream } from "effect"

let last = Date.now()
const log = (message: string) =>
  Effect.sync(() => {
    const end = Date.now()
    console.log(`${message} after ${end - last}ms`)
    last = end
  })

const stream = Stream.fromSchedule(Schedule.spaced("50 millis")).pipe(
  Stream.take(6),
  Stream.tap((n) => log(`Received ${n}`)),
  Stream.throttle({
    cost: Chunk.size,
    duration: "100 millis",
    units: 1
  }),
  Stream.tap((n) => log(`> Emitted ${n}`))
)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Received 0 after 56ms
// > Emitted 0 after 0ms
// Received 1 after 52ms
// > Emitted 1 after 48ms
// Received 2 after 52ms
// > Emitted 2 after 49ms
// Received 3 after 52ms
// > Emitted 3 after 48ms
// Received 4 after 52ms
// > Emitted 4 after 47ms
// Received 5 after 52ms
// > Emitted 5 after 49ms
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4, 5 ] }
```

**Signature**

```ts
export declare const throttle: {
  <A>(options: {
    readonly cost: (chunk: Chunk.Chunk<A>) => number
    readonly units: number
    readonly duration: Duration.DurationInput
    readonly burst?: number | undefined
    readonly strategy?: "enforce" | "shape" | undefined
  }): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R>(
    self: Stream<A, E, R>,
    options: {
      readonly cost: (chunk: Chunk.Chunk<A>) => number
      readonly units: number
      readonly duration: Duration.DurationInput
      readonly burst?: number | undefined
      readonly strategy?: "enforce" | "shape" | undefined
    }
  ): Stream<A, E, R>
}
```


# throttleEffect

Delays the chunks of this stream according to the given bandwidth
parameters using the token bucket algorithm. Allows for burst in the
processing of elements by allowing the token bucket to accumulate tokens up
to a `units + burst` threshold. The weight of each chunk is determined by
the effectful `costFn` function.

If using the "enforce" strategy, chunks that do not meet the bandwidth
constraints are dropped. If using the "shape" strategy, chunks are delayed
until they can be emitted without exceeding the bandwidth constraints.

Defaults to the "shape" strategy.

To import and use `throttleEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.throttleEffect
```

**Signature**

```ts
export declare const throttleEffect: {
  <A, E2, R2>(options: {
    readonly cost: (chunk: Chunk.Chunk<A>) => Effect.Effect<number, E2, R2>
    readonly units: number
    readonly duration: Duration.DurationInput
    readonly burst?: number | undefined
    readonly strategy?: "enforce" | "shape" | undefined
  }): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E, R, E2, R2>(
    self: Stream<A, E, R>,
    options: {
      readonly cost: (chunk: Chunk.Chunk<A>) => Effect.Effect<number, E2, R2>
      readonly units: number
      readonly duration: Duration.DurationInput
      readonly burst?: number | undefined
      readonly strategy?: "enforce" | "shape" | undefined
    }
  ): Stream<A, E | E2, R | R2>
}
```


# tick

A stream that emits void values spaced by the specified duration.

To import and use `tick` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.tick
```

**Example**

```ts
import { Effect, Stream } from "effect"

let last = Date.now()
const log = (message: string) =>
  Effect.sync(() => {
    const end = Date.now()
    console.log(`${message} after ${end - last}ms`)
    last = end
  })

const stream = Stream.tick("1 seconds").pipe(Stream.tap(() => log("tick")))

// Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// tick after 4ms
// tick after 1003ms
// tick after 1001ms
// tick after 1002ms
// tick after 1002ms
// { _id: 'Chunk', values: [ undefined, undefined, undefined, undefined, undefined ] }
```

**Signature**

```ts
export declare const tick: (interval: Duration.DurationInput) => Stream<void>
```


# timeout

Ends the stream if it does not produce a value after the specified duration.

To import and use `timeout` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.timeout
```

**Signature**

```ts
export declare const timeout: {
  (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>
}
```


# timeoutFail

Fails the stream with given error if it does not produce a value after d
duration.

To import and use `timeoutFail` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.timeoutFail
```

**Signature**

```ts
export declare const timeoutFail: {
  <E2>(error: LazyArg<E2>, duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>
  <A, E, R, E2>(self: Stream<A, E, R>, error: LazyArg<E2>, duration: Duration.DurationInput): Stream<A, E | E2, R>
}
```


# timeoutFailCause

Fails the stream with given cause if it does not produce a value after d
duration.

To import and use `timeoutFailCause` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.timeoutFailCause
```

**Signature**

```ts
export declare const timeoutFailCause: {
  <E2>(
    cause: LazyArg<Cause.Cause<E2>>,
    duration: Duration.DurationInput
  ): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>
  <A, E, R, E2>(
    self: Stream<A, E, R>,
    cause: LazyArg<Cause.Cause<E2>>,
    duration: Duration.DurationInput
  ): Stream<A, E | E2, R>
}
```


# timeoutTo

Switches the stream if it does not produce a value after the specified
duration.

To import and use `timeoutTo` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.timeoutTo
```

**Signature**

```ts
export declare const timeoutTo: {
  <A2, E2, R2>(
    duration: Duration.DurationInput,
    that: Stream<A2, E2, R2>
  ): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    duration: Duration.DurationInput,
    that: Stream<A2, E2, R2>
  ): Stream<A | A2, E | E2, R | R2>
}
```


# toChannel

Creates a channel from a `Stream`.

To import and use `toChannel` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.toChannel
```

**Signature**

```ts
export declare const toChannel: <A, E, R>(
  stream: Stream<A, E, R>
) => Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown, R>
```


# toPubSub

Converts the stream to a scoped `PubSub` of chunks. After the scope is closed,
the `PubSub` will never again produce values and should be discarded.

To import and use `toPubSub` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.toPubSub
```

**Signature**

```ts
export declare const toPubSub: {
  (
    capacity:
      | number
      | { readonly capacity: "unbounded"; readonly replay?: number | undefined }
      | {
          readonly capacity: number
          readonly strategy?: "sliding" | "dropping" | "suspend" | undefined
          readonly replay?: number | undefined
        }
  ): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<PubSub.PubSub<Take.Take<A, E>>, never, Scope.Scope | R>
  <A, E, R>(
    self: Stream<A, E, R>,
    capacity:
      | number
      | { readonly capacity: "unbounded"; readonly replay?: number | undefined }
      | {
          readonly capacity: number
          readonly strategy?: "sliding" | "dropping" | "suspend" | undefined
          readonly replay?: number | undefined
        }
  ): Effect.Effect<PubSub.PubSub<Take.Take<A, E>>, never, Scope.Scope | R>
}
```


# toPull

Returns in a scope a ZIO effect that can be used to repeatedly pull chunks
from the stream. The pull effect fails with None when the stream is
finished, or with Some error if it fails, otherwise it returns a chunk of
the stream's output.

To import and use `toPull` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.toPull
```

**Example**

```ts
import { Effect, Stream } from "effect"

// Simulate a chunked stream
const stream = Stream.fromIterable([1, 2, 3, 4, 5]).pipe(Stream.rechunk(2))

const program = Effect.gen(function* () {
  // Create an effect to get data chunks from the stream
  const getChunk = yield* Stream.toPull(stream)

  // Continuously fetch and process chunks
  while (true) {
    const chunk = yield* getChunk
    console.log(chunk)
  }
})

// Effect.runPromise(Effect.scoped(program)).then(console.log, console.error)
// { _id: 'Chunk', values: [ 1, 2 ] }
// { _id: 'Chunk', values: [ 3, 4 ] }
// { _id: 'Chunk', values: [ 5 ] }
// (FiberFailure) Error: {
//   "_id": "Option",
//   "_tag": "None"
// }
```

**Signature**

```ts
export declare const toPull: <A, E, R>(
  self: Stream<A, E, R>
) => Effect.Effect<Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>, never, Scope.Scope | R>
```


# toQueue

Converts the stream to a scoped queue of chunks. After the scope is closed,
the queue will never again produce values and should be discarded.

Defaults to the "suspend" back pressure strategy with a capacity of 2.

To import and use `toQueue` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.toQueue
```

**Signature**

```ts
export declare const toQueue: {
  (
    options?:
      | { readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; readonly capacity?: number | undefined }
      | { readonly strategy: "unbounded" }
      | undefined
  ): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope | R>
  <A, E, R>(
    self: Stream<A, E, R>,
    options?:
      | { readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; readonly capacity?: number | undefined }
      | { readonly strategy: "unbounded" }
      | undefined
  ): Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope | R>
}
```


# toQueueOfElements

Converts the stream to a scoped queue of elements. After the scope is
closed, the queue will never again produce values and should be discarded.

Defaults to a capacity of 2.

To import and use `toQueueOfElements` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.toQueueOfElements
```

**Signature**

```ts
export declare const toQueueOfElements: {
  (
    options?: { readonly capacity?: number | undefined } | undefined
  ): <A, E, R>(
    self: Stream<A, E, R>
  ) => Effect.Effect<Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>, never, Scope.Scope | R>
  <A, E, R>(
    self: Stream<A, E, R>,
    options?: { readonly capacity?: number | undefined } | undefined
  ): Effect.Effect<Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>, never, Scope.Scope | R>
}
```


# toReadableStream

Converts the stream to a `ReadableStream`.

See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.

To import and use `toReadableStream` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.toReadableStream
```

**Signature**

```ts
export declare const toReadableStream: {
  <A>(options?: { readonly strategy?: QueuingStrategy<A> | undefined }): <E>(self: Stream<A, E>) => ReadableStream<A>
  <A, E>(self: Stream<A, E>, options?: { readonly strategy?: QueuingStrategy<A> | undefined }): ReadableStream<A>
}
```


# toReadableStreamEffect

Converts the stream to a `Effect<ReadableStream>`.

See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.

To import and use `toReadableStreamEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.toReadableStreamEffect
```

**Signature**

```ts
export declare const toReadableStreamEffect: {
  <A>(options?: {
    readonly strategy?: QueuingStrategy<A> | undefined
  }): <E, R>(self: Stream<A, E, R>) => Effect.Effect<ReadableStream<A>, never, R>
  <A, E, R>(
    self: Stream<A, E, R>,
    options?: { readonly strategy?: QueuingStrategy<A> | undefined }
  ): Effect.Effect<ReadableStream<A>, never, R>
}
```


# toReadableStreamRuntime

Converts the stream to a `ReadableStream` using the provided runtime.

See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.

To import and use `toReadableStreamRuntime` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.toReadableStreamRuntime
```

**Signature**

```ts
export declare const toReadableStreamRuntime: {
  <A, XR>(
    runtime: Runtime<XR>,
    options?: { readonly strategy?: QueuingStrategy<A> | undefined }
  ): <E, R extends XR>(self: Stream<A, E, R>) => ReadableStream<A>
  <A, E, XR, R extends XR>(
    self: Stream<A, E, R>,
    runtime: Runtime<XR>,
    options?: { readonly strategy?: QueuingStrategy<A> | undefined }
  ): ReadableStream<A>
}
```


# transduce

Applies the transducer to the stream and emits its outputs.

To import and use `transduce` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.transduce
```

**Signature**

```ts
export declare const transduce: {
  <A2, A, E2, R2>(sink: Sink.Sink<A2, A, A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, A, E2, R2>): Stream<A2, E | E2, R | R2>
}
```


# unfold

Creates a stream by peeling off the "layers" of a value of type `S`.

To import and use `unfold` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.unfold
```

**Example**

```ts
import { Effect, Option, Stream } from "effect"

const stream = Stream.unfold(1, (n) => Option.some([n, n + 1]))

// Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }
```

**Signature**

```ts
export declare const unfold: <S, A>(s: S, f: (s: S) => Option.Option<readonly [A, S]>) => Stream<A>
```


# unfoldChunk

Creates a stream by peeling off the "layers" of a value of type `S`.

To import and use `unfoldChunk` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.unfoldChunk
```

**Signature**

```ts
export declare const unfoldChunk: <S, A>(s: S, f: (s: S) => Option.Option<readonly [Chunk.Chunk<A>, S]>) => Stream<A>
```


# unfoldChunkEffect

Creates a stream by effectfully peeling off the "layers" of a value of type
`S`.

To import and use `unfoldChunkEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.unfoldChunkEffect
```

**Signature**

```ts
export declare const unfoldChunkEffect: <S, A, E, R>(
  s: S,
  f: (s: S) => Effect.Effect<Option.Option<readonly [Chunk.Chunk<A>, S]>, E, R>
) => Stream<A, E, R>
```


# unfoldEffect

Creates a stream by effectfully peeling off the "layers" of a value of type
`S`.

To import and use `unfoldEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.unfoldEffect
```

**Example**

```ts
import { Effect, Option, Random, Stream } from "effect"

const stream = Stream.unfoldEffect(1, (n) =>
  Random.nextBoolean.pipe(Effect.map((b) => (b ? Option.some([n, -n]) : Option.some([n, n]))))
)

// Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// { _id: 'Chunk', values: [ 1, -1, -1, -1, -1 ] }
```

**Signature**

```ts
export declare const unfoldEffect: <S, A, E, R>(
  s: S,
  f: (s: S) => Effect.Effect<Option.Option<readonly [A, S]>, E, R>
) => Stream<A, E, R>
```


# unwrap

Creates a stream produced from an `Effect`.

To import and use `unwrap` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.unwrap
```

**Signature**

```ts
export declare const unwrap: <A, E2, R2, E, R>(
  effect: Effect.Effect<Stream<A, E2, R2>, E, R>
) => Stream<A, E | E2, R | R2>
```


# unwrapScoped

Creates a stream produced from a scoped `Effect`.

To import and use `unwrapScoped` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.unwrapScoped
```

**Signature**

```ts
export declare const unwrapScoped: <A, E2, R2, E, R>(
  effect: Effect.Effect<Stream<A, E2, R2>, E, R>
) => Stream<A, E | E2, R2 | Exclude<R, Scope.Scope>>
```


# unwrapScopedWith

Creates a stream produced from a function which receives a `Scope` and
returns an `Effect`. The resulting stream will emit a single element, which
will be the result of the returned effect, if successful.

To import and use `unwrapScopedWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.unwrapScopedWith
```

**Signature**

```ts
export declare const unwrapScopedWith: <A, E2, R2, E, R>(
  f: (scope: Scope.Scope) => Effect.Effect<Stream<A, E2, R2>, E, R>
) => Stream<A, E | E2, R | R2>
```


# updateService

Updates the specified service within the context of the `Stream`.

To import and use `updateService` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.updateService
```

**Signature**

```ts
export declare const updateService: {
  <I, S>(
    tag: Context.Tag<I, S>,
    f: (service: NoInfer<S>) => NoInfer<S>
  ): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, I | R>
  <A, E, R, I, S>(
    self: Stream<A, E, R>,
    tag: Context.Tag<I, S>,
    f: (service: NoInfer<S>) => NoInfer<S>
  ): Stream<A, E, I | R>
}
```


# void

A stream that contains a single `void` value.

To import and use `void` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.void
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.void

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ undefined ] }
```


# when

Returns the specified stream if the given condition is satisfied, otherwise
returns an empty stream.

To import and use `when` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.when
```

**Signature**

```ts
export declare const when: {
  (test: LazyArg<boolean>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>
  <A, E, R>(self: Stream<A, E, R>, test: LazyArg<boolean>): Stream<A, E, R>
}
```


# whenCase

Returns the resulting stream when the given `PartialFunction` is defined
for the given value, otherwise returns an empty stream.

To import and use `whenCase` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.whenCase
```

**Signature**

```ts
export declare const whenCase: <A, A2, E, R>(
  evaluate: LazyArg<A>,
  pf: (a: A) => Option.Option<Stream<A2, E, R>>
) => Stream<A2, E, R>
```


# whenCaseEffect

Returns the stream when the given partial function is defined for the given
effectful value, otherwise returns an empty stream.

To import and use `whenCaseEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.whenCaseEffect
```

**Signature**

```ts
export declare const whenCaseEffect: {
  <A, A2, E2, R2>(
    pf: (a: A) => Option.Option<Stream<A2, E2, R2>>
  ): <E, R>(self: Effect.Effect<A, E, R>) => Stream<A2, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Effect.Effect<A, E, R>,
    pf: (a: A) => Option.Option<Stream<A2, E2, R2>>
  ): Stream<A2, E | E2, R | R2>
}
```


# whenEffect

Returns the stream if the given effectful condition is satisfied, otherwise
returns an empty stream.

To import and use `whenEffect` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.whenEffect
```

**Signature**

```ts
export declare const whenEffect: {
  <E2, R2>(effect: Effect.Effect<boolean, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E, R, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>
}
```


# withSpan

Wraps the stream with a new span for tracing.

To import and use `withSpan` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.withSpan
```

**Signature**

```ts
export declare const withSpan: {
  (
    name: string,
    options?: Tracer.SpanOptions | undefined
  ): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, Exclude<R, Tracer.ParentSpan>>
  <A, E, R>(
    self: Stream<A, E, R>,
    name: string,
    options?: Tracer.SpanOptions | undefined
  ): Stream<A, E, Exclude<R, Tracer.ParentSpan>>
}
```


# zip

Zips this stream with another point-wise and emits tuples of elements from
both streams.

The new stream will end when one of the sides ends.

To import and use `zip` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zip
```

**Example**

```ts
import { Effect, Stream } from "effect"

// We create two streams and zip them together.
const stream = Stream.zip(Stream.make(1, 2, 3, 4, 5, 6), Stream.make("a", "b", "c"))

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ [ 1, 'a' ], [ 2, 'b' ], [ 3, 'c' ] ] }
```

**Signature**

```ts
export declare const zip: {
  <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<[A, A2], E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<[A, A2], E | E2, R | R2>
}
```


# zipAll

Zips this stream with another point-wise, creating a new stream of pairs of
elements from both sides.

The defaults `defaultLeft` and `defaultRight` will be used if the streams
have different lengths and one of the streams has ended before the other.

To import and use `zipAll` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipAll
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.zipAll(Stream.make(1, 2, 3, 4, 5, 6), {
  other: Stream.make("a", "b", "c"),
  defaultSelf: 0,
  defaultOther: "x"
})

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: "Chunk", values: [ [ 1, "a" ], [ 2, "b" ], [ 3, "c" ], [ 4, "x" ], [ 5, "x" ], [ 6, "x" ] ] }
```

**Signature**

```ts
export declare const zipAll: {
  <A2, E2, R2, A>(options: {
    readonly other: Stream<A2, E2, R2>
    readonly defaultSelf: A
    readonly defaultOther: A2
  }): <E, R>(self: Stream<A, E, R>) => Stream<[A, A2], E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    options: { readonly other: Stream<A2, E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2 }
  ): Stream<[A, A2], E | E2, R | R2>
}
```


# zipAllLeft

Zips this stream with another point-wise, and keeps only elements from this
stream.

The provided default value will be used if the other stream ends before
this one.

To import and use `zipAllLeft` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipAllLeft
```

**Signature**

```ts
export declare const zipAllLeft: {
  <A2, E2, R2, A>(that: Stream<A2, E2, R2>, defaultLeft: A): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, defaultLeft: A): Stream<A, E | E2, R | R2>
}
```


# zipAllRight

Zips this stream with another point-wise, and keeps only elements from the
other stream.

The provided default value will be used if this stream ends before the
other one.

To import and use `zipAllRight` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipAllRight
```

**Signature**

```ts
export declare const zipAllRight: {
  <A2, E2, R2>(
    that: Stream<A2, E2, R2>,
    defaultRight: A2
  ): <A, E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, defaultRight: A2): Stream<A2, E | E2, R | R2>
}
```


# zipAllSortedByKey

Zips this stream that is sorted by distinct keys and the specified stream
that is sorted by distinct keys to produce a new stream that is sorted by
distinct keys. Combines values associated with each key into a tuple,
using the specified values `defaultLeft` and `defaultRight` to fill in
missing values.

This allows zipping potentially unbounded streams of data by key in
constant space but the caller is responsible for ensuring that the
streams are sorted by distinct keys.

To import and use `zipAllSortedByKey` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipAllSortedByKey
```

**Signature**

```ts
export declare const zipAllSortedByKey: {
  <A2, E2, R2, A, K>(options: {
    readonly other: Stream<readonly [K, A2], E2, R2>
    readonly defaultSelf: A
    readonly defaultOther: A2
    readonly order: Order.Order<K>
  }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, [A, A2]], E2 | E, R2 | R>
  <K, A, E, R, A2, E2, R2>(
    self: Stream<readonly [K, A], E, R>,
    options: {
      readonly other: Stream<readonly [K, A2], E2, R2>
      readonly defaultSelf: A
      readonly defaultOther: A2
      readonly order: Order.Order<K>
    }
  ): Stream<[K, [A, A2]], E | E2, R | R2>
}
```


# zipAllSortedByKeyLeft

Zips this stream that is sorted by distinct keys and the specified stream
that is sorted by distinct keys to produce a new stream that is sorted by
distinct keys. Keeps only values from this stream, using the specified
value `default` to fill in missing values.

This allows zipping potentially unbounded streams of data by key in
constant space but the caller is responsible for ensuring that the
streams are sorted by distinct keys.

To import and use `zipAllSortedByKeyLeft` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipAllSortedByKeyLeft
```

**Signature**

```ts
export declare const zipAllSortedByKeyLeft: {
  <A2, E2, R2, A, K>(options: {
    readonly other: Stream<readonly [K, A2], E2, R2>
    readonly defaultSelf: A
    readonly order: Order.Order<K>
  }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A], E2 | E, R2 | R>
  <K, A, E, R, A2, E2, R2>(
    self: Stream<readonly [K, A], E, R>,
    options: {
      readonly other: Stream<readonly [K, A2], E2, R2>
      readonly defaultSelf: A
      readonly order: Order.Order<K>
    }
  ): Stream<[K, A], E | E2, R | R2>
}
```


# zipAllSortedByKeyRight

Zips this stream that is sorted by distinct keys and the specified stream
that is sorted by distinct keys to produce a new stream that is sorted by
distinct keys. Keeps only values from that stream, using the specified
value `default` to fill in missing values.

This allows zipping potentially unbounded streams of data by key in
constant space but the caller is responsible for ensuring that the
streams are sorted by distinct keys.

To import and use `zipAllSortedByKeyRight` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipAllSortedByKeyRight
```

**Signature**

```ts
export declare const zipAllSortedByKeyRight: {
  <K, A2, E2, R2>(options: {
    readonly other: Stream<readonly [K, A2], E2, R2>
    readonly defaultOther: A2
    readonly order: Order.Order<K>
  }): <A, E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A2], E2 | E, R2 | R>
  <A, E, R, K, A2, E2, R2>(
    self: Stream<readonly [K, A], E, R>,
    options: {
      readonly other: Stream<readonly [K, A2], E2, R2>
      readonly defaultOther: A2
      readonly order: Order.Order<K>
    }
  ): Stream<[K, A2], E | E2, R | R2>
}
```


# zipAllSortedByKeyWith

Zips this stream that is sorted by distinct keys and the specified stream
that is sorted by distinct keys to produce a new stream that is sorted by
distinct keys. Uses the functions `left`, `right`, and `both` to handle
the cases where a key and value exist in this stream, that stream, or
both streams.

This allows zipping potentially unbounded streams of data by key in
constant space but the caller is responsible for ensuring that the
streams are sorted by distinct keys.

To import and use `zipAllSortedByKeyWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipAllSortedByKeyWith
```

**Signature**

```ts
export declare const zipAllSortedByKeyWith: {
  <K, A2, E2, R2, A, A3>(options: {
    readonly other: Stream<readonly [K, A2], E2, R2>
    readonly onSelf: (a: A) => A3
    readonly onOther: (a2: A2) => A3
    readonly onBoth: (a: A, a2: A2) => A3
    readonly order: Order.Order<K>
  }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A3], E2 | E, R2 | R>
  <K, A, E, R, A2, E2, R2, A3>(
    self: Stream<readonly [K, A], E, R>,
    options: {
      readonly other: Stream<readonly [K, A2], E2, R2>
      readonly onSelf: (a: A) => A3
      readonly onOther: (a2: A2) => A3
      readonly onBoth: (a: A, a2: A2) => A3
      readonly order: Order.Order<K>
    }
  ): Stream<[K, A3], E | E2, R | R2>
}
```


# zipAllWith

Zips this stream with another point-wise. The provided functions will be
used to create elements for the composed stream.

The functions `left` and `right` will be used if the streams have different
lengths and one of the streams has ended before the other.

To import and use `zipAllWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipAllWith
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.zipAllWith(Stream.make(1, 2, 3, 4, 5, 6), {
  other: Stream.make("a", "b", "c"),
  onSelf: (n) => [n, "x"],
  onOther: (s) => [0, s],
  onBoth: (n, s) => [n - s.length, s]
})

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: "Chunk", values: [ [ 0, "a" ], [ 1, "b" ], [ 2, "c" ], [ 4, "x" ], [ 5, "x" ], [ 6, "x" ] ] }
```

**Signature**

```ts
export declare const zipAllWith: {
  <A2, E2, R2, A, A3>(options: {
    readonly other: Stream<A2, E2, R2>
    readonly onSelf: (a: A) => A3
    readonly onOther: (a2: A2) => A3
    readonly onBoth: (a: A, a2: A2) => A3
  }): <E, R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2, A3>(
    self: Stream<A, E, R>,
    options: {
      readonly other: Stream<A2, E2, R2>
      readonly onSelf: (a: A) => A3
      readonly onOther: (a2: A2) => A3
      readonly onBoth: (a: A, a2: A2) => A3
    }
  ): Stream<A3, E | E2, R | R2>
}
```


# zipFlatten

Zips this stream with another point-wise and emits tuples of elements from
both streams.

The new stream will end when one of the sides ends.

To import and use `zipFlatten` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipFlatten
```

**Signature**

```ts
export declare const zipFlatten: {
  <A2, E2, R2>(
    that: Stream<A2, E2, R2>
  ): <A extends ReadonlyArray<any>, E, R>(self: Stream<A, E, R>) => Stream<[...A, A2], E2 | E, R2 | R>
  <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(
    self: Stream<A, E, R>,
    that: Stream<A2, E2, R2>
  ): Stream<[...A, A2], E | E2, R | R2>
}
```


# zipLatest

Zips the two streams so that when a value is emitted by either of the two
streams, it is combined with the latest value from the other stream to
produce a result.

Note: tracking the latest value is done on a per-chunk basis. That means
that emitted elements that are not the last value in chunks will never be
used for zipping.

To import and use `zipLatest` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipLatest
```

**Example**

```ts
import { Effect, Schedule, Stream } from "effect"

const s1 = Stream.make(1, 2, 3).pipe(Stream.schedule(Schedule.spaced("1 second")))

const s2 = Stream.make("a", "b", "c", "d").pipe(Stream.schedule(Schedule.spaced("500 millis")))

const stream = Stream.zipLatest(s1, s2)

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: "Chunk", values: [ [ 1, "a" ], [ 1, "b" ], [ 2, "b" ], [ 2, "c" ], [ 2, "d" ], [ 3, "d" ] ] }
```

**Signature**

```ts
export declare const zipLatest: {
  <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<[AL, AR], EL | ER, RL | RR>
  <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<[AL, AR], EL | ER, RL | RR>
}
```


# zipLatestAll

Zips multiple streams so that when a value is emitted by any of the streams,
it is combined with the latest values from the other streams to produce a result.

Note: tracking the latest value is done on a per-chunk basis. That means
that emitted elements that are not the last value in chunks will never be
used for zipping.

To import and use `zipLatestAll` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipLatestAll
```

**Example**

```ts
import { Stream, Schedule, Console, Effect } from "effect"

const stream = Stream.zipLatestAll(
  Stream.fromSchedule(Schedule.spaced("1 millis")),
  Stream.fromSchedule(Schedule.spaced("2 millis")),
  Stream.fromSchedule(Schedule.spaced("4 millis"))
).pipe(Stream.take(6), Stream.tap(Console.log))

// Effect.runPromise(Stream.runDrain(stream))
// Output:
// [ 0, 0, 0 ]
// [ 1, 0, 0 ]
// [ 1, 1, 0 ]
// [ 2, 1, 0 ]
// [ 3, 1, 0 ]
// [ 3, 1, 1 ]
// .....
```

**Signature**

```ts
export declare const zipLatestAll: <T extends ReadonlyArray<Stream<any, any, any>>>(
  ...streams: T
) => Stream<
  [T[number]] extends [never]
    ? never
    : { [K in keyof T]: T[K] extends Stream<infer A, infer _E, infer _R> ? A : never },
  [T[number]] extends [never] ? never : T[number] extends Stream<infer _A, infer _E, infer _R> ? _E : never,
  [T[number]] extends [never] ? never : T[number] extends Stream<infer _A, infer _E, infer _R> ? _R : never
>
```


# zipLatestWith

Zips the two streams so that when a value is emitted by either of the two
streams, it is combined with the latest value from the other stream to
produce a result.

Note: tracking the latest value is done on a per-chunk basis. That means
that emitted elements that are not the last value in chunks will never be
used for zipping.

To import and use `zipLatestWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipLatestWith
```

**Signature**

```ts
export declare const zipLatestWith: {
  <AR, ER, RR, AL, A>(
    right: Stream<AR, ER, RR>,
    f: (left: AL, right: AR) => A
  ): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>
  <AL, EL, RL, AR, ER, RR, A>(
    left: Stream<AL, EL, RL>,
    right: Stream<AR, ER, RR>,
    f: (left: AL, right: AR) => A
  ): Stream<A, EL | ER, RL | RR>
}
```


# zipLeft

Zips this stream with another point-wise, but keeps only the outputs of
`left` stream.

The new stream will end when one of the sides ends.

To import and use `zipLeft` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipLeft
```

**Signature**

```ts
export declare const zipLeft: {
  <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, ER | EL, RR | RL>
  <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>
}
```


# zipRight

Zips this stream with another point-wise, but keeps only the outputs of the
`right` stream.

The new stream will end when one of the sides ends.

To import and use `zipRight` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipRight
```

**Signature**

```ts
export declare const zipRight: {
  <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, ER | EL, RR | RL>
  <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>
}
```


# zipWith

Zips this stream with another point-wise and applies the function to the
paired elements.

The new stream will end when one of the sides ends.

To import and use `zipWith` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipWith
```

**Example**

```ts
import { Effect, Stream } from "effect"

// We create two streams and zip them with custom logic.
const stream = Stream.zipWith(Stream.make(1, 2, 3, 4, 5, 6), Stream.make("a", "b", "c"), (n, s) => [n - s.length, s])

// Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ [ 0, 'a' ], [ 1, 'b' ], [ 2, 'c' ] ] }
```

**Signature**

```ts
export declare const zipWith: {
  <AR, ER, RR, AL, A>(
    right: Stream<AR, ER, RR>,
    f: (left: AL, right: AR) => A
  ): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>
  <AL, EL, RL, AR, ER, RR, A>(
    left: Stream<AL, EL, RL>,
    right: Stream<AR, ER, RR>,
    f: (left: AL, right: AR) => A
  ): Stream<A, EL | ER, RL | RR>
}
```


# zipWithChunks

Zips this stream with another point-wise and applies the function to the
paired elements.

The new stream will end when one of the sides ends.

To import and use `zipWithChunks` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipWithChunks
```

**Signature**

```ts
export declare const zipWithChunks: {
  <A2, E2, R2, A, A3>(
    that: Stream<A2, E2, R2>,
    f: (
      left: Chunk.Chunk<A>,
      right: Chunk.Chunk<A2>
    ) => readonly [Chunk.Chunk<A3>, Either.Either<Chunk.Chunk<A2>, Chunk.Chunk<A>>]
  ): <E, R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R>
  <A, E, R, A2, E2, R2, A3>(
    self: Stream<A, E, R>,
    that: Stream<A2, E2, R2>,
    f: (
      left: Chunk.Chunk<A>,
      right: Chunk.Chunk<A2>
    ) => readonly [Chunk.Chunk<A3>, Either.Either<Chunk.Chunk<A2>, Chunk.Chunk<A>>]
  ): Stream<A3, E | E2, R | R2>
}
```


# zipWithIndex

Zips this stream together with the index of elements.

To import and use `zipWithIndex` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipWithIndex
```

**Example**

```ts
import { Effect, Stream } from "effect"

const stream = Stream.make("Mary", "James", "Robert", "Patricia")

const indexedStream = Stream.zipWithIndex(stream)

// Effect.runPromise(Stream.runCollect(indexedStream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [ [ 'Mary', 0 ], [ 'James', 1 ], [ 'Robert', 2 ], [ 'Patricia', 3 ] ]
// }
```

**Signature**

```ts
export declare const zipWithIndex: <A, E, R>(self: Stream<A, E, R>) => Stream<[A, number], E, R>
```


# zipWithNext

Zips each element with the next element if present.

To import and use `zipWithNext` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipWithNext
```

**Example**

```ts
import { Chunk, Effect, Stream } from "effect"

const stream = Stream.zipWithNext(Stream.make(1, 2, 3, 4))

// Effect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))
// [
//   [ 1, { _id: 'Option', _tag: 'Some', value: 2 } ],
//   [ 2, { _id: 'Option', _tag: 'Some', value: 3 } ],
//   [ 3, { _id: 'Option', _tag: 'Some', value: 4 } ],
//   [ 4, { _id: 'Option', _tag: 'None' } ]
// ]
```

**Signature**

```ts
export declare const zipWithNext: <A, E, R>(self: Stream<A, E, R>) => Stream<[A, Option.Option<A>], E, R>
```


# zipWithPrevious

Zips each element with the previous element. Initially accompanied by
`None`.

To import and use `zipWithPrevious` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipWithPrevious
```

**Example**

```ts
import { Chunk, Effect, Stream } from "effect"

const stream = Stream.zipWithPrevious(Stream.make(1, 2, 3, 4))

// Effect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))
// [
//   [ { _id: 'Option', _tag: 'None' }, 1 ],
//   [ { _id: 'Option', _tag: 'Some', value: 1 }, 2 ],
//   [ { _id: 'Option', _tag: 'Some', value: 2 }, 3 ],
//   [ { _id: 'Option', _tag: 'Some', value: 3 }, 4 ]
// ]
```

**Signature**

```ts
export declare const zipWithPrevious: <A, E, R>(self: Stream<A, E, R>) => Stream<[Option.Option<A>, A], E, R>
```


# zipWithPreviousAndNext

Zips each element with both the previous and next element.

To import and use `zipWithPreviousAndNext` from the "Stream" module:

```ts
import * as Stream from "effect/Stream"
// Can be accessed like this
Stream.zipWithPreviousAndNext
```

**Example**

```ts
import { Chunk, Effect, Stream } from "effect"

const stream = Stream.zipWithPreviousAndNext(Stream.make(1, 2, 3, 4))

// Effect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))
// [
//   [
//     { _id: 'Option', _tag: 'None' },
//     1,
//     { _id: 'Option', _tag: 'Some', value: 2 }
//   ],
//   [
//     { _id: 'Option', _tag: 'Some', value: 1 },
//     2,
//     { _id: 'Option', _tag: 'Some', value: 3 }
//   ],
//   [
//     { _id: 'Option', _tag: 'Some', value: 2 },
//     3,
//     { _id: 'Option', _tag: 'Some', value: 4 }
//   ],
//   [
//     { _id: 'Option', _tag: 'Some', value: 3 },
//     4,
//     { _id: 'Option', _tag: 'None' }
//   ]
// ]
```

**Signature**

```ts
export declare const zipWithPreviousAndNext: <A, E, R>(
  self: Stream<A, E, R>
) => Stream<[Option.Option<A>, A, Option.Option<A>], E, R>
```


# Emit

An `Emit<R, E, A, B>` represents an asynchronous callback that can be
called multiple times. The callback can be called with a value of type
`Effect<Chunk<A>, Option<E>, R>`, where succeeding with a `Chunk<A>`
indicates to emit those elements, failing with `Some<E>` indicates to
terminate with that error, and failing with `None` indicates to terminate
with an end of stream signal.

To import and use `Emit` from the "StreamEmit" module:

```ts
import * as StreamEmit from "effect/StreamEmit"
// Can be accessed like this
StreamEmit.Emit
```


# match

Folds over the specified `HaltStrategy` using the provided case functions.

To import and use `match` from the "StreamHaltStrategy" module:

```ts
import * as StreamHaltStrategy from "effect/StreamHaltStrategy"
// Can be accessed like this
StreamHaltStrategy.match
```

**Signature**

```ts
export declare const match: {
  <Z>(options: {
    readonly onLeft: () => Z
    readonly onRight: () => Z
    readonly onBoth: () => Z
    readonly onEither: () => Z
  }): (self: HaltStrategy) => Z
  <Z>(
    self: HaltStrategy,
    options: {
      readonly onLeft: () => Z
      readonly onRight: () => Z
      readonly onBoth: () => Z
      readonly onEither: () => Z
    }
  ): Z
}
```


# concat

Concatenates two strings at runtime.

To import and use `concat` from the "String" module:

```ts
import * as String from "effect/String"
// Can be accessed like this
String.concat
```

**Signature**

```ts
export declare const concat: {
  <B extends string>(that: B): <A extends string>(self: A) => Concat<A, B>
  <A extends string, B extends string>(self: A, that: B): Concat<A, B>
}
```


# Concat

Concatenates two strings at the type level.

To import and use `Concat` from the "String" module:

```ts
import * as String from "effect/String"
// Can be accessed like this
String.Concat
```


# empty

The empty string `""`.

To import and use `empty` from the "String" module:

```ts
import * as String from "effect/String"
// Can be accessed like this
String.empty
```

**Signature**

```ts
export declare const empty: ""
```


# includes

Returns `true` if `searchString` appears as a substring of `self`, at one or more positions that are
greater than or equal to `position`; otherwise, returns `false`.

To import and use `includes` from the "String" module:

```ts
import * as String from "effect/String"
// Can be accessed like this
String.includes
```

**Signature**

```ts
export declare const includes: (searchString: string, position?: number) => (self: string) => boolean
```


# isEmpty

Test whether a `string` is empty.

To import and use `isEmpty` from the "String" module:

```ts
import * as String from "effect/String"
// Can be accessed like this
String.isEmpty
```

**Example**

```ts
import { String } from "effect"

assert.deepStrictEqual(String.isEmpty(""), true)
assert.deepStrictEqual(String.isEmpty("a"), false)
```

**Signature**

```ts
export declare const isEmpty: (self: string) => self is ""
```


# isNonEmpty

Test whether a `string` is non empty.

To import and use `isNonEmpty` from the "String" module:

```ts
import * as String from "effect/String"
// Can be accessed like this
String.isNonEmpty
```

**Signature**

```ts
export declare const isNonEmpty: (self: string) => boolean
```


# isString

Tests if a value is a `string`.

To import and use `isString` from the "String" module:

```ts
import * as String from "effect/String"
// Can be accessed like this
String.isString
```

**Example**

```ts
import { String } from "effect"

assert.deepStrictEqual(String.isString("a"), true)
assert.deepStrictEqual(String.isString(1), false)
```

**Signature**

```ts
export declare const isString: Refinement<unknown, string>
```


# length

Calculate the number of characters in a `string`.

To import and use `length` from the "String" module:

```ts
import * as String from "effect/String"
// Can be accessed like this
String.length
```

**Example**

```ts
import { String } from "effect"

assert.deepStrictEqual(String.length("abc"), 3)
```

**Signature**

```ts
export declare const length: (self: string) => number
```


# linesIterator

Returns an `IterableIterator` which yields each line contained within the
string, trimming off the trailing newline character.

To import and use `linesIterator` from the "String" module:

```ts
import * as String from "effect/String"
// Can be accessed like this
String.linesIterator
```

**Signature**

```ts
export declare const linesIterator: (self: string) => LinesIterator
```


# linesWithSeparators

Returns an `IterableIterator` which yields each line contained within the
string as well as the trailing newline character.

To import and use `linesWithSeparators` from the "String" module:

```ts
import * as String from "effect/String"
// Can be accessed like this
String.linesWithSeparators
```

**Signature**

```ts
export declare const linesWithSeparators: (s: string) => LinesIterator
```


# match

It is the `pipe`-able version of the native `match` method.

To import and use `match` from the "String" module:

```ts
import * as String from "effect/String"
// Can be accessed like this
String.match
```

**Signature**

```ts
export declare const match: (regexp: RegExp | string) => (self: string) => Option.Option<RegExpMatchArray>
```


# matchAll

It is the `pipe`-able version of the native `matchAll` method.

To import and use `matchAll` from the "String" module:

```ts
import * as String from "effect/String"
// Can be accessed like this
String.matchAll
```

**Signature**

```ts
export declare const matchAll: (regexp: RegExp) => (self: string) => IterableIterator<RegExpMatchArray>
```


# stripMargin

For every line in this string, strip a leading prefix consisting of blanks
or control characters followed by the `"|"` character from the line.

To import and use `stripMargin` from the "String" module:

```ts
import * as String from "effect/String"
// Can be accessed like this
String.stripMargin
```

**Signature**

```ts
export declare const stripMargin: (self: string) => string
```


# stripMarginWith

For every line in this string, strip a leading prefix consisting of blanks
or control characters followed by the character specified by `marginChar`
from the line.

To import and use `stripMarginWith` from the "String" module:

```ts
import * as String from "effect/String"
// Can be accessed like this
String.stripMarginWith
```

**Signature**

```ts
export declare const stripMarginWith: {
  (marginChar: string): (self: string) => string
  (self: string, marginChar: string): string
}
```


# takeLeft

Keep the specified number of characters from the start of a string.

If `n` is larger than the available number of characters, the string will
be returned whole.

If `n` is not a positive number, an empty string will be returned.

If `n` is a float, it will be rounded down to the nearest integer.

To import and use `takeLeft` from the "String" module:

```ts
import * as String from "effect/String"
// Can be accessed like this
String.takeLeft
```

**Example**

```ts
import { String } from "effect"

assert.deepStrictEqual(String.takeLeft("Hello World", 5), "Hello")
```

**Signature**

```ts
export declare const takeLeft: { (n: number): (self: string) => string; (self: string, n: number): string }
```


# takeRight

Keep the specified number of characters from the end of a string.

If `n` is larger than the available number of characters, the string will
be returned whole.

If `n` is not a positive number, an empty string will be returned.

If `n` is a float, it will be rounded down to the nearest integer.

To import and use `takeRight` from the "String" module:

```ts
import * as String from "effect/String"
// Can be accessed like this
String.takeRight
```

**Example**

```ts
import { String } from "effect"

assert.deepStrictEqual(String.takeRight("Hello World", 5), "World")
```

**Signature**

```ts
export declare const takeRight: { (n: number): (self: string) => string; (self: string, n: number): string }
```


# evolve

Transforms the values of a Struct provided a transformation function for each key.
If no transformation function is provided for a key, it will return the origional value for that key.

To import and use `evolve` from the "Struct" module:

```ts
import * as Struct from "effect/Struct"
// Can be accessed like this
Struct.evolve
```

**Example**

```ts
import { pipe, Struct } from "effect"

assert.deepStrictEqual(
  pipe(
    { a: "a", b: 1, c: 3 },
    Struct.evolve({
      a: (a) => a.length,
      b: (b) => b * 2
    })
  ),
  { a: 1, b: 2, c: 3 }
)
```

**Signature**

```ts
export declare const evolve: {
  <O, T>(t: PartialTransform<O, T>): (obj: O) => Transformed<O, T>
  <O, T>(obj: O, t: PartialTransform<O, T>): Transformed<O, T>
}
```


# get

Retrieves the value associated with the specified key from a struct.

To import and use `get` from the "Struct" module:

```ts
import * as Struct from "effect/Struct"
// Can be accessed like this
Struct.get
```

**Example**

```ts
import { pipe, Struct } from "effect"

const value = pipe({ a: 1, b: 2 }, Struct.get("a"))

assert.deepStrictEqual(value, 1)
```

**Signature**

```ts
export declare const get: <K extends PropertyKey>(
  key: K
) => <S extends { [P in K]?: any }>(s: S) => MatchRecord<S, S[K] | undefined, S[K]>
```


# getEquivalence

Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct
by applying each `Equivalence` to the corresponding property of the struct.

Alias of {@link Equivalence.struct}.

To import and use `getEquivalence` from the "Struct" module:

```ts
import * as Struct from "effect/Struct"
// Can be accessed like this
Struct.getEquivalence
```

**Example**

```ts
import { Struct, String, Number } from "effect"

const PersonEquivalence = Struct.getEquivalence({
  name: String.Equivalence,
  age: Number.Equivalence
})

assert.deepStrictEqual(PersonEquivalence({ name: "John", age: 25 }, { name: "John", age: 25 }), true)
assert.deepStrictEqual(PersonEquivalence({ name: "John", age: 25 }, { name: "John", age: 40 }), false)
```

**Signature**

```ts
export declare const getEquivalence: <R extends Record<string, Equivalence.Equivalence<any>>>(
  isEquivalents: R
) => Equivalence.Equivalence<{ readonly [K in keyof R]: [R[K]] extends [Equivalence.Equivalence<infer A>] ? A : never }>
```


# getOrder

This function creates and returns a new `Order` for a struct of values based on the given `Order`s
for each property in the struct.

Alias of {@link order.struct}.

To import and use `getOrder` from the "Struct" module:

```ts
import * as Struct from "effect/Struct"
// Can be accessed like this
Struct.getOrder
```

**Signature**

```ts
export declare const getOrder: <R extends { readonly [x: string]: order.Order<any> }>(
  fields: R
) => order.Order<{ [K in keyof R]: [R[K]] extends [order.Order<infer A>] ? A : never }>
```


# keys

Retrieves the object keys that are strings in a typed manner

To import and use `keys` from the "Struct" module:

```ts
import * as Struct from "effect/Struct"
// Can be accessed like this
Struct.keys
```

**Example**

```ts
import { Struct } from "effect"

const symbol: unique symbol = Symbol()

const value = {
  a: 1,
  b: 2,
  [symbol]: 3
}

const keys: Array<"a" | "b"> = Struct.keys(value)

assert.deepStrictEqual(keys, ["a", "b"])
```

**Signature**

```ts
export declare const keys: <T extends {}>(o: T) => Array<keyof T & string>
```


# omit

Create a new object by omitting properties of an existing object.

To import and use `omit` from the "Struct" module:

```ts
import * as Struct from "effect/Struct"
// Can be accessed like this
Struct.omit
```

**Example**

```ts
import { pipe, Struct } from "effect"

assert.deepStrictEqual(pipe({ a: "a", b: 1, c: true }, Struct.omit("c")), { a: "a", b: 1 })
assert.deepStrictEqual(Struct.omit({ a: "a", b: 1, c: true }, "c"), { a: "a", b: 1 })
```

**Signature**

```ts
export declare const omit: {
  <Keys extends Array<PropertyKey>>(
    ...keys: Keys
  ): <S extends { [K in Keys[number]]?: any }>(s: S) => Simplify<Omit<S, Keys[number]>>
  <S extends object, Keys extends Array<keyof S>>(s: S, ...keys: Keys): Simplify<Omit<S, Keys[number]>>
}
```


# pick

Create a new object by picking properties of an existing object.

To import and use `pick` from the "Struct" module:

```ts
import * as Struct from "effect/Struct"
// Can be accessed like this
Struct.pick
```

**Example**

```ts
import { pipe, Struct } from "effect"

assert.deepStrictEqual(pipe({ a: "a", b: 1, c: true }, Struct.pick("a", "b")), { a: "a", b: 1 })
assert.deepStrictEqual(Struct.pick({ a: "a", b: 1, c: true }, "a", "b"), { a: "a", b: 1 })
```

**Signature**

```ts
export declare const pick: {
  <Keys extends Array<PropertyKey>>(
    ...keys: Keys
  ): <S extends { [K in Keys[number]]?: any }>(
    s: S
  ) => MatchRecord<S, { [K in Keys[number]]?: S[K] }, Simplify<Pick<S, Keys[number]>>>
  <S extends object, Keys extends Array<keyof S>>(
    s: S,
    ...keys: Keys
  ): MatchRecord<S, { [K in Keys[number]]?: S[K] }, Simplify<Pick<S, Keys[number]>>>
}
```


# make

Creates a new `SubscriptionRef` with the specified value.

To import and use `make` from the "SubscriptionRef" module:

```ts
import * as SubscriptionRef from "effect/SubscriptionRef"
// Can be accessed like this
SubscriptionRef.make
```

**Signature**

```ts
export declare const make: <A>(value: A) => Effect.Effect<SubscriptionRef<A>>
```


# SubscriptionRef

A `SubscriptionRef<A>` is a `Ref` that can be subscribed to in order to
receive the current value as well as all changes to the value.

To import and use `SubscriptionRef` from the "SubscriptionRef" module:

```ts
import * as SubscriptionRef from "effect/SubscriptionRef"
// Can be accessed like this
SubscriptionRef.SubscriptionRef
```


# fibersIn

Creates a new supervisor that tracks children in a set.

To import and use `fibersIn` from the "Supervisor" module:

```ts
import * as Supervisor from "effect/Supervisor"
// Can be accessed like this
Supervisor.fibersIn
```

**Signature**

```ts
export declare const fibersIn: (
  ref: MutableRef.MutableRef<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>>
) => Effect.Effect<Supervisor<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>>>
```


# fromEffect

Creates a new supervisor that constantly yields effect when polled

To import and use `fromEffect` from the "Supervisor" module:

```ts
import * as Supervisor from "effect/Supervisor"
// Can be accessed like this
Supervisor.fromEffect
```

**Signature**

```ts
export declare const fromEffect: <A>(effect: Effect.Effect<A>) => Supervisor<A>
```


# none

A supervisor that doesn't do anything in response to supervision events.

To import and use `none` from the "Supervisor" module:

```ts
import * as Supervisor from "effect/Supervisor"
// Can be accessed like this
Supervisor.none
```

**Signature**

```ts
export declare const none: Supervisor<void>
```


# track

Creates a new supervisor that tracks children in a set.

To import and use `track` from the "Supervisor" module:

```ts
import * as Supervisor from "effect/Supervisor"
// Can be accessed like this
Supervisor.track
```

**Signature**

```ts
export declare const track: Effect.Effect<Supervisor<Fiber.RuntimeFiber<any, any>[]>, never, never>
```


# unsafeTrack

Unsafely creates a new supervisor that tracks children in a set.

To import and use `unsafeTrack` from the "Supervisor" module:

```ts
import * as Supervisor from "effect/Supervisor"
// Can be accessed like this
Supervisor.unsafeTrack
```

**Signature**

```ts
export declare const unsafeTrack: () => Supervisor<Array<Fiber.RuntimeFiber<any, any>>>
```


# isSymbol

Tests if a value is a `symbol`.

To import and use `isSymbol` from the "Symbol" module:

```ts
import * as Symbol from "effect/Symbol"
// Can be accessed like this
Symbol.isSymbol
```

**Example**

```ts
import { Predicate } from "effect"

assert.deepStrictEqual(Predicate.isSymbol(Symbol.for("a")), true)
assert.deepStrictEqual(Predicate.isSymbol("a"), false)
```

**Signature**

```ts
export declare const isSymbol: (u: unknown) => u is symbol
```


# chunk

Creates a `Take` with the specified chunk.

To import and use `chunk` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.chunk
```

**Signature**

```ts
export declare const chunk: <A>(chunk: Chunk.Chunk<A>) => Take<A>
```


# die

Creates a failing `Take` with the specified defect.

To import and use `die` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.die
```

**Signature**

```ts
export declare const die: (defect: unknown) => Take<never>
```


# dieMessage

Creates a failing `Take` with the specified error message.

To import and use `dieMessage` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.dieMessage
```

**Signature**

```ts
export declare const dieMessage: (message: string) => Take<never>
```


# done

Transforms a `Take<A, E>` to an `Effect<A, E>`.

To import and use `done` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.done
```

**Signature**

```ts
export declare const done: <A, E>(self: Take<A, E>) => Effect.Effect<Chunk.Chunk<A>, Option.Option<E>>
```


# end

Represents the end-of-stream marker.

To import and use `end` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.end
```

**Signature**

```ts
export declare const end: Take<never, never>
```


# fail

Creates a failing `Take` with the specified error.

To import and use `fail` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.fail
```

**Signature**

```ts
export declare const fail: <E>(error: E) => Take<never, E>
```


# failCause

Creates a failing `Take` with the specified cause.

To import and use `failCause` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.failCause
```

**Signature**

```ts
export declare const failCause: <E>(cause: Cause.Cause<E>) => Take<never, E>
```


# fromEffect

Creates an effect from `Effect<A, E, R>` that does not fail, but succeeds with
the `Take<A, E>`. Error from stream when pulling is converted to
`Take.failCause`. Creates a single value chunk.

To import and use `fromEffect` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.fromEffect
```

**Signature**

```ts
export declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<Take<A, E>, never, R>
```


# fromExit

Creates a `Take` from an `Exit`.

To import and use `fromExit` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.fromExit
```

**Signature**

```ts
export declare const fromExit: <A, E>(exit: Exit.Exit<A, E>) => Take<A, E>
```


# fromPull

Creates effect from `Effect<Chunk<A>, Option<E>, R>` that does not fail, but
succeeds with the `Take<A, E>`. Errors from stream when pulling are converted
to `Take.failCause`, and the end-of-stream is converted to `Take.end`.

To import and use `fromPull` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.fromPull
```

**Signature**

```ts
export declare const fromPull: <A, E, R>(
  pull: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>
) => Effect.Effect<Take<A, E>, never, R>
```


# isDone

Checks if this `take` is done (`Take.end`).

To import and use `isDone` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.isDone
```

**Signature**

```ts
export declare const isDone: <A, E>(self: Take<A, E>) => boolean
```


# isFailure

Checks if this `take` is a failure.

To import and use `isFailure` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.isFailure
```

**Signature**

```ts
export declare const isFailure: <A, E>(self: Take<A, E>) => boolean
```


# isSuccess

Checks if this `take` is a success.

To import and use `isSuccess` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.isSuccess
```

**Signature**

```ts
export declare const isSuccess: <A, E>(self: Take<A, E>) => boolean
```


# make

Constructs a `Take`.

To import and use `make` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.make
```

**Signature**

```ts
export declare const make: <A, E>(exit: Exit.Exit<Chunk.Chunk<A>, Option.Option<E>>) => Take<A, E>
```


# map

Transforms `Take<A, E>` to `Take<B, A>` by applying function `f`.

To import and use `map` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.map
```

**Signature**

```ts
export declare const map: {
  <A, B>(f: (a: A) => B): <E>(self: Take<A, E>) => Take<B, E>
  <A, E, B>(self: Take<A, E>, f: (a: A) => B): Take<B, E>
}
```


# match

Folds over the failure cause, success value and end-of-stream marker to
yield a value.

To import and use `match` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.match
```

**Signature**

```ts
export declare const match: {
  <Z, E, Z2, A, Z3>(options: {
    readonly onEnd: () => Z
    readonly onFailure: (cause: Cause.Cause<E>) => Z2
    readonly onSuccess: (chunk: Chunk.Chunk<A>) => Z3
  }): (self: Take<A, E>) => Z | Z2 | Z3
  <A, E, Z, Z2, Z3>(
    self: Take<A, E>,
    options: {
      readonly onEnd: () => Z
      readonly onFailure: (cause: Cause.Cause<E>) => Z2
      readonly onSuccess: (chunk: Chunk.Chunk<A>) => Z3
    }
  ): Z | Z2 | Z3
}
```


# matchEffect

Effectful version of `Take.fold`.

Folds over the failure cause, success value and end-of-stream marker to
yield an effect.

To import and use `matchEffect` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.matchEffect
```

**Signature**

```ts
export declare const matchEffect: {
  <Z, E2, R, E, Z2, R2, A, Z3, E3, R3>(options: {
    readonly onEnd: Effect.Effect<Z, E2, R>
    readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<Z2, E2, R2>
    readonly onSuccess: (chunk: Chunk.Chunk<A>) => Effect.Effect<Z3, E3, R3>
  }): (self: Take<A, E>) => Effect.Effect<Z | Z2 | Z3, E2 | E | E3, R | R2 | R3>
  <A, E, Z, E2, R, Z2, R2, Z3, E3, R3>(
    self: Take<A, E>,
    options: {
      readonly onEnd: Effect.Effect<Z, E2, R>
      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<Z2, E2, R2>
      readonly onSuccess: (chunk: Chunk.Chunk<A>) => Effect.Effect<Z3, E3, R3>
    }
  ): Effect.Effect<Z | Z2 | Z3, E | E2 | E3, R | R2 | R3>
}
```


# of

Creates a `Take` with a single value chunk.

To import and use `of` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.of
```

**Signature**

```ts
export declare const of: <A>(value: A) => Take<A>
```


# Take

A `Take<A, E>` represents a single `take` from a queue modeling a stream of
values. A `Take` may be a failure cause `Cause<E>`, a chunk value `Chunk<A>`,
or an end-of-stream marker.

To import and use `Take` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.Take
```


# tap

Returns an effect that effectfully "peeks" at the success of this take.

To import and use `tap` from the "Take" module:

```ts
import * as Take from "effect/Take"
// Can be accessed like this
Take.tap
```

**Signature**

```ts
export declare const tap: {
  <A, X, E2, R>(
    f: (chunk: Chunk.Chunk<A>) => Effect.Effect<X, E2, R>
  ): <E>(self: Take<A, E>) => Effect.Effect<void, E2 | E, R>
  <A, E, X, E2, R>(
    self: Take<A, E>,
    f: (chunk: Chunk.Chunk<A>) => Effect.Effect<X, E2, R>
  ): Effect.Effect<void, E | E2, R>
}
```


# collectFirst

Finds the result of applying a partial function to the first value in its
domain.

To import and use `collectFirst` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.collectFirst
```

**Signature**

```ts
export declare const collectFirst: {
  <A, B>(pf: (a: A) => Option.Option<B>): (self: TArray<A>) => STM.STM<Option.Option<B>>
  <A, B>(self: TArray<A>, pf: (a: A) => Option.Option<B>): STM.STM<Option.Option<B>>
}
```


# collectFirstSTM

Finds the result of applying an transactional partial function to the first
value in its domain.

To import and use `collectFirstSTM` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.collectFirstSTM
```

**Signature**

```ts
export declare const collectFirstSTM: {
  <A, B, E, R>(pf: (a: A) => Option.Option<STM.STM<B, E, R>>): (self: TArray<A>) => STM.STM<Option.Option<B>, E, R>
  <A, B, E, R>(self: TArray<A>, pf: (a: A) => Option.Option<STM.STM<B, E, R>>): STM.STM<Option.Option<B>, E, R>
}
```


# contains

Determine if the array contains a specified value.

To import and use `contains` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.contains
```

**Signature**

```ts
export declare const contains: {
  <A>(value: A): (self: TArray<A>) => STM.STM<boolean>
  <A>(self: TArray<A>, value: A): STM.STM<boolean>
}
```


# count

Count the values in the array matching a predicate.

To import and use `count` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.count
```

**Signature**

```ts
export declare const count: {
  <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<number>
  <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<number>
}
```


# countSTM

Count the values in the array matching a transactional predicate.

To import and use `countSTM` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.countSTM
```

**Signature**

```ts
export declare const countSTM: {
  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<number, E, R>
  <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<number, E, R>
}
```


# empty

Makes an empty `TArray`.

To import and use `empty` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.empty
```

**Signature**

```ts
export declare const empty: <A>() => STM.STM<TArray<A>>
```


# every

Atomically evaluate the conjunction of a predicate across the members of
the array.

To import and use `every` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.every
```

**Signature**

```ts
export declare const every: {
  <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<boolean>
  <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<boolean>
}
```


# everySTM

Atomically evaluate the conjunction of a transactional predicate across the
members of the array.

To import and use `everySTM` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.everySTM
```

**Signature**

```ts
export declare const everySTM: {
  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<boolean, E, R>
  <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<boolean, E, R>
}
```


# findFirst

Find the first element in the array matching the specified predicate.

To import and use `findFirst` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.findFirst
```

**Signature**

```ts
export declare const findFirst: {
  <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>
  <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<A>>
}
```


# findFirstIndex

Get the first index of a specific value in the array.

To import and use `findFirstIndex` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.findFirstIndex
```

**Signature**

```ts
export declare const findFirstIndex: {
  <A>(value: A): (self: TArray<A>) => STM.STM<Option.Option<number>>
  <A>(self: TArray<A>, value: A): STM.STM<Option.Option<number>>
}
```


# findFirstIndexFrom

Get the first index of a specific value in the array starting from the
specified index.

To import and use `findFirstIndexFrom` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.findFirstIndexFrom
```

**Signature**

```ts
export declare const findFirstIndexFrom: {
  <A>(value: A, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>>
  <A>(self: TArray<A>, value: A, from: number): STM.STM<Option.Option<number>>
}
```


# findFirstIndexWhere

Get the index of the first entry in the array matching a predicate.

To import and use `findFirstIndexWhere` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.findFirstIndexWhere
```

**Signature**

```ts
export declare const findFirstIndexWhere: {
  <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<number>>
  <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<number>>
}
```


# findFirstIndexWhereFrom

Get the index of the first entry in the array starting from the specified
index, matching a predicate.

To import and use `findFirstIndexWhereFrom` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.findFirstIndexWhereFrom
```

**Signature**

```ts
export declare const findFirstIndexWhereFrom: {
  <A>(predicate: Predicate<A>, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>>
  <A>(self: TArray<A>, predicate: Predicate<A>, from: number): STM.STM<Option.Option<number>>
}
```


# findFirstIndexWhereFromSTM

Starting at specified index, get the index of the next entry that matches a
transactional predicate.

To import and use `findFirstIndexWhereFromSTM` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.findFirstIndexWhereFromSTM
```

**Signature**

```ts
export declare const findFirstIndexWhereFromSTM: {
  <A, R, E>(
    predicate: (value: A) => STM.STM<boolean, E, R>,
    from: number
  ): (self: TArray<A>) => STM.STM<Option.Option<number>, E, R>
  <A, R, E>(
    self: TArray<A>,
    predicate: (value: A) => STM.STM<boolean, E, R>,
    from: number
  ): STM.STM<Option.Option<number>, E, R>
}
```


# findFirstIndexWhereSTM

Get the index of the next entry that matches a transactional predicate.

To import and use `findFirstIndexWhereSTM` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.findFirstIndexWhereSTM
```

**Signature**

```ts
export declare const findFirstIndexWhereSTM: {
  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<number>, E, R>
  <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<number>, E, R>
}
```


# findFirstSTM

Find the first element in the array matching a transactional predicate.

To import and use `findFirstSTM` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.findFirstSTM
```

**Signature**

```ts
export declare const findFirstSTM: {
  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>
  <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<A>, E, R>
}
```


# findLast

Find the last element in the array matching a predicate.

To import and use `findLast` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.findLast
```

**Signature**

```ts
export declare const findLast: {
  <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>
  <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<A>>
}
```


# findLastIndex

Get the last index of a specific value in the array bounded above by a
specific index.

To import and use `findLastIndex` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.findLastIndex
```

**Signature**

```ts
export declare const findLastIndex: {
  <A>(value: A): (self: TArray<A>) => STM.STM<Option.Option<number>>
  <A>(self: TArray<A>, value: A): STM.STM<Option.Option<number>>
}
```


# findLastIndexFrom

Get the last index of a specific value in the array bounded above by a
specific index.

To import and use `findLastIndexFrom` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.findLastIndexFrom
```

**Signature**

```ts
export declare const findLastIndexFrom: {
  <A>(value: A, end: number): (self: TArray<A>) => STM.STM<Option.Option<number>>
  <A>(self: TArray<A>, value: A, end: number): STM.STM<Option.Option<number>>
}
```


# findLastSTM

Find the last element in the array matching a transactional predicate.

To import and use `findLastSTM` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.findLastSTM
```

**Signature**

```ts
export declare const findLastSTM: {
  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>
  <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<A>, E, R>
}
```


# forEach

Atomically performs transactional effect for each item in array.

To import and use `forEach` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.forEach
```

**Signature**

```ts
export declare const forEach: {
  <A, R, E>(f: (value: A) => STM.STM<void, E, R>): (self: TArray<A>) => STM.STM<void, E, R>
  <A, R, E>(self: TArray<A>, f: (value: A) => STM.STM<void, E, R>): STM.STM<void, E, R>
}
```


# fromIterable

Creates a new `TArray` from an iterable collection of values.

To import and use `fromIterable` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.fromIterable
```

**Signature**

```ts
export declare const fromIterable: <A>(iterable: Iterable<A>) => STM.STM<TArray<A>>
```


# get

Extracts value from ref in array.

To import and use `get` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.get
```

**Signature**

```ts
export declare const get: {
  (index: number): <A>(self: TArray<A>) => STM.STM<A>
  <A>(self: TArray<A>, index: number): STM.STM<A>
}
```


# headOption

The first entry of the array, if it exists.

To import and use `headOption` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.headOption
```

**Signature**

```ts
export declare const headOption: <A>(self: TArray<A>) => STM.STM<Option.Option<A>>
```


# lastOption

The last entry in the array, if it exists.

To import and use `lastOption` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.lastOption
```

**Signature**

```ts
export declare const lastOption: <A>(self: TArray<A>) => STM.STM<Option.Option<A>>
```


# make

Makes a new `TArray` that is initialized with specified values.

To import and use `make` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.make
```

**Signature**

```ts
export declare const make: <Elements extends [any, ...Array<any>]>(
  ...elements: Elements
) => STM.STM<TArray<Elements[number]>>
```


# maxOption

Atomically compute the greatest element in the array, if it exists.

To import and use `maxOption` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.maxOption
```

**Signature**

```ts
export declare const maxOption: {
  <A>(order: Order.Order<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>
  <A>(self: TArray<A>, order: Order.Order<A>): STM.STM<Option.Option<A>>
}
```


# minOption

Atomically compute the least element in the array, if it exists.

To import and use `minOption` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.minOption
```

**Signature**

```ts
export declare const minOption: {
  <A>(order: Order.Order<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>
  <A>(self: TArray<A>, order: Order.Order<A>): STM.STM<Option.Option<A>>
}
```


# reduce

Atomically folds using a pure function.

To import and use `reduce` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.reduce
```

**Signature**

```ts
export declare const reduce: {
  <Z, A>(zero: Z, f: (accumulator: Z, current: A) => Z): (self: TArray<A>) => STM.STM<Z>
  <Z, A>(self: TArray<A>, zero: Z, f: (accumulator: Z, current: A) => Z): STM.STM<Z>
}
```


# reduceOption

Atomically reduce the array, if non-empty, by a binary operator.

To import and use `reduceOption` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.reduceOption
```

**Signature**

```ts
export declare const reduceOption: {
  <A>(f: (x: A, y: A) => A): (self: TArray<A>) => STM.STM<Option.Option<A>>
  <A>(self: TArray<A>, f: (x: A, y: A) => A): STM.STM<Option.Option<A>>
}
```


# reduceOptionSTM

Atomically reduce the non-empty array using a transactional binary
operator.

To import and use `reduceOptionSTM` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.reduceOptionSTM
```

**Signature**

```ts
export declare const reduceOptionSTM: {
  <A, R, E>(f: (x: A, y: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>
  <A, R, E>(self: TArray<A>, f: (x: A, y: A) => STM.STM<A, E, R>): STM.STM<Option.Option<A>, E, R>
}
```


# reduceSTM

Atomically folds using a transactional function.

To import and use `reduceSTM` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.reduceSTM
```

**Signature**

```ts
export declare const reduceSTM: {
  <Z, A, R, E>(zero: Z, f: (accumulator: Z, current: A) => STM.STM<Z, E, R>): (self: TArray<A>) => STM.STM<Z, E, R>
  <Z, A, R, E>(self: TArray<A>, zero: Z, f: (accumulator: Z, current: A) => STM.STM<Z, E, R>): STM.STM<Z, E, R>
}
```


# size

Returns the size of the `TArray`.

To import and use `size` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.size
```

**Signature**

```ts
export declare const size: <A>(self: TArray<A>) => number
```


# some

Determine if the array contains a value satisfying a predicate.

To import and use `some` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.some
```

**Signature**

```ts
export declare const some: {
  <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<boolean>
  <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<boolean>
}
```


# someSTM

Determine if the array contains a value satisfying a transactional
predicate.

To import and use `someSTM` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.someSTM
```

**Signature**

```ts
export declare const someSTM: {
  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<boolean, E, R>
  <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<boolean, E, R>
}
```


# toArray

Collects all elements into a chunk.

To import and use `toArray` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.toArray
```

**Signature**

```ts
export declare const toArray: <A>(self: TArray<A>) => STM.STM<Array<A>>
```


# transform

Atomically updates all elements using a pure function.

To import and use `transform` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.transform
```

**Signature**

```ts
export declare const transform: {
  <A>(f: (value: A) => A): (self: TArray<A>) => STM.STM<void>
  <A>(self: TArray<A>, f: (value: A) => A): STM.STM<void>
}
```


# transformSTM

Atomically updates all elements using a transactional effect.

To import and use `transformSTM` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.transformSTM
```

**Signature**

```ts
export declare const transformSTM: {
  <A, R, E>(f: (value: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<void, E, R>
  <A, R, E>(self: TArray<A>, f: (value: A) => STM.STM<A, E, R>): STM.STM<void, E, R>
}
```


# update

Updates element in the array with given function.

To import and use `update` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.update
```

**Signature**

```ts
export declare const update: {
  <A>(index: number, f: (value: A) => A): (self: TArray<A>) => STM.STM<void>
  <A>(self: TArray<A>, index: number, f: (value: A) => A): STM.STM<void>
}
```


# updateSTM

Atomically updates element in the array with given transactional effect.

To import and use `updateSTM` from the "TArray" module:

```ts
import * as TArray from "effect/TArray"
// Can be accessed like this
TArray.updateSTM
```

**Signature**

```ts
export declare const updateSTM: {
  <A, R, E>(index: number, f: (value: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<void, E, R>
  <A, R, E>(self: TArray<A>, index: number, f: (value: A) => STM.STM<A, E, R>): STM.STM<void, E, R>
}
```


# QuitException

A `QuitException` represents an exception that occurs when a user attempts to
quit out of a `Terminal` prompt for input (usually by entering `ctrl`+`c`).

To import and use `QuitException` from the "Terminal" module:

```ts
import * as Terminal from "@effect/platform/Terminal"
// Can be accessed like this
Terminal.QuitException
```


# Terminal

A `Terminal` represents a command-line interface which can read input from a
user and display messages to a user.

To import and use `Terminal` from the "Terminal" module:

```ts
import * as Terminal from "@effect/platform/Terminal"
// Can be accessed like this
Terminal.Terminal
```


# ignored

An annotation which counts ignored tests.

To import and use `ignored` from the "TestAnnotation" module:

```ts
import * as TestAnnotation from "effect/TestAnnotation"
// Can be accessed like this
TestAnnotation.ignored
```

**Signature**

```ts
export declare const ignored: TestAnnotation<number>
```


# repeated

An annotation which counts repeated tests.

To import and use `repeated` from the "TestAnnotation" module:

```ts
import * as TestAnnotation from "effect/TestAnnotation"
// Can be accessed like this
TestAnnotation.repeated
```

**Signature**

```ts
export declare const repeated: TestAnnotation<number>
```


# retried

An annotation which counts retried tests.

To import and use `retried` from the "TestAnnotation" module:

```ts
import * as TestAnnotation from "effect/TestAnnotation"
// Can be accessed like this
TestAnnotation.retried
```

**Signature**

```ts
export declare const retried: TestAnnotation<number>
```


# tagged

An annotation which tags tests with strings.

To import and use `tagged` from the "TestAnnotation" module:

```ts
import * as TestAnnotation from "effect/TestAnnotation"
// Can be accessed like this
TestAnnotation.tagged
```

**Signature**

```ts
export declare const tagged: TestAnnotation<HashSet.HashSet<string>>
```


# annotate

Appends the specified annotation to the annotation map.

To import and use `annotate` from the "TestAnnotationMap" module:

```ts
import * as TestAnnotationMap from "effect/TestAnnotationMap"
// Can be accessed like this
TestAnnotationMap.annotate
```

**Signature**

```ts
export declare const annotate: (<A>(
  key: TestAnnotation.TestAnnotation<A>,
  value: A
) => (self: TestAnnotationMap) => TestAnnotationMap) &
  (<A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>, value: A) => TestAnnotationMap)
```


# get

Retrieves the annotation of the specified type, or its default value if
there is none.

To import and use `get` from the "TestAnnotationMap" module:

```ts
import * as TestAnnotationMap from "effect/TestAnnotationMap"
// Can be accessed like this
TestAnnotationMap.get
```

**Signature**

```ts
export declare const get: (<A>(key: TestAnnotation.TestAnnotation<A>) => (self: TestAnnotationMap) => A) &
  (<A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>) => A)
```


# TestAnnotationMap

An annotation map keeps track of annotations of different types.

To import and use `TestAnnotationMap` from the "TestAnnotationMap" module:

```ts
import * as TestAnnotationMap from "effect/TestAnnotationMap"
// Can be accessed like this
TestAnnotationMap.TestAnnotationMap
```


# TestAnnotations

The `Annotations` trait provides access to an annotation map that tests can
add arbitrary annotations to. Each annotation consists of a string
identifier, an initial value, and a function for combining two values.
Annotations form monoids and you can think of `Annotations` as a more
structured logging service or as a super polymorphic version of the writer
monad effect.

To import and use `TestAnnotations` from the "TestAnnotations" module:

```ts
import * as TestAnnotations from "effect/TestAnnotations"
// Can be accessed like this
TestAnnotations.TestAnnotations
```


# adjust

Accesses a `TestClock` instance in the context and increments the time
by the specified duration, running any actions scheduled for on or before
the new time in order.

To import and use `adjust` from the "TestClock" module:

```ts
import * as TestClock from "effect/TestClock"
// Can be accessed like this
TestClock.adjust
```

**Signature**

```ts
export declare const adjust: (durationInput: Duration.DurationInput) => Effect.Effect<void>
```


# currentTimeMillis

Accesses the current time of a `TestClock` instance in the context in
milliseconds.

To import and use `currentTimeMillis` from the "TestClock" module:

```ts
import * as TestClock from "effect/TestClock"
// Can be accessed like this
TestClock.currentTimeMillis
```

**Signature**

```ts
export declare const currentTimeMillis: Effect.Effect<number, never, never>
```


# Data

`Data` represents the state of the `TestClock`, including the clock time.

To import and use `Data` from the "TestClock" module:

```ts
import * as TestClock from "effect/TestClock"
// Can be accessed like this
TestClock.Data
```


# save

Accesses a `TestClock` instance in the context and saves the clock
state in an effect which, when run, will restore the `TestClock` to the
saved state.

To import and use `save` from the "TestClock" module:

```ts
import * as TestClock from "effect/TestClock"
// Can be accessed like this
TestClock.save
```

**Signature**

```ts
export declare const save: () => Effect.Effect<Effect.Effect<void>>
```


# setTime

Accesses a `TestClock` instance in the context and sets the clock time
to the specified `Instant`, running any actions scheduled for on or before
the new time in order.

To import and use `setTime` from the "TestClock" module:

```ts
import * as TestClock from "effect/TestClock"
// Can be accessed like this
TestClock.setTime
```

**Signature**

```ts
export declare const setTime: (instant: number) => Effect.Effect<void>
```


# sleep

Semantically blocks the current fiber until the clock time is equal to or
greater than the specified duration. Once the clock time is adjusted to
on or after the duration, the fiber will automatically be resumed.

To import and use `sleep` from the "TestClock" module:

```ts
import * as TestClock from "effect/TestClock"
// Can be accessed like this
TestClock.sleep
```

**Signature**

```ts
export declare const sleep: (durationInput: Duration.DurationInput) => Effect.Effect<void>
```


# sleeps

Accesses a `TestClock` instance in the context and returns a list of
times that effects are scheduled to run.

To import and use `sleeps` from the "TestClock" module:

```ts
import * as TestClock from "effect/TestClock"
// Can be accessed like this
TestClock.sleeps
```

**Signature**

```ts
export declare const sleeps: () => Effect.Effect<Chunk.Chunk<number>>
```


# testClock

Retrieves the `TestClock` service for this test.

To import and use `testClock` from the "TestClock" module:

```ts
import * as TestClock from "effect/TestClock"
// Can be accessed like this
TestClock.testClock
```

**Signature**

```ts
export declare const testClock: () => Effect.Effect<TestClock>
```


# TestClock

A `TestClock` makes it easy to deterministically and efficiently test effects
involving the passage of time.

Instead of waiting for actual time to pass, `sleep` and methods implemented
in terms of it schedule effects to take place at a given clock time. Users
can adjust the clock time using the `adjust` and `setTime` methods, and all
effects scheduled to take place on or before that time will automatically be
run in order.

For example, here is how we can test `Effect.timeout` using `TestClock`:

```ts
import { Duration, Effect, Fiber, TestClock, Option } from "effect"

Effect.gen(function* () {
  const fiber = yield* pipe(Effect.sleep(Duration.minutes(5)), Effect.timeout(Duration.minutes(1)), Effect.fork)
  yield* TestClock.adjust(Duration.minutes(1))
  const result = yield* Fiber.join(fiber)
  assert.deepStrictEqual(result, Option.none())
})
```

Note how we forked the fiber that `sleep` was invoked on. Calls to `sleep`
and methods derived from it will semantically block until the time is set to
on or after the time they are scheduled to run. If we didn't fork the fiber
on which we called sleep we would never get to set the time on the line
below. Thus, a useful pattern when using `TestClock` is to fork the effect
being tested, then adjust the clock time, and finally verify that the
expected effects have been performed.

To import and use `TestClock` from the "TestClock" module:

```ts
import * as TestClock from "effect/TestClock"
// Can be accessed like this
TestClock.TestClock
```


# testClockWith

Retrieves the `TestClock` service for this test and uses it to run the
specified workflow.

To import and use `testClockWith` from the "TestClock" module:

```ts
import * as TestClock from "effect/TestClock"
// Can be accessed like this
TestClock.testClockWith
```

**Signature**

```ts
export declare const testClockWith: <A, E, R>(
  f: (testClock: TestClock) => Effect.Effect<A, E, R>
) => Effect.Effect<A, E, R>
```


# TestConfig

The `TestConfig` service provides access to default configuration settings
used by tests, including the number of times to repeat tests to ensure
they are stable, the number of times to retry flaky tests, the sufficient
number of samples to check from a random variable, and the maximum number of
shrinkings to minimize large failures.

To import and use `TestConfig` from the "TestConfig" module:

```ts
import * as TestConfig from "effect/TestConfig"
// Can be accessed like this
TestConfig.TestConfig
```


# TestLive

The `Live` trait provides access to the "live" default Effect services from
within tests for workflows such as printing test results to the console or
timing out tests where it is necessary to access the real implementations of
these services.

To import and use `TestLive` from the "TestLive" module:

```ts
import * as TestLive from "effect/TestLive"
// Can be accessed like this
TestLive.TestLive
```


# annotate

Accesses an `Annotations` instance in the context and appends the
specified annotation to the annotation map.

To import and use `annotate` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.annotate
```

**Signature**

```ts
export declare const annotate: <A>(key: TestAnnotation.TestAnnotation<A>, value: A) => Effect.Effect<void>
```


# annotations

Retrieves the `Annotations` service for this test.

To import and use `annotations` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.annotations
```

**Signature**

```ts
export declare const annotations: () => Effect.Effect<Annotations.TestAnnotations>
```


# annotationsLayer

Constructs a new `Annotations` service wrapped in a layer.

To import and use `annotationsLayer` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.annotationsLayer
```

**Signature**

```ts
export declare const annotationsLayer: () => Layer.Layer<Annotations.TestAnnotations>
```


# annotationsWith

Retrieves the `Annotations` service for this test and uses it to run the
specified workflow.

To import and use `annotationsWith` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.annotationsWith
```

**Signature**

```ts
export declare const annotationsWith: <A, E, R>(
  f: (annotations: Annotations.TestAnnotations) => Effect.Effect<A, E, R>
) => Effect.Effect<A, E, R>
```


# get

Accesses an `Annotations` instance in the context and retrieves the
annotation of the specified type, or its default value if there is none.

To import and use `get` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.get
```

**Signature**

```ts
export declare const get: <A>(key: TestAnnotation.TestAnnotation<A>) => Effect.Effect<A>
```


# live

Retrieves the `Live` service for this test.

To import and use `live` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.live
```

**Signature**

```ts
export declare const live: Effect.Effect<Live.TestLive, never, never>
```


# liveLayer

Constructs a new `Live` service wrapped in a layer.

To import and use `liveLayer` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.liveLayer
```

**Signature**

```ts
export declare const liveLayer: () => Layer.Layer<Live.TestLive, never, DefaultServices.DefaultServices>
```


# liveServices

The default Effect test services.

To import and use `liveServices` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.liveServices
```

**Signature**

```ts
export declare const liveServices: Context.Context<TestServices>
```


# liveWith

Retrieves the `Live` service for this test and uses it to run the specified
workflow.

To import and use `liveWith` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.liveWith
```

**Signature**

```ts
export declare const liveWith: <A, E, R>(f: (live: Live.TestLive) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
```


# provideLive

Provides a workflow with the "live" default Effect services.

To import and use `provideLive` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.provideLive
```

**Signature**

```ts
export declare const provideLive: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
```


# provideWithLive

Runs a transformation function with the live default Effect services while
ensuring that the workflow itself is run with the test services.

To import and use `provideWithLive` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.provideWithLive
```

**Signature**

```ts
export declare const provideWithLive: (<A, E, R, A2, E2, R2>(
  f: (effect: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R2>
) => (self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E | E2, R | R2>) &
  (<A, E, R, A2, E2, R2>(
    self: Effect.Effect<A, E, R>,
    f: (effect: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R2>
  ) => Effect.Effect<A2, E | E2, R | R2>)
```


# repeats

The number of times to repeat tests to ensure they are stable.

To import and use `repeats` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.repeats
```

**Signature**

```ts
export declare const repeats: Effect.Effect<number, never, never>
```


# retries

The number of times to retry flaky tests.

To import and use `retries` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.retries
```

**Signature**

```ts
export declare const retries: Effect.Effect<number, never, never>
```


# samples

The number of sufficient samples to check for a random variable.

To import and use `samples` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.samples
```

**Signature**

```ts
export declare const samples: Effect.Effect<number, never, never>
```


# shrinks

The maximum number of shrinkings to minimize large failures.

To import and use `shrinks` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.shrinks
```

**Signature**

```ts
export declare const shrinks: Effect.Effect<number, never, never>
```


# sized

Retrieves the `Sized` service for this test.

To import and use `sized` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.sized
```

**Signature**

```ts
export declare const sized: Effect.Effect<Sized.TestSized, never, never>
```


# sizedWith

Retrieves the `Sized` service for this test and uses it to run the
specified workflow.

To import and use `sizedWith` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.sizedWith
```

**Signature**

```ts
export declare const sizedWith: <A, E, R>(
  f: (sized: Sized.TestSized) => Effect.Effect<A, E, R>
) => Effect.Effect<A, E, R>
```


# supervisedFibers

Returns the set of all fibers in this test.

To import and use `supervisedFibers` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.supervisedFibers
```

**Signature**

```ts
export declare const supervisedFibers: () => Effect.Effect<SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>>
```


# testConfig

Retrieves the `TestConfig` service for this test.

To import and use `testConfig` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.testConfig
```

**Signature**

```ts
export declare const testConfig: Effect.Effect<TestConfig.TestConfig, never, never>
```


# testConfigLayer

Constructs a new `TestConfig` service with the specified settings.

To import and use `testConfigLayer` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.testConfigLayer
```

**Signature**

```ts
export declare const testConfigLayer: (params: {
  readonly repeats: number
  readonly retries: number
  readonly samples: number
  readonly shrinks: number
}) => Layer.Layer<TestConfig.TestConfig>
```


# testConfigWith

Retrieves the `TestConfig` service for this test and uses it to run the
specified workflow.

To import and use `testConfigWith` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.testConfigWith
```

**Signature**

```ts
export declare const testConfigWith: <A, E, R>(
  f: (config: TestConfig.TestConfig) => Effect.Effect<A, E, R>
) => Effect.Effect<A, E, R>
```


# withAnnotations

Executes the specified workflow with the specified implementation of the
annotations service.

To import and use `withAnnotations` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.withAnnotations
```

**Signature**

```ts
export declare const withAnnotations: ((
  annotations: Annotations.TestAnnotations
) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) &
  (<A, E, R>(effect: Effect.Effect<A, E, R>, annotations: Annotations.TestAnnotations) => Effect.Effect<A, E, R>)
```


# withAnnotationsScoped

Sets the implementation of the annotations service to the specified value
and restores it to its original value when the scope is closed.

To import and use `withAnnotationsScoped` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.withAnnotationsScoped
```

**Signature**

```ts
export declare const withAnnotationsScoped: (
  annotations: Annotations.TestAnnotations
) => Effect.Effect<void, never, Scope.Scope>
```


# withLive

Executes the specified workflow with the specified implementation of the
live service.

To import and use `withLive` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.withLive
```

**Signature**

```ts
export declare const withLive: ((
  live: Live.TestLive
) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) &
  (<A, E, R>(effect: Effect.Effect<A, E, R>, live: Live.TestLive) => Effect.Effect<A, E, R>)
```


# withLiveScoped

Sets the implementation of the live service to the specified value and
restores it to its original value when the scope is closed.

To import and use `withLiveScoped` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.withLiveScoped
```

**Signature**

```ts
export declare const withLiveScoped: (live: Live.TestLive) => Effect.Effect<void, never, Scope.Scope>
```


# withSized

Executes the specified workflow with the specified implementation of the
sized service.

To import and use `withSized` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.withSized
```

**Signature**

```ts
export declare const withSized: ((
  sized: Sized.TestSized
) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) &
  (<A, E, R>(effect: Effect.Effect<A, E, R>, sized: Sized.TestSized) => Effect.Effect<A, E, R>)
```


# withSizedScoped

Sets the implementation of the sized service to the specified value and
restores it to its original value when the scope is closed.

To import and use `withSizedScoped` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.withSizedScoped
```

**Signature**

```ts
export declare const withSizedScoped: (sized: Sized.TestSized) => Effect.Effect<void, never, Scope.Scope>
```


# withTestConfig

Executes the specified workflow with the specified implementation of the
config service.

To import and use `withTestConfig` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.withTestConfig
```

**Signature**

```ts
export declare const withTestConfig: ((
  config: TestConfig.TestConfig
) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) &
  (<A, E, R>(effect: Effect.Effect<A, E, R>, config: TestConfig.TestConfig) => Effect.Effect<A, E, R>)
```


# withTestConfigScoped

Sets the implementation of the config service to the specified value and
restores it to its original value when the scope is closed.

To import and use `withTestConfigScoped` from the "TestServices" module:

```ts
import * as TestServices from "effect/TestServices"
// Can be accessed like this
TestServices.withTestConfigScoped
```

**Signature**

```ts
export declare const withTestConfigScoped: (config: TestConfig.TestConfig) => Effect.Effect<void, never, Scope.Scope>
```


# empty

Makes an empty `TMap`.

To import and use `empty` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.empty
```

**Signature**

```ts
export declare const empty: <K, V>() => STM.STM<TMap<K, V>>
```


# find

Finds the key/value pair matching the specified predicate, and uses the
provided function to extract a value out of it.

To import and use `find` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.find
```

**Signature**

```ts
export declare const find: {
  <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<Option.Option<A>>
  <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<Option.Option<A>>
}
```


# findAll

Finds all the key/value pairs matching the specified predicate, and uses
the provided function to extract values out them.

To import and use `findAll` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.findAll
```

**Signature**

```ts
export declare const findAll: {
  <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<Array<A>>
  <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<Array<A>>
}
```


# findAllSTM

Finds all the key/value pairs matching the specified predicate, and uses
the provided effectful function to extract values out of them..

To import and use `findAllSTM` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.findAllSTM
```

**Signature**

```ts
export declare const findAllSTM: {
  <K, V, A, E, R>(
    pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>
  ): (self: TMap<K, V>) => STM.STM<Array<A>, E, R>
  <K, V, A, E, R>(self: TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<Array<A>, E, R>
}
```


# findSTM

Finds the key/value pair matching the specified predicate, and uses the
provided effectful function to extract a value out of it.

To import and use `findSTM` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.findSTM
```

**Signature**

```ts
export declare const findSTM: {
  <K, V, A, E, R>(
    f: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>
  ): (self: TMap<K, V>) => STM.STM<Option.Option<A>, E, R>
  <K, V, A, E, R>(
    self: TMap<K, V>,
    f: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>
  ): STM.STM<Option.Option<A>, E, R>
}
```


# forEach

Atomically performs transactional-effect for each binding present in map.

To import and use `forEach` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.forEach
```

**Signature**

```ts
export declare const forEach: {
  <K, V, X, E, R>(f: (key: K, value: V) => STM.STM<X, E, R>): (self: TMap<K, V>) => STM.STM<void, E, R>
  <K, V, X, E, R>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<X, E, R>): STM.STM<void, E, R>
}
```


# fromIterable

Creates a new `TMap` from an iterable collection of key/value pairs.

To import and use `fromIterable` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.fromIterable
```

**Signature**

```ts
export declare const fromIterable: <K, V>(iterable: Iterable<readonly [K, V]>) => STM.STM<TMap<K, V>>
```


# get

Retrieves value associated with given key.

To import and use `get` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.get
```

**Signature**

```ts
export declare const get: {
  <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<Option.Option<V>>
  <K, V>(self: TMap<K, V>, key: K): STM.STM<Option.Option<V>>
}
```


# getOrElse

Retrieves value associated with given key or default value, in case the key
isn't present.

To import and use `getOrElse` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.getOrElse
```

**Signature**

```ts
export declare const getOrElse: {
  <K, V>(key: K, fallback: LazyArg<V>): (self: TMap<K, V>) => STM.STM<V>
  <K, V>(self: TMap<K, V>, key: K, fallback: LazyArg<V>): STM.STM<V>
}
```


# has

Tests whether or not map contains a key.

To import and use `has` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.has
```

**Signature**

```ts
export declare const has: {
  <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<boolean>
  <K, V>(self: TMap<K, V>, key: K): STM.STM<boolean>
}
```


# isEmpty

Tests if the map is empty or not.

To import and use `isEmpty` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.isEmpty
```

**Signature**

```ts
export declare const isEmpty: <K, V>(self: TMap<K, V>) => STM.STM<boolean>
```


# keys

Collects all keys stored in map.

To import and use `keys` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.keys
```

**Signature**

```ts
export declare const keys: <K, V>(self: TMap<K, V>) => STM.STM<Array<K>>
```


# make

Makes a new `TMap` that is initialized with specified values.

To import and use `make` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.make
```

**Signature**

```ts
export declare const make: <K, V>(...entries: Array<readonly [K, V]>) => STM.STM<TMap<K, V>>
```


# merge

If the key is not already associated with a value, stores the provided value,
otherwise merge the existing value with the new one using function `f` and
store the result.

To import and use `merge` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.merge
```

**Signature**

```ts
export declare const merge: {
  <K, V>(key: K, value: V, f: (x: V, y: V) => V): (self: TMap<K, V>) => STM.STM<V>
  <K, V>(self: TMap<K, V>, key: K, value: V, f: (x: V, y: V) => V): STM.STM<V>
}
```


# reduce

Atomically folds using a pure function.

To import and use `reduce` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.reduce
```

**Signature**

```ts
export declare const reduce: {
  <Z, K, V>(zero: Z, f: (acc: Z, value: V, key: K) => Z): (self: TMap<K, V>) => STM.STM<Z>
  <K, V, Z>(self: TMap<K, V>, zero: Z, f: (acc: Z, value: V, key: K) => Z): STM.STM<Z>
}
```


# reduceSTM

Atomically folds using a transactional function.

To import and use `reduceSTM` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.reduceSTM
```

**Signature**

```ts
export declare const reduceSTM: {
  <Z, V, K, R, E>(zero: Z, f: (acc: Z, value: V, key: K) => STM.STM<Z, E, R>): (self: TMap<K, V>) => STM.STM<Z, E, R>
  <Z, V, K, R, E>(self: TMap<K, V>, zero: Z, f: (acc: Z, value: V, key: K) => STM.STM<Z, E, R>): STM.STM<Z, E, R>
}
```


# remove

Removes binding for given key.

To import and use `remove` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.remove
```

**Signature**

```ts
export declare const remove: {
  <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<void>
  <K, V>(self: TMap<K, V>, key: K): STM.STM<void>
}
```


# removeAll

Deletes all entries associated with the specified keys.

To import and use `removeAll` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.removeAll
```

**Signature**

```ts
export declare const removeAll: {
  <K>(keys: Iterable<K>): <V>(self: TMap<K, V>) => STM.STM<void>
  <K, V>(self: TMap<K, V>, keys: Iterable<K>): STM.STM<void>
}
```


# removeIf

Removes entries from a `TMap` that satisfy the specified predicate and returns the removed entries
(or `void` if `discard = true`).

To import and use `removeIf` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.removeIf
```

**Signature**

```ts
export declare const removeIf: {
  <K, V>(
    predicate: (key: K, value: V) => boolean,
    options: { readonly discard: true }
  ): (self: TMap<K, V>) => STM.STM<void>
  <K, V>(
    predicate: (key: K, value: V) => boolean,
    options?: { readonly discard: false }
  ): (self: TMap<K, V>) => STM.STM<Array<[K, V]>>
  <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options: { readonly discard: true }): STM.STM<void>
  <K, V>(
    self: TMap<K, V>,
    predicate: (key: K, value: V) => boolean,
    options?: { readonly discard: false }
  ): STM.STM<Array<[K, V]>>
}
```


# retainIf

Retains entries in a `TMap` that satisfy the specified predicate and returns the removed entries
(or `void` if `discard = true`).

To import and use `retainIf` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.retainIf
```

**Signature**

```ts
export declare const retainIf: {
  <K, V>(
    predicate: (key: K, value: V) => boolean,
    options: { readonly discard: true }
  ): (self: TMap<K, V>) => STM.STM<void>
  <K, V>(
    predicate: (key: K, value: V) => boolean,
    options?: { readonly discard: false }
  ): (self: TMap<K, V>) => STM.STM<Array<[K, V]>>
  <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options: { readonly discard: true }): STM.STM<void>
  <K, V>(
    self: TMap<K, V>,
    predicate: (key: K, value: V) => boolean,
    options?: { readonly discard: false }
  ): STM.STM<Array<[K, V]>>
}
```


# set

Stores new binding into the map.

To import and use `set` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.set
```

**Signature**

```ts
export declare const set: {
  <K, V>(key: K, value: V): (self: TMap<K, V>) => STM.STM<void>
  <K, V>(self: TMap<K, V>, key: K, value: V): STM.STM<void>
}
```


# setIfAbsent

Stores new binding in the map if it does not already exist.

To import and use `setIfAbsent` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.setIfAbsent
```

**Signature**

```ts
export declare const setIfAbsent: {
  <K, V>(key: K, value: V): (self: TMap<K, V>) => STM.STM<void>
  <K, V>(self: TMap<K, V>, key: K, value: V): STM.STM<void>
}
```


# size

Returns the number of bindings.

To import and use `size` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.size
```

**Signature**

```ts
export declare const size: <K, V>(self: TMap<K, V>) => STM.STM<number>
```


# takeFirst

Takes the first matching value, or retries until there is one.

To import and use `takeFirst` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.takeFirst
```

**Signature**

```ts
export declare const takeFirst: {
  <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<A>
  <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<A>
}
```


# takeFirstSTM

Takes the first matching value, or retries until there is one.

To import and use `takeFirstSTM` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.takeFirstSTM
```

**Signature**

```ts
export declare const takeFirstSTM: {
  <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<A, E, R>
  <K, V, A, E, R>(self: TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<A, E, R>
}
```


# takeSome

Takes all matching values, or retries until there is at least one.

To import and use `takeSome` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.takeSome
```

**Signature**

```ts
export declare const takeSome: {
  <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<[A, ...Array<A>]>
  <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<[A, ...Array<A>]>
}
```


# takeSomeSTM

Takes all matching values, or retries until there is at least one.

To import and use `takeSomeSTM` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.takeSomeSTM
```

**Signature**

```ts
export declare const takeSomeSTM: {
  <K, V, A, E, R>(
    pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>
  ): (self: TMap<K, V>) => STM.STM<[A, ...Array<A>], E, R>
  <K, V, A, E, R>(
    self: TMap<K, V>,
    pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>
  ): STM.STM<[A, ...Array<A>], E, R>
}
```


# TMap

Transactional map implemented on top of `TRef` and `TArray`. Resolves
conflicts via chaining.

To import and use `TMap` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.TMap
```


# toArray

Collects all bindings into an `Array`.

To import and use `toArray` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.toArray
```

**Signature**

```ts
export declare const toArray: <K, V>(self: TMap<K, V>) => STM.STM<Array<[K, V]>>
```


# toChunk

Collects all bindings into a `Chunk`.

To import and use `toChunk` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.toChunk
```

**Signature**

```ts
export declare const toChunk: <K, V>(self: TMap<K, V>) => STM.STM<Chunk.Chunk<[K, V]>>
```


# toHashMap

Collects all bindings into a `HashMap`.

To import and use `toHashMap` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.toHashMap
```

**Signature**

```ts
export declare const toHashMap: <K, V>(self: TMap<K, V>) => STM.STM<HashMap.HashMap<K, V>>
```


# toMap

Collects all bindings into a `Map`.

To import and use `toMap` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.toMap
```

**Signature**

```ts
export declare const toMap: <K, V>(self: TMap<K, V>) => STM.STM<ReadonlyMap<K, V>>
```


# transform

Atomically updates all bindings using a pure function.

To import and use `transform` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.transform
```

**Signature**

```ts
export declare const transform: {
  <K, V>(f: (key: K, value: V) => readonly [K, V]): (self: TMap<K, V>) => STM.STM<void>
  <K, V>(self: TMap<K, V>, f: (key: K, value: V) => readonly [K, V]): STM.STM<void>
}
```


# transformSTM

Atomically updates all bindings using a transactional function.

To import and use `transformSTM` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.transformSTM
```

**Signature**

```ts
export declare const transformSTM: {
  <K, V, R, E>(f: (key: K, value: V) => STM.STM<readonly [K, V], E, R>): (self: TMap<K, V>) => STM.STM<void, E, R>
  <K, V, R, E>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<readonly [K, V], E, R>): STM.STM<void, E, R>
}
```


# transformValues

Atomically updates all values using a pure function.

To import and use `transformValues` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.transformValues
```

**Signature**

```ts
export declare const transformValues: {
  <V>(f: (value: V) => V): <K>(self: TMap<K, V>) => STM.STM<void>
  <K, V>(self: TMap<K, V>, f: (value: V) => V): STM.STM<void>
}
```


# transformValuesSTM

Atomically updates all values using a transactional function.

To import and use `transformValuesSTM` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.transformValuesSTM
```

**Signature**

```ts
export declare const transformValuesSTM: {
  <V, R, E>(f: (value: V) => STM.STM<V, E, R>): <K>(self: TMap<K, V>) => STM.STM<void, E, R>
  <K, V, R, E>(self: TMap<K, V>, f: (value: V) => STM.STM<V, E, R>): STM.STM<void, E, R>
}
```


# updateWith

Updates the mapping for the specified key with the specified function,
which takes the current value of the key as an input, if it exists, and
either returns `Some` with a new value to indicate to update the value in
the map or `None` to remove the value from the map. Returns `Some` with the
updated value or `None` if the value was removed from the map.

To import and use `updateWith` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.updateWith
```

**Signature**

```ts
export declare const updateWith: {
  <K, V>(key: K, f: (value: Option.Option<V>) => Option.Option<V>): (self: TMap<K, V>) => STM.STM<Option.Option<V>>
  <K, V>(self: TMap<K, V>, key: K, f: (value: Option.Option<V>) => Option.Option<V>): STM.STM<Option.Option<V>>
}
```


# values

Collects all values stored in map.

To import and use `values` from the "TMap" module:

```ts
import * as TMap from "effect/TMap"
// Can be accessed like this
TMap.values
```

**Signature**

```ts
export declare const values: <K, V>(self: TMap<K, V>) => STM.STM<Array<V>>
```


# empty

Constructs a new empty `TPriorityQueue` with the specified `Order`.

To import and use `empty` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.empty
```

**Signature**

```ts
export declare const empty: <A>(order: Order.Order<A>) => STM.STM<TPriorityQueue<A>>
```


# fromIterable

Creates a new `TPriorityQueue` from an iterable collection of values.

To import and use `fromIterable` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.fromIterable
```

**Signature**

```ts
export declare const fromIterable: <A>(order: Order.Order<A>) => (iterable: Iterable<A>) => STM.STM<TPriorityQueue<A>>
```


# isEmpty

Checks whether the queue is empty.

To import and use `isEmpty` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.isEmpty
```

**Signature**

```ts
export declare const isEmpty: <A>(self: TPriorityQueue<A>) => STM.STM<boolean>
```


# isNonEmpty

Checks whether the queue is not empty.

To import and use `isNonEmpty` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.isNonEmpty
```

**Signature**

```ts
export declare const isNonEmpty: <A>(self: TPriorityQueue<A>) => STM.STM<boolean>
```


# make

Makes a new `TPriorityQueue` that is initialized with specified values.

To import and use `make` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.make
```

**Signature**

```ts
export declare const make: <A>(order: Order.Order<A>) => (...elements: Array<A>) => STM.STM<TPriorityQueue<A>>
```


# offer

Offers the specified value to the queue.

To import and use `offer` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.offer
```

**Signature**

```ts
export declare const offer: {
  <A>(value: A): (self: TPriorityQueue<A>) => STM.STM<void>
  <A>(self: TPriorityQueue<A>, value: A): STM.STM<void>
}
```


# offerAll

Offers all of the elements in the specified collection to the queue.

To import and use `offerAll` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.offerAll
```

**Signature**

```ts
export declare const offerAll: {
  <A>(values: Iterable<A>): (self: TPriorityQueue<A>) => STM.STM<void>
  <A>(self: TPriorityQueue<A>, values: Iterable<A>): STM.STM<void>
}
```


# peek

Peeks at the first value in the queue without removing it, retrying until a
value is in the queue.

To import and use `peek` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.peek
```

**Signature**

```ts
export declare const peek: <A>(self: TPriorityQueue<A>) => STM.STM<A>
```


# peekOption

Peeks at the first value in the queue without removing it, returning `None`
if there is not a value in the queue.

To import and use `peekOption` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.peekOption
```

**Signature**

```ts
export declare const peekOption: <A>(self: TPriorityQueue<A>) => STM.STM<Option.Option<A>>
```


# removeIf

Removes all elements from the queue matching the specified predicate.

To import and use `removeIf` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.removeIf
```

**Signature**

```ts
export declare const removeIf: {
  <A>(predicate: Predicate<A>): (self: TPriorityQueue<A>) => STM.STM<void>
  <A>(self: TPriorityQueue<A>, predicate: Predicate<A>): STM.STM<void>
}
```


# retainIf

Retains only elements from the queue matching the specified predicate.

To import and use `retainIf` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.retainIf
```

**Signature**

```ts
export declare const retainIf: {
  <A>(predicate: Predicate<A>): (self: TPriorityQueue<A>) => STM.STM<void>
  <A>(self: TPriorityQueue<A>, predicate: Predicate<A>): STM.STM<void>
}
```


# size

Returns the size of the queue.

To import and use `size` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.size
```

**Signature**

```ts
export declare const size: <A>(self: TPriorityQueue<A>) => STM.STM<number>
```


# take

Takes a value from the queue, retrying until a value is in the queue.

To import and use `take` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.take
```

**Signature**

```ts
export declare const take: <A>(self: TPriorityQueue<A>) => STM.STM<A>
```


# takeAll

Takes all values from the queue.

To import and use `takeAll` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.takeAll
```

**Signature**

```ts
export declare const takeAll: <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>
```


# takeOption

Takes a value from the queue, returning `None` if there is not a value in
the queue.

To import and use `takeOption` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.takeOption
```

**Signature**

```ts
export declare const takeOption: <A>(self: TPriorityQueue<A>) => STM.STM<Option.Option<A>>
```


# takeUpTo

Takes up to the specified maximum number of elements from the queue.

To import and use `takeUpTo` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.takeUpTo
```

**Signature**

```ts
export declare const takeUpTo: {
  (n: number): <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>
  <A>(self: TPriorityQueue<A>, n: number): STM.STM<Array<A>>
}
```


# toArray

Collects all values into an array.

To import and use `toArray` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.toArray
```

**Signature**

```ts
export declare const toArray: <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>
```


# toChunk

Collects all values into a `Chunk`.

To import and use `toChunk` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.toChunk
```

**Signature**

```ts
export declare const toChunk: <A>(self: TPriorityQueue<A>) => STM.STM<Chunk.Chunk<A>>
```


# TPriorityQueue

A `TPriorityQueue` contains values of type `A` that an `Order` is defined
on. Unlike a `TQueue`, `take` returns the highest priority value (the value
that is first in the specified ordering) as opposed to the first value
offered to the queue. The ordering that elements with the same priority will
be taken from the queue is not guaranteed.

To import and use `TPriorityQueue` from the "TPriorityQueue" module:

```ts
import * as TPriorityQueue from "effect/TPriorityQueue"
// Can be accessed like this
TPriorityQueue.TPriorityQueue
```


# awaitShutdown

Waits until the `TPubSub` is shutdown. The `STM` returned by this method will
not resume until the queue has been shutdown. If the `TPubSub` is already
shutdown, the `STM` will resume right away.

To import and use `awaitShutdown` from the "TPubSub" module:

```ts
import * as TPubSub from "effect/TPubSub"
// Can be accessed like this
TPubSub.awaitShutdown
```

**Signature**

```ts
export declare const awaitShutdown: <A>(self: TPubSub<A>) => STM.STM<void>
```


# bounded

Creates a bounded `TPubSub` with the back pressure strategy. The `TPubSub` will retain
messages until they have been taken by all subscribers, applying back
pressure to publishers if the `TPubSub` is at capacity.

To import and use `bounded` from the "TPubSub" module:

```ts
import * as TPubSub from "effect/TPubSub"
// Can be accessed like this
TPubSub.bounded
```

**Signature**

```ts
export declare const bounded: <A>(requestedCapacity: number) => STM.STM<TPubSub<A>>
```


# capacity

Returns the number of elements the `TPubSub` can hold.

To import and use `capacity` from the "TPubSub" module:

```ts
import * as TPubSub from "effect/TPubSub"
// Can be accessed like this
TPubSub.capacity
```

**Signature**

```ts
export declare const capacity: <A>(self: TPubSub<A>) => number
```


# dropping

Creates a bounded `TPubSub` with the dropping strategy. The `TPubSub` will drop new
messages if the `TPubSub` is at capacity.

To import and use `dropping` from the "TPubSub" module:

```ts
import * as TPubSub from "effect/TPubSub"
// Can be accessed like this
TPubSub.dropping
```

**Signature**

```ts
export declare const dropping: <A>(requestedCapacity: number) => STM.STM<TPubSub<A>>
```


# isEmpty

Returns `true` if the `TPubSub` contains zero elements, `false` otherwise.

To import and use `isEmpty` from the "TPubSub" module:

```ts
import * as TPubSub from "effect/TPubSub"
// Can be accessed like this
TPubSub.isEmpty
```

**Signature**

```ts
export declare const isEmpty: <A>(self: TPubSub<A>) => STM.STM<boolean>
```


# isFull

Returns `true` if the `TPubSub` contains at least one element, `false`
otherwise.

To import and use `isFull` from the "TPubSub" module:

```ts
import * as TPubSub from "effect/TPubSub"
// Can be accessed like this
TPubSub.isFull
```

**Signature**

```ts
export declare const isFull: <A>(self: TPubSub<A>) => STM.STM<boolean>
```


# isShutdown

Returns `true` if `shutdown` has been called, otherwise returns `false`.

To import and use `isShutdown` from the "TPubSub" module:

```ts
import * as TPubSub from "effect/TPubSub"
// Can be accessed like this
TPubSub.isShutdown
```

**Signature**

```ts
export declare const isShutdown: <A>(self: TPubSub<A>) => STM.STM<boolean>
```


# publish

Publishes a message to the `TPubSub`, returning whether the message was published
to the `TPubSub`.

To import and use `publish` from the "TPubSub" module:

```ts
import * as TPubSub from "effect/TPubSub"
// Can be accessed like this
TPubSub.publish
```

**Signature**

```ts
export declare const publish: {
  <A>(value: A): (self: TPubSub<A>) => STM.STM<boolean>
  <A>(self: TPubSub<A>, value: A): STM.STM<boolean>
}
```


# publishAll

Publishes all of the specified messages to the `TPubSub`, returning whether they
were published to the `TPubSub`.

To import and use `publishAll` from the "TPubSub" module:

```ts
import * as TPubSub from "effect/TPubSub"
// Can be accessed like this
TPubSub.publishAll
```

**Signature**

```ts
export declare const publishAll: {
  <A>(iterable: Iterable<A>): (self: TPubSub<A>) => STM.STM<boolean>
  <A>(self: TPubSub<A>, iterable: Iterable<A>): STM.STM<boolean>
}
```


# shutdown

Interrupts any fibers that are suspended on `offer` or `take`. Future calls
to `offer*` and `take*` will be interrupted immediately.

To import and use `shutdown` from the "TPubSub" module:

```ts
import * as TPubSub from "effect/TPubSub"
// Can be accessed like this
TPubSub.shutdown
```

**Signature**

```ts
export declare const shutdown: <A>(self: TPubSub<A>) => STM.STM<void>
```


# size

Retrieves the size of the `TPubSub`, which is equal to the number of elements
in the `TPubSub`. This may be negative if fibers are suspended waiting for
elements to be added to the `TPubSub`.

To import and use `size` from the "TPubSub" module:

```ts
import * as TPubSub from "effect/TPubSub"
// Can be accessed like this
TPubSub.size
```

**Signature**

```ts
export declare const size: <A>(self: TPubSub<A>) => STM.STM<number>
```


# sliding

Creates a bounded `TPubSub` with the sliding strategy. The `TPubSub` will add new
messages and drop old messages if the `TPubSub` is at capacity.

For best performance use capacities that are powers of two.

To import and use `sliding` from the "TPubSub" module:

```ts
import * as TPubSub from "effect/TPubSub"
// Can be accessed like this
TPubSub.sliding
```

**Signature**

```ts
export declare const sliding: <A>(requestedCapacity: number) => STM.STM<TPubSub<A>>
```


# subscribe

Subscribes to receive messages from the `TPubSub`. The resulting subscription can
be evaluated multiple times to take a message from the `TPubSub` each time. The
caller is responsible for unsubscribing from the `TPubSub` by shutting down the
queue.

To import and use `subscribe` from the "TPubSub" module:

```ts
import * as TPubSub from "effect/TPubSub"
// Can be accessed like this
TPubSub.subscribe
```

**Signature**

```ts
export declare const subscribe: <A>(self: TPubSub<A>) => STM.STM<TQueue.TDequeue<A>>
```


# subscribeScoped

Subscribes to receive messages from the `TPubSub`. The resulting subscription can
be evaluated multiple times within the scope to take a message from the `TPubSub`
each time.

To import and use `subscribeScoped` from the "TPubSub" module:

```ts
import * as TPubSub from "effect/TPubSub"
// Can be accessed like this
TPubSub.subscribeScoped
```

**Signature**

```ts
export declare const subscribeScoped: <A>(self: TPubSub<A>) => Effect.Effect<TQueue.TDequeue<A>, never, Scope.Scope>
```


# unbounded

Creates an unbounded `TPubSub`.

To import and use `unbounded` from the "TPubSub" module:

```ts
import * as TPubSub from "effect/TPubSub"
// Can be accessed like this
TPubSub.unbounded
```

**Signature**

```ts
export declare const unbounded: <A>() => STM.STM<TPubSub<A>>
```


# awaitShutdown

Waits until the queue is shutdown. The `STM` returned by this method will
not resume until the queue has been shutdown. If the queue is already
shutdown, the `STM` will resume right away.

To import and use `awaitShutdown` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.awaitShutdown
```

**Signature**

```ts
export declare const awaitShutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<void>
```


# BaseTQueue

The base interface that all `TQueue`s must implement.

To import and use `BaseTQueue` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.BaseTQueue
```


# bounded

Creates a bounded queue with the back pressure strategy. The queue will
retain values until they have been taken, applying back pressure to
offerors if the queue is at capacity.

For best performance use capacities that are powers of two.

To import and use `bounded` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.bounded
```

**Signature**

```ts
export declare const bounded: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>
```


# capacity

Returns the number of elements the queue can hold.

To import and use `capacity` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.capacity
```

**Signature**

```ts
export declare const capacity: <A>(self: TDequeue<A> | TEnqueue<A>) => number
```


# dropping

Creates a bounded queue with the dropping strategy. The queue will drop new
values if the queue is at capacity.

For best performance use capacities that are powers of two.

To import and use `dropping` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.dropping
```

**Signature**

```ts
export declare const dropping: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>
```


# isEmpty

Returns `true` if the `TQueue` contains zero elements, `false` otherwise.

To import and use `isEmpty` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.isEmpty
```

**Signature**

```ts
export declare const isEmpty: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>
```


# isFull

Returns `true` if the `TQueue` contains at least one element, `false`
otherwise.

To import and use `isFull` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.isFull
```

**Signature**

```ts
export declare const isFull: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>
```


# isShutdown

Returns `true` if `shutdown` has been called, otherwise returns `false`.

To import and use `isShutdown` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.isShutdown
```

**Signature**

```ts
export declare const isShutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>
```


# isTDequeue

Returns `true` if the specified value is a `TDequeue`, `false` otherwise.

To import and use `isTDequeue` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.isTDequeue
```

**Signature**

```ts
export declare const isTDequeue: (u: unknown) => u is TDequeue<unknown>
```


# isTEnqueue

Returns `true` if the specified value is a `TEnqueue`, `false` otherwise.

To import and use `isTEnqueue` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.isTEnqueue
```

**Signature**

```ts
export declare const isTEnqueue: (u: unknown) => u is TEnqueue<unknown>
```


# isTQueue

Returns `true` if the specified value is a `TQueue`, `false` otherwise.

To import and use `isTQueue` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.isTQueue
```

**Signature**

```ts
export declare const isTQueue: (u: unknown) => u is TQueue<unknown>
```


# offer

Places one value in the queue.

To import and use `offer` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.offer
```

**Signature**

```ts
export declare const offer: {
  <A>(value: A): (self: TEnqueue<A>) => STM.STM<void>
  <A>(self: TEnqueue<A>, value: A): STM.STM<void>
}
```


# offerAll

For Bounded TQueue: uses the `BackPressure` Strategy, places the values in
the queue and always returns true. If the queue has reached capacity, then
the fiber performing the `offerAll` will be suspended until there is room
in the queue.

For Unbounded TQueue: Places all values in the queue and returns true.

For Sliding TQueue: uses `Sliding` Strategy If there is room in the queue,
it places the values otherwise it removes the old elements and enqueues the
new ones. Always returns true.

For Dropping TQueue: uses `Dropping` Strategy, It places the values in the
queue but if there is no room it will not enqueue them and return false.

To import and use `offerAll` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.offerAll
```

**Signature**

```ts
export declare const offerAll: {
  <A>(iterable: Iterable<A>): (self: TEnqueue<A>) => STM.STM<boolean>
  <A>(self: TEnqueue<A>, iterable: Iterable<A>): STM.STM<boolean>
}
```


# peek

Views the next element in the queue without removing it, retrying if the
queue is empty.

To import and use `peek` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.peek
```

**Signature**

```ts
export declare const peek: <A>(self: TDequeue<A>) => STM.STM<A>
```


# peekOption

Views the next element in the queue without removing it, returning `None`
if the queue is empty.

To import and use `peekOption` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.peekOption
```

**Signature**

```ts
export declare const peekOption: <A>(self: TDequeue<A>) => STM.STM<Option.Option<A>>
```


# poll

Takes a single element from the queue, returning `None` if the queue is
empty.

To import and use `poll` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.poll
```

**Signature**

```ts
export declare const poll: <A>(self: TDequeue<A>) => STM.STM<Option.Option<A>>
```


# seek

Drops elements from the queue while they do not satisfy the predicate,
taking and returning the first element that does satisfy the predicate.
Retries if no elements satisfy the predicate.

To import and use `seek` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.seek
```

**Signature**

```ts
export declare const seek: {
  <A>(predicate: Predicate<A>): (self: TDequeue<A>) => STM.STM<A>
  <A>(self: TDequeue<A>, predicate: Predicate<A>): STM.STM<A>
}
```


# shutdown

Interrupts any fibers that are suspended on `offer` or `take`. Future calls
to `offer*` and `take*` will be interrupted immediately.

To import and use `shutdown` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.shutdown
```

**Signature**

```ts
export declare const shutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<void>
```


# size

Retrieves the size of the queue, which is equal to the number of elements
in the queue. This may be negative if fibers are suspended waiting for
elements to be added to the queue.

To import and use `size` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.size
```

**Signature**

```ts
export declare const size: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<number>
```


# sliding

Creates a bounded queue with the sliding strategy. The queue will add new
values and drop old values if the queue is at capacity.

For best performance use capacities that are powers of two.

To import and use `sliding` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.sliding
```

**Signature**

```ts
export declare const sliding: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>
```


# take

Takes the oldest value in the queue. If the queue is empty, this will return
a computation that resumes when an item has been added to the queue.

To import and use `take` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.take
```

**Signature**

```ts
export declare const take: <A>(self: TDequeue<A>) => STM.STM<A>
```


# takeAll

Takes all the values in the queue and returns the values. If the queue is
empty returns an empty collection.

To import and use `takeAll` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.takeAll
```

**Signature**

```ts
export declare const takeAll: <A>(self: TDequeue<A>) => STM.STM<Array<A>>
```


# takeBetween

Takes a number of elements from the queue between the specified minimum and
maximum. If there are fewer than the minimum number of elements available,
retries until at least the minimum number of elements have been collected.

To import and use `takeBetween` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.takeBetween
```

**Signature**

```ts
export declare const takeBetween: {
  (min: number, max: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>
  <A>(self: TDequeue<A>, min: number, max: number): STM.STM<Array<A>>
}
```


# takeN

Takes the specified number of elements from the queue. If there are fewer
than the specified number of elements available, it retries until they
become available.

To import and use `takeN` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.takeN
```

**Signature**

```ts
export declare const takeN: {
  (n: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>
  <A>(self: TDequeue<A>, n: number): STM.STM<Array<A>>
}
```


# takeUpTo

Takes up to max number of values from the queue.

To import and use `takeUpTo` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.takeUpTo
```

**Signature**

```ts
export declare const takeUpTo: {
  (max: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>
  <A>(self: TDequeue<A>, max: number): STM.STM<Array<A>>
}
```


# unbounded

Creates an unbounded queue.

To import and use `unbounded` from the "TQueue" module:

```ts
import * as TQueue from "effect/TQueue"
// Can be accessed like this
TQueue.unbounded
```

**Signature**

```ts
export declare const unbounded: <A>() => STM.STM<TQueue<A>>
```


# withSpanContext

Set the effect's parent span from the given opentelemetry `SpanContext`.

This is handy when you set up OpenTelemetry outside of Effect and want to
attach to a parent span.

To import and use `withSpanContext` from the "Tracer" module:

```ts
import * as Tracer from "@effect/opentelemetry/Tracer"
// Can be accessed like this
Tracer.withSpanContext
```

**Signature**

```ts
export declare const withSpanContext: {
  (spanContext: Otel.SpanContext): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, ParentSpan>>
  <A, E, R>(effect: Effect<A, E, R>, spanContext: Otel.SpanContext): Effect<A, E, Exclude<R, ParentSpan>>
}
```


# live

The "live" `TRandom` service wrapped into a `Layer`.

To import and use `live` from the "TRandom" module:

```ts
import * as TRandom from "effect/TRandom"
// Can be accessed like this
TRandom.live
```

**Signature**

```ts
export declare const live: Layer.Layer<TRandom, never, never>
```


# next

Returns the next number from the pseudo-random number generator.

To import and use `next` from the "TRandom" module:

```ts
import * as TRandom from "effect/TRandom"
// Can be accessed like this
TRandom.next
```

**Signature**

```ts
export declare const next: STM.STM<number, never, TRandom>
```


# nextBoolean

Returns the next boolean value from the pseudo-random number generator.

To import and use `nextBoolean` from the "TRandom" module:

```ts
import * as TRandom from "effect/TRandom"
// Can be accessed like this
TRandom.nextBoolean
```

**Signature**

```ts
export declare const nextBoolean: STM.STM<boolean, never, TRandom>
```


# nextInt

Returns the next integer from the pseudo-random number generator.

To import and use `nextInt` from the "TRandom" module:

```ts
import * as TRandom from "effect/TRandom"
// Can be accessed like this
TRandom.nextInt
```

**Signature**

```ts
export declare const nextInt: STM.STM<number, never, TRandom>
```


# nextIntBetween

Returns the next integer in the specified range from the pseudo-random number
generator.

To import and use `nextIntBetween` from the "TRandom" module:

```ts
import * as TRandom from "effect/TRandom"
// Can be accessed like this
TRandom.nextIntBetween
```

**Signature**

```ts
export declare const nextIntBetween: (low: number, high: number) => STM.STM<number, never, TRandom>
```


# nextRange

Returns the next number in the specified range from the pseudo-random number
generator.

To import and use `nextRange` from the "TRandom" module:

```ts
import * as TRandom from "effect/TRandom"
// Can be accessed like this
TRandom.nextRange
```

**Signature**

```ts
export declare const nextRange: (min: number, max: number) => STM.STM<number, never, TRandom>
```


# shuffle

Uses the pseudo-random number generator to shuffle the specified iterable.

To import and use `shuffle` from the "TRandom" module:

```ts
import * as TRandom from "effect/TRandom"
// Can be accessed like this
TRandom.shuffle
```

**Signature**

```ts
export declare const shuffle: <A>(elements: Iterable<A>) => STM.STM<Array<A>, never, TRandom>
```


# Tag

The service tag used to access `TRandom` in the environment of an effect.

To import and use `Tag` from the "TRandom" module:

```ts
import * as TRandom from "effect/TRandom"
// Can be accessed like this
TRandom.Tag
```

**Signature**

```ts
export declare const Tag: Context.Tag<TRandom, TRandom>
```


# sequence

Returns a default `sequence` implementation.

To import and use `sequence` from the "Traversable" module:

```ts
import * as Traversable from "@effect/typeclass/Traversable"
// Can be accessed like this
Traversable.sequence
```

**Signature**

```ts
export declare const sequence: <T extends TypeLambda>(
  T: Traversable<T>
) => <F extends TypeLambda>(
  F: Applicative<F>
) => <TR, TO, TE, R, O, E, A>(
  self: Kind<T, TR, TO, TE, Kind<F, R, O, E, A>>
) => Kind<F, R, O, E, Kind<T, TR, TO, TE, A>>
```


# traverseComposition

Returns a default binary `traverse` composition.

To import and use `traverseComposition` from the "Traversable" module:

```ts
import * as Traversable from "@effect/typeclass/Traversable"
// Can be accessed like this
Traversable.traverseComposition
```

**Signature**

```ts
export declare const traverseComposition: <T extends TypeLambda, G extends TypeLambda>(
  T: Traversable<T>,
  G: Traversable<G>
) => <F extends TypeLambda>(
  F: Applicative<F>
) => <TR, TO, TE, GR, GO, GE, A, R, O, E, B>(
  self: Kind<T, TR, TO, TE, Kind<G, GR, GO, GE, A>>,
  f: (a: A) => Kind<F, R, O, E, B>
) => Kind<F, R, O, E, Kind<T, TR, TO, TE, Kind<G, GR, GO, GE, B>>>
```


# traverseTap

Given a function which returns a `F` effect, thread this effect
through the running of this function on all the values in `T`,
returning an `T<A>` in a `F` context, ignoring the values
returned by the provided function.

To import and use `traverseTap` from the "Traversable" module:

```ts
import * as Traversable from "@effect/typeclass/Traversable"
// Can be accessed like this
Traversable.traverseTap
```

**Signature**

```ts
export declare const traverseTap: <T extends TypeLambda>(
  T: Traversable<T>
) => <F extends TypeLambda>(
  F: Applicative<F>
) => {
  <A, R, O, E, B>(
    f: (a: A) => Kind<F, R, O, E, B>
  ): <TR, TO, TE>(self: Kind<T, TR, TO, TE, A>) => Kind<F, R, O, E, Kind<T, TR, TO, TE, A>>
  <TR, TO, TE, A, R, O, E, B>(
    self: Kind<T, TR, TO, TE, A>,
    f: (a: A) => Kind<F, R, O, E, B>
  ): Kind<F, R, O, E, Kind<T, TR, TO, TE, A>>
}
```


# traverseFilterMap

Returns a default binary `traverseFilterMap` implementation.

To import and use `traverseFilterMap` from the "TraversableFilterable" module:

```ts
import * as TraversableFilterable from "@effect/typeclass/TraversableFilterable"
// Can be accessed like this
TraversableFilterable.traverseFilterMap
```

**Signature**

```ts
export declare const traverseFilterMap: <T extends TypeLambda>(
  T: Traversable<T> & Filterable<T>
) => <F extends TypeLambda>(
  F: Applicative<F>
) => <TR, TO, TE, A, R, O, E, B>(
  self: Kind<T, TR, TO, TE, A>,
  f: (a: A) => Kind<F, R, O, E, Option<B>>
) => Kind<F, R, O, E, Kind<T, TR, TO, TE, B>>
```


# traversePartitionMap

Returns a default binary `traversePartitionMap` implementation.

To import and use `traversePartitionMap` from the "TraversableFilterable" module:

```ts
import * as TraversableFilterable from "@effect/typeclass/TraversableFilterable"
// Can be accessed like this
TraversableFilterable.traversePartitionMap
```

**Signature**

```ts
export declare const traversePartitionMap: <T extends TypeLambda>(
  T: Traversable<T> & Covariant<T> & Filterable<T>
) => <F extends TypeLambda>(
  F: Applicative<F>
) => <TR, TO, TE, A, R, O, E, B, C>(
  self: Kind<T, TR, TO, TE, A>,
  f: (a: A) => Kind<F, R, O, E, Either<C, B>>
) => Kind<F, R, O, E, [Kind<T, TR, TO, TE, B>, Kind<T, TR, TO, TE, C>]>
```


# acquireRead

Acquires a read lock. The transaction will suspend until no other fiber is
holding a write lock. Succeeds with the number of read locks held by this
fiber.

To import and use `acquireRead` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.acquireRead
```

**Signature**

```ts
export declare const acquireRead: (self: TReentrantLock) => STM.STM<number>
```


# acquireWrite

Acquires a write lock. The transaction will suspend until no other fibers
are holding read or write locks. Succeeds with the number of write locks
held by this fiber.

To import and use `acquireWrite` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.acquireWrite
```

**Signature**

```ts
export declare const acquireWrite: (self: TReentrantLock) => STM.STM<number>
```


# fiberReadLocks

Retrieves the number of acquired read locks for this fiber.

To import and use `fiberReadLocks` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.fiberReadLocks
```

**Signature**

```ts
export declare const fiberReadLocks: (self: TReentrantLock) => STM.STM<number>
```


# fiberWriteLocks

Retrieves the number of acquired write locks for this fiber.

To import and use `fiberWriteLocks` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.fiberWriteLocks
```

**Signature**

```ts
export declare const fiberWriteLocks: (self: TReentrantLock) => STM.STM<number>
```


# lock

Just a convenience method for applications that only need reentrant locks,
without needing a distinction between readers / writers.

See `TReentrantLock.writeLock`.

To import and use `lock` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.lock
```

**Signature**

```ts
export declare const lock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>
```


# locked

Determines if any fiber has a read or write lock.

To import and use `locked` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.locked
```

**Signature**

```ts
export declare const locked: (self: TReentrantLock) => STM.STM<boolean>
```


# make

Makes a new reentrant read/write lock.

To import and use `make` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.make
```

**Signature**

```ts
export declare const make: STM.STM<TReentrantLock, never, never>
```


# readLock

Obtains a read lock in a scoped context.

To import and use `readLock` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.readLock
```

**Signature**

```ts
export declare const readLock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>
```


# readLocked

Determines if any fiber has a read lock.

To import and use `readLocked` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.readLocked
```

**Signature**

```ts
export declare const readLocked: (self: TReentrantLock) => STM.STM<boolean>
```


# readLocks

Retrieves the total number of acquired read locks.

To import and use `readLocks` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.readLocks
```

**Signature**

```ts
export declare const readLocks: (self: TReentrantLock) => STM.STM<number>
```


# releaseRead

Releases a read lock held by this fiber. Succeeds with the outstanding
number of read locks held by this fiber.

To import and use `releaseRead` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.releaseRead
```

**Signature**

```ts
export declare const releaseRead: (self: TReentrantLock) => STM.STM<number>
```


# releaseWrite

Releases a write lock held by this fiber. Succeeds with the outstanding
number of write locks held by this fiber.

To import and use `releaseWrite` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.releaseWrite
```

**Signature**

```ts
export declare const releaseWrite: (self: TReentrantLock) => STM.STM<number>
```


# TReentrantLock

A `TReentrantLock` is a reentrant read/write lock. Multiple readers may all
concurrently acquire read locks. Only one writer is allowed to acquire a
write lock at any given time. Read locks may be upgraded into write locks. A
fiber that has a write lock may acquire other write locks or read locks.

The two primary methods of this structure are `readLock`, which acquires a
read lock in a scoped context, and `writeLock`, which acquires a write lock
in a scoped context.

Although located in the STM package, there is no need for locks within STM
transactions. However, this lock can be quite useful in effectful code, to
provide consistent read/write access to mutable state; and being in STM
allows this structure to be composed into more complicated concurrent
structures that are consumed from effectful code.

To import and use `TReentrantLock` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.TReentrantLock
```


# withLock

Runs the specified workflow with a lock.

To import and use `withLock` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.withLock
```

**Signature**

```ts
export declare const withLock: {
  (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
  <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>
}
```


# withReadLock

Runs the specified workflow with a read lock.

To import and use `withReadLock` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.withReadLock
```

**Signature**

```ts
export declare const withReadLock: {
  (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
  <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>
}
```


# withWriteLock

Runs the specified workflow with a write lock.

To import and use `withWriteLock` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.withWriteLock
```

**Signature**

```ts
export declare const withWriteLock: {
  (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
  <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>
}
```


# writeLock

Obtains a write lock in a scoped context.

To import and use `writeLock` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.writeLock
```

**Signature**

```ts
export declare const writeLock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>
```


# writeLocked

Determines if a write lock is held by some fiber.

To import and use `writeLocked` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.writeLocked
```

**Signature**

```ts
export declare const writeLocked: (self: TReentrantLock) => STM.STM<boolean>
```


# writeLocks

Computes the number of write locks held by fibers.

To import and use `writeLocks` from the "TReentrantLock" module:

```ts
import * as TReentrantLock from "effect/TReentrantLock"
// Can be accessed like this
TReentrantLock.writeLocks
```

**Signature**

```ts
export declare const writeLocks: (self: TReentrantLock) => STM.STM<number>
```


# TRef

A `TRef<A>` is a purely functional description of a mutable reference that can
be modified as part of a transactional effect. The fundamental operations of
a `TRef` are `set` and `get`. `set` transactionally sets the reference to a
new value. `get` gets the current value of the reference.

NOTE: While `TRef<A>` provides the transactional equivalent of a mutable
reference, the value inside the `TRef` should be immutable.

To import and use `TRef` from the "TRef" module:

```ts
import * as TRef from "effect/TRef"
// Can be accessed like this
TRef.TRef
```


# compact

Filters out `None` values from a `Trie` of `Options`s.

To import and use `compact` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.compact
```

**Example**

```ts
import { Trie, Equal, Option } from "effect"

const trie = Trie.empty<Option.Option<number>>().pipe(
  Trie.insert("shells", Option.some(0)),
  Trie.insert("sells", Option.none()),
  Trie.insert("she", Option.some(2))
)

const trieMapV = Trie.empty<number>().pipe(Trie.insert("shells", 0), Trie.insert("she", 2))

assert.equal(Equal.equals(Trie.compact(trie), trieMapV), true)
```

**Signature**

```ts
export declare const compact: <A>(self: Trie<Option<A>>) => Trie<A>
```


# empty

Creates an empty `Trie`.

To import and use `empty` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.empty
```

**Example**

```ts
import { Trie, Equal } from "effect"

const trie = Trie.empty<string>()

assert.equal(Trie.size(trie), 0)
assert.deepStrictEqual(Array.from(trie), [])
```

**Signature**

```ts
export declare const empty: <V = never>() => Trie<V>
```


# entries

Returns an `IterableIterator` of the entries within the `Trie`.

The entries are returned by keys in alphabetical order, regardless of insertion order.

To import and use `entries` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.entries
```

**Example**

```ts
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(Trie.insert("call", 0), Trie.insert("me", 1))

const result = Array.from(Trie.entries(trie))
assert.deepStrictEqual(result, [
  ["call", 0],
  ["me", 1]
])
```

**Signature**

```ts
export declare const entries: <V>(self: Trie<V>) => IterableIterator<[string, V]>
```


# entriesWithPrefix

Returns an `IterableIterator` of the entries within the `Trie`
that have `prefix` as prefix (`prefix` included if it exists).

To import and use `entriesWithPrefix` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.entriesWithPrefix
```

**Example**

```ts
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("she", 0),
  Trie.insert("shells", 1),
  Trie.insert("sea", 2),
  Trie.insert("shore", 3)
)

const result = Array.from(Trie.entriesWithPrefix(trie, "she"))
assert.deepStrictEqual(result, [
  ["she", 0],
  ["shells", 1]
])
```

**Signature**

```ts
export declare const entriesWithPrefix: {
  (prefix: string): <V>(self: Trie<V>) => IterableIterator<[string, V]>
  <V>(self: Trie<V>, prefix: string): IterableIterator<[string, V]>
}
```


# filter

Filters entries out of a `Trie` using the specified predicate.

To import and use `filter` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.filter
```

**Example**

```ts
import { Trie, Equal } from "effect"

const trie = Trie.empty<number>().pipe(Trie.insert("shells", 0), Trie.insert("sells", 1), Trie.insert("she", 2))

const trieMapV = Trie.empty<number>().pipe(Trie.insert("she", 2))

const trieMapK = Trie.empty<number>().pipe(Trie.insert("shells", 0), Trie.insert("sells", 1))

assert.equal(
  Equal.equals(
    Trie.filter(trie, (v) => v > 1),
    trieMapV
  ),
  true
)
assert.equal(
  Equal.equals(
    Trie.filter(trie, (_, k) => k.length > 3),
    trieMapK
  ),
  true
)
```

**Signature**

```ts
export declare const filter: {
  <A, B extends A>(f: (a: NoInfer<A>, k: string) => a is B): (self: Trie<A>) => Trie<B>
  <A>(f: (a: NoInfer<A>, k: string) => boolean): (self: Trie<A>) => Trie<A>
  <A, B extends A>(self: Trie<A>, f: (a: A, k: string) => a is B): Trie<B>
  <A>(self: Trie<A>, f: (a: A, k: string) => boolean): Trie<A>
}
```


# filterMap

Maps over the entries of the `Trie` using the specified partial function
and filters out `None` values.

To import and use `filterMap` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.filterMap
```

**Example**

```ts
import { Trie, Equal, Option } from "effect"

const trie = Trie.empty<number>().pipe(Trie.insert("shells", 0), Trie.insert("sells", 1), Trie.insert("she", 2))

const trieMapV = Trie.empty<number>().pipe(Trie.insert("she", 2))

const trieMapK = Trie.empty<number>().pipe(Trie.insert("shells", 0), Trie.insert("sells", 1))

assert.equal(
  Equal.equals(
    Trie.filterMap(trie, (v) => (v > 1 ? Option.some(v) : Option.none())),
    trieMapV
  ),
  true
)
assert.equal(
  Equal.equals(
    Trie.filterMap(trie, (v, k) => (k.length > 3 ? Option.some(v) : Option.none())),
    trieMapK
  ),
  true
)
```

**Signature**

```ts
export declare const filterMap: {
  <A, B>(f: (value: A, key: string) => Option<B>): (self: Trie<A>) => Trie<B>
  <A, B>(self: Trie<A>, f: (value: A, key: string) => Option<B>): Trie<B>
}
```


# forEach

Applies the specified function to the entries of the `Trie`.

To import and use `forEach` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.forEach
```

**Example**

```ts
import { Trie } from "effect"

let value = 0

Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2),
  Trie.forEach((n, key) => {
    value += n + key.length
  })
)

assert.equal(value, 17)
```

**Signature**

```ts
export declare const forEach: {
  <V>(f: (value: V, key: string) => void): (self: Trie<V>) => void
  <V>(self: Trie<V>, f: (value: V, key: string) => void): void
}
```


# fromIterable

Creates a new `Trie` from an iterable collection of key/value pairs (e.g. `Array<[string, V]>`).

To import and use `fromIterable` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.fromIterable
```

**Example**

```ts
import { Trie, Equal } from "effect"

const iterable: Array<readonly [string, number]> = [
  ["call", 0],
  ["me", 1],
  ["mind", 2],
  ["mid", 3]
]
const trie = Trie.fromIterable(iterable)

// The entries in the `Trie` are extracted in alphabetical order, regardless of the insertion order
assert.deepStrictEqual(Array.from(trie), [
  ["call", 0],
  ["me", 1],
  ["mid", 3],
  ["mind", 2]
])
assert.equal(Equal.equals(Trie.make(["call", 0], ["me", 1], ["mind", 2], ["mid", 3]), trie), true)
```

**Signature**

```ts
export declare const fromIterable: <V>(entries: Iterable<readonly [string, V]>) => Trie<V>
```


# get

Safely lookup the value for the specified key in the `Trie`.

To import and use `get` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.get
```

**Example**

```ts
import { Trie, Option } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1),
  Trie.insert("mind", 2),
  Trie.insert("mid", 3)
)

assert.deepStrictEqual(Trie.get(trie, "call"), Option.some(0))
assert.deepStrictEqual(Trie.get(trie, "me"), Option.some(1))
assert.deepStrictEqual(Trie.get(trie, "mind"), Option.some(2))
assert.deepStrictEqual(Trie.get(trie, "mid"), Option.some(3))
assert.deepStrictEqual(Trie.get(trie, "cale"), Option.none())
assert.deepStrictEqual(Trie.get(trie, "ma"), Option.none())
assert.deepStrictEqual(Trie.get(trie, "midn"), Option.none())
assert.deepStrictEqual(Trie.get(trie, "mea"), Option.none())
```

**Signature**

```ts
export declare const get: { (key: string): <V>(self: Trie<V>) => Option<V>; <V>(self: Trie<V>, key: string): Option<V> }
```


# has

Check if the given key exists in the `Trie`.

To import and use `has` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.has
```

**Example**

```ts
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1),
  Trie.insert("mind", 2),
  Trie.insert("mid", 3)
)

assert.equal(Trie.has(trie, "call"), true)
assert.equal(Trie.has(trie, "me"), true)
assert.equal(Trie.has(trie, "mind"), true)
assert.equal(Trie.has(trie, "mid"), true)
assert.equal(Trie.has(trie, "cale"), false)
assert.equal(Trie.has(trie, "ma"), false)
assert.equal(Trie.has(trie, "midn"), false)
assert.equal(Trie.has(trie, "mea"), false)
```

**Signature**

```ts
export declare const has: { (key: string): <V>(self: Trie<V>) => boolean; <V>(self: Trie<V>, key: string): boolean }
```


# insert

Insert a new entry in the `Trie`.

To import and use `insert` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.insert
```

**Example**

```ts
import { Trie } from "effect"

const trie1 = Trie.empty<number>().pipe(Trie.insert("call", 0))
const trie2 = trie1.pipe(Trie.insert("me", 1))
const trie3 = trie2.pipe(Trie.insert("mind", 2))
const trie4 = trie3.pipe(Trie.insert("mid", 3))

assert.deepStrictEqual(Array.from(trie1), [["call", 0]])
assert.deepStrictEqual(Array.from(trie2), [
  ["call", 0],
  ["me", 1]
])
assert.deepStrictEqual(Array.from(trie3), [
  ["call", 0],
  ["me", 1],
  ["mind", 2]
])
assert.deepStrictEqual(Array.from(trie4), [
  ["call", 0],
  ["me", 1],
  ["mid", 3],
  ["mind", 2]
])
```

**Signature**

```ts
export declare const insert: {
  <V1>(key: string, value: V1): <V>(self: Trie<V>) => Trie<V | V1>
  <V1, V>(self: Trie<V>, key: string, value: V1): Trie<V | V1>
}
```


# insertMany

Insert multiple entries in the `Trie` at once.

To import and use `insertMany` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.insertMany
```

**Example**

```ts
import { Trie, Equal } from "effect"

const trie = Trie.empty<number>().pipe(Trie.insert("shells", 0), Trie.insert("sells", 1), Trie.insert("she", 2))

const trieInsert = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insertMany([
    ["sells", 1],
    ["she", 2]
  ])
)

assert.equal(Equal.equals(trie, trieInsert), true)
```

**Signature**

```ts
export declare const insertMany: {
  <V1>(iter: Iterable<[string, V1]>): <V>(self: Trie<V>) => Trie<V | V1>
  <V1, V>(self: Trie<V>, iter: Iterable<[string, V1]>): Trie<V | V1>
}
```


# isEmpty

Checks if the `Trie` contains any entries.

To import and use `isEmpty` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.isEmpty
```

**Example**

```ts
import { Trie } from "effect"

const trie = Trie.empty<number>()
const trie1 = trie.pipe(Trie.insert("ma", 0))

assert.equal(Trie.isEmpty(trie), true)
assert.equal(Trie.isEmpty(trie1), false)
```

**Signature**

```ts
export declare const isEmpty: <V>(self: Trie<V>) => boolean
```


# keys

Returns an `IterableIterator` of the keys within the `Trie`.

The keys are returned in alphabetical order, regardless of insertion order.

To import and use `keys` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.keys
```

**Example**

```ts
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(Trie.insert("cab", 0), Trie.insert("abc", 1), Trie.insert("bca", 2))

const result = Array.from(Trie.keys(trie))
assert.deepStrictEqual(result, ["abc", "bca", "cab"])
```

**Signature**

```ts
export declare const keys: <V>(self: Trie<V>) => IterableIterator<string>
```


# keysWithPrefix

Returns an `IterableIterator` of the keys within the `Trie`
that have `prefix` as prefix (`prefix` included if it exists).

To import and use `keysWithPrefix` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.keysWithPrefix
```

**Example**

```ts
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("she", 0),
  Trie.insert("shells", 1),
  Trie.insert("sea", 2),
  Trie.insert("shore", 3)
)

const result = Array.from(Trie.keysWithPrefix(trie, "she"))
assert.deepStrictEqual(result, ["she", "shells"])
```

**Signature**

```ts
export declare const keysWithPrefix: {
  (prefix: string): <V>(self: Trie<V>) => IterableIterator<string>
  <V>(self: Trie<V>, prefix: string): IterableIterator<string>
}
```


# longestPrefixOf

Returns the longest key/value in the `Trie`
that is a prefix of that `key` if it exists, `None` otherwise.

To import and use `longestPrefixOf` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.longestPrefixOf
```

**Example**

```ts
import { Trie, Option } from "effect"

const trie = Trie.empty<number>().pipe(Trie.insert("shells", 0), Trie.insert("sells", 1), Trie.insert("she", 2))

assert.deepStrictEqual(Trie.longestPrefixOf(trie, "sell"), Option.none())
assert.deepStrictEqual(Trie.longestPrefixOf(trie, "sells"), Option.some(["sells", 1]))
assert.deepStrictEqual(Trie.longestPrefixOf(trie, "shell"), Option.some(["she", 2]))
assert.deepStrictEqual(Trie.longestPrefixOf(trie, "shellsort"), Option.some(["shells", 0]))
```

**Signature**

```ts
export declare const longestPrefixOf: {
  (key: string): <V>(self: Trie<V>) => Option<[string, V]>
  <V>(self: Trie<V>, key: string): Option<[string, V]>
}
```


# make

Constructs a new `Trie` from the specified entries (`[string, V]`).

To import and use `make` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.make
```

**Example**

```ts
import { Trie, Equal } from "effect"

const trie = Trie.make(["ca", 0], ["me", 1])

assert.deepStrictEqual(Array.from(trie), [
  ["ca", 0],
  ["me", 1]
])
assert.equal(
  Equal.equals(
    Trie.fromIterable([
      ["ca", 0],
      ["me", 1]
    ]),
    trie
  ),
  true
)
```

**Signature**

```ts
export declare const make: <Entries extends Array<readonly [string, any]>>(
  ...entries: Entries
) => Trie<Entries[number] extends readonly [any, infer V] ? V : never>
```


# map

Maps over the entries of the `Trie` using the specified function.

To import and use `map` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.map
```

**Example**

```ts
import { Trie, Equal } from "effect"

const trie = Trie.empty<number>().pipe(Trie.insert("shells", 0), Trie.insert("sells", 1), Trie.insert("she", 2))

const trieMapV = Trie.empty<number>().pipe(Trie.insert("shells", 1), Trie.insert("sells", 2), Trie.insert("she", 3))

const trieMapK = Trie.empty<number>().pipe(Trie.insert("shells", 6), Trie.insert("sells", 5), Trie.insert("she", 3))

assert.equal(
  Equal.equals(
    Trie.map(trie, (v) => v + 1),
    trieMapV
  ),
  true
)
assert.equal(
  Equal.equals(
    Trie.map(trie, (_, k) => k.length),
    trieMapK
  ),
  true
)
```

**Signature**

```ts
export declare const map: {
  <A, V>(f: (value: V, key: string) => A): (self: Trie<V>) => Trie<A>
  <V, A>(self: Trie<V>, f: (value: V, key: string) => A): Trie<A>
}
```


# modify

Updates the value of the specified key within the `Trie` if it exists.

To import and use `modify` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.modify
```

**Example**

```ts
import { Trie, Equal, Option } from "effect"

const trie = Trie.empty<number>().pipe(Trie.insert("shells", 0), Trie.insert("sells", 1), Trie.insert("she", 2))

assert.deepStrictEqual(
  trie.pipe(
    Trie.modify("she", (v) => v + 10),
    Trie.get("she")
  ),
  Option.some(12)
)

assert.equal(Equal.equals(trie.pipe(Trie.modify("me", (v) => v)), trie), true)
```

**Signature**

```ts
export declare const modify: {
  <V1, V>(key: string, f: (v: V) => V1): (self: Trie<V>) => Trie<V1 | V>
  <V1, V>(self: Trie<V>, key: string, f: (v: V) => V1): Trie<V | V1>
}
```


# reduce

Reduce a state over the entries of the `Trie`.

To import and use `reduce` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.reduce
```

**Example**

```ts
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(Trie.insert("shells", 0), Trie.insert("sells", 1), Trie.insert("she", 2))

assert.equal(trie.pipe(Trie.reduce(0, (acc, n) => acc + n)), 3)
assert.equal(trie.pipe(Trie.reduce(10, (acc, n) => acc + n)), 13)
assert.equal(trie.pipe(Trie.reduce("", (acc, _, key) => acc + key)), "sellssheshells")
```

**Signature**

```ts
export declare const reduce: {
  <Z, V>(zero: Z, f: (accumulator: Z, value: V, key: string) => Z): (self: Trie<V>) => Z
  <Z, V>(self: Trie<V>, zero: Z, f: (accumulator: Z, value: V, key: string) => Z): Z
}
```


# remove

Remove the entry for the specified key in the `Trie`.

To import and use `remove` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.remove
```

**Example**

```ts
import { Trie, Option } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1),
  Trie.insert("mind", 2),
  Trie.insert("mid", 3)
)

const trie1 = trie.pipe(Trie.remove("call"))
const trie2 = trie1.pipe(Trie.remove("mea"))

assert.deepStrictEqual(Trie.get(trie, "call"), Option.some(0))
assert.deepStrictEqual(Trie.get(trie1, "call"), Option.none())
assert.deepStrictEqual(Trie.get(trie2, "call"), Option.none())
```

**Signature**

```ts
export declare const remove: { (key: string): <V>(self: Trie<V>) => Trie<V>; <V>(self: Trie<V>, key: string): Trie<V> }
```


# removeMany

Removes all entries in the `Trie` which have the specified keys.

To import and use `removeMany` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.removeMany
```

**Example**

```ts
import { Trie, Equal } from "effect"

const trie = Trie.empty<number>().pipe(Trie.insert("shells", 0), Trie.insert("sells", 1), Trie.insert("she", 2))

assert.equal(
  Equal.equals(trie.pipe(Trie.removeMany(["she", "sells"])), Trie.empty<number>().pipe(Trie.insert("shells", 0))),
  true
)
```

**Signature**

```ts
export declare const removeMany: {
  (keys: Iterable<string>): <V>(self: Trie<V>) => Trie<V>
  <V>(self: Trie<V>, keys: Iterable<string>): Trie<V>
}
```


# size

Returns the size of the `Trie` (number of entries in the `Trie`).

To import and use `size` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.size
```

**Example**

```ts
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(Trie.insert("a", 0), Trie.insert("b", 1))

assert.equal(Trie.size(trie), 2)
```

**Signature**

```ts
export declare const size: <V>(self: Trie<V>) => number
```


# toEntries

Returns an `Array<[K, V]>` of the entries within the `Trie`.

Equivalent to `Array.from(Trie.entries(trie))`.

To import and use `toEntries` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.toEntries
```

**Example**

```ts
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(Trie.insert("call", 0), Trie.insert("me", 1))
const result = Trie.toEntries(trie)

assert.deepStrictEqual(result, [
  ["call", 0],
  ["me", 1]
])
```

**Signature**

```ts
export declare const toEntries: <V>(self: Trie<V>) => Array<[string, V]>
```


# toEntriesWithPrefix

Returns `Array<[K, V]>` of the entries within the `Trie`
that have `prefix` as prefix (`prefix` included if it exists).

To import and use `toEntriesWithPrefix` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.toEntriesWithPrefix
```

**Example**

```ts
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("sea", 2),
  Trie.insert("she", 3)
)

const result = Trie.toEntriesWithPrefix(trie, "she")
assert.deepStrictEqual(result, [
  ["she", 3],
  ["shells", 0]
])
```

**Signature**

```ts
export declare const toEntriesWithPrefix: {
  (prefix: string): <V>(self: Trie<V>) => Array<[string, V]>
  <V>(self: Trie<V>, prefix: string): Array<[string, V]>
}
```


# unsafeGet

Unsafely lookup the value for the specified key in the `Trie`.

`unsafeGet` will throw if the key is not found. Use `get` instead to safely
get a value from the `Trie`.

To import and use `unsafeGet` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.unsafeGet
```

**Example**

```ts
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(Trie.insert("call", 0), Trie.insert("me", 1))

assert.throws(() => Trie.unsafeGet(trie, "mae"))
```

**Signature**

```ts
export declare const unsafeGet: { (key: string): <V>(self: Trie<V>) => V; <V>(self: Trie<V>, key: string): V }
```


# values

Returns an `IterableIterator` of the values within the `Trie`.

Values are ordered based on their key in alphabetical order, regardless of insertion order.

To import and use `values` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.values
```

**Example**

```ts
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(Trie.insert("call", 0), Trie.insert("me", 1), Trie.insert("and", 2))

const result = Array.from(Trie.values(trie))
assert.deepStrictEqual(result, [2, 0, 1])
```

**Signature**

```ts
export declare const values: <V>(self: Trie<V>) => IterableIterator<V>
```


# valuesWithPrefix

Returns an `IterableIterator` of the values within the `Trie`
that have `prefix` as prefix (`prefix` included if it exists).

To import and use `valuesWithPrefix` from the "Trie" module:

```ts
import * as Trie from "effect/Trie"
// Can be accessed like this
Trie.valuesWithPrefix
```

**Example**

```ts
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("she", 0),
  Trie.insert("shells", 1),
  Trie.insert("sea", 2),
  Trie.insert("shore", 3)
)

const result = Array.from(Trie.valuesWithPrefix(trie, "she"))

// 0: "she", 1: "shells"
assert.deepStrictEqual(result, [0, 1])
```

**Signature**

```ts
export declare const valuesWithPrefix: {
  (prefix: string): <V>(self: Trie<V>) => IterableIterator<V>
  <V>(self: Trie<V>, prefix: string): IterableIterator<V>
}
```


# add

Stores new element in the set.

To import and use `add` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.add
```

**Signature**

```ts
export declare const add: {
  <A>(value: A): (self: TSet<A>) => STM.STM<void>
  <A>(self: TSet<A>, value: A): STM.STM<void>
}
```


# difference

Atomically transforms the set into the difference of itself and the
provided set.

To import and use `difference` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.difference
```

**Signature**

```ts
export declare const difference: {
  <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>
  <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>
}
```


# empty

Makes an empty `TSet`.

To import and use `empty` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.empty
```

**Signature**

```ts
export declare const empty: <A>() => STM.STM<TSet<A>>
```


# forEach

Atomically performs transactional-effect for each element in set.

To import and use `forEach` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.forEach
```

**Signature**

```ts
export declare const forEach: {
  <A, R, E>(f: (value: A) => STM.STM<void, E, R>): (self: TSet<A>) => STM.STM<void, E, R>
  <A, R, E>(self: TSet<A>, f: (value: A) => STM.STM<void, E, R>): STM.STM<void, E, R>
}
```


# fromIterable

Creates a new `TSet` from an iterable collection of values.

To import and use `fromIterable` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.fromIterable
```

**Signature**

```ts
export declare const fromIterable: <A>(iterable: Iterable<A>) => STM.STM<TSet<A>>
```


# has

Tests whether or not set contains an element.

To import and use `has` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.has
```

**Signature**

```ts
export declare const has: {
  <A>(value: A): (self: TSet<A>) => STM.STM<boolean>
  <A>(self: TSet<A>, value: A): STM.STM<boolean>
}
```


# intersection

Atomically transforms the set into the intersection of itself and the
provided set.

To import and use `intersection` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.intersection
```

**Signature**

```ts
export declare const intersection: {
  <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>
  <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>
}
```


# isEmpty

Tests if the set is empty or not

To import and use `isEmpty` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.isEmpty
```

**Signature**

```ts
export declare const isEmpty: <A>(self: TSet<A>) => STM.STM<boolean>
```


# make

Makes a new `TSet` that is initialized with specified values.

To import and use `make` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.make
```

**Signature**

```ts
export declare const make: <Elements extends Array<any>>(...elements: Elements) => STM.STM<TSet<Elements[number]>>
```


# reduce

Atomically folds using a pure function.

To import and use `reduce` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.reduce
```

**Signature**

```ts
export declare const reduce: {
  <Z, A>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: TSet<A>) => STM.STM<Z>
  <Z, A>(self: TSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z): STM.STM<Z>
}
```


# reduceSTM

Atomically folds using a transactional function.

To import and use `reduceSTM` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.reduceSTM
```

**Signature**

```ts
export declare const reduceSTM: {
  <Z, A, R, E>(zero: Z, f: (accumulator: Z, value: A) => STM.STM<Z, E, R>): (self: TSet<A>) => STM.STM<Z, E, R>
  <Z, A, R, E>(self: TSet<A>, zero: Z, f: (accumulator: Z, value: A) => STM.STM<Z, E, R>): STM.STM<Z, E, R>
}
```


# remove

Removes a single element from the set.

To import and use `remove` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.remove
```

**Signature**

```ts
export declare const remove: {
  <A>(value: A): (self: TSet<A>) => STM.STM<void>
  <A>(self: TSet<A>, value: A): STM.STM<void>
}
```


# removeAll

Removes elements from the set.

To import and use `removeAll` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.removeAll
```

**Signature**

```ts
export declare const removeAll: {
  <A>(iterable: Iterable<A>): (self: TSet<A>) => STM.STM<void>
  <A>(self: TSet<A>, iterable: Iterable<A>): STM.STM<void>
}
```


# removeIf

Removes entries from a `TSet` that satisfy the specified predicate and returns the removed entries
(or `void` if `discard = true`).

To import and use `removeIf` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.removeIf
```

**Signature**

```ts
export declare const removeIf: {
  <A>(predicate: Predicate<A>, options: { readonly discard: true }): (self: TSet<A>) => STM.STM<void>
  <A>(predicate: Predicate<A>, options?: { readonly discard: false }): (self: TSet<A>) => STM.STM<Array<A>>
  <A>(self: TSet<A>, predicate: Predicate<A>, options: { readonly discard: true }): STM.STM<void>
  <A>(self: TSet<A>, predicate: Predicate<A>, options?: { readonly discard: false }): STM.STM<Array<A>>
}
```


# retainIf

Retains entries in a `TSet` that satisfy the specified predicate and returns the removed entries
(or `void` if `discard = true`).

To import and use `retainIf` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.retainIf
```

**Signature**

```ts
export declare const retainIf: {
  <A>(predicate: Predicate<A>, options: { readonly discard: true }): (self: TSet<A>) => STM.STM<void>
  <A>(predicate: Predicate<A>, options?: { readonly discard: false }): (self: TSet<A>) => STM.STM<Array<A>>
  <A>(self: TSet<A>, predicate: Predicate<A>, options: { readonly discard: true }): STM.STM<void>
  <A>(self: TSet<A>, predicate: Predicate<A>, options?: { readonly discard: false }): STM.STM<Array<A>>
}
```


# size

Returns the set's cardinality.

To import and use `size` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.size
```

**Signature**

```ts
export declare const size: <A>(self: TSet<A>) => STM.STM<number>
```


# takeFirst

Takes the first matching value, or retries until there is one.

To import and use `takeFirst` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.takeFirst
```

**Signature**

```ts
export declare const takeFirst: {
  <A, B>(pf: (a: A) => Option.Option<B>): (self: TSet<A>) => STM.STM<B>
  <A, B>(self: TSet<A>, pf: (a: A) => Option.Option<B>): STM.STM<B>
}
```


# takeFirstSTM

Takes the first matching value, or retries until there is one.

To import and use `takeFirstSTM` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.takeFirstSTM
```

**Signature**

```ts
export declare const takeFirstSTM: {
  <A, B, E, R>(pf: (a: A) => STM.STM<B, Option.Option<E>, R>): (self: TSet<A>) => STM.STM<B, E, R>
  <A, B, E, R>(self: TSet<A>, pf: (a: A) => STM.STM<B, Option.Option<E>, R>): STM.STM<B, E, R>
}
```


# takeSome

Takes all matching values, or retries until there is at least one.

To import and use `takeSome` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.takeSome
```

**Signature**

```ts
export declare const takeSome: {
  <A, B>(pf: (a: A) => Option.Option<B>): (self: TSet<A>) => STM.STM<[B, ...Array<B>]>
  <A, B>(self: TSet<A>, pf: (a: A) => Option.Option<B>): STM.STM<[B, ...Array<B>]>
}
```


# takeSomeSTM

Takes all matching values, or retries until there is at least one.

To import and use `takeSomeSTM` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.takeSomeSTM
```

**Signature**

```ts
export declare const takeSomeSTM: {
  <A, B, E, R>(pf: (a: A) => STM.STM<B, Option.Option<E>, R>): (self: TSet<A>) => STM.STM<[B, ...Array<B>], E, R>
  <A, B, E, R>(self: TSet<A>, pf: (a: A) => STM.STM<B, Option.Option<E>, R>): STM.STM<[B, ...Array<B>], E, R>
}
```


# toArray

Collects all elements into a `Array`.

To import and use `toArray` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.toArray
```

**Signature**

```ts
export declare const toArray: <A>(self: TSet<A>) => STM.STM<Array<A>>
```


# toChunk

Collects all elements into a `Chunk`.

To import and use `toChunk` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.toChunk
```

**Signature**

```ts
export declare const toChunk: <A>(self: TSet<A>) => STM.STM<Chunk.Chunk<A>>
```


# toHashSet

Collects all elements into a `HashSet`.

To import and use `toHashSet` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.toHashSet
```

**Signature**

```ts
export declare const toHashSet: <A>(self: TSet<A>) => STM.STM<HashSet.HashSet<A>>
```


# toReadonlySet

Collects all elements into a `ReadonlySet`.

To import and use `toReadonlySet` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.toReadonlySet
```

**Signature**

```ts
export declare const toReadonlySet: <A>(self: TSet<A>) => STM.STM<ReadonlySet<A>>
```


# transform

Atomically updates all elements using a pure function.

To import and use `transform` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.transform
```

**Signature**

```ts
export declare const transform: {
  <A>(f: (a: A) => A): (self: TSet<A>) => STM.STM<void>
  <A>(self: TSet<A>, f: (a: A) => A): STM.STM<void>
}
```


# transformSTM

Atomically updates all elements using a transactional function.

To import and use `transformSTM` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.transformSTM
```

**Signature**

```ts
export declare const transformSTM: {
  <A, R, E>(f: (a: A) => STM.STM<A, E, R>): (self: TSet<A>) => STM.STM<void, E, R>
  <A, R, E>(self: TSet<A>, f: (a: A) => STM.STM<A, E, R>): STM.STM<void, E, R>
}
```


# TSet

Transactional set implemented on top of `TMap`.

To import and use `TSet` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.TSet
```


# union

Atomically transforms the set into the union of itself and the provided
set.

To import and use `union` from the "TSet" module:

```ts
import * as TSet from "effect/TSet"
// Can be accessed like this
TSet.union
```

**Signature**

```ts
export declare const union: {
  <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>
  <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>
}
```


# TSubscriptionRef

A `TSubscriptionRef<A>` is a `TRef` that can be subscribed to in order to
receive a `TDequeue<A>` of the current value and all committed changes to the value.

To import and use `TSubscriptionRef` from the "TSubscriptionRef" module:

```ts
import * as TSubscriptionRef from "effect/TSubscriptionRef"
// Can be accessed like this
TSubscriptionRef.TSubscriptionRef
```


# appendElement

Appends an element to the end of a tuple.

To import and use `appendElement` from the "Tuple" module:

```ts
import * as Tuple from "effect/Tuple"
// Can be accessed like this
Tuple.appendElement
```

**Signature**

```ts
export declare const appendElement: {
  <B>(that: B): <A extends ReadonlyArray<unknown>>(self: A) => [...A, B]
  <A extends ReadonlyArray<unknown>, B>(self: A, that: B): [...A, B]
}
```


# at

Retrieves the element at a specified index from a tuple.

To import and use `at` from the "Tuple" module:

```ts
import * as Tuple from "effect/Tuple"
// Can be accessed like this
Tuple.at
```

**Example**

```ts
import { Tuple } from "effect"

assert.deepStrictEqual(Tuple.at([1, "hello", true], 1), "hello")
```

**Signature**

```ts
export declare const at: {
  <N extends number>(index: N): <A extends ReadonlyArray<unknown>>(self: A) => A[N]
  <A extends ReadonlyArray<unknown>, N extends number>(self: A, index: N): A[N]
}
```


# getEquivalence

Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple
by applying each `Equivalence` to the corresponding element of the tuple.

To import and use `getEquivalence` from the "Tuple" module:

```ts
import * as Tuple from "effect/Tuple"
// Can be accessed like this
Tuple.getEquivalence
```

**Signature**

```ts
export declare const getEquivalence: <T extends ReadonlyArray<Equivalence.Equivalence<any>>>(
  ...isEquivalents: T
) => Equivalence.Equivalence<
  Readonly<{ [I in keyof T]: [T[I]] extends [Equivalence.Equivalence<infer A>] ? A : never }>
>
```


# getFirst

Return the first element of a tuple.

To import and use `getFirst` from the "Tuple" module:

```ts
import * as Tuple from "effect/Tuple"
// Can be accessed like this
Tuple.getFirst
```

**Example**

```ts
import { getFirst } from "effect/Tuple"

assert.deepStrictEqual(getFirst(["hello", 42]), "hello")
```

**Signature**

```ts
export declare const getFirst: <L, R>(self: readonly [L, R]) => L
```


# getOrder

This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.
The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.
It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element
of the tuple.

To import and use `getOrder` from the "Tuple" module:

```ts
import * as Tuple from "effect/Tuple"
// Can be accessed like this
Tuple.getOrder
```

**Signature**

```ts
export declare const getOrder: <T extends ReadonlyArray<order.Order<any>>>(
  ...elements: T
) => order.Order<{ [I in keyof T]: [T[I]] extends [order.Order<infer A>] ? A : never }>
```


# getSecond

Return the second element of a tuple.

To import and use `getSecond` from the "Tuple" module:

```ts
import * as Tuple from "effect/Tuple"
// Can be accessed like this
Tuple.getSecond
```

**Example**

```ts
import { getSecond } from "effect/Tuple"

assert.deepStrictEqual(getSecond(["hello", 42]), 42)
```

**Signature**

```ts
export declare const getSecond: <L, R>(self: readonly [L, R]) => R
```


# isTupleOf

Determine if an `Array` is a tuple with exactly `N` elements, narrowing down the type to `TupleOf`.

An `Array` is considered to be a `TupleOf` if its length is exactly `N`.

To import and use `isTupleOf` from the "Tuple" module:

```ts
import * as Tuple from "effect/Tuple"
// Can be accessed like this
Tuple.isTupleOf
```

**Example**

```ts
import { isTupleOf } from "effect/Tuple"

assert.deepStrictEqual(isTupleOf([1, 2, 3], 3), true)
assert.deepStrictEqual(isTupleOf([1, 2, 3], 2), false)
assert.deepStrictEqual(isTupleOf([1, 2, 3], 4), false)

const arr: number[] = [1, 2, 3]
if (isTupleOf(arr, 3)) {
  console.log(arr)
  // ^? [number, number, number]
}
```


# isTupleOfAtLeast

Determine if an `Array` is a tuple with at least `N` elements, narrowing down the type to `TupleOfAtLeast`.

An `Array` is considered to be a `TupleOfAtLeast` if its length is at least `N`.

To import and use `isTupleOfAtLeast` from the "Tuple" module:

```ts
import * as Tuple from "effect/Tuple"
// Can be accessed like this
Tuple.isTupleOfAtLeast
```

**Example**

```ts
import { isTupleOfAtLeast } from "effect/Tuple"

assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 3), true)
assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 2), true)
assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 4), false)

const arr: number[] = [1, 2, 3, 4]
if (isTupleOfAtLeast(arr, 3)) {
  console.log(arr)
  // ^? [number, number, number, ...number[]]
}
```


# make

Constructs a new tuple from the provided values.

To import and use `make` from the "Tuple" module:

```ts
import * as Tuple from "effect/Tuple"
// Can be accessed like this
Tuple.make
```

**Example**

```ts
import { make } from "effect/Tuple"

assert.deepStrictEqual(make(1, "hello", true), [1, "hello", true])
```

**Signature**

```ts
export declare const make: <A extends ReadonlyArray<any>>(...elements: A) => A
```


# map

Transforms each element of tuple using the given function, treating tuple homomorphically

To import and use `map` from the "Tuple" module:

```ts
import * as Tuple from "effect/Tuple"
// Can be accessed like this
Tuple.map
```

**Example**

```ts
import { pipe, Tuple } from "effect"

const result = pipe(
  ["a", 1, false] as const,
  Tuple.map((el) => el.toString().toUpperCase())
)
assert.deepStrictEqual(result, ["A", "1", "FALSE"])
```

**Signature**

```ts
export declare const map: {
  <T extends ReadonlyArray<any> | [], B>(fn: (element: T[number]) => B): (self: T) => TupleOf<T["length"], B>
  <B, T extends ReadonlyArray<any> | []>(self: T, fn: (element: T[number]) => B): TupleOf<T["length"], B>
}
```


# mapBoth

Transforms both elements of a tuple using the given functions.

To import and use `mapBoth` from the "Tuple" module:

```ts
import * as Tuple from "effect/Tuple"
// Can be accessed like this
Tuple.mapBoth
```

**Example**

```ts
import { mapBoth } from "effect/Tuple"

assert.deepStrictEqual(mapBoth(["hello", 42], { onFirst: (s) => s.toUpperCase(), onSecond: (n) => n.toString() }), [
  "HELLO",
  "42"
])
```

**Signature**

```ts
export declare const mapBoth: {
  <L1, L2, R1, R2>(options: {
    readonly onFirst: (e: L1) => L2
    readonly onSecond: (a: R1) => R2
  }): (self: readonly [L1, R1]) => [L2, R2]
  <L1, R1, L2, R2>(
    self: readonly [L1, R1],
    options: { readonly onFirst: (e: L1) => L2; readonly onSecond: (a: R1) => R2 }
  ): [L2, R2]
}
```


# mapFirst

Transforms the first component of a tuple using a given function.

To import and use `mapFirst` from the "Tuple" module:

```ts
import * as Tuple from "effect/Tuple"
// Can be accessed like this
Tuple.mapFirst
```

**Example**

```ts
import { mapFirst } from "effect/Tuple"

assert.deepStrictEqual(
  mapFirst(["hello", 42], (s) => s.toUpperCase()),
  ["HELLO", 42]
)
```

**Signature**

```ts
export declare const mapFirst: {
  <L1, L2>(f: (left: L1) => L2): <R>(self: readonly [L1, R]) => [L2, R]
  <L1, R, L2>(self: readonly [L1, R], f: (left: L1) => L2): [L2, R]
}
```


# mapSecond

Transforms the second component of a tuple using a given function.

To import and use `mapSecond` from the "Tuple" module:

```ts
import * as Tuple from "effect/Tuple"
// Can be accessed like this
Tuple.mapSecond
```

**Example**

```ts
import { mapSecond } from "effect/Tuple"

assert.deepStrictEqual(
  mapSecond(["hello", 42], (n) => n.toString()),
  ["hello", "42"]
)
```

**Signature**

```ts
export declare const mapSecond: {
  <R1, R2>(f: (right: R1) => R2): <L>(self: readonly [L, R1]) => [L, R2]
  <L, R1, R2>(self: readonly [L, R1], f: (right: R1) => R2): [L, R2]
}
```


# swap

Swaps the two elements of a tuple.

To import and use `swap` from the "Tuple" module:

```ts
import * as Tuple from "effect/Tuple"
// Can be accessed like this
Tuple.swap
```

**Example**

```ts
import { swap } from "effect/Tuple"

assert.deepStrictEqual(swap(["hello", 42]), [42, "hello"])
```

**Signature**

```ts
export declare const swap: <L, R>(self: readonly [L, R]) => [R, L]
```


# Concurrency

Describes the concurrency to use when executing multiple Effect's.

To import and use `Concurrency` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.Concurrency
```


# Contravariant

Contravariant helper.

To import and use `Contravariant` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.Contravariant
```


# Covariant

Covariant helper.

To import and use `Covariant` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.Covariant
```


# DeepMutable

Like `Types.Mutable`, but works recursively.

To import and use `DeepMutable` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.DeepMutable
```

**Example**

```ts
import type { Types } from "effect"

type DeepMutableStruct = Types.DeepMutable<{
  readonly a: string
  readonly b: readonly string[]
}>
// { a: string; b: string[] }
```


# Equals

Determines if two types are equal.

To import and use `Equals` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.Equals
```

**Example**

```ts
import type { Types } from "effect"

type Res1 = Types.Equals<{ a: number }, { a: number }> // true
type Res2 = Types.Equals<{ a: number }, { b: number }> // false
```


# ExcludeTag

Excludes the tagged object from the type.

To import and use `ExcludeTag` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.ExcludeTag
```

**Example**

```ts
import type { Types } from "effect"

type Res = Types.ExcludeTag<string | { _tag: "a" } | { _tag: "b" }, "a"> // string | { _tag: "b" }
```


# ExtractTag

Extracts the type of the given tag.

To import and use `ExtractTag` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.ExtractTag
```

**Example**

```ts
import type { Types } from "effect"

type Res = Types.ExtractTag<{ _tag: "a"; a: number } | { _tag: "b"; b: number }, "b"> // { _tag: "b", b: number }
```


# Has

Determines if a record contains any of the given keys.

To import and use `Has` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.Has
```

**Example**

```ts
import type { Types } from "effect"

type Res1 = Types.Has<{ a: number }, "a" | "b"> // true
type Res2 = Types.Has<{ c: number }, "a" | "b"> // false
```


# Invariant

Invariant helper.

To import and use `Invariant` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.Invariant
```


# MergeLeft

Merges two object where the keys of the left object take precedence in the case of a conflict.

To import and use `MergeLeft` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.MergeLeft
```

**Example**

```ts
import type { Types } from "effect"
type MergeLeft = Types.MergeLeft<{ a: number; b: number }, { a: string }> // { a: number; b: number; }
```


# MergeRight

Merges two object where the keys of the right object take precedence in the case of a conflict.

To import and use `MergeRight` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.MergeRight
```

**Example**

```ts
import type { Types } from "effect"
type MergeRight = Types.MergeRight<{ a: number; b: number }, { a: string }> // { a: string; b: number; }
```


# Mutable

Make all properties in `T` mutable. Supports arrays, tuples, and records as well.

To import and use `Mutable` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.Mutable
```

**Example**

```ts
import type { Types } from "effect"

type MutableStruct = Types.Mutable<{ readonly a: string; readonly b: number }> // { a: string; b: number; }

type MutableArray = Types.Mutable<ReadonlyArray<string>> // string[]

type MutableTuple = Types.Mutable<readonly [string, number]> // [string, number]

type MutableRecord = Types.Mutable<{ readonly [_: string]: number }> // { [x: string]: number; }
```


# NoInfer

Avoid inference on a specific parameter

To import and use `NoInfer` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.NoInfer
```


# Simplify

Simplifies the type signature of a type.

To import and use `Simplify` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.Simplify
```

**Example**

```ts
import type { Types } from "effect"

type Res = Types.Simplify<{ a: number } & { b: number }> // { a: number; b: number; }
```


# Tags

Returns the tags in a type.

To import and use `Tags` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.Tags
```

**Example**

```ts
import type { Types } from "effect"

type Res = Types.Tags<string | { _tag: "a" } | { _tag: "b" }> // "a" | "b"
```


# TupleOf

Represents a tuple with a fixed number of elements of type `T`.

This type constructs a tuple that has exactly `N` elements of type `T`.

To import and use `TupleOf` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.TupleOf
```

**Example**

```ts
import { TupleOf } from "effect/Types"

// A tuple with exactly 3 numbers
const example1: TupleOf<3, number> = [1, 2, 3] // valid
// @ts-expect-error
const example2: TupleOf<3, number> = [1, 2] // invalid
// @ts-expect-error
const example3: TupleOf<3, number> = [1, 2, 3, 4] // invalid
```


# TupleOfAtLeast

Represents a tuple with at least `N` elements of type `T`.

This type constructs a tuple that has a fixed number of elements `N` of type `T` at the start,
followed by any number (including zero) of additional elements of the same type `T`.

To import and use `TupleOfAtLeast` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.TupleOfAtLeast
```

**Example**

```ts
import { TupleOfAtLeast } from "effect/Types"

// A tuple with at least 3 numbers
const example1: TupleOfAtLeast<3, number> = [1, 2, 3] // valid
const example2: TupleOfAtLeast<3, number> = [1, 2, 3, 4, 5] // valid
// @ts-expect-error
const example3: TupleOfAtLeast<3, number> = [1, 2] // invalid
```


# UnionToIntersection

A utility type that transforms a union type `T` into an intersection type.

To import and use `UnionToIntersection` from the "Types" module:

```ts
import * as Types from "effect/Types"
// Can be accessed like this
Types.UnionToIntersection
```


# isNoUpstream

Returns `true` if the specified `UpstreamPullRequest` is a `NoUpstream`,
`false` otherwise.

To import and use `isNoUpstream` from the "UpstreamPullRequest" module:

```ts
import * as UpstreamPullRequest from "effect/UpstreamPullRequest"
// Can be accessed like this
UpstreamPullRequest.isNoUpstream
```

**Signature**

```ts
export declare const isNoUpstream: <A>(self: UpstreamPullRequest<A>) => self is NoUpstream
```


# isPulled

Returns `true` if the specified `UpstreamPullRequest` is a `Pulled`, `false`
otherwise.

To import and use `isPulled` from the "UpstreamPullRequest" module:

```ts
import * as UpstreamPullRequest from "effect/UpstreamPullRequest"
// Can be accessed like this
UpstreamPullRequest.isPulled
```

**Signature**

```ts
export declare const isPulled: <A>(self: UpstreamPullRequest<A>) => self is Pulled<A>
```


# isUpstreamPullRequest

Returns `true` if the specified value is an `UpstreamPullRequest`, `false`
otherwise.

To import and use `isUpstreamPullRequest` from the "UpstreamPullRequest" module:

```ts
import * as UpstreamPullRequest from "effect/UpstreamPullRequest"
// Can be accessed like this
UpstreamPullRequest.isUpstreamPullRequest
```

**Signature**

```ts
export declare const isUpstreamPullRequest: (u: unknown) => u is UpstreamPullRequest<unknown>
```


# match

Folds an `UpstreamPullRequest<A>` into a value of type `Z`.

To import and use `match` from the "UpstreamPullRequest" module:

```ts
import * as UpstreamPullRequest from "effect/UpstreamPullRequest"
// Can be accessed like this
UpstreamPullRequest.match
```

**Signature**

```ts
export declare const match: {
  <A, Z>(options: {
    readonly onPulled: (value: A) => Z
    readonly onNoUpstream: (activeDownstreamCount: number) => Z
  }): (self: UpstreamPullRequest<A>) => Z
  <A, Z>(
    self: UpstreamPullRequest<A>,
    options: { readonly onPulled: (value: A) => Z; readonly onNoUpstream: (activeDownstreamCount: number) => Z }
  ): Z
}
```


# isPullAfterAllEnqueued

Returns `true` if the specified `UpstreamPullStrategy` is a
`PullAfterAllEnqueued`, `false` otherwise.

To import and use `isPullAfterAllEnqueued` from the "UpstreamPullStrategy" module:

```ts
import * as UpstreamPullStrategy from "effect/UpstreamPullStrategy"
// Can be accessed like this
UpstreamPullStrategy.isPullAfterAllEnqueued
```

**Signature**

```ts
export declare const isPullAfterAllEnqueued: <A>(self: UpstreamPullStrategy<A>) => self is PullAfterAllEnqueued<A>
```


# isPullAfterNext

Returns `true` if the specified `UpstreamPullStrategy` is a `PullAfterNext`,
`false` otherwise.

To import and use `isPullAfterNext` from the "UpstreamPullStrategy" module:

```ts
import * as UpstreamPullStrategy from "effect/UpstreamPullStrategy"
// Can be accessed like this
UpstreamPullStrategy.isPullAfterNext
```

**Signature**

```ts
export declare const isPullAfterNext: <A>(self: UpstreamPullStrategy<A>) => self is PullAfterNext<A>
```


# isUpstreamPullStrategy

Returns `true` if the specified value is an `UpstreamPullStrategy`, `false`
otherwise.

To import and use `isUpstreamPullStrategy` from the "UpstreamPullStrategy" module:

```ts
import * as UpstreamPullStrategy from "effect/UpstreamPullStrategy"
// Can be accessed like this
UpstreamPullStrategy.isUpstreamPullStrategy
```

**Signature**

```ts
export declare const isUpstreamPullStrategy: (u: unknown) => u is UpstreamPullStrategy<unknown>
```


# match

Folds an `UpstreamPullStrategy<A>` into a value of type `Z`.

To import and use `match` from the "UpstreamPullStrategy" module:

```ts
import * as UpstreamPullStrategy from "effect/UpstreamPullStrategy"
// Can be accessed like this
UpstreamPullStrategy.match
```

**Signature**

```ts
export declare const match: {
  <A, Z>(options: {
    readonly onNext: (emitSeparator: Option.Option<A>) => Z
    readonly onAllEnqueued: (emitSeparator: Option.Option<A>) => Z
  }): (self: UpstreamPullStrategy<A>) => Z
  <A, Z>(
    self: UpstreamPullStrategy<A>,
    options: {
      readonly onNext: (emitSeparator: Option.Option<A>) => Z
      readonly onAllEnqueued: (emitSeparator: Option.Option<A>) => Z
    }
  ): Z
}
```


# fromString

Parses a URL string into a `URL` object, returning an `Either` type for safe
error handling.

**Details**

This function converts a string into a `URL` object, enabling safe URL
parsing with built-in error handling. If the string is invalid or fails to
parse, this function does not throw an error; instead, it wraps the error in
a `IllegalArgumentException` and returns it as the `Left` value of an
`Either`. The `Right` value contains the successfully parsed `URL`.

An optional `base` parameter can be provided to resolve relative URLs. If
specified, the function interprets the input `url` as relative to this
`base`. This is especially useful when dealing with URLs that might not be
fully qualified.

To import and use `fromString` from the "Url" module:

```ts
import * as Url from "@effect/platform/Url"
// Can be accessed like this
Url.fromString
```

**Example**

```ts
import { Url } from "@effect/platform"
import { Either } from "effect"

// Parse an absolute URL
//
//       Either<URL, IllegalArgumentException>
//      
const parsed = Url.fromString("https://example.com/path")

if (Either.isRight(parsed)) {
  console.log("Parsed URL:", parsed.right.toString())
} else {
  console.log("Error:", parsed.left.message)
}
// Output: Parsed URL: https://example.com/path

// Parse a relative URL with a base
const relativeParsed = Url.fromString("/relative-path", "https://example.com")

if (Either.isRight(relativeParsed)) {
  console.log("Parsed relative URL:", relativeParsed.right.toString())
} else {
  console.log("Error:", relativeParsed.left.message)
}
// Output: Parsed relative URL: https://example.com/relative-path
```

**Signature**

```ts
export declare const fromString: (
  url: string,
  base?: string | URL | undefined
) => Either.Either<URL, Cause.IllegalArgumentException>
```


# modifyUrlParams

Reads, modifies, and updates the query parameters of a URL.

**Details**

This function provides a functional way to interact with query parameters by
reading the current parameters, applying a transformation function, and then
writing the updated parameters back to the URL. It returns a new `URL` object
with the modified parameters, ensuring immutability.

To import and use `modifyUrlParams` from the "Url" module:

```ts
import * as Url from "@effect/platform/Url"
// Can be accessed like this
Url.modifyUrlParams
```

**Example**

```ts
import { Url, UrlParams } from "@effect/platform"

const myUrl = new URL("https://example.com?foo=bar")

const changedUrl = Url.modifyUrlParams(myUrl, UrlParams.append("key", "value"))

console.log(changedUrl.toString())
// Output: https://example.com/?foo=bar&key=value
```

**Signature**

```ts
export declare const modifyUrlParams: {
  (f: (urlParams: UrlParams.UrlParams) => UrlParams.UrlParams): (url: URL) => URL
  (url: URL, f: (urlParams: UrlParams.UrlParams) => UrlParams.UrlParams): URL
}
```


# mutate

This function clones the original `URL` object and applies a callback to the
clone, allowing multiple updates at once.

To import and use `mutate` from the "Url" module:

```ts
import * as Url from "@effect/platform/Url"
// Can be accessed like this
Url.mutate
```

**Example**

```ts
import { Url } from "@effect/platform"

const myUrl = new URL("https://example.com")

const mutatedUrl = Url.mutate(myUrl, (url) => {
  url.username = "user"
  url.password = "pass"
})

console.log("Mutated:", mutatedUrl.toString())
// Output: Mutated: https://user:pass@example.com/
```

**Signature**

```ts
export declare const mutate: { (f: (url: URL) => void): (self: URL) => URL; (self: URL, f: (url: URL) => void): URL }
```


# setHash

Updates the hash fragment of the URL.

To import and use `setHash` from the "Url" module:

```ts
import * as Url from "@effect/platform/Url"
// Can be accessed like this
Url.setHash
```

**Signature**

```ts
export declare const setHash: { (hash: string): (url: URL) => URL; (url: URL, hash: string): URL }
```


# setHost

Updates the host (domain and port) of the URL.

To import and use `setHost` from the "Url" module:

```ts
import * as Url from "@effect/platform/Url"
// Can be accessed like this
Url.setHost
```

**Signature**

```ts
export declare const setHost: { (host: string): (url: URL) => URL; (url: URL, host: string): URL }
```


# setHostname

Updates the domain of the URL without modifying the port.

To import and use `setHostname` from the "Url" module:

```ts
import * as Url from "@effect/platform/Url"
// Can be accessed like this
Url.setHostname
```

**Signature**

```ts
export declare const setHostname: { (hostname: string): (url: URL) => URL; (url: URL, hostname: string): URL }
```


# setHref

Replaces the entire URL string.

To import and use `setHref` from the "Url" module:

```ts
import * as Url from "@effect/platform/Url"
// Can be accessed like this
Url.setHref
```

**Signature**

```ts
export declare const setHref: { (href: string): (url: URL) => URL; (url: URL, href: string): URL }
```


# setPassword

Updates the password used for authentication.

To import and use `setPassword` from the "Url" module:

```ts
import * as Url from "@effect/platform/Url"
// Can be accessed like this
Url.setPassword
```

**Signature**

```ts
export declare const setPassword: { (password: string): (url: URL) => URL; (url: URL, password: string): URL }
```


# setPathname

Updates the path of the URL.

To import and use `setPathname` from the "Url" module:

```ts
import * as Url from "@effect/platform/Url"
// Can be accessed like this
Url.setPathname
```

**Signature**

```ts
export declare const setPathname: { (pathname: string): (url: URL) => URL; (url: URL, pathname: string): URL }
```


# setPort

Updates the port of the URL.

To import and use `setPort` from the "Url" module:

```ts
import * as Url from "@effect/platform/Url"
// Can be accessed like this
Url.setPort
```

**Signature**

```ts
export declare const setPort: { (port: string): (url: URL) => URL; (url: URL, port: string): URL }
```


# setProtocol

Updates the protocol (e.g., `http`, `https`).

To import and use `setProtocol` from the "Url" module:

```ts
import * as Url from "@effect/platform/Url"
// Can be accessed like this
Url.setProtocol
```

**Signature**

```ts
export declare const setProtocol: { (protocol: string): (url: URL) => URL; (url: URL, protocol: string): URL }
```


# setSearch

Updates the query string of the URL.

To import and use `setSearch` from the "Url" module:

```ts
import * as Url from "@effect/platform/Url"
// Can be accessed like this
Url.setSearch
```

**Signature**

```ts
export declare const setSearch: { (search: string): (url: URL) => URL; (url: URL, search: string): URL }
```


# setUrlParams

Updates the query parameters of a URL.

**Details**

This function allows you to set or replace the query parameters of a `URL`
object using the provided `UrlParams`. It creates a new `URL` object with the
updated parameters, leaving the original object unchanged.

To import and use `setUrlParams` from the "Url" module:

```ts
import * as Url from "@effect/platform/Url"
// Can be accessed like this
Url.setUrlParams
```

**Example**

```ts
import { Url, UrlParams } from "@effect/platform"

const myUrl = new URL("https://example.com?foo=bar")

// Write parameters
const updatedUrl = Url.setUrlParams(myUrl, UrlParams.fromInput([["key", "value"]]))

console.log(updatedUrl.toString())
// Output: https://example.com/?key=value
```

**Signature**

```ts
export declare const setUrlParams: {
  (urlParams: UrlParams.UrlParams): (url: URL) => URL
  (url: URL, urlParams: UrlParams.UrlParams): URL
}
```


# setUsername

Updates the username used for authentication.

To import and use `setUsername` from the "Url" module:

```ts
import * as Url from "@effect/platform/Url"
// Can be accessed like this
Url.setUsername
```

**Signature**

```ts
export declare const setUsername: { (username: string): (url: URL) => URL; (url: URL, username: string): URL }
```


# urlParams

Retrieves the query parameters from a URL.

**Details**

This function extracts the query parameters from a `URL` object and returns
them as `UrlParams`. The resulting structure can be easily manipulated or
inspected.

To import and use `urlParams` from the "Url" module:

```ts
import * as Url from "@effect/platform/Url"
// Can be accessed like this
Url.urlParams
```

**Example**

```ts
import { Url } from "@effect/platform"

const myUrl = new URL("https://example.com?foo=bar")

// Read parameters
const params = Url.urlParams(myUrl)

console.log(params)
// Output: [ [ 'foo', 'bar' ] ]
```

**Signature**

```ts
export declare const urlParams: (url: URL) => UrlParams.UrlParams
```


# schemaStruct

Extract schema from all key-value pairs in the given `UrlParams`.

To import and use `schemaStruct` from the "UrlParams" module:

```ts
import * as UrlParams from "@effect/platform/UrlParams"
// Can be accessed like this
UrlParams.schemaStruct
```

**Example**

```ts
import { Effect, Schema } from "effect"
import { UrlParams } from "@effect/platform"

Effect.gen(function* () {
  const urlParams = UrlParams.fromInput({ a: [10, "string"], b: false })
  const result = yield* UrlParams.schemaStruct(
    Schema.Struct({
      a: Schema.Tuple(Schema.NumberFromString, Schema.String),
      b: Schema.BooleanFromString
    })
  )(urlParams)

  assert.deepStrictEqual(result, {
    a: [10, "string"],
    b: false
  })
})
```

**Signature**

```ts
export declare const schemaStruct: <A, I extends Record<string, string | ReadonlyArray<string> | undefined>, R>(
  schema: Schema.Schema<A, I, R>,
  options?: ParseOptions | undefined
) => (self: UrlParams) => Effect.Effect<A, ParseResult.ParseError, R>
```


# toRecord

Builds a `Record` containing all the key-value pairs in the given `UrlParams`
as `string` (if only one value for a key) or a `NonEmptyArray<string>`
(when more than one value for a key)

To import and use `toRecord` from the "UrlParams" module:

```ts
import * as UrlParams from "@effect/platform/UrlParams"
// Can be accessed like this
UrlParams.toRecord
```

**Example**

```ts
import { UrlParams } from "@effect/platform"

const urlParams = UrlParams.fromInput({ a: 1, b: true, c: "string", e: [1, 2, 3] })
const result = UrlParams.toRecord(urlParams)

assert.deepStrictEqual(result, { a: "1", b: "true", c: "string", e: ["1", "2", "3"] })
```

**Signature**

```ts
export declare const toRecord: (self: UrlParams) => Record<string, string | Arr.NonEmptyArray<string>>
```


# PCGRandom

PCG is a family of simple fast space-efficient statistically good algorithms
for random number generation. Unlike many general-purpose RNGs, they are also
hard to predict.

To import and use `PCGRandom` from the "Utils" module:

```ts
import * as Utils from "effect/Utils"
// Can be accessed like this
Utils.PCGRandom
```


# structuralRegion

Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code

To import and use `structuralRegion` from the "Utils" module:

```ts
import * as Utils from "effect/Utils"
// Can be accessed like this
Utils.structuralRegion
```

**Signature**

```ts
export declare const structuralRegion: <A>(body: () => A, tester?: (a: unknown, b: unknown) => boolean) => A
```


# structuralRegionState

Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code

To import and use `structuralRegionState` from the "Utils" module:

```ts
import * as Utils from "effect/Utils"
// Can be accessed like this
Utils.structuralRegionState
```

**Signature**

```ts
export declare const structuralRegionState: {
  enabled: boolean
  tester: ((a: unknown, b: unknown) => boolean) | undefined
}
```


# CloseLatch

The worker close latch is used by platform runners to signal that the worker
has been closed.

To import and use `CloseLatch` from the "WorkerRunner" module:

```ts
import * as WorkerRunner from "@effect/platform/WorkerRunner"
// Can be accessed like this
WorkerRunner.CloseLatch
```


# launch

Launch the specified layer, interrupting the fiber when the CloseLatch is
triggered.

To import and use `launch` from the "WorkerRunner" module:

```ts
import * as WorkerRunner from "@effect/platform/WorkerRunner"
// Can be accessed like this
WorkerRunner.launch
```

**Signature**

```ts
export declare const launch: <A, E, R>(layer: Layer.Layer<A, E, R>) => Effect.Effect<void, E | WorkerError, R>
```

